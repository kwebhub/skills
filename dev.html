<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="robots" content="noindex, nofollow"><meta name="robots" content="none"><meta name="robots" content="noimageindex, nofollow"><link rel="stylesheet" type="text/css" href="./style.min.css"><title>Skills</title></head><body><div class="wrapper"><header> <a class="logo" href="https://kwebhub.github.io/skills/">MAY THE FORCE BE WITH YOU</a></header><main><nav class="menu"><div class="menu__inner"><details><summary class="menu__submenu">Platform</summary><p>Design: react - tailwind | pug - scss - alpinejs</p><a href="https://github.com">Github</a><a href="http://www.figma.com">Figma</a><a href="https://dbdiagram.io">DB Diagram</a><a href="https://nodejs.org/en/download/">Node.js</a><a href="https://code.visualstudio.com">VSCode (Theme: Catppuccin Mocha, Font: Cascadia Code)</a><a href="http://www.contentful.com/blog/react-app-tailwind-css">React App Tailwind CSS</a><a href="http://www.github.com/gitname/react-gh-pages/">React GitHub Pages</a><br><p>Development:</p><a href="https://refactoring.guru/ru">Паттерны, рефакторинг, SOLID</a><a href="http://docs.docker.com/engine">Docker</a><a href="https://aws.amazon.com/ru/?nc2=h_lg">AWS</a><a href="https://laravel.com">laravel</a><a href="https://laravel.su/">laravel(ru)<br></a><br><p>Security: bash, linux, rust, net, crypto</p></details><details> <summary class="menu__submenu">Languages</summary><details><summary class="menu__submenu_lv1">Symbols</summary><p>Symbols<br>
<b>0b11111111</b> - бинарная (двоичная) форма записи числа 255<br>
<b>0о377</b> - восьмиричная форма записи числа 255<br>
<b>0xff</b> - шестнадцатиричная форма записи числа 255<br>
<br>
Регулярные выражения<br>
<b>^</b> - циркумфлекс, значение начинается с указанной подстроки<br>
<b>$</b> - доллар, значение заканчивается указанной подстрокой<br>
<b>~</b> - тильда, значение содержит указанное слово<br>
<b>*</b> - звезда, значение содержит указанную подстроку<br>
<b>!</b> - восклецательный знак, значение без указанной подстроки<br>
<b>|</b> - вертикальная черта, значение содержит указанное слово или после этого слова знак дефиса<br>
</p></details><details><summary class="menu__submenu_lv1">API</summary><p><dfn>API</dfn> (Application programming interface) - это контракт, который предоставляется программою “Ко мне можно обращаться так и так, я обязуюсь делать то и это”.<br>
<dfn>API</dfn> -  это набор функций. <br>
Наборы группируются разработчиком по функционалу, по заказчику, по смыслу операций и т.д.<br>
<br>
<em>HTML, XML - языки:</em> <br>
  HTML - закрепленные теги, прощает некоторые синтаксические ошибки. <br>
  XML - теги создает пользователь, проверка синтаксиса и валидация документа по WDSL. <br>
<br>
<em>RPC, REST - архитектура API:</em> <br>
  RPC - запрос на выполнение функции на сервере по имени функции с входными параметрами. <br>
  REST - запрос с помощью установленных методов к ресурсу (сущности) на сервере. <br>
<br>
<em>XML, JSON - формат передачи данных:</em> <br>
  XML - наличие тегов, корневого элемента и пространства имен. Не может содержать массивы. <br>
  JSON - более компактный, не имеет тегов, может содержать в значениях массивы. <br>
<br>
<em>HTTP, SOAP - протоколы передачи данных:</em> <br>
  HTTP - протокол прикладного уровня передачи данных. <br>
  SOAP - формальный корпоративный подход, работает поверх любого протокола связи, даже асинхронно. <br>
<br>
<em>Наиболее распространенные связки:</em> <br>
  JSON + REST + HTTP <br>
  XML + RPC + SOAP <br>
<br>
<dfn>Интерфейс программирования приложений</dfn> (API) - это интерфейс или правила связи между клиентом и сервером, предназначенный для упрощения создания программного обеспечения на стороне клиента. <br>
API является важной абстракцией, описывающей функциональность «в чистом виде», безотносительно того, как реализована эта функциональность.<br>
<br>
<dfn>RPC</dfn> (Remote Procedure Call) <br>
<dfn>Удаленный вызов процедур</dfn> — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). <br></p><img src="./img/web/rpc.png" alt=""><img src="./img/web/rpc1.png" alt=""><br><p><dfn>REST</dfn> (Representational State Transfer) <br>
<dfn>Передача состояния представления</dfn> — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.<br>
REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой системы по модели клиент-сервер.<br>
Особенности архитектурного стиля:<br>
- Каждая сущность должна иметь уникальный идентификатор – URI<br>
- Сущности должны быть связаны между собой<br>
- Для чтения и изменения данных должны использоваться стандартные методы<br>
- Должна быть поддержка нескольких типов ресурсов<br>
- Взаимодействие должно осуществляться без состояния<br>
<br>
Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.<br>
Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35 страница в этой книге — /book/3/page/35.<br>
CRUD в REST:<br>
- GET /book/ — получить список всех книг<br>
- GET /book/3/ — получить книгу номер 3<br>
- POST /book/ — добавить книгу (данные в теле запроса)<br>
- PUT /book/3 – изменить книгу (данные в теле запроса)<br>
- DELETE /book/3 – удалить книгу<br>
<br>
Или:<br>
- GET /book/ — получить список всех книг<br>
- GET /book/3/ — получить книгу номер 3<br>
- POST /book/ — добавить книгу (данные в теле запроса)<br>
- POST /book/3 — изменить книгу (данные в теле запроса)<br>
- POST /book/3 — удалить книгу (тело запроса пустое)<br>
<br></p><img src="./img/web/MicroService.png" alt=""><p>RPC: Мы отправляем сообщение, и это может привести к тому, что что-то сохранится в базе данных для сохранения истории, что может быть другим вызовом RPC, возможно, с теми же именами полей. <br>
REST: Мы создаем ресурс сообщений в коллекции сообщений пользователя.<br>
Мы можем легко увидеть историю этого, выполнив GET для того же URL.<br></p><img src="./img/web/rpcrest.png" alt=""><img src="./img/web/rpcrest1.png" alt=""><p>API основанные на RPC прекрасно работают для действий (выполнения процедур или команд).<br>
API основанные на REST хороши для моделирования сущностей и применения CRUD (create, read, update, delete) для данных.<br>
<br>
<dfn>JSON</dfn> - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером.<br>
Он основан на подмножестве языка программирования JavaScript.<br>
Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. <br>
<br>
Ключи в JSON находятся с левой стороны от двоеточия.<br>
Их нужно оборачивать в двойные кавычки (например, "key ") и это может быть любая строка.<br>
В каждом объекте, ключи должны быть уникальными.<br>
Пробелы допускаются, но лучше их заменять знаком подчеркивания.<br>
Значения находятся с правой стороны от двоеточия.<br>
Значения могут быть одним из шести типов данных:<br>
Строкой<br>
Числом<br>
Объектом<br>
Массивом<br>
Булевым значением<br>
null<br></p><img src="./img/web/json1.png" alt=""><img src="./img/web/json2.png" alt=""><p>JSON более компактный и не требует тегов закрытия как в XML.<br>
Более того, XML не может использовать массивы, как в примере с JSON.
</p></details><details><summary class="menu__submenu_lv1">Markdown</summary><pre><code><span>Heading:</span>
# H1
## H2
### H3
#### H4
##### H5
###### H6

<span>Bold:</span>
**bold text**

<span>Italic:</span>
*italicized text*

<span>Strikethrough:</span>
~~The world is flat.~~

<span>Blockquote:</span>
> blockquote

<span>Ordered List:</span>
1. First item
2. Second item
3. Third item

<span>Unordered List:</span>
- First item
- Second item
- Third item

<span>Code:</span>
`code`

<span>Link:</span>
[title](https://www.example.com)

<span>Image:</span>
![alt text](image.jpg)

<span>Table:</span>
| Item         | Price | # In stock |
|--------------|:-----:|-----------:|
| Juicy Apples |  1.99 |        739 |
| Bananas      |  1.89 |          6 |

<span>Fenced Code Block:</span>
  {
    "firstName": "John",
    "lastName": "Smith",
    "age": 25
  }

<span>Footnote:</span>
Here's a sentence with a footnote. [^1]
[^1]: This is the footnote. 

<span>Heading ID:</span>
My Great Heading {#custom-id}

<span>Definition List:</span>
term
: definition

<span>Task List:</span>
- [x] Write the press release
- [ ] Update the website
- [ ] Contact the media 

<span>Emoji:</span>
That is so funny! :joy:

<span>Highlight:</span>
I need to highlight these ==very important words==. 

<span>Subscript:</span>
H~2~O

<span>Superscript:</span>
X^2^
</code></pre></details><details><summary class="menu__submenu_lv1">XML</summary><p><dfn>XML</dfn> - это язык разметки подобный HTML. <br>
Расшифровывается как (англ. <i>Extensible Markup Language</i> - Расширяемый Язык Разметки). <br>
В отличии от остальных языков разметки, XML сам по себе не определён (это означает, что вы должны сами определять используемые теги). <br>
Основной целью XML является передача данных между разными системами (даже концептуально разными), такими как интернет.<br>
Cвое название получил по той причине, что в нем нет фиксированного формата, как в HTML. <br>В то время как язык HTML ограничивается набором твердо закрепленных тегов, пользователи XML могут создавать свои собственные тэги, которые бы отвечали тематике документа. <br>Таким образом, XML - это метаязык. <br>Этот язык используется в качестве средства для описания грамматики других языков и контроля за правильностью составления документов.<br>
Для корректного XML документа должны исполняться следующие условия: <br>
Правильное оформление документа. <br>
Соблюдаться все синтаксические правила XML. <br>
Документ должен соответствовать семантическим правилам языка (которые обычно заданны в схеме XML или DTD (англ. Document Type Definition (en-US))).<br>
<br>
Сходство с HTML:<br>
- В XML существуют открывающие, закрывающие и пустые тэги.<br>
- Теги в документе могут быть вложены друг в друга.<br>
- Теги начала и конца элемента являются основными используемыми в XML разметками.<br>
- Тэги могут иметь атрибуты, причем количество атрибутов зависит от фантазии автора.<br>
- Документы XML могут содержать ссылки на другие объекты.<br>
<br>
Основные отличия от HTML: <br>
Большое внимание уделяется контролю документа. <br>
Проверка действительности документа предполагает выполнение следующих действий: <br>
- Синтаксическая проверка, <br>
- Проверка валидности документа.<br>
<br>
XML обычно используют для описания чего-то. <br>
Существуют методы отображения XML данных, но если вы не определили способ визуализации XML документа, то в браузере он отобразится построчно, как обычный текстовый файл. <br>
Один из методов отображения XML - указать CSS (чтобы использовать в документе нужно прописать инструкцию xml-stylesheet). <br></p><code>xml-stylesheet type="text/css" href="stylesheet.css"</code><br><p>Есть также много других мощных методов отображения XML, например, <dfn>XSLT</dfn>(англ. <i>Extensible Stylesheet Language Transformations</i>), который может использоваться для преобразование XML в другие языки такие, как HTML. <br>
Это делает XML очень универсальным. <br></p><code>xml-stylesheet type="text/xsl" href="transform.xsl"</code><br><img src="./img/web/XML_.png" alt=""><img src="./img/web/XMLDTD.png" alt=""><img src="./img/web/XMLEntities.png" alt=""></details><details><summary class="menu__submenu_lv1">HTML</summary><pre><code>&lt;div&gt;
  &lt;p&gt;Привет, мир!&lt;/p&gt;
&lt;/div&gt;</code></pre><p><dfn>Структура</dfn><br>
<b>!DOCTYPE</b> - Тип документа<br>
<b>html</b> - Корень HTML-документа<br>
<b>head</b> - Содержит метаданные/информацию для документа, блочный<br>
<b>title</b> - Название сайта, которое отображается во вкладке<br>
<b>body</b> - Тело документа, блочный<br>
<b>header</b> - Заголовок документа или раздела, блочный, семантика<br>
<b>nav</b> - Навигационные ссылки, блочный, семантика<br>
<b>main</b> - Основное содержимое документа, блочный, семантика<br>
<b>section</b> - Раздел в документе, семантика<br>
<b>aside</b> - Боковая панель сайта, второстепенный контент, семантика<br>
<b>div</b> - Контейнер, блочный<br>
<b>footer</b> - Нижний колонтитул документа или раздела, блочный, семантика<br>
<br>
<dfn>Вставка</dfn><br>
<b>script</b> - JS вставка<br>
<b>style</b> - CSS вставка<br>
<b>embed</b> - Контейнер для внешнего приложения, блочный<br>
<b>object</b> - Контейнер для внешнего приложения, блочный<br>
<b>template</b> - Контейнер для контента, который должен быть скрыт при загрузке страницы<br>
<b>iframe</b> - Встроенный фрейм (страница в странице)<br>
<b>noscript</b> - Альтернативный контент при не поддержании JS<br>
<br>
<dfn>Списки</dfn><br>
<b>details</b> - Спойлер, блочный<br>
<b>summary</b> - название спойлера<br>
<b>dl</b> - Список определений, блочный<br>
<b>dt</b> - Термин<br>
<b>dd</b> - Значение термина<br>
<b>ol</b> - Упорядоченный список, блочный<br>
<b>ul</b> - Неупорядоченный список, блочный<br>
<b>menu</b> - Неупорядоченный список, блочный<br>
<b>li</b> - Элемент списка, блочный<br>
<b>optgroup</b> label="" - Группу связанных параметров в раскрывающемся списке<br>
<b>option</b> value="" - параметр в раскрывающемся списке<br>
<b>label</b> for="cars" - Имя раскрывающегося списка<br>
<b>select</b> name="cars" id="cars"- Раскрывающийся список<br>
<b>option</b> value="" - Значение раскрывающегося списка<br>
<br>
<dfn>Текст</dfn><br>
<b>article</b> - Группировка связанных элементов в независимый объект, семантика<br>
<b>hgroup</b> - Заголовок и связанный контент, блочный<br>
<b>abbr</b> title="Расшифровка" - Аббревиатура или акроним, строчный<br>
<b>address</b> - Вывод контактной информации, строчный<br>
<b>b</b> - Жирный текст, строчный<br>
<b>small</b> - Меньший текст, строчный<br>
<b>span</b> - Часть текста в строке, строчный<br>
<b>strong</b> - Текст большой важности, строчный, семантика<br>
<b>u</b> - Подчеркнутый текст, строчный<br>
<b>sub</b> - Подстрочный текст<br>
<b>sup</b> - Надстрочный текст<br>
<b>bdi</b> - Изолирует часть текста, строчный<br>
<b>bdo</b> dir="rtl" - Переопределяет направление текста, строчный<br>
<b>blockquote</b> cite="ссылка на источник" - Раздел, цитируемый из другого источника, блочный, семантика<br>
<b>q</b> - Короткая цитата, семантика<br>
<b>time</b> - Вывод даты и времени, семантика<br>
<b>br</b> - Разрыв строки, строчный<br>
<b>cite</b> - Название произведения, вывод автора цитаты, строчный, семантика<br>
<b>code</b> - Часть компьютерного кода, строчный<br>
<b>data</b> value="номер продукта" - Ассоциирует название продукта с номером продукта, строчный<br>
<b>del</b> - Перечеркнутый текст, строчный<br>
<b>dfn</b> - Термин, который будет определен, строчный<br>
<b>em</b> - Выделенный текст, текст с ударением (более громко), отдельная мысль или перефразировка, строчный, семантика<br>
<b>h1</b> - h1 - h6, Заголовок, блочный, семантика<br>
<b>i</b> - Текст курсивом. Текст, который отличается (иностранное слово, мысли и т.д.), строчный<br>
<b>ins</b> - Текст, который был вставлен, строчный<br>
<b>kbd</b> - Текст, как ввод с клавиатуры, строчный<br>
<b>mark</b> - Отмеченный/выделенный текст особого внимания, строчный<br>
<b>s</b> - Неправильныйт текст<br>
<b>samp</b> - Текст как вывод компьютерной программы<br>
<b>var</b> - Текст как переменная<br>
<b>wbr</b> - Возможный разрыв строки<br>
<b>p</b> - Параграф, блочный<br>
<b>pre</b> - Предварительно отформатированный текст, блочный<br>
<b>ruby</b> - Аннотация Ruby (для восточноазиатской типографики)<br>
<b>hr</b> - Тематическое изменение содержания (линия), блочный<br>
<br>
<dfn>Ссылки</dfn><br>
<b>link</b> - Связывает с документом другой документ, блочный<br>
<b>a</b> href="ссылка" - Гиперссылка<br>
<b>a</b> href="#" target="_blank" title="Подсказка" class="" id="" style=""<br>
<b>a</b> href="tel: phone"<br>
<b>a</b> href="email: address"<br>
<b>base</b> href="..." - Базовый URL-адрес для всех относительных URL-адресов в документе, строчный<br>
<br>
<dfn>Формы</dfn><br>
<b>dialog</b> - Диалоговое окно, блочный<br>
<b>textarea</b> rows="" cols="" - Поле многострочного ввода (текстовая область)<br>
<b>button</b> - Кликабельная кнопка, блочный<br>
<br>
<b>table</b> - Таблица, блочный<br>
<b>caption</b> - Название таблицы, блочный<br>
<b>thead</b> - Шапка таблицы, блочный<br>
<b>tbody</b> - Тело таблицы, блочный<br>
<b>tr</b> - Строка таблицы, блочный<br>
<b>th</b> - Ячейка шапки таблицы, блочный<br>
<b>td</b> - Ячейка тела таблицы, блочный<br>
<b>tfoot</b> - Подвал таблицы, блочный<br>
<b>colgroup</b> - Группа столбцов в таблице<br>
<b>colspan</b> ="2" - Объединение столбцов в таблице<br>
<b>rowspan</b> ="2" - Объединение строк в таблице<br></p><pre><code>form action="" method=""
  label for="" /label
  input type="" id="" name="" value="" tabindex=""
  textarea name="" placeholder="" /textarea
  select
    option /option
  /select
  input type="submit" id="" name="" value="Надпись на кнопке"
  button /button
/form</code></pre><p><b>form</b> action="/action_page.php" - HTML-форма для ввода пользователя. Отвечает за отправку введенных данных, адрес передачи - атрибут action, метод передачи - атрибут method<br>
<b>fieldset</b> - Групперует элементы формы<br>
<b>legend</b> - Заголовок формы<br>
<b>label</b> for="fname" - Заголовок поля<br>
<b>input</b> type="text" id="fname" name="fname" - Поле ввода<br>
<b>input</b> type="submit" value="Submit" - Кнопка отправить<br>
<br>
<b>form</b> action="/action_page.php" method="get" - Форма с предопределённым списком вариантов для поля ввода<br>
<b>label</b> for="browser" - Заголовок поля<br>
<b>input</b> list="browsers" name="browser" id="browser" - Поле ввода<br>
<b>datalist</b> id="browsers" - Список вариантов<br>
<b>option</b> value="Edge" - Вариант ввода<br>
<b>input</b> type="submit" - Кнопка отправить<br>
<br>
<b>search</b> - Раздел поиска<br>
<b>form</b> - Форма поиска<br>
<b>input</b> name="" id="" placeholder="" - Поле ввода поиска<br>
<br>
<b>form</b> oninput="x.value=parseInt(a.value)+parseInt(b.value)" - Результат расчета<br>
<b>input</b> type="range" id="a" value="50" - ввод первого слагаемого<br>
+ <b>input</b> type="number" id="b" value="25" - ввод второго слагаемого<br>
= <b>output</b> name="x" for="a b" - вывод суммы<br>
<br>
<b>label</b> for="idname" - Заголовок манометра<br>
<b>meter</b> id="idname" value="" - Скалярное измерение в известном диапазоне (манометр)<br>
<br>          
<b>label</b> for="file" - Заголовок прогресса<br>
<b>progress</b> id="file" value="32" max="100" - Представляет ход выполнения задачи, блочный<br>
<br>
<dfn>Медиа</dfn><br>
<b>canvas</b> id="myCanvas" - Рисование графики на лету, блочный<br>
<b>svg</b> width="" height="" - Контейнер для графики SVG, блочный<br>
<b>img</b> src="" alt="" - Изображение, строчный<br>
<br>
<b>img</b> src="" alt="" usemap="#workmap" - Карта-изображения<br>
<b>map</b> name="workmap" - Карта-изображения<br>
<b>area</b> shape="" coords="" alt="" href="" - Карта-изображения<br>
<br>
<b>picture</b> - контейнер для нескольких вариантов ресурсов изображений, блочный<br>
  source media="(min-width: 650px)" srcset="img_food.jpg" - Адаптив без css, ускоряет загрузку верстки.<br>
  source media="(min-width: 465px)" srcset="img_car.jpg" <br>
  img src="img_girl.jpg" - Если браузер не поддерживает picture, то выведет img.<br>
/picture<br>
<br>
<b>figure</b> - Групировка медиа-элементов, блочный, изображение с доп.тегами<br>
  img src="" - медиа-элемент<br>
  figcaption  - Заголовок медиа-элемента<br>
<b>audio</b> controls - Встроенный аудио контент<br>
<b>source</b> src="horse.ogg" type="audio/ogg" - аудио контент<br>
<b>source</b> src="horse.mp3" type="audio/mpeg" - аудио контент<br>
<b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
<br>          
<b>video</b> width="" height="" controls - Встроенный видио контент, блочный<br>
<b>source</b> src="" type="" - видио контент<br>
<b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
<br>
<dfn>Мета</dfn>
<b>meta charset="UTF-8"</b> - Кодировка<br>
<b>meta name="viewport" content="width=1170"</b> - фиксированная ширина вся помещается в экран<br>
<b>meta name="viewport" content="width=device-width"</b> - адаптивный<br>
<b>meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</b> - параметры адаптивности<br>
<b>meta name="format-detection" content="telephone=no"</b> - отключает ссылку у номера телефона на iOS<br>
<b>meta name="description" content="<i>описание до 140 символов</i>"</b> - для SEO<br>
<b>meta name="keywords" content="<i>ключевые слова через запятую до 20</i>"</b> - ключевые слова для SEO<br>
<b>meta name="robots" content="noindex, nofollow"</b> - недопуск поисковых роботов к страице<br>
<b>meta name="robots" content="none"</b>
<b>meta name="robots" content="noimageindex, nofollow"</b> - запрет индексации картинок и ссылок<br>
<b>meta name="Author" content="<i>Дарт Вейдер</i>"</b> - Автор страницы<br>
<b>meta name="Copyright" content="<i>Люк Скайвокер</i>"</b> - Авторские права<br>
<b>meta name="Address" content="<i>Татуин, кратер № 97</i>"</b> - Адрес автора<br>
<b>meta http-equiv="refresh" content="0"; url=""</b> - обновляет страницу либо перенаправляет пользователя, указать количество секунд до перенаправления и адрес страницы<br>
<b>meta property="og:locale" content="<i>ru_RU</i>"</b> - локализация для русcкоязычного сайта<br>
<b>meta property="og:type" content="<i>article</i>"</b> - тип контента статья<br>
<b>meta property="og:title" content="<i>META теги</i>"</b> - заголовок записи в социальной сети<br>
<b>meta property="og:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
<b>meta property="og:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
<b>meta property="og:url" content="http://fls.guru/meta/ "</b> - ссылка на текущую страницу<br>
<b>meta property="og:site_name" content="<i>Название сайта</i>"</b> - Название сайта<br>
<b>meta name="twitter:card" content="<i>summary</i>"</b> - тип карты твитер<br>
<b>meta name="twitter:site" content="<i>Автор</i>"</b> - имя/логин автора<br>
<b>meta name="twitter:title" content="<i>META теги</i>"</b> - название страницы<br>
<b>meta name="twitter:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
<b>meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
<br>
p Валидаторы HTML:<br></p><a href="https://caninclude.glitch.me/">glitch<br></a><a href="https://validator.w3.org/">w3<br></a><a href="https://developers.facebook.com/tools/debug/sharing/"> Facebook<br></a><a href="https://ruogp.me/">ogp<br></a><a href="https://cards-dev.twitter.com/validator">twitter<br></a><a href="https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started">twitter<br></a><a href="https://www.w3schools.com/html/default.asp">W3schools<br></a></details><details><summary class="menu__submenu_lv1">Pug</summary><a href="https://pugjs.org/language/attributes.html">Официальная документация по Pug</a><p>Pug - это препроцессор HTML и шаблонизатор, который был написан на JavaScript для Node.js.<br>
<br>
В терминале:<br></p><code>pug -w . -o ./ -P -E php</code><p><b>pug</b> - компилировать файлы с расширением .pug<br>
<b>-w</b> - watcher - следить за изменениями в файлах<br>
<b>.</b> - текущий каталог (каталог слежения)<br>
<b>-o</b> - output - вывод скомпилированных файлов<br>
<b>./</b> - каталог вывода<br>
<b>-P</b> - pretty - удобочитаемый вид<br>
<b>-E php</b> - компилировать с расширением php<br>
<br>
В Pug нет закрывающих тегов, вместо этого он использует строгую табуляцию (отступы) для определения вложености тегов.<br>
Для закрытия тегов в конце необходимо добавить символ `/`: `foo(bar='baz')/`<br></p><pre><code>ul            
  li Item A
  li Item B
  li Item C</code></pre><p>Теги внутри строки<br></p><code>This is plain old <em>text</em> content.</code><br><p><dfn>Комментарии</dfn>
Существуют различные комментариев: те, которые будут отображаться после компиляции, и те, которые пропадут.</p><pre><code>//-
  Comments for your template writers.
  Use as much text as you want.
//
  Comments for your HTML readers.
  Use as much text as you want.</code></pre><p>Перенос текста на несколько строк</p><pre><code>| The
| mulyiline
| text</code></pre><p>или так</p><pre><code>The
mulyiline
text</code></pre><br><p>Синтаксис</p><pre><code>a(class='button' href='google.com') Google

input(type='checkbox' name='agreement' checked)

- var url = 'pug-test.html';
a(href='/' + url) Link

- url = 'https://example.com/'
a(href=url) Another link

- var classes = ['foo', 'bar', 'baz']
a(class=classes)

//- the class attribute may also be repeated to merge arrays
a.bang(class=classes class=['bing'])</code></pre><br><p>Многострочный ассоциативный массив</p><pre><code>-
  var priceItem = [
    {include: filterInc, parameter : "Розовый фильтр"},
    {include: smileInc, parameter : "Смайлики"},
    {include: commentInc, parameter : "Комментарии"}
  ]</code></pre><br><p><dfn>Условия</dfn></p><pre><code>- var user = { description: 'foo bar baz' }
- var authorised = false

// user
if user.description
  h2.green Description
  p.description= user.description
else if authorised
  h2.blue Description
  p.description.
    User has no description,
    why not add one...
else
  h2.red Description
  p.description User has no description

- var authenticated = true
body(class=authenticated ? 'authed' : 'anon')</code></pre><br><p><dfn>Конструкция Switch Case</dfn><br>
Pug поддерживает switch case, которая представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.</p><pre><code>- var friends = 10
case friends
  when 0
    p you have no friends
  when 1
    p you have a friend
  default
    p you have  friends</code></pre><br><p><dfn>Циклы</dfn></p><pre><code>ul                                            
  each val, index in ['zero', 'one', 'two']
    li= index + ': ' + val

- var values = [];
ul
  each val in values
    li= val
  else
    li There are no values

- var n = 0;
ul
  while n < 4
    li= n++</code></pre><br><p><dfn>Вставка JavaScript кода</dfn><br>
Pug поддерживает вставку частей JavaScript кода в шаблоны.<br>
Не буфферизированный код начинается с символа `-`  </p><pre><code>- for (var x = 0; x < 3; x++)                 
  li item</code></pre><br><p>Буфферизированный код начинается с символа `=`</p><pre><code>- let firstName = "Bob"
p= firstName
- let lastName = "Joe"
.full-name= firstName + " " + lastName
.full-name= `First name: ${firstName} Last name: ${lastName}`

- const names = ['Bob Joe', 'John Doe', 'Billy Bob', 'John Week']
ol
  each name in names
    li= name

-
  const friendsList = [
    {
      "firstName":"Bob",
      "lastName":"Joe",
      "mobile":"123456789"
    },
    {
      "firstName":"John",
      "lastName":"Doe",
      "mobile":"123456789"
    },
    {
      "firstName":"Billy",
      "lastName":"Bob",
      "mobile":"123456789"
    }
  ]

// friendsList
  each friend in friendsList
    .friend
      .first-name= friend.firstName
      .last-name= friend.lastName
      .mobile= friend.mobile

-
  const friendsList2 = []

// friendsList2
  each friend in friendsList
    .friend
      .first-name # {friend.firstName}
      .last-name # {friend.lastName}
      .mobile # {friend.mobile}
  else
    .oh-no You have no friends!

mixin friendCard(friend)
  .friend
    .first-name # {friend.firstName}
    .last-name # {friend.lastName}
    .mobile # {friend.mobile}

// friends
  each friend in friendsList
    +friendCard(friend)</code></pre><br><p><dfn>PHP</dfn><br>
вывод данных полученных из формы, код вместе с html в php файле.</p><pre><code>.friend.
  <?php
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
  ?></code></pre><p><b>.friend.</b> - точка вначале обозначает класс (friend), точка в конце означает, что далее многостраничный текст<br></p><br><p><dfn>Интерполяция переменных</dfn>
Pug предоставляет различные способы вывода переменных.</p><pre><code>- var title = "On Dogs: Man's Best Friend";
- var author = "enlore";
- var theGreat = "<span>escape!</span>";
h1= title
p Written with love by # {author}
p This will be safe: ! {theGreat}</code></pre><br><p>doctype html - Тип документа<br>
<br>
<dfn>Инклюды</dfn> (Includes)<br>
Pug имеет возможность вставки содержимого одного файла в другой файл Pug.</p><pre><code>doctype html
html
  head
    style
    include style.css
  body
    h1 My Site
    p Welcome to my super lame site.
    script
      include script.js</code></pre><p><dfn>Наследование шаблонов</dfn><br>
Pug поддерживает наследование шаблонов.<br>
Наследование шаблонов работает через ключевые слова <b>block</b> и <b>extend</b>.<br>
В шаблоне block - обычный блок Pug, который может заменить дочерний шаблон.<br>
Этот процесс является рекурсивным.</p><pre><code>// layout.pug
html
  head
    title My Site
    block scripts
      script(src='/jquery.js')
  body
    block content
    block foot
      #footer
        p some footer content

// home.pug
extends templates/layout
- var title = 'Animals'
- var pets = ['cat', 'dog']
block content
  h1= title // or h1 # {title}
  each petName in pets
    p= petName // or p # {petName}</code></pre><p><dfn>Миксины</dfn><br>
Поддержка миксинов позволяет создавать переиспользуемые блоки.</p><pre><code>// Declaration
mixin pet(name)
  li.pet= name
// use
ul                                              
  +pet('cat')
  +pet('dog')
  +pet('pig') 

mixin article(title)
  .article
    .article-wrapper
      h1= title
      if block
        block
      else
        p No content provided
+article('Hello world')
+article('Hello world')
  p This is my
  p Amazing article

mixin link(href, name)
// attributes == {class: "btn"}
  a(class!=attributes.class href=href)= name

+link('/foo', 'foo')(class="btn")
</code></pre></details><details><summary class="menu__submenu_lv1">CSS</summary><p><em>Стилем или CSS</em> (<i>Cascading Style Sheets, каскадные таблицы стилей</i>) <br>
  называется набор параметров форматирования,
  который применяется к элементам документа,
  чтобы изменить их внешний вид.<br>
  <em>Достоинства</em>:<br>
  - Разграничение кода и оформления<br>
  - Разное оформление для разных устройств<br>
  - Расширенные по сравнению с HTML способы оформления элементов<br>
  - Ускорение загрузки сайта<br>
  - Единое стилевое оформление множества документов<br>
<br>
<b>h1</b> <em>style</em> ="color: red;" - Внутренние стили. Приоритет максимальный.<br>
<br>
<b>style</b> - Глобальные стили<br>
  h1 {<br>
    color: red;<br>
  }<br>
<b>style</b><br>
<br>
<b>link</b> rel="stylesheet" href="<i>путь/к файлу/CSS</i>" - Связанные стили<br>
<br></p><a href="https://www.w3schools.com/css/default.asp">W3schools</a><details><summary>Селекторы</summary><pre><code>селектор {
  свойство: значение;
}</code></pre><p>- Базовые ( #id,.class, tag)<br>
- Иерархические (+, >, ~)<br>
- Атрибутные ([atribute])<br>
- :псевдоклассы (:hover, :visited и т.д.) - при действии<br>
- ::псевдоэлементы (::after, ::before) - добавляем элемент до или после выбранного<br>
<br>
<b>"tag</b> - имя тэга<br>
<b>".class</b> - CSS-класс<br>
<b>"#id</b> - ID тэга<br>
<b>"name = value</b> - Атрибут тэга<br>
<b>":filter</b> - фильтр<br>
<br>
<b>"*</b> - все элементы на странице<br>
<b>"sel, sel, sel</b> - выбор элементов по множетву селекторов<br>
<b>"sel sel</b> - всех потомков<br>
<b>"sel > sel</b> - только прямых потомков<br>
<b>"sel + sel</b> - следующий сосед этого же уровня<br>
<b>"sel ~ sel</b> - всех следующих соседей этого же уровня<br>
<br>
<b>[title="first"]</b> - атрибут title равен first<br>
<b>[title~="first"]</b> - атрибут title содержит слово first<br>
<b>sel:first-child {}</b> - первый ребенок<br>
<b>sel:last-child {}</b> - последний ребенок<br>
<b>sel:nth-child(2) {}</b> - второй ребенок<br>
<b>sel:nth-child(2n) {}</b> - каждый второй ребенок<br>
<b>sel:nth-child(even) {}</b> - чётные<br>
<b>sel:nth-child(add) {}</b> - нечётные<br>
<b>div.text {}</b>  применяем css-свойство к тегу div с классом text<br>
<b>.block.text {}</b>  применяем к тегам, содержащим оба класса<br>
<b>.block,.text {}</b>  применяем к тегам, содержащим один из классов<br>
<b>.block .text {}</b>  применяем к тегам, содержащим класс text и находящийся внутри элемента с классом block<br>
<b>.text > div {}</b>  применяем к первому div верхнего уровня внутри элемента с классом text<br>
<b>.block + .text</b> sibling<br>
<b>.block : hover</b> <br>
псевдоклассы состояния: hover, active, target, focus<br>
псевдоклассы навигации: first child, last child, first off type, last off type, not<br>
<b>.block :: after</b> псевдоэлементы: before, after<br>
@import "имя файла"; - импорт файлов<br>
<br>
<em>Параметр в качестве селектора</em>:<br>
[class*="__container"] {}  применяем css-свойство ко всем элементам с атрибутом class, значение которого содержит __container<br>
<br>
<em>Псевдокласс</em> - это модификатор селектора<br>
<b>.link:hover{}</b><br>
<b>:hover</b> - срабатывает при наведении<br>
<b>:visited</b> - срабатывает для посещенных ссылок<br>
<b>:active</b> - срабатывает при нажатии на элемент<br>
<b>:focus</b> - срабатывает при получении элементом фокуса<br>
<b>:first-child</b> - обращение к первому элементу в блоке<br>
<b>:last-child</b> - обращение к последнему элементу в блоке<br>
<b>:nth-child(номер элемента по порядку, odd, even)</b> - обращение к конкретному элементу в блоке<br>
<br>
<em>Псевдоэлемент</em><br>
строчный, модификатор содержимого элемента, синтаксис<br>
<b>.text:hover::befor{}</b> либо <b>.text::first-line{}</b><br>
<b>::first-line{}</b> - задает стиль первой строки текста<br>
<b>::first-letter{}</b> - задает стиль первого символа<br>
<b>::before</b> - для отображения контента до содержимого элемента, к которому применяется.<br>
  Обязательное свойство <b>content</b>: '';<br>
<b>::after</b> - для отображения контента после содержимого элемента, к которому применяется.<br>
  Обязательное свойство <b>content</b>: '';<br>
<br>
<em>БЭМ</em><br>
- блок - часть кода, которая повторяется или может повторяться самостоятельно<br>
- элемент - это часть блока. имя класса блока__имя класса элемента<br>
- модификатор - дополняет или уточняет стиль блока или элемента<br>
<br>
класс_модификатор<br>
класс__элемент_модификатор<br>
микс - позволяет использовать блоки и элементы в одном объекте<br>
<br>
<em>Абсолютные единицы измерения</em><br>
<b>px</b> (пиксель)  Все остальные еденицы измерения пересчитываются браузером в пиксели<br>
<br>
<em>Относительные единицы измерения</em><br>
<b>em</b> - равен текущему размеру объекта.<br> Лучше использовать для медиа-запросов и в случае когда нужно привязаться к текущему размеру шрифта.<br>
<b>rem</b> - равен размеру шрифта в теге html, а если там нет, то браузера по умолчанию (16px).<br> Т.е. не зависит от резмаера шрифта родителя.<br> Лучше использовать для размеров шрифтов, отступов, не указывая размер для тега html.<br>
<b>%</b> - разные свойства css вычисляют % от разных оснований.<br> Лучше использовать для отзывчивых резиновых конструкций, для позиционирования объектов и для скрола.<br>
<b>vw, vh, vmin, vmax</b> - работают относительно окна браузера (viewport).<br> Лучше использовать для полноэкранных блоков и scss вычислений.<br>
<b>fr</b> - единица измерения в модуле grid.<br>
<b>ex</b> - единица измерения относительно размера прописной "е".<br>
<b>ch</b> - единица измерения относительно размера 0.<br>
</p></details><details><summary>Свойства</summary><p><em>Текст</em><br>
<b>font-family</b> - семейство шрифта.<br>
<b>font-size</b> - размер шрифта елемента.<br>
<b>font-style</b> - начертание шрифта (курсив, наклон и нормальный)<br>
<b>font-weight</b> - насыщенность (вес) шрифта<br>
<b>color</b> - цвет текста<br>
<b>text-align</b> - горизонтальное выравнивание текста<br>
<b>text-decoration</b> - оформление текста (подчеркивание, перечеркивание и т.д.)<br>
<b>text-shadow</b> - добавляет тень к тексту<br>
<b>text-transform</b> - преобразование заглавных и прописных символов<br>
<b>text-ident</b> - отступ первой строки от края блока<br>
<b>letter-spacing</b> - определяет интервал между символами<br>
<b>word-spacing</b> - определяет интервал между словами<br>
<b>white-space</b> - управляет свойствами пробелов между словами<br>
<b>line-height</b> - устанавливает межстрочный интервал текста<br>
<br>
<em>Геометрия</em><br>
<b>padding</b> - внутренний отступ блочных тегов<br>
<b>margin</b> - внешний отступ блочных тегов<br>
<b>width</b> - ширина блочных тегов<br>
<b>max-width</b> - устанавливает макимальную ширину блочных тегов<br>
<b>min-width</b> - устанавливает минимальную ширину блочных тегов<br>
<b>height</b> - устанавливает высоту блочных тегов<br>
<b>max-height</b> - устанавливает максимальную высоту блочных тегов<br>
<b>min-height</b> - устанавливает минимальную высоту блочных тегов<br>
<br>
<em>Отоброжение</em><br>
<b>overflow</b> - управляет отображением содержания блочного елемента<br>
<b>display</b> - определяет как елемент должен быть показан в документе<br>
<b>border</b> - граница блока<br>
<b>border-radius</b> - устанавливает радиус скругления уголков блока<br>
<b>outline</b> - внешняя граница блока<br>
<b>box-shadow</b> - добавляет тень к блоку<br>
<b>opacity</b> - определяет уровень прозрачности элемента<br>
<b>visibility</b> - отображение или скрытие блока<br>
<b>background</b> - управляет фоном элемента<br>
<b>background-color</b> - цвет фона элемента<br>
<b>background-image</b> - фоновое изображение или градиентная заливка<br>
<b>background-repeat</b> - повторение фонового изображения<br>
<b>background-position</b> - положение фонового изображения<br>
<b>background-attachment</b> - прокручивание фона вместе с содержимым элемента<br>
<b>background-size</b> - размеры фонового изображения<br>
<b>background</b> - позволяет задать несколько фоновых изображений одному блоку<br>
<b>background-origin и background-clip</b> - отвечают за показ фона вместе с границей border.<br>
<br>
<em>Позиционирование</em><br>
<b>position</b> - совйство позиционирования устанавливает тип позиционирования элемента относительно других элементов или окна браузера<br>
<b>position: static</b>; - по умолчанию у всех блоков<br>
<b>position: relative</b>; - положение относительно изначального места в коде, обязательно с:<br>
<b>left, top, right, bottom</b> - управляют позицией элемента<br>
<b>z-index</b> - управляет наложением элементов<br>
Для взаиморасположения относительно друг друга у одного элемента должно быть absolute у другого relative<br>
<b>position: absolute</b>; - утрачивает связь с местом в коде и свойствами тега, обязательно с:<br>
<b>position: fixed</b>; - фиксирует элемент относительно окна браузера не завися от элементов с relative и прокрутки обязательно с: left, top, right, bottom - управляют позицией элемента<br>
<b>position: sticky</b>; - переводит элемент из static в fixed при достижении элементом указаной позиции обязательно с: left, top, right, bottom - управляют позицией элемента<br>
<br>
<em>Трансформ</em><br>
<b>transform</b> - применяется только к блочным объектам<br>
<b>transform: translate(0px, 0px</b>); - translate сдвигает элемент на новое место<br>
<b>transform: scale(1, 1)</b>; - scale масштабирует изображения, т.е. zoom. При отрицательном значении - зеркалит.<br>
<b>transform: rotate(0deg)</b>; - поворачивает элемент. Положительное значение по часовой, отрицетельное - против.<br>
<b>transform: skew(0deg, 0deg)</b>; - деформирует стороны объекта по вертикали и горизонтали.<br>
<b>transform: matrix(a, b, c, d, e)</b>; - позволяет объединить трансформации. Значения без едениц измерения.<br>
<b>transform: translate(0px, 0px) scale(1, 1) rotate(0deg)</b>;
<b>transform-origin: center</b>; - смещает центр трансформации<br>
<b>perspective: 0px</b>; - установка глубины перспективы<br>
<b>perspective-origin: center</b>; - смена точки начала координат<br>
<b>transform: translate3d(0px, 0px, 0px)</b>;<br>
<b>transform: scale3d(1, 1, 1)</b>;<br>
<b>transform: rotate3d(x, y, z, deg)</b>;<br>
<b>transform: matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n)</b>; - 16 значений<br>
<b>transform: translate3d(0px, 0px, 0px) rotate3d(1, 1, 1, 0deg)</b>;
<b>transform-style: flat</b>; - задает стиль трансформации<br>
<b>backface-visibility: visible</b>; - показывает обратную сторону объекта<br>
<br>
<em>Шрифты</em> подключаем любо в html тегом <b>link</b> либо в scss через <b>@import</b><br>
fonts.google.com<br>
nomail.com.ua<br>
font2web.com<br>
<br>
БЭМ: ru.bem.info<br>
</p></details><details><summary>Flex</summary><p><b>display</b>: flex; - включает флекс разметку<br>
<b>display</b>: inline-flex; - строчный флекс-контейнер<br>
<br>
<b>justify-content</b> - определяет выравнивание вдоль основной оси<br>
<b>justify-content</b>: flex-start; - елементы слева<br>
<b>justify-content</b>: flx-end; - елементы справа<br>
<b>justify-content</b>: cnter; - елементы в центре<br>
<b>justify-content</b>: space-between; - пространство между елементами<br>
<b>justify-content</b>: space-around; - пространство вокруг елементов<br>
<br>
<em>для флекс-контейнера:</em>
<b>align-items</b> - определяет поведение вдоль перекрёсной оси<br>
<b>align-items</b>: stretch; - елементы подстраиваются под самый высокий<br>
<b>align-items</b>: flex-start; - высота флекс-елемента от верха на высоту контента<br>
<b>align-items</b>: flex-end; - высота флекс-елемента от низа на высоту контента<br>
<b>align-items</b>: center; - флекс-елементы выстроятся по горизонтальному центру самого высокого елемента<br>
<b>align-items</b>: baseline; - выстраивает флекс-елементы по базовой линии<br>
<b>flex-wrap</b>: nowrap; - флекс-елементы не адаптируются<br>
<b>flex-wrap</b>: wrap; - флекс-елементы адаптируются<br>
<b>flex-wrap</b>: wrap-reverse; - флекс-елементы адаптируются в обратном порядке<br>
<br>
<em>для флекс-елемента:</em>
<b>align-self</b> - переопределяет выравнивание<br>
<b>align-self</b>: stretch;<br>
<b>align-self</b>: center;<br>
<b>align-self</b>: flex-start;<br>
<b>align-self</b>: flex-end;<br>
<br>
<b>order</b> - порядок вывода елементов<br>
<b>order</b>: 1; - выводим первым<br>
<b>flex-basis</b> - базовый размер элемента<br>
<b>flex-basis</b>: auto; - по размеру контента<br>
<br>
<b>flex-grow</b> - возможность увеличиваться в размере<br>
<b>flex-grow</b>: 0; - не больше чем flex-basis<br>
<b>flex-shrink</b> - возможность уменьшаться в размере<br>
<b>flex-shrink</b>: 1; - разрешено становиться меньше<br>
<b>flex</b>: 0 1 auto; - короткая запись flex-grow flex-shrink flex-basis<br>
<br>
<b>flex-direction</b> - устанавливает основную ось<br>
<b>flex-direction</b>: row; - в ряд<br>
<b>flex-direction</b>: row-reverse; - в обратную сторону в обратном порядке<br>
<b>flex-direction</b>: column; - основная ось вертикально<br>
<b>flex-direction</b>: column-revers; - вертикально снизу вверх<br>
</p></details><details><summary>GRID</summary><p><b>display</b>: grid; - определяет блочный грид-контейнер<br>
<b>display</b>: inline-grid; - определяет строчный грид-контейнер<br>
<b>grid-template-columns</b>: ; - управление колонками<br>
<b>grid-template-rows</b>: ; - управление рядами<br>
<b>grid-template-columns</b>: 200px minmax(150px, 1fr) 200px; - первая колонка шириной 200рх, вторая - минимум 150рх и максимум на всю ширину грид-контейнера, третья - шириной 200рх<br>
<b>grid-template-rows</b>: 1fr 1fr; - два ряда делят высоту грид-контейнера поровну<br>
<b>grid-template-columns</b>: fit-content(400px) 1fr auto; - ширина первой колонки по контенту, но не шире 400рх, вторая колонка - вся свободная ширина блока, третья колонка по ширине контента<br>
<b>grid-template-columns</b>: repeat(3, 1fr); - 3 колонки размером 1fr<br>
<b>grid-template-areas</b>: ; - управляет областями<br>
<b>grid-area</b>: ; - применяется к елементам<br>
<b>grid-template</b>: repeat(2, 1fr) / repeat(3, 1fr); - две равные строки и три равные колонки<br>
<b>grid-template</b>:<br>
[start] "header header" 100px [row2]<br>
[row2]  "side content" 1fr [row-end] / 150px 1fr; - управление областями, через свойство grid-area присваиваем имена элементам, в первом ряду header занимает две колонки, второй ряд содержит колонки side и content, высота рядов 1fr, ширина колонок 150px 1fr.<br>
<b>grid-auto-rows</b>: ; - управляет рядом неявной сетки, т.е. ряд, который не обозначен в grid-template-rows<br>
<b>grid-auto-columns</b>: ; - если не задан grid-template-columns<br>
<b>grid-auto-flow</b>: row; - выстраивает грид-элементы поочередно в ряд<br>
<b>grid-auto-flow</b>: column; - выстраивает грид-элементы поочередно в колонку<br>
<b>grid-auto-flow</b>: dense; - выстраивает грид-элементы в произвольном порядке<br>
<br>
<em>Размещение элементов с помощью линий сетки</em>:<br>  
<b>grid-row-start</b>: auto;<br>
<b>grid-row-end</b>: auto;<br>
<b>grid-column-start</b>: auto;<br>
<b>grid-column-end</b>: auto;<br>
<b>grid-row-start</b>: span 2; объект занимает 2 строчки<br>
<b>grid-template-rows</b>: [start] 1fr [row2] 1fr [row-end]; - две строки одинаковой высоты и [имена линий] между строк сверху вниз<br>
<b>grid-template-columns</b>: [start] 1fr [col2] 1fr [col3] 1fr [col-end]; - три столбца одинаковой ширины и [имена линий] меду столбцами слева направо<br>
<b>grid-row</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
<b>grid-column</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
или<br>
<b>grid-row</b>: start / row2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
<b>grid-column</b>: start / col2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
<b>order</b>: 1; - задается каждому елементу сетки и определяет порядок вывода елемента<br>
<b>justify-items</b>: stretch; - растягивает/прижимает елементы в ячейках вправо/влево<br>
<b>align-items</b>: stretch; - растягивает/прижимает елементы в ячейках вверх/вниз<br>
<b>row-gap</b>: 20px; - расстояние между строками<br>
<b>column-gap</b>: 20px; - расстояние между колонками<br>
или<br>
<b>gap</b>: 20px; - и для строк и для колонок одновременно<br>
</p></details><details><summary>Адаптивная верстка</summary><p><em>отзывчивая</em> - всё в <b>%</b>, указываем только максимальную ширину для body, весь контент на своём месте, отзывается на изменение ширины экрана.<br>
<em>адаптивная</em> - <b>брейкпоинты</b>, медиа-запросы, контент перестраивается на брейкпоинтах при изменении ширины экрана.<br>
<em>отзывчиво-адаптивная</em> - делаем отзывчиую пока читается контент при уменьшении ширины экрана. При ширине плохо читабельного контента далем брейкпоинт - адаптив.<br>
<b>meta</b> name="viewport" content="width=device-width"<br>
<em>Брейкпоинт</em>:</p><pre><code>@media (max-width:1200px){
  .container{
    max-width: 970px;
  }
}

@media (max-width:992px){
  .container{
    max-width: 750px;
  }
}

@media (max-width:767px){
  .container{
    max-width: none;
  }
}</code></pre><b>@import</b> url(color.css) screen and (color); - медиа-запрос в css,<br>
<b>link</b> rel="stylesheet" media="screen and (color)" href="example.css" - медиа-запрос в html: файл стилей подключится в только при выполнении условия медиа-запроса<br></details><details><summary>Animation</summary><pre><code><b>@keyframes</b> <i>grow</i> {
  <b>from</b> {
    font-size: 20px;
  }
  <b>to</b> {
    font-size: 100px;
  }
}

<b>h1</b> {
  <b>animation-name</b>: <i>grow</i>;
  <b>animation-direction</b>: 2s;
  <b>animation-fill-mode</b>: forwards;
}

<span>или</span>

<b>@keyframes</b> <i>grow</i> {
  <b>from</b> {
    left: 0%;
  }
  <b>to</b> {
    left: 50%;
  }
}

<b>h1</b> {
  <b>position: relative</b>
  <b>animation-name</b>: <i>grow</i>;
  <b>animation-direction</b>: 2s;
  <b>animation-fill-mode</b>: forwards;
}</code></pre><p><b>animation-name</b>: имя ключевых кадров, имя ключевых кадров № 2; - список применяемых к элементу анимаций (кадров)<br>
<b>animation-duration</b> - продолжительность анимации<br>
<b>animation-timing-function</b> - сценарий анимации<br>
<b>animation-iteration-count</b> - количество повторов ключевых кадров<br>
<b>animation-direction</b> - тип и направление проигрования ключевых кадров<br>
<b>animation-play-state</b> - запускает либо приостанавливает анимацию по событию<br>
<b>animation-name</b>: none; - возвращает анимацию на исходную<br>
<b>animation-delay</b> - задержка перед началом анимации<br>
<b>animation-fill-mode</b> - определяет какие свойства применятся после завершения анимации<br>
<b>animation</b>: name duration function count direction delay mode;<br>
<b>animation</b>: firstname 2s linear infinite alternate 0s forwards, secondname 5s ease infinite alternate 0s forwards;<br>
<br>
Сколько свойств - столько и значений transition-duration через запятую<br>
<b>transition-duration</b> - время перехода<br>
<b>transition-property</b> - содержит css свойства к которым будет применен переход<br>
<b>transition-delay</b> - время задержки перехода<br>
<b>transition-timing-function</b> - сценарий анимации<br>
<b>общая запись</b>: transition: all 1s ease 0s; - transition: property duration function delay;<br>
<b>transition</b>: padding 1s ease 0s, color 2s ease-in 0.5s;<br>
</p></details><details><summary>Графика</summary><p><b>JPEG/JPG</b> - растровый, оптимизируется хорошо, лучше для контента<br>
<b>PNG</b> - растровый, оптимизируется плохо, может быть прозрачным, лучше для фона и элементов дизайна<br>
<b>GIF</b> - растровый, до 256 цветов, видеоролик в формате изображения, оптимизируется хорошо<br>
<b>SVG</b> - векторный, хорошо подходит для иконок и при масштабировании изображения<br>
<b>WebP</b> - замена всех растровых форматов (прозрачность, анимация, хорошо оптимизируется)<br>
<b>ico</b> - растровый, оптимизируется хорошо, может быть прозрачным, 16х16рх, для иконок<br>
<b>link</b> rel="shortcut icon" href="favicon.ico"<br>
<b>object</b> - работа с изображениями в контейнере как background в фоне<br>
<b>object-fit</b>: fill; - управляет изображением внутри контейнера<br>
<b>object-position</b>: center; - позиционирование изображения относительно родителя<br>
</p></details><a href="https://www.youtube.com/@OnlineTutorialsYT">OnlineTutorialsYT</a><a href="https://www.youtube.com/@codeonly">Code Only</a><a href="https://www.youtube.com/playlist?list=PLM6XATa8CAG6IJvQBkrTTNZmpIcyS2Avk">Как сделать</a><a href="https://www.youtube.com/watch?v=kfOe-F64C_A&amp;list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr&amp;index=9">Уроки HTML CSS JS</a><a href="https://www.youtube.com/playlist?list=PLN2KCaMlZNdCBrVcXJXEO1iaTkZIMEA7R">Верстка сайта от 0 до 1</a><a href="https://www.w3.org/TR/cssom-1/">CSSOM</a></details><details><summary class="menu__submenu_lv1">Sass</summary><p><em>Sass</em> - препроцессор, добавляет функционала в css<br>
<em>SCSS</em> - синтаксис Sass похожий на синтаксис css<br>
<em>Вложенность</em> - писать правила css внутрь других правил<br>
<em>&</em> - подставляет вместо себя класс, внутри которого указан. Удобно для указания псевдоклассов и псевдо элементов<br> 
<em>$var:80px;</em> - переменная var со значением 80 пикселей<br>
<br>
<em>Шаблоны</em>:<br>
<b>%tpl</b> {параметры css} - задаём шаблон tpl<br>
<b>@extend</b> %tpl; - вставляем в нужный блок правил css<br>
либо<br>
<b>.tpl</b> {параметры css} - задаём шаблон tpl<br>
<b>@extend</b> .tpl; - вставляем в нужный блок правил css<br></p><pre><code>%message {
  <b>font-family</b>: sans-serif;
  <b>font-size</b>: 18px;
  <b>font-weight</b>: bold;
  <b>border</b>: 1px solid black;
  <b>padding</b>: 20px;
  <b>maigin</b>: 20px;
}

.success {
  <b>@extend %message</b>;
  <b>background-color</b>: green;
}

.warning {
  <b>@extend %message</b>;
  <b>background-color</b>: orange;
}

.error {
  <b>@extend %message</b>;
  <b>background-color</b>: red;
}</code></pre><br><p><em>Миксины</em>:<br>
@<b>mixin</b> exempl($var) {font-size: $var;} - объявляем миксин с переменной<br>
@<b>include</b> exempl(100px); - вставляем в нужный блок правил css со значением поддерживает математические рассчеты<br>
<br>
<em>Комментарии</em>:<br>
<b>/* */</b> - отображается и в файле scss и в css<br>
<b>//</b> - отображается только в файле scss<br></p><br><a href="https://sass-scss.ru/">Manual</a></details><details><summary class="menu__submenu_lv1">JS</summary><details><summary>Синтаксис</summary><p>&lt;<b>script</b>&gt;alert('Привет мир!') &lt;/<b>script</b>&gt; - вставить скрипт в html, либо<br>
&lt;<b>script</b> src="/path/to/script.js"&gt; &lt;/<b>script</b>&gt; - подключить в html файл со скриптом.<br>
<b>"use strict"</b> или <b>'use strict'</b> - строгий режим. Отключить невозможно.<br>
Классы и модули строгий режим включают автоматически.<br>
<br>
Имена должны быть легко читаемые, camelCase, описательные и лаконичные.<br>
<b>" "</b> или <b>' '</b> - это строка<br>
<b>`${...} `</b> - вставить выражение в строку<br>
<b>//</b> - однострочный комментарий<br>
<b>/*...*/</b> - многострочный комментарий<br>
<br>
<dfn>Блок инструкций</dfn>:</p><pre><code>{
  console.log('Учим');
  console.log('JS');
}</code></pre><br><p><dfn>Область видимости {}</dfn><br>
<b>const KNOW_VAL = I know the value</b>; - константа с известным заранее значением пишем в верхнем регистре<br>
<b>const donotKnow = I don't know the value</b>; - константа с неизвестным заранее значением<br>
<b>var</b> - ключевое слово переменной, можно использовать до объявления.<br>
область видимости в пределах модуля, <br>
исключение: если объявлена в теле функции, то видна только в теле функции.<br>
<br>
<dfn>Комментируй</dfn>:<br>
  - общую архитектуру<br>
  - использование функций<br>
  - неочевидные решения<br>
  - важные детали<br>
<em>Не комментируй что делает код.</em><br>
<br></p><table><caption><dfn>Значения</dfn>:</caption><thead><th>фиксированные значения</th><th>литералы</th></thead><tbody><tr><td>литерал целого числа</td><td>25</td></tr><tr><td>литерал дробного числа</td><td>23.8</td></tr><tr><td>литерал строки</td><td>'Javascript', "Javascript"</td></tr><tr><td>литерал массива</td><td>[], [15,7,89]</td></tr><tr><td>литерал объекта</td><td>{}, {name: 'Javascript', surname: 'Javascript'}</td></tr><tr><td>литерал регулярного выражения</td><td>(ab|bc)</td></tr><tr><td>значения констант</td><td>const MAX_VALUE = 17;</td></tr><tr><td>значения переменных</td><td>var section = 'JS';</td></tr></tbody></table><code>let arr = ['HTML','CSS','JS'];</code><br><p><dfn>Выражения</dfn> - комбинация значений переменных и операторов<br>
<dfn>Ключевые слова</dfn> - определяет какое действие нужно выполнить<br>
<br>
<dfn>Автоматическое тестирование</dfn> - тесты пишуться отдельно:<br>
по-разному запускают функции и сравнивают результат с ожидаемым.<br>
<br>
<dfn>спецификация состоит из</dfn>:</p><pre><code><span>описываем функцию pow</span>
describe ("pow", function(){
  <span>рабочий блок - описывает что делает</span>
  it ("возводит в степень n", function() {
    <span>функция assert проверяет работу функции pow</span>
    assert.equal(pow(2, 3), 8);
  });
});</code></pre><br><p><dfn>Опциональная цепочка</dfn>:<br>
Если перед <em>?.</em> undefined или null, то останавливает вычисление и возвращает undefined (без ошибки).<br>
<em>?.</em> работает:<br>
  - с существующими переменными<br>
  - с функциями user1.admin?.(...)<br>
  - с квадратными скобками ?.[...]<br>
<b>let user = {}</b>; - пользователь без адреса<br>
<b>alert(user?.adress?.street)</b>; - undefined (без ошибки)<br>
<b>delete user?.name</b> - удалит user.name если user существует<br>
<b>obj?.prop</b> - вернёт obj.prop если obj есть, иначе undefined<br>
<b>obj?.[prop]</b> - вернёт obj[prop] если obj есть, иначе undefined<br>
<b>obj.method?.()</b> - вызовет obj.method если он есть, иначе undefined<br>
      </p></details><details><summary>Types</summary><p><dfn>Тип</dfn>:<br>
- набор характеристик значения,<br>
- не у переменной, а у значения,<br>
- присваиваится переменной вместе со значением.
</p><details><summary>Object</summary><pre><code>Object {
        property1: value1,
        property2: value2
      }

let someObj = new Object();
let someObj = {
  key1: value1,
};
console.log(someObj.key);
либо 
console.log(someObj['key']);</code></pre><p><b>someObj.key2 = value2</b>; - добавил в объект свойство (ключ: значение)<br>
<b>delete someObj.key2</b>; - удалил из объекта свойство (ключ: значение)<br>
<b>let obj = someObj</b>; - скопировал ссылку на объект в другую переменную<br>
<b>let obj = Object.assign({}, someObj)</b>; - сделал дубликат объекта</p><pre><code><span>проверка на наличие свойства</span>
if ("key1" in someObj) {}
<span>перебирает все свойства объекта</span>
for (let key in object) {}
let someObj = {
  key1: value1,
  <span>метод объекта</span>
  someFunc: function () {},
  <span>либо</span>
  someFunc() {},
};</code></pre><p><dfn>Function</dfn> - это Object, но выведен отдельно для простоты определения функций<br>
<dfn>Object.getOwnPropertySymbols(obj)</dfn> - получить все свойства объекта с ключами-символами<br>
<dfn>Reflect.ownKeys(obj)</dfn> - возвращает все ключи объекта включая символьные<br>
</p></details><details><summary>Примитивы</summary><p><dfn>Примитивы</dfn> - это конкретные значения.<br>
С помощью объектов-оберток (Number, String, ...) все примитивы кроме null и undefined
имеют методы работы с ними.<br>
<dfn>undefined</dfn> - неопределен, нет значения<br>
<dfn>null</dfn> - переменная определена, значение - ничего<br>
<dfn>boolean</dfn> - true/false<br>
<dfn>number</dfn> - числа целые и с точкой<br>
<dfn>infinity</dfn> (безконечность)<br>
<dfn>NaN</dfn> (Not a Number)<br>
<br>
<dfn>Обычные числа в JS</dfn> - это числа с плавающей точкой двойной точности 
(double precision floating point numbers), 64-битный формат IEEE-754.<br>
<br>
<dfn>BigInt</dfn> - числа позволяют работать с числами произвольной длины.<br>
123e6 = 123 000 000 (e6 - это 6 нулей) 123e-6 = 0,000123<br>
let someNum = 1000000; лучше так: let someNum = 1e6;<br>
let num = 0.000001; - let num = 1e-6;<br>
<br>
<dfn>string</dfn> - строка ' ', " ", `${}`<br>
"Какое-то \n предложение \n\t тут": \n - перевод строки, \t - табуляция (отступ), \ - экранирование<br>
let someText = "text";<br></p><pre><code><span>длина строки</span>
console.log(someText.length);

<span>получаем символ строки</span>
let firstSymbol = someText[0];

<span>последний символ строки</span>
let lastSymbol = someText[someText.length-1];

<span>перебирает символы строки</span>
for (const char of someText) {
  console.log(char);
}</code></pre><p><dfn>someText.toUpperCase()</dfn> - все буквы большие<br>
<dfn>someText.toLowerCase()</dfn> - все буквы маленькие<br>
<dfn>someText.indexOf(substr, pos)</dfn> - ищет подстроку substr в строке someText,<br>
  pos - необязательный, символ с которого искать<br>
<dfn>includes(substr, pos), startsWith(substr), endsWith(substr)</dfn> - проверяет на наличие, возвращает true или false<br>
<dfn>slice(start, end)</dfn> - возвращает часть строки без end<br>
<br>
<dfn>Symbol</dfn> - идентификатор объекта<br>
Два <b>Symbol("id")</b> с одинаковым "<b>id</b>" - это разные символы.<br>
let id = Symbol.for("id") - читает символ "id" из глобального реестра,
если символа нет, то создаст новый глобальный символ.<br>
В глобальном реестре под одним именем один символ.<br>
Используется как "скрытые" свойства объектов, т.к. символьное свойство не появится в for..in,
например:<br>
- Symbol.iterator - для итераторов,<br>
- Symbol.toPrimitive - для преобразования объектов в примитивы<br></p><pre><code><span>создание символа</span>
let id = Symbol("id");
let user = {
<span>не преобразуются в строку автоматически</span>
  name: "Вася",
<span>просто id:123 не работает,</span>
<span>т.к. нужно значение переменной id,</span>
<span>а не срока id.</span>
  [id]: 123
};
</code></pre></details><details><summary>typeof</summary><p><em>typeof</em> - возвращает тип аргумента<br>
<em>typeof 0</em> - number<br>
<em>typeof true</em> - boolean<br>
<em>typeof 'JS'</em> - string<br>
<em>typeof undefined</em> - undefined<br>
<em>typeof Math</em> - object<br>
<em>typeof Symbol ('JS')</em> - symbol<br>
<em>typeof null</em> - object - баг, это null<br>
<em>typeof function() {}</em> - function - баг, это object<br>
<em>typeof NaN</em> - number - Not a Number возвращает number<br>
</p></details><details><summary>Приведение типов</summary><p>Основные приведения: <dfn>строковое, численное и логическое.</dfn><br>
<em>' ', 0, null, undefined, Nan, false</em> - приводятся Boolean() к false.<br>
<em>Boolean('Hello')</em> - true<br>
<em>Boolean(' ')</em> - true, пробел - это символ<br>
<em>Boolean('0')</em> - true, '0' приводится к строке<br>
<em>Boolean(0)</em> - false<br>
<em>Boolean([])</em> - true<br>
<em>Boolean({})</em> - true<br>
<br>
Операторы приводят значения null к 0, а undefined к NaN:<br>
<em>null > 0</em> - false<br>
<em>null >= 0</em> - true<br>
<em>null == 0</em> - false<br>
<em>undefined > 0</em> - false<br>
<em>undefined == 0</em> - false<br>
<br>
<b>NaN</b> возвращает <b>false</b> при любых сравнениях.<br>
При нестрогом равенстве null/undefined ни к чему не приводятся и равны только друг другу.<br>
<br>
<dfn>Строки и числа</dfn><br>
<em>String(value);</em> - приведение к строке<br>
<em>Number(value);</em> - приведение к числу<br>
<em>Number("123");</em> - 123<br>
<em>Number("123z");</em> - NaN<br>
<em>Number(true);</em> - 1<br>
<em>Number(false);</em> - 0<br>
<em>+true</em> - 1<br>
<em>+''</em> - 0<br>
<em>null + 2</em> - number 2, null приводится к 0<br>
<em>1 + '2'</em> - string 12<br>
<em>'' + 1 + 0</em> - string 10<br>
<em>'' - 1 + 0</em> - number -1, у строки есть только оператор сложения (конкатенация), поэтому -1 это число + 0<br>
<em>'3' + '8'</em> - number 24<br>
<em>4 + 10 + 'px'</em> - string 14px<br>
<em>'px' + 4 + 10</em> - string px410<br>
<em>'42' - 40</em> - number 2<br>
<em>'42px' - 40</em> - NaN, px к числу не приводится<br>
<em>undefined + 2</em> - NaN, undefined приводится к NaN<br>
<em>parseInt()</em> - возвращает целое число, которое смогло получить из параметра<br>
<em>parseFloat()</em>- возвращает число с точкой, которое смогло получить из параметра<br>
<em>parseInt(str, base)</em> - преобразует строку в число,<br>
base - система исчисления 2 =&lt;base =&lt;36, по умолчанию 10<br>
<em>parseInt('0xff', 16)</em> - 255, дополнительное свойство - читает кодировки чисел<br>
<em>parseInt('100px')</em> - 100<br>
<em>parseFloat('12.5dfn')</em> - 12.5<br>
<em>parseInt('a123')</em> - NaN, не смог прочитать ни одной цифры<br>
<em>num.toString(base)</em> - преобразует число num в строку в виде системы исчисления base (от 2 до 32, по умолчанию 10)<br>
Если вызывать метод на числе, то <b>123..toString(36)</b> или <b>(123).toString(36)</b><br>
<em>num.toFixed(n)</em> - округляет до n знаков после запятой и возвращает результат в виде строки<br>
<em>isNaN(value)</em> - преобразует в число и проверяет является ли оно NaN. NaN никогда не будет равно NaN.<br>
<em>NaN === NaN</em> - false<br>
<em>isFinite(value)</em> - преобразует в число и возвращает true если обычное число<br>
<em>Object.is(a, b)</em> - идентично a === b<br>
<em>Object.is(NaN, NaN)</em> === true<br>
<em>Object.is(0, -0)</em> === false, технически 0 и -0 это разные значения<br>
встроенный объект <em>Math</em> - математические операции над числами<br>
<br>
<dfn>Преобразование объектов в примитивы:</dfn><br>
<b>obj[Symbol.toPrimitive](hint)</b> - вызывается метод объекта если он существует<br>
Если <b>hint = string</b>, то вызывается <b>obj.toString()</b>,<br>если такого нет, то <b>obj.valueOf()</b><br>
Если <b>hint = number или default</b>, то вызывается <b>obj.valueOf()</b>,<br>если такого нет, то <b>obj.toString()</b>.</p><img src="../img/js/Прототип.png" alt=""></details></details><details><summary>Регулярные выражения</summary></details><details><summary>Операторы</summary><p><em>операнд</em> - это то, к чему применяется оператор<br>
<em>-х;</em> - унарный оператор - применяется к одному операнду<br>
<em>у - х;</em> - бинарный оператор - применяется к двум операндам<br>
<em>+операнд</em> - приведение к числу<br>
<em>=</em> - оператор присваивания<br>
<br>
<dfn>все операторы возвращают значение</dfn><br>
<em>+</em> сложения, если одно из слагаемых строка, то сумма - строка.<br>
Остальные операторы дают число.<br>
<em>-</em> вычитания<br>
<em>*</em> умножения<br>
<em>/</em> деления<br>
<em>%</em> взятие остатка от деления (5%2 = 1)<br>
<em>**</em> возведения в степень<br>
<br>
<dfn>Инкремент/декремент можно применять только к переменной.</dfn><br>
<em>++</em> инкремент увеличивает на 1<br>
<em>--</em> декремент уменьшает на 1<br>
<em>counter++</em> постфиксная форма возвращает старое значение (до увеличения/уменьшения числа)<br>
<em>++counter</em> префиксная форма возвращает новое значение<br>
<br>
<dfn>операторы == vs === (нестрогое vs строгое)</dfn><br>
<em>==</em> сравнивает с приведением типов<br>
<em>===</em> сравнивает без приведения типов<br></p><pre><code>2 == '2' <span>true</span>
2 === '2' <span>false</span>
undefined == null <span>true</span>
undefined === null <span>false</span>
'0' == false    <span>true</span>
'0' == 0        <span>true</span>
0 == 0          <span>true</span>
false == ''     <span>true</span>
false == []     <span>true</span>
false == {}     <span>false</span>
'' == 0         <span>true</span>
'' == []        <span>true</span>
'' == {}        <span>false</span>
'' == null      <span>false</span>
{} == {}        <span>false</span>
{} === {}       <span>false</span></code></pre><p>== и === для объектов работают одинаково.<br>
Два объекта равны если это один и тот же объект.</p><pre><code>2**2 = 4
4**(1/2) = 2 <span>квадратный корень</span>
8**(1/3) = 2 <span>кубический корень</span></code></pre><br><p><dfn>Приоритет</dfn>:<br>
<em>+</em> унарный плюс<br>
<em>-</em> унарный минус<br>
<em>**</em> возведение в степень<br>
<em>*</em> умножение<br>
<em>/</em> деление<br>
<em>+</em> сложение<br>
<em>-</em> вычитание<br>
<em>=</em> присваивание<br>
<br></p><p><dfn>Операторы сравнения</dfn>:<br></p><pre><code>a&gt; b, a &lt;b    <span>больше/меньше</span>
a&gt;= b, a <= b  <span>больше/меньше или равно</span>
a == b          <span>равно</span>
a === b         <span>строгое равно</span>
a != b          <span>не равно</span>
a !== b         <span>строгое не равно</span></code></pre><p>Все операторы возвращают true или false.<br>
Строки сравниваются посимвольно.<br>
При сравнении разных типов - приведение к числу.<br></p><br><p><dfn>Оператор запятая</dfn> (,):<br>
- позволяет вычислять несколько выражений, разделяя их запятой.<br>
- каждое выражение выполняется, но возвращается результат только последнего.<br></p><pre><code>let a = (1+2, 3+4);   <span>скобки важны, т.к. приоритет ниже чем =</span>
alert(a);   <span>7-результат 3+4.</span></code></pre><br><p><dfn>Побитовые операторы</dfn>:</p><pre><code>&   <em>AND</em>                     <span>и</span>
|   <em>OR</em>                      <span>или</span>
^   <em>XOR</em>                     <span>побитовое исключающие или</span>
~   <em>NOT</em>                     <span>не</span>
<<  <em>LEFT SHIFT</em>              <span>левый сдвиг</span>
>>  <em>RIGHT SHIFT</em>             <span>правый сдвиг</span>
>>> <em>ZERO-FILL RIGHT SHIFT</em>   <span>правый сдвиг с заполнением нулями</span></code></pre><p>Побитовые операторы работают с 32-разрядными целыми числами (приводят к ним), на уровне их внутреннего двоичного представления.<br></p><br><p><dfn>Логические операторы</dfn>:<br>
<em>||</em>  или - если любой из аргументов true, то вернет true, иначе false</p><pre><code>true  || true   <span>true</span>
false || true   <span>true</span>
true  || false  <span>true</span>
false || false  <span>false</span></code></pre><p>- цепочка или || возвращает первое истиное значение или последнее, если такое значение не найдено.<br>
- цепочка вычисляется слева направо.<br></p><code>undefined || null || 0  <span>результат 0</span></code><br><p><em>&&</em>  и - если оба аргумента true, то вернет true, иначе false</p><pre><code>true  && true   <span>true</span>
false && true   <span>false</span>
true  && false  <span>false</span>
false && false  <span>false</span></code></pre><p>- цепочка или && возвращает первое ложное значение или или последнее, если такое значение не найдено.<br>
- приоритет и && больше чем или ||.<br>
<em>Или ||</em> спотыкается на правде, <em>и &&</em> спотыкается на лжи.<br></p><br><p><em>!</em> не  - принимает один аргумент, приводит к логическому типу и возвращает к противоположное значение.<br>
<em>!true</em> - false<br>
<em>!0</em> - true<br>
<em>!"non-empty string"</em> - true<br>
<em>!null</em> - false<br>
<em>!операнд</em> - приведение к boolean<br>
Приоритет <em>!</em> наивысший из всех логических операторов.<br></p><br><p><em>??</em> - оператор объединения с null, возвращает первое определённое значение, если оно отличается от null или undefined.</p><pre><code>let height = 0;
height || 100 <span>вернет 100</span> 
height ?? 100 <span>вернет 0</span>
a ?? b <span>результат a, если а определено, иначе b</span>
let user;
alert(user??"Аноним");  <span>Аноним</span></code></pre><p>Запрещено использовать оператор ?? вместе с && и || без явного указания приоритета скобками.</p><br><p><em>...</em> - троеточие, обозначает оператор "остаточные параметры" если нахидотся в конце списка аргументов функции либо оператор "расширения".<br>
- оператор "остаточные параметры" используется, чтобы создавать функции с неопределённым числом аргументов, собирает оставшиеся параметры в массив:</p><code>let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Repablic"];</code><p>- оператор "расширения" позволяет вставить массив в функцию, расширяя перебираемый объект arr в список аргументов (f...arr);<br>
оператор "расширения" работает только с итерируемыми объектами.
</p></details><details><summary>Инструкции</summary><p><dfn>Условное ветвление</dfn>:</p><pre><code>if (...) {          
  ...             
} else if (...) {    
  ...
}</code></pre><p>- вычисляет условие в скобках<br>
- приводит к логическому типу<br>
- если условие true, то выполняет блок кода<br>
Блоков else и else if может быть сколько угодно, а может и не быть.<br></p><pre><code>if () {}
if () {} else {}
if () {} else if () {} else {}

switch(x) {
  case 'value1':
    ...
    break
  case 'value2':
    ...
    break
  default:
    ...
  break
}</code></pre><p>- switch заменяет несколько if.<br>
- switch имеет один или несколько блоков case.<br>
- проверка равенства всегда строгая.<br>
- если нет break, то выполнение пойдет по следующим case без проверки.<br></p><br><p>? - тернарный оператор (три аргумента)<br>
let result = условие <b>?</b> значение1 <b>:</b> значение2;<br>
если условие true, то значение1, иначе значение2<br>
break/continue использовать нельзя<br>
() <b>?</b> valueIfTrue <b>:</b> valueIfFalse; тоже самое <b>if () {} else {}</b><br></p><br><p><dfn>Циклы</dfn>:</p><pre><code>while (...) {
  <span>тело цикла - выполняется пока условие true</span>
}
while () {} - <span>если процедура не одна, то {}.
Если процедура одна: while () procedure;</span>

do {
  <span>тело цикла</span>
} while (...);</code></pre><p>- выполнить и проверить условие<br>
- если условие true, то выполнить и проверить условие ещё раз<br></p><pre><code>for (начало; условаие; шаг) {
  <span>тело цикла</span>
}</code></pre><p>- выполнить начало<br>
- посторять пока условие true:<br>
если условие true, то выполнить тело<br>
выполнить шаг и проверить условие<br>
Любая часть может быть пропущена.<br></p><pre><code>for (;;) {
  <span>будет выполняться вечно</span>
}

for (key in object) {
  <span>тело цикла выполняется для каждого свойства объекта</span>
}</code></pre><p><em>for..in</em> - для перебора свойств объекта<br>
<em>for..of</em> - для перебора значений массива<br></p><pre><code>let fruits = ["Яблоко", "Апельсин", "Слива"];
for (let fruit of fruits) {
  alert(fruit);
}</code></pre><p>- проходит по значениям каждого элемента массива<br>
- не предоставляет доступа к номеру элемента, только к его значению<br></p><br><p><dfn>Метка</dfn> - точка местоположения в коде:</p><pre><code>outer: for (...) {
  for (...) {
    if (!input) break outer;
  }
}</code></pre><p>outer: - метка-идентификатор с двоеточием<br>
break/continue поддерживает метки
</p></details><details><summary>Функция</summary><img src="../img/js/Синтаксис.png" alt=""><br><p><dfn>Функция</dfn> - это значение, представляющее действие.<br>
Одна функция - одно действие.</p><pre><code>function sayHi(аргументы, через, запятую) {
  <span>тело функции, код</span>
}</code></pre><p><em>sayHi</em> - обращение к переменной, содержащей код функции.<br>
<em>sayHi()</em> - вызываем код функции на выполнение.<br></p><br><p>Можно передать внутрь функции любую информацию через аргументы функции.<br>
Переданные через аргументы значения копируются в локальные переменные (параметры) и используются в теле функции.<br>
Функция всегда получает только копию значения.<br>
Если аргумент не указан, то его значением становится undefined.<br></p><pre><code>function showMessage(from, text = "текст не добавлен") {
  alert(from + ": " + text);  <span>"текст не добавлен" - текст по умолчанию.</span>
} </code></pre><p><dfn>return</dfn> - функция останавливается и возвращает значение.<br>
Результат функции с пустым retutn или без него - undefined.<br>
<br>
Функция внутри другой функции называется <dfn>вложенной</dfn>.<br>
<br>
<dfn>Рекурсия</dfn> - функция вызывает саму себя. Глубина рекурсии - количество вызовов самой себя.<br>
<br>
<dfn>Колбэк функция</dfn> - функция передаваемая параметром в другую функцию и вызываемая внутри другой функции.<br></p><pre><code>function func1(param1, param2) {}
function func2(param3) {}
function func3(param1, param2) {
  func2(func1(param1, param2));
}
func3(param1, param2); <span>- выдаст результат работы func1 и func2</span></code></pre><p>Функция - это объект, его свойства:<br>
- <b>name</b> - имя функции<br>
- <b>length</b> - количество аргументов в объявлении функции, троеточие (остаточные аргументы) не считаються.<br>
<br>
Функция может содержать другие функции в своих свойствах.<br>
<br>
<em>Переменные</em> - это не свойства функции и не наоборот - это два параллельных мира.<br>
<br>
Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.<br>
Arguments не поддерживает методы массивов и всегда содержит все аргументы функции - мы не можем получить их часть.<br>
<br>
<dfn>Function Declaration</dfn> (Объявление функций) считывается интерпритатором когда создаётся лексическое окуржение,
в котором объявлена, hosting работает.<br>
При запуске функций, для неё создаётся лексическое окружение для хранения локальных переменных и параметров вызова.<br></p><pre><code>function sayHi(аргументы, через, запятую) {
  <span>тело, код функции</span>
}</code></pre><br><p><dfn>Function Expression</dfn> (Функциональное выражение) считывается когда выполнение доходит до него, hosting не работает.</p><pre><code>let sayHi = function() {
  alert("Привет");
}</code></pre><p><dfn>Named Function Expression NFE</dfn> (именованное функциональное выражение) - когда у функционального выражения есть имя.<br>
Имя функционального выражения не доступно за пределами функции и позволяет функции ссылаться на себя (рекурсивные вызовы).</p><pre><code>let sayHi = function func(who) {
  alert(`Hello, ${who}`);
}</code></pre><p><dfn>IIFE</dfn> - Immediate Invoked Function Expression<br>
Функциональное выражение моментального выполнения.<br>
Позволяет оборачивать функции для моментального выполнения, передавая необходимые параметры.<br>
Используются для создания локальной области видимости (scope) с замыканием на внешнюю переменную.<br>
Пути создания IIFE:<br></p><pre><code>(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с логического оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();</code></pre><br><p><dfn>=> Arrow functions</dfn> (Стрелочные функции):<br>
- не имееют this. При обращении к this, его значение берётся снаружи.<br>
- не имеют arguments. Arguments внешней функции.<br>
- не могут быть вызваны с new. Не могут быть конструктором.<br>
- нет super.<br>
- предназначены для небольшого кода без контекста, выполняемого в контексте текущего кода.<br>
- func.bind(this) создаёт связанную версию функции, а => ничего не привязывает, т.к. у неё нет this.<br></p><pre><code>let sum = (a, b) => a + b;
<span>или</span>
let sum = (a, b) => {
  let result = a + b;
  return result;
};        </code></pre><p>при фигурных скобках для возврата значения нужно явно вызвать return.</p><br><p><dfn>new Function</dfn><br>
При создании функции через new Function в её [[Environment]] записывается ссылка не на внешнее лексическое окружение,
в котором она была создана, а на глобальное.<br>
Поэтому у неё доступ только к глобальным перменным.<br>
Используют new Function когда код функции заранее не известен, а будет определен только в процессе выполнения.<br></p><pre><code>let func = new Function([arg1, arg2, ...argN], functionBody);
let sum = new Function('a', 'b', return a+b);</code></pre><p>Можно получить код функции с сервера:</p><pre><code>let str = ...код полученный с сервера динамически...
let func = new Function(str);
func();</code></pre><p>Переданные явно глобальные аргументы не вызывают проблем у минификаторов.<br>
<br>
<dfn>Минификатор</dfn> - специальная программа, которая уменьшает размер кода, удаляя комментарии,
лишние пробелы, а локальным переменным даются укороченные имена.<br>
<br>
<dfn>Функции-конструкторы</dfn> (Конструкторы):<br>
- имя с заглавной буквы<br>
- вызывается при помощи оператора new<br>
- используется для повторного создания однотипных объектов<br>
При вызове создаёт пустой this в начале и возвращает заполненный (свойства и их значения) в конце:<br>
<em>this = {};</em> явно добавляет свойства к this<br>
<em>return this;</em> неявно<br></p><pre><code>function User(name) {             
  this.name = name;            
  this.isAdmin = false;
}                                
let user = new User("Вася");</code></pre><p>выполняет роль класса, сама функция ничего не возвращает</p><pre><code>function Cat(color, name) {      
  this.color = color;
  this.name = name;
}
const cat = new Cat('black', 'Кот');
console.log(cat);      <span>Cat {color:'black', name: 'Кот'}</span>
const cat = Cat();     <span>присвоит cat undefined, т.к. Cat() ничего не возвращает</span>
const cat = new Cat(); <span>присвоит cat - Cat{color: undefined, name: undefined}, т.к. нет входных аргументов</span>

function myNew(constractor, ...args) {   <span>создаём своё ключевое слово new</span>
  const obj = {};                      <span>new всегда возвращает новый объект</span>
  Object.setPrototypeOf(obj.constractor.prototype)
  return constractor.apply(obj, args) || obj;
}</code></pre><p>- устанавливаем в поле prototype объекта переданную во входных аргументах constructor-ссылку, теперь constructor прототип obj.<br>
- теперь obj имеет доступ ко всем полям constructor, выполняет функцию-конструктор в контексте obj с входными аргументами args
или в случае ошибки только сам obj.<br>
const cat = myNew(Cat, 'black', 'Кот');
console.log(cat);   <span>Cat {color:'black', name:'Кот'}</span></p><p>выполняем своё ключевое слово myNew c constructor в контексте Cat и входными аргументами 'black' и 'Кот'.</p><pre><code>function SomeFuncCon(name, age) {
  this.name = name;
  this.age = age;
}
<span>создаю конструктором новый объект Вася и вывожу в консоль</span>
console.log(new SomeFuncCon('Vasya', 30));</code></pre><p>Планирование вызова функции:<br>
<em>setTimeout</em>(функция или код, задержка, параметр, параметр) - вызывает функцию один раз через какое-то время<br>
<em>setInterval</em>(функция или код, задержка, параметр, параметр) - вызывает функцию много раз через интервал времени<br>
<br></p><code>let timeId = setTimeout(someFunc, param, param);</code><p><em>setInterval(timeId)</em>; - прерывание setTimeout.<br>
Если setTimeout вызывать из setTimeout (рекурсия), то получим setInterval<br>
clearInterval тоже самое что и setInterval<br>
<br>
<dfn>Контекст</dfn> - объект, который передают при вызове и который указывает с каким объектом работает вызываемая функция.<br>
Ключевое слово function создаёт свой контекст, к которому нужно привязать объект (this), с которым работает функция.<br>
<em>this</em> - обозначает текущий объект<br>
<br>
<dfn>Контекст выполнения</dfn> - специальная внутренняя структура данных, которая содержит информацию о вызове функции:<br>
- место в коде, где находится итерпритатор<br>
- локальные переменные функции<br>
- значение this<br>
- прочая служебная информация.<br>
<br>
<dfn>Привязка контекста: bind</dfn><br></p><code>person.knows.bind(john, 'ничего не', 'Джон');</code><p>в отличии от call и apply, bind не вызывает метод knows на выполнение, 
а возвращает новый объект, который нужно вызвать как функцию (),
чтобы передать вызов в knows и установить this = john.<br>
Для выполнения пишем так:<br></p><code>person.knows.bind(john, 'ничего не', 'Джон')();</code><p>либо так</p><pre><code>const bound = person.knows.bind(john, 'ничего не', 'Джон');
bound();</code></pre><p>При передаче методов объекта в качестве колбэков,
например в setTimeout, метод передаётся отдельно от объекта, происходит потеря this.<br>
Встроенный в функции метод bind позволяет зафиксировать this.<br>
Частичная или частично применённая функция - это функция с привязанными аргументами.<br></p><code>let bound = func.bind(context, [arg1], [arg2], ...);</code><br><p><dfn>Явная привязка контекста</dfn>:</p><pre><code>function logThis() {
  console.log(this)
}
const obj = {num: 42};
logThis.apply(obj); {num: 42}
logThis.call(obj); {num: 42}
logThis.bind(obj)(); {num: 42}</code></pre><br><p><dfn>Неявная привязка контекста</dfn>:</p><pre><code>const animal = {
  legs: 4,
    logThis: function() {
      console.log(this);
  }
}
animal.logThis();  {legs: 4, logThis:[Function: logThis]}</code></pre><p>в контекст привязался тот объект, в котором была вызвана функция.<br>
<br>
<dfn>Методы</dfn> - это функции как свойства объекта.<br>
Методы ссылаются на объект через this для доступа к информации внутри объекта.<br>
Значение this вычисляется во время выполнения кода (когда функция вызвана) и зависит от контекста.<br>
Функция может быть скопирована между объектами (из одного объекта в другой).<br>
Значением this во время вызова синтаксисом "метода" (object.method()) является объект перед точкой.<br>
У стрелочных функций нет this, его значение берётся из внешей функции.<br>
Для работы вызовов типа user.hi(), точка возвращает не саму функцию, 
а специальное значение "ссылочного типа" - Reference Type.<br>
<br>
<dfn>Значение ссылочного типа</dfn> - это "триплет", комбинация из трёх значений:<br>
<em>base</em> - объект<br>
<em>name</em> - имя свойства объекта<br>
<em>strict</em> - режим исполнения (true если <b>'use strict</b>')<br>
Когда скобки () применяются к значению ссылочного типа (вызов функции), 
они получают полную информацию об объекте и его методе, и могут подставить правильный <b>this</b>.<br>
Ссылочный тип - исключительно внутренний, промежуточный, используется чтобы передать информацию от точки до вызывающих скобок().<br>
При любой другой операции, например присваении <b>hi = user.hi</b>;
ссылочный тип заменяется на само значение <b>user.hi</b> (функцию), и дальше работа только с ней - без this.<br>
<br>
<dfn>Замыкание</dfn> - это функция, которая помнит лексическое окружение где она была создана (свои внешние переменные)
и может получить к нему доступ с помощью скрытого свойства [[Environment]].<br>
Все функции, кроме newFunction(), изначально являются замыканиями.<br></p><pre><code>function sayHelloTo(name) {
  const message = 'Helo' + name;
  return function() {   <span>анонимная функция</span>
    console.log(message);
  }
}
<span>helloToElena ссылается на анонимную функцию</span>
const helloToElena = sayHelloTo('Elena');

<span>helloToIgor ссылается на анонимную функцию</span>
const helloToIgor = sayHelloTo('Igor');  

helloToElena();      <span>Hello Elena</span>
helloToIgor();       <span>Hello Igor</span>

const fib = [1, 2, 3, 5, 8, 13];
for (var i=0; i &lt;fib.length; i++) {
  setTimeout(function() {
    console.log(`fib[${j}] = ${fib[j]}`)
  }, 1500)
}</code></pre><p>через 1,5 секунды должен вывести индекс = значение, 
но не работает т.к. цикл for за 1,5 секунды успевает пробежать по всей длине массива и var i уже имеет значение 6.<br>
Только потом срабатывает setTimeout.<br>
<br>
<dfn>Исправление через область видимости</dfn>:<br>
const fib = [1, 2, 3, 5, 8, 13];
for (let i=0; i &lt;fib.length; i++) {
  setTimeout(function() {
    console.log(`fib[${j}] = ${fib[j]}`)
  }, 1500)
}</p><p>поменять var на let, т.к. let действует только в области видимости цикла.<br>
<br>
<dfn>Исправление через замыкание</dfn>:<br></p><pre><code>const fib = [1, 2, 3, 5, 8, 13];
for (var i=0; i &lt;fib.length; i++) {
(function(j) {
  setTimeout(function() {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  })(i)
}</code></pre><p>обернуть setTimeoutв функцию и через ()()(IIFE) замкнуть функцию на var i.</p><pre><code>let someObj = {
  key1: value1,

  someFunc() {
    function anotherFunc() {console.log(`${this.key1}`)}

    anotherFunc();
  }
};</code></pre><p><b>someObj.someFunc();</b> - ошибка, anotherFunc() создает свою область видимости и замыкается (использует)
область видимости someFunc(), this ищет в области видимости someFunc() свойство key1.</p><pre><code>let someObj = {
  key1: value1,

  someFunc() {
    let someVar = () => console.log(`${this.key1}`)

    someVar();
  }
};</code></pre><p><b>someObj.someFunc();</b> - стрелочная функция не создает свою область видимости и пользуется всем что есть у
someFunc(), т.е. области видимости someFunc() и someObj.<br>
<b>this</b> находит свойство key1 в области видимости someObj<br>
<br>
<dfn>Перенапрвление вызова</dfn> (call forwarding) - передача всех аргументов вместе с контекстом другой функции:<br>
<b>call и apply</b> - встроенные методы функции, позволяют вызывать функцию, явно устанавливая this.<br>
Одна разница:<br>
- оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.<br>
- apply принимает только псевдомассив args.<br></p><pre><code>const person = {
  surname: 'Старк',
  knows: function(what, name) {
    console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
  }
}    <span>функция работает в контексте (this) объекта person</span>

const john = {surname: 'Сноу'}
person.knows('всё', 'Бран')      <span>Ты всё знаешь Бран Старк</span></code></pre><p>чтобы перенаправить вызов, функцию knows не вызываем (), а обращаемся к ней как к объекту
и вызываем её метод call(), в который передаём объект (this), в контексте которого она
должна отработать и аргументы самой функции knows:<br></p><pre><code><span>Ты ничего не знаешь, Джон Сноу.</span>
person.knows.call(john, 'ничего не', 'Джон');

<span>аргументы в виде массива.</span>
person.knows.apply(john, ['ничего не', 'Джон']);

<span>ES-6 синтаксис - оператор спред (...) разворачивает массив.</span>
person.knows.call(john, ...['ничего не', 'Джон']);</code></pre><br><p><dfn>Заимствование метода</dfn>:</p><pre><code><span>функция делает ключ-строку из принимаемых аргументов</span>
function hash (args) {
  return args[0] + ',' + args[1];
}
<span>позаимствовали join у массива</span>
function hash (args) {
  alert([].join.call(args));
}
</code></pre></details><details><summary>Event loop</summary><dfn>Event loop</dfn> - событийный цикл (бесконечный цикл):<img src="../img/js/EventLoop.png" alt=""><p>1. Выполнить старейшую задачу из очереди макрозадач.<br>
<b>setTimeout(f)</b> с нулевой задержкой добавляет в очередь новую макрозадачу.<br>
2. Выполнить старейшую задачу из очереди микрозадач.<br>
<b>queuemicrotask(f)</b> - добавляет в очередь новую микрозадачу.<br>
Обработчики промисов в микрозадачах.<br>
3. Отрисовать изменения страницы (если есть).<br>
4. Если очередь макрозадач пуста - подождать, когда появится макрозадача.<br>
Сразу после каждой макрозадачи: все микрозадачи -> события -> рендеринг -> макрозадача<br>
<br>
<dfn>Очередь</dfn> - (queue) добавляем в конец, извлекаем с начала.<br>
<dfn>Стек</dfn> - (stack) новые элементы всегда добавляются или удаляются с конца.<br>
<br>
<dfn>Web workers</dfn>:<br>
- способ исполнить код в параллельном потоке<br>
- обмениваются сообщениями с основным процессом<br>
- имеют свои переменные и свой событийный цикл<br>
- позволяют задействовать несколько ядер процессора сразу<br>
- не имеют доступа к DOM<br>
- используются для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.<br>
</p></details><details><summary>Environment</summary><p><dfn>Переменная</dfn> - это именованное хранилище для данных, которое является свойством Environment Record.<br>
<dfn>Переменные</dfn> - это ссылки на значения, объекты или на другие переменные.<br>
Объекты храняться и копируются по ссылке.<br>
Создание переменной происходит в два этапа:<br>
- <dfn>declaration</dfn> (объявление)<br>
- <dfn>definition</dfn> (определение), <dfn>initalization</dfn> (инициализация)<br>
Имя переменной может содержать буквы, цифры, символы $ и _.<br>
Первый символ в имени не цифра. Регистр имеет значение.<br>
Переменная не объявлена - is not defined.<br>
Переменная не определена - undefined.<br>
<br>
<dfn>hoisting</dfn> (всплытие, поднятие) - это механизм в JS, в котором объявления переменных и функций, 
передвигаются вверх своей области видимости (локальной или глобальной) перед тем как код будет выполнен и мы
можем обратиться к ним ещё до их определения.<br>
hoisting передвигает только объявления функций и переменных, их определения остаются на своих местах.<br>
<br>
<dfn>LexicalEnvironment</dfn> - объект лексического окружения состоит из двух частей:<br>
<dfn>Environment Record</dfn> - (лексическое окружение) объект, в котором как свойства храняться все локальные переменные, 
значение this и т.д.<br>
Это структура, состоящая из лексических областей видимости, 
которая определяет связи между идентификаторами переменных и функций с их определениями 
на основе вложенности лексических областей видимости.<br></p><pre><code>function funcA() {
  let a = 1;
  function funcB() {
    let b = 2;
    function funcC() {
      let c = 3;
      console.log(a, b, c);
    }
  }
}</code></pre><p>Один вызов функции - одно лексическое окружение.<br>
Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.<br>
Для цикла у каждой итерации свой отдельное лексическое окружение.<br>
Из-за того, что у блока есть собственное лексическое окружение, код снаружи не видит переменные этого блока.<br>
При обращении к переменной - сначала ищем во внутреннем лексическом окружении, затем во внешнем, и так до глобального.<br>
Функция получает последнее значение внешних переменных.<br>
Объект лексического окружения существует пока есть хотя бы одна вложенная функция, которая ссылается на него.<br>
<br>
<dfn>Scope</dfn> - (лексическая область видимости) ссылка на внешнее лексическое окружение, 
т.е. это область видимости, которая указывает на доступность переменных:<br>
- глобальная область видимости - window или document в браузере<br>
- локальная область видимости  - в рамках одной функции или блока кода<br>
<br>
Это область видимости, которая определена во время разбора кода на лексемы 
и формируется исходя из того, где переменные, функции и инструкции размещены в коде.<br>
<br>
лексемы:<br>
<b>var a = 2;</b><br>
<em>var</em> - объявление переменной<br>
<em>a</em> - идентификатор (имя) переменной<br>
<em>=</em> - оператор присваивания<br>
<em>2</em> - число<br>
<em>;</em> - конец инструкции<br>
<dfn>let</dfn> - изменяемая впеременная, область видимости блок, hoisting не работает.<br>
<dfn>const</dfn> - неизеняемая переменная, область видимости блок, hoisting не работает.<br>
Константы с заглавными буквами для заранее известных значений.<br>
Константы маленькими буквами для значений вычисляемых и присваиваемых в процессе выполнения.<br>
<dfn>var</dfn> - изменяемая переменная, область видимости функция или скрипт, hoisting работает.<br></p><pre><code>let a = 'variable a'; <span>- global scope</span>
let b = 'variable b';
{
  a = 'New variable A'; <span>- a from global scope</span>
  let b = 'Local Variable B'; <span>- b from local scope</span>
  console.log('A:', a); <span>- New Variable A</span>
  console.log('B:', b); <span>- Local Variable B</span>
  console.log('C:', c); <span>- ReferenceError</span>
  let c = 'Something';
}
console.log('A:', a); <span>- New Variable A</span>
console.log('B:', b); <span>- Local Variable B</span>
</code></pre></details><details><summary>Коллекции</summary><p>Объекты для хранения именованных коллекций.<br>
<dfn>Массив</dfn> - (Array), подвид объектов для хранения упорядоченых коллекций,
расширяют объекты методами для работы с упорядоченными коллекциями данных и свойством <b>length</b>.<br>
Получить доступ к элементу <b>arr[0]</b> - это синтаксис доступа по ключу (<b>obj[key]</b>),
где в роли obj у нас arr, а key - числовой индекс.<br>
Создание пустого массива: <br></p><pre><code>let arr = new Array();
<span>либо</span>
let arr = [];
let arr = newArray(2); <span>- создать пустой массив на 2 пустых элемента.</span>

let fruins = ["Яблоко", "Апельсин", "Слива"];
fruits[0] <span>- получить элемент</span>
fruins[2] = 'Груша'; <span>- заменить элемент с индеком 2</span>
fruins[3] = 'Лимон'; <span>- добывить новый элемент</span>
fruins.length <span>- общее число элементов массива</span>
alert(fruins); <span>- вывести массив целиком</span></code></pre><p>В массиве могут храниться элементы любого типа.<br>
<br>
<dfn>Массив</dfn> - это объект, который намного быстрее объекта если работать с массивом ни как с объектом, 
а как с упорядоченной коллекцией:<br>
- свойства именовать цифрами (индексы - числа, а не строки)<br>
- не создавать дыр, т.е. не оставлять свойства без значений (0: "Вася", 1: , 2: "Петя")<br>
- не заполнять массив значениями в обратном порядке (сконца)<br></p><pre><code>let arr = new Array();
let arr = [];
let arr = [el1, el2, el3,]; <span>- элементом массива может быть что угодно.</span>
arr[1] <span>- обращение к элементу, индексация с 0</span>
arr.length <span>- длина массива</span>
let arrNew = arr; <span>- скопировал ссылку на массив</span></code></pre><br><p>масcивы могут работать и как очередь и как стек:<br>
<em>push()</em> - добавляет в конец массива - выполняется быстро<br>
<em>pop()</em> - удаляет элемент вконце массива - выполняется быстро<br>
<em>shift()</em> - удаляет элемент вначале массива - выполняется медленно<br>
<em>unshift()</em> - добавляет элемент вначало массива - выполняется медленно<br>
<em>delete arr[1]</em>; - удаление конкретного элемента<br>
<em>arr.splice(pos, count)</em>; - начиная с позиции pos удалить count элементов<br>
(pos - считаем сначала, -pos - считаем сконца)</p><pre><code><span>начиная с позиции pos удалить count элементов и вернуть удаленные элементы в переменную</span>
let rm = arr.splice(pos, count);

<span>начиная с позиции pos заменить count элементов на elem</span>
arr.splice(pos, count, elem);

<span>начиная с позиции pos добавить elem1, elem2</span>
arr.splice(pos, 0, eldfn1, eldfn2); -

<span>копируем весь массив</span>
let arrNew = arr.slice();

<span>копируем массив с позиции 1 до позиции 2, не включая позицию 2</span>
let arrNew = arr.slice(1, 2);

<span>копирует весь массив и добавляет в конец нового массива elem</span>
let arrNew = arr.concat(elem);

<span>ищет elem с индекса from, возвращает индекс найденого item или -1</span>
arr.indexOf(elem, from);

<span>возвращает индекс найденого elem или -1, ищет справа налево</span>
arr.lastIndexOf(elem);

<span>ищет elem с индекса from, возвращает true  или false</span>
arr.includes(elem, from);</code></pre><br><p>Для массивов, элементы которых объекты:<br>
<em>find()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то прерывает поиск и возвращает соответствующее свойство либо undefined</p><pre><code>let res = arr.find(function(elem, index, array) {
  return elem.prop === 18;
});
<span>либо</span>
let res = arr.find(elem => elem.prop === 18);</code></pre><p><em>findIndex()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то прерывает поиск и возвращает соответствующей индекс либо undefined</p><code>let res = arr.findIndex(elem => elem.prop === 18);</code><p><em>filter()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то продолжает поиск и возвращает массив совпавших свойств либо undefined</p><code>let res = arr.filter(elem => elem.prop&gt;= 18);</code><p><em>sort(fn)</em> - сортирует массив, меняя в нем порядок элементов по алгоритму функции fn,<br>
если fn не указана, то по возрастанию</p><pre><code>function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  if (a&gt; b) return 1;
  if (a == b) return 0;
  if (a &lt;b) return -1;
}
console.log(arr.sort(compareNum));
<span>либо</span>
function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  return a - b;
}
console.log(arr.sort(compareNum));
<span>либо</span>
console.log(arr.sort((a, b) => a - b));</code></pre><p><em>reverse()</em> - меняет порядок елементов в массиве на обратный <b>arr.reverse()</b>;
<br>
<em>map()</em> - перебирает элементы массива, применяет функцию к каждому элементу и возвращает 
на его место в массиве результат работы функции.<br></p><code>let res = arr.map(function(eldfn, index, array) {});</code><p><em>split()</em> - преобразовывает строку в массив по указанному разделителю</p><pre><code>let str = 'eldfn1,eldfn2,eldfn3';
let arr = str.split(',', limit);</code></pre><p>limit ограничивает количество элементов, которые попадут в массив если не указывать, то все
<br>
<em>join()</em> - преобразовывает массив в строку с указанным разделителем</p><pre><code>let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
let res =  arr.join(',');
<span>либо</span>
let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
let res =  String(arr); - разделитель всегда запятая</code></pre><p><b>Array.isArray(arr)</b> - возвращает true если arr это массив, иначе false
<br>  
Циклы для перебора элементов массива:<br></p><code>for (i=0; i &lt;arr.length; i++) и for (let var of arr) {}</code><p><em>forEach()</em> - метод перебора массива, применяет функцию для каждого элемента массива</p><pre><code>arr.foreach(function(eldfn, index, array) {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
});
<span>либо</span>
arr.forEach((eldfn, index, array) => {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
});
<span>либо</span>
let func = function(eldfn, index, array) {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
};
arr.forEach(func);</code></pre><p><em>reduce()</em> - перебирает элементы массива и вычисляет значение на основе всего массива<br></p><pre><code>let value = arr.reduce(
  function(
    previousValue, eldfn, index, array
  ) {},
[initial]);</code></pre><br><p><em>previousValue</em> - результат предыдущего вызова этой функции, равен initial при первом вызове функции (если initial передан),<br>
<em>elem</em> - очередной элемент массива<br>
<em>index</em> - его индекс<br>
<em>array</em> - сам массив<br>
<br>
<dfn>reduceRight()</dfn> - так же как и reduce(), но справа на лево<br></p><br><img src="../img/js/Methods.jpg" alt=""><br><p><dfn>Псевдомассив</dfn> - объекты, у которых есть индексы и свойство length,
могут иметь другие свойства и методы, но у них нет встроенных методов массива.<br>
<b>Array.from(obj[,mapFn, thisArg])</b> - создаёт Array из итерируемого объекта
или псевдомассива obj, и затем к нему можно применить методы массивов.<br>
Необязательные аргументы mapFn и thisArg позволяют применять функцию с 
задаваемым контекстом к каждому элементу.<br>
<br>
<dfn>Итерируемые объекты</dfn> - объекты, которые реализуют метод <b>Symbol.iterator</b>,
и их можно использовать в цикле for..of.<br>
Результат вызова <b>obj[Symbol.iterator]</b> называется итератором. Он управляет итерацией.<br>
Итератор должен иметь метод <b>next()</b>, который возвращает объект<br>
<b>{done: Boolean, value: any}</b>,<br> где done: true - окончание итерации,
иначе value - следующее значение.<br>
Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его
и напрямую. Строковый итератор знает про сурогатные пары.<br>
<br>
Свойство <dfn>length</dfn> - это наибольший цифровой индекс плюс один.
Самый простой способ очистить массив - это <b>arr.length = 0</b>;<br>
Метод <b>toString</b> возвращает список элементов, разделённых запятыми.<br>
<br>
<dfn>Добавление/удаление элементов</dfn>:<br>
<em>push(...itdfns)</em> - добавляет элементы в конец<br>
<em>pop()</em> - извлекает элемент с конца<br>
<em>shift()</em> - извлекает элемент с начала<br>
<em>unshift(...itdfns)</em> - добавляет элемент в начало<br>
<em>splice(pos, deleteCount, ...itdfns)</em> - начиная с индекса pos, удаляет deleteCount элементов и вставляет itdfns.<br>
<em>slice(start, end)</em> - создаёт новый массив, копируя в него элементы с позиции start до end, не включая end.<br>
<em>concat(...itdfns)</em> - возвращает новый массив: копирует все элементы текущего массива и добавляет к нему itdfns.<br>
Если какой-то из itdfns является массивом, то беруться его элементы.<br>
Если объект имеет специальное свойство <b>Symbol.isConcatSpreadable</b>, то он обрабатывается concat как массив,
т.е. вместо объекта добавляются его числовые свойства.<br>
Методы push/pop выполняются быстро, а shift/unshift - медлено.<br>
<br>
<dfn>Поиск среди элементов</dfn>:<br>
<em>indexOf/lastIndexOf(itdfn, pos)</em> - ищет itdfn, начиая с позиции pos, и возвращает его индекс или -1, если ничего не найдено.<br>
<em>includes(value)</em> - возвращает true, если в массиве есть элемент value, иначе false.<br>
<em>find/filter(func)</em> - фильтрует элементы через функцию и отдаёт первое/все значения, 
у которых при прохождении через функцию возвращается true.<br>
<em>findIndex</em> - похож на find, но возвращает индекс вместо значения.<br>
<br>
<dfn>Перебор элементов</dfn>:<br>
<em>forEach(func)</em> - вызывает func для каждого элемента. Ничего не возвращает.<br></p><code>["Bilbo", "Gandalf", "Nazgul"].forEach(alert); - вызов alert для каждого элемента.<br></code><br><p><dfn>Преобразование массива</dfn>:<br>
<em>map(func)</em> - создаёт новый массив из результатов вызова func для каждого элемента.<br>
<em>sort(func)</em> - сортирует массив "на месте", а потом возвращает его.<br>
<em>revers(func, initial)</em> - вычисляет одно значение на основе всего массива,
вызывая func для каждого элемента и передавая промежуточный результат между вызовами.<br>
<br>
<dfn>Деструктуризация</dfn> позволяет разбивать объект или массив на переменные при присвоении.<br>
Для объекта: (неупомянутые свойства копируются в объект rest.)<br></p><code>let {prop: varName = default, ...rest} = object</code><p>Для массива: (первый элемент копируется в itdfn1, второй в itdfn2, остальные в массив rest.)<br></p><code>let [itdfn1 = default, itdfn2, ...rest] = array</code><p>Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и первая.</p><br><p><dfn>Map</dfn> - коллекция пар: ключ-значение.<br>
Отличия от обычного объекта Object:<br>
- что угодно может быть ключом, в том числе и объекты.<br>
- есть дополнительные методы, свойство size.<br>
<br>
<dfn>Методы и свойства</dfn>:<br>
<em>newMap([iterable])</em> - создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ, значение] для инициализации.<br>
<em>map.set(key.value)</em> - записывает по ключу key значение value.<br>
<em>map.get(key)</em> - возвращает значение по ключу или undefined, если ключа нет.<br>
<em>map.has(key)</em> - возвращает true, если ключ key присутствует в коллекции, иначе false.<br>
<em>map.delete(key)</em> - удаляет элемент по ключу key.<br>
<em>map.clear()</em> - очищает коллекцию от всех элементов.<br>
<em>map.size</em> - возвращает текущее количество элементов.<br>
<em>map.keys()</em> - возвращает итерируемый объект по ключам.<br>
<em>map.values()</em> - возвращает итерируемый объект по значениям.<br>
<em>map.entries()</em> - возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.<br>
<em>Object.entries(obj)</em> - создаёт Map из обычного объекта.<br>
<em>let obj = Object.fromEntries(map)</em>; - создаёт объект из Map.<br>
<br>
<dfn>Set</dfn> - коллекция значений без ключей, где каждое значение может появляться только один раз.<br>
<br>
<dfn>Методы и свойства</dfn>:<br>
<em>newSet([iterable])</em> - создаёт Set, можно указать перебираемый объект со значениями без инициализации.<br>
<em>set.add(value)</em> - добавляет значение если такого нет, возвращает тот же объект.<br>
<em>set.delete(value)</em> - удаляет значение, возвращает true если value было, иначе false.<br>
<em>set.has(value)</em> - возвращает true, если значение есть, иначе false.<br>
<em>set.clear()</em> - удаляет все значения.<br>
<em>set.size</em> - возвращает количество элементов в множестве.<br>
<em>set.values()</em> - возвращает перебираемый объект для значений.<br>
<em>set.keys()</em> - то же самое, что и <b>set.values()</b>, нужен для обратной совместимости с Map.<br>
<br>
Перебор Map и Set всегда осуществляется в порядке добавления элементов,
поменять порядок элементов или получить элемент напрямую по номеру нельзя.<br>
<br>
<dfn>WeakMap & WeakSet</dfn>:<br>
<em>WeakMap</em> - Map-подобная коллекция, где ключи только объекты, автоматически удаляемые вместе со значениями
как только они становяться недостижимыми.<br>
<em>WeakSet</em> - Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми.<br>
<dfn>Methods</dfn>:<br></p><pre><code>weakMap.get(key)          weakSet.get(key)
weakMap.set(key, value)   weakSet.set(key, value)
weakMap.delete(key)       weakSet.delete(key)
weakMap.has(key)          weakSet.has(key)</code></pre><p>WeakMap и WeakSet поддерживают операции только на отдельном элементе коллекции.</p></details><details><summary>Модуль</summary><p><dfn>Модуль</dfn> - это файл.<br>
Чтобы работал import/export, нужно указать <b>&lt;script type="module"&gt;</b>.<br>
<b>export</b> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.<br>
<b>import</b> позволяет импортировать функциональность из других модулей.<br></p><pre><code>&lt;!doctype html&gt;
&lt;script type="module"&gt;
import {sayHi} from './say.js';
document.body.innerHTML = sayHi('John');
&lt;/script&gt;</code></pre><p><dfn>У модулей</dfn>:<br>
- Отложенное (deferred) выполнение по умолчанию.<br>
- Загрузка внешних модулей (&lt;script type="module" src="..."&gt;) не блокирует обработку HTML и выполняются только после загрузки HTML документа.<br>
- Выполняются в порядке расположения в документе.<br>
- Для загрузки внешнего модуля с другого источника, он должен ставить заголовки CORS.<br>
- Дублирующиеся внешние скрипты игнорируются.<br>
- У модулей своя область видимости, обмен через import/export.<br>
- В модуле всегда включен "use strict".<br>
- Код в модуле выполняется только один раз.<br>
- Сборщик Webpack объединяет модули для производительности.<br>
<br>
<dfn>Синтаксис</dfn>:</p><pre><code><span>перед объявлением</span>
export default class/function/variable

<span>отдельный экспорт</span>
export {x as y, ...}

<span>реэкспорт</span>
export {x [as y], ...} from "module"

<span>реэкспорт всего кроме export default</span>
export * from "module"

<span>реэкспорт только export default </span>
export {default [as y], ...} from "module"

<span>именованный импорт из модуля</span>
import {x [as y], ...}

<span>импорт по умолчанию</span>
import x from "module"

<span>импорт по умолчанию</span>
import {default as x} from "module"

<span>импорт всего сразу</span>
import * as obj from "module"

<span>подключить модуль без присваивания переменной</span>
import "module"</code></pre><p>import/export могут быть вначале или вконце скрипта, но не в {...}.</p><pre><code><dfn>Именованный экспорт</dfn>                <dfn>Экпорт по умолчанию</dfn>
export class User {...}           export default class User {...}
import {User} from ...            import User from ...</code></pre><p>Выражение import (module) загружает модуль и возвращает промис,
результатом которого становится объект модуля, содержащий все его экспорты.</p><pre><code>say.js
export function hi() {
  alert('Привет');
}
export function buy() {
  alert('Пока');
}
export default function() {
  alert('Модуль загружен');
}

&lt;!doctype html&gt;
&lt;script&gt;                    
  async function load() {                             
    let say = await import('./say.js');         
    say.hi();       <span>Привет</span>
    say.buy();      <span>Пока</span>
    say.default();  <span>Модуль загружен</span>
  }                                               
&lt;/script&gt;
&lt;button onclick = "load"&gt;Нажми меня &lt;/button&gt;</code></pre><p>Динамический импорт работает в обычных скриптах и не требует указания <b>script type="module"</b>.<br>
<em>import()</em> - это не функция, а спец.синтаксис, как <b>super()</b>.</p><img src="../img/js/promise.png" alt=""></details><details><summary>Browser</summary><img src="../img/js/windowJS.png" alt=""><details><summary>Window</summary><p><dfn>Window</dfn> = <b>globalThis + DOM + BOM</b> - глобальный объект JS в браузере.<br>
<em>Object <- EventTarget <- Window</em> - интерфейс Window наследует свойства интерфейса EventTarget
и реализует свойства из WindowOrWorkerGlobalScope и миксин WindowEventHandlers.<br>
Объект Window реализует интерфейс Window.<br>
У каждого окна и у каждой вкладки свой объект Window.<br>
глобальные функции доступны как методы глобального объекта</p><pre><code>functionsayHi() {       
    alert('Hello');
}
window.sayHi();</code></pre><p><dfn>Window.properties</dfn>:<br>
<em>opener</em> - ссылка на открывающее окно,<br>
<em>closed</em> - true (закрыто), false (открыто),<br>
<em>frames</em> - коллекция объектов window вложенных ифреймов<br>
<em>parent</em> - ссылка на родительское окно<br>
<em>top</em> - ссылка на окно самого верхнего уровня<br>
<br>
<dfn>Window.methods</dfn>:<br>
<em>open (url, name, params)</em> - открывает новое окно и возвращает ссылку на него.<br>
<em>close()</em><br>
<em>focus()</em><br>
<em>blur()</em><br>
<em>alert("Hello")</em> - показывает сообщение<br>
<em>result = promt(title, [default])</em>; - показывает сообщение и запрашивает у пользователя
ввод текста.<br> Возвращает напечатанный в поле ввода текст или null.<br>
<em>result = confirm (question)</em>; - показывает сообщение и ждёт, пока пользователь 
нажмёт ОК или Отмена.<br> Возвращает true если нажата ОК и fasle - если отмена.<br>
<em>iframe.contentWindow</em> - объект Window внутри тега &lt;iframe&gt;<br>
</p></details><details><summary>BOM</summary><p><em>Browser Object Model</em> - объектная модель браузера.<br>
<em>Window.navigator</em> - информация о браузере пользователя.<br>
<em>Window.screen</em> - информация об экране пользователя.<br>
<em>Window.location</em> - адресная строка: текущие компоненты.<br>
<em>Window.frames</em> - фреймы и ифреймы.<br>
<em>Window.history</em> - история посещений (url), движения вперед и назад в окне.<br>
<em>Window.XMLHttp Request</em> - встроенный объект для Http запросов к серверу без перезагрузки страницы.<br>
<em>Window.document</em> - DOM-документ загруженный в окно.<br>
https://html.spec.whatwg.org
</p></details><details><summary>DOM</summary><p><dfn>Document Object Model</dfn> - объектная модель документа, представляет всё содержимое страницы в виде объектов.<br></p><code>document.body.style.background = "red"</code><p>Object <- EventTarget <- Node <- Document<br>
html-документы представленны в браузере в виде дерева DOM.<br>
<br>
<dfn>Веб-воркер</dfn> — это JavaScript, который работает в фоновом режиме, 
независимо от других скриптов, не влияя на производительность страницы. <br>
Вы можете продолжать делать все, что захотите: щелкать, выбирать объекты и т. д.,
пока веб-воркер работает в фоновом режиме.<br>
https://dom.spec.whatwg.org<br>
https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov
</p></details><details><summary>Node</summary><p><dfn>Node</dfn> - абстрактный класс.<br>
Обеспечивает базовую функциональность для всех узлов.<br>
Объекты класса Node никогда не создаются, но от него наследуются.<br>
<br>
<dfn>Классы</dfn>:<br>
<dfn>Text</dfn> - для текстовых узлов. Содержат текст.<br>
<dfn>Comment</dfn> - для узлов-комментариев. Иногда в них можно включить информацию, которая 
не будет поазана, но будет доступна в DOM для чтения JS.<br>
<dfn>Element</dfn> - для узлов-элементов. HTML-тэги - строительные блоки документа.<br>
Обеспечивает навигацию на уровне узлов-элементов и служит базой
для классов SVGElement, XMLElement, HTMLElement.<br>
<br>
Текст, комментарий и тэг - это DOM-узел.<br>
Каждый DOM-узел принадлежит своему классу.<br>
Для наследования используют классы, основанные на прототипах.<br>
Классы формируют иерархию.<br>
Весь набор свойств и методов является результатом наследования.<br>
<dfn>DOM-узлы</dfn> - это обычные JS объекты. Реализация соответствующего класса.<br>
<dfn>DOM-элемент</dfn> - это JS объект тэга.<br>
<br>
<dfn>HTMLElement</dfn> - является базовым классом для всех остальных HTML-элементов.<br>
От него наследуют элементы:<br>
<dfn>HTMLInputElement</dfn> - класс для тега &lt;input&gt;<br>
<dfn>HTMLBodyElement</dfn> - класс для тега &lt;body&gt;<br>
<dfn>HTMLAnchorElement</dfn> - класс для тега &lt;a&gt;<br>
и т.д., <br>
каждому тегу соответствует свой класс, который представляет свойства и методы:<br>
<dfn>value</dfn> - значение для &lt;input&gt;, &lt;select&gt; и &lt;textarea&gt; (HTMLInputElement, HTMLSelectElement, ...).<br>
<dfn>href</dfn> - адрес ссылки "href" для &lt;a href="..."&gt; (HTMLAnchorElement).<br>
<dfn>id</dfn> - значение атрибута "id" для всех элементов (HTMLElement).<br>
<br>
console.log(elem) выводит элемент в виде DOM-дерева.<br>
console.dir(elem) выводит элемент в виде DOM-объекта, это удобно для анализа его свойств.<br>
<br>
Для изменения элементов или проверки DOM-дерева можем использовать инструменты разработчика в браузере.<br>
</p></details><details><summary>DOM-navigation</summary><img src="../img/js/Навигация DOM.png" alt=""><p><dfn>Дочерние узлы (дети)</dfn> - непосредственные дети-элементы узла.<br>
<dfn>Потомки</dfn> - все элементы, внутри данного, ключая детей, их детей и т.д.<br>
Коллекция childNodes содержит список всех детей, включая текст.<br></p><pre><code>eldfn.childNodes[0] === eldfn.firstChild
eldfn.childNodes[eldfn.childNodes.length-1] === eldfn.lastChild</code></pre><p><dfn>Соседи</dfn> - узлы, у которых один и тот же родитель.<br>
&lt;<b>body</b>&gt; - следующий или правый сосоед &lt;<b>head</b>&gt;<br>
&lt;<b>head</b>&gt; - предыдущий или левый сосед &lt;<b>body</b>&gt;<br></p><pre><code>const bodyElement = document.body;
const firstChildNode = bodyElement.firstChild; <span>- первый узел</span>
const lastChildNode = bodyElement.lastChild; <span>- последний узел</span></code></pre><br><p>список всех детей (узлов) объекта (в данном случае body) в виде коллекции</p><code>const childNodes = bodyElement.childNodes;</code><br><p>проверяет есть ли дочерние узлы у объекта true or false</p><code>bodyElement.hasChildNodes()</code><br><p><dfn>Коллекция</dfn> - это псевдомассив:<br>
можно перебирать с помощью <b>for( of ) {}</b> и <b>forEach()</b>
методы массива не работают<br>
изменять элемент коллекции как в массиве не получится, только через специальные методы<br></p><pre><code>bodyElement.previousSibling; <span>- предыдущий соседний узел</span>
bodyElement.nextSibling; <span>- следующий соседний узел</span>
bodyElement.parentNode; <span>- родительский узел</span></code></pre><br><p><dfn>Для элементов (тегов)</dfn>:</p><pre><code>bodyElement.childNodes; <span>- получаем коллекцию всех дочерних узлов</span>
bodyElement.children; <span>- получаем коллекцию всех дочерних элементов (тегов)</span>
bodyElement.firstElementChild; <span>- первый элемент</span>
bodyElement.lastElementChild; <span>- последний элемент</span>
bodyElement.previousElementSibling; <span>- предыдущий соседний элемент</span>
bodyElement.nextElementSibling; <span>- следующий соседний элемент</span>
bodyElement.parentElement; <span>- родительский элемент</span></code></pre><br><p><dfn>Поиск произвольного элемента</dfn>:<br>
возвращает статичную коллекцию со всеми элементами внутри elem, соответствующие указанному CSS-селектору (класс (с точкой впереди), тег, вложенные теги, атрибут, id и т.д.)</p><code>elem.querySelectorAll(CSS);</code><br><p>проверяет только последний указанный в CSS-селекторе элемент без учета контекста используется чаще других, ищет и возвращает первый попавшийся объект по указанному CSS-селектору</p><code>querySelector(CSS);</code><br><p>ищет и возвращает элемент по id, ищет только в document</p><code>document.getElementById(id без решетки);</code><br><p>возвращает живую коллекцию, ищет где угодно</p><code>getElementsByTagName(тег);</code><br><p>возвращает живую коллекцию, ищет где угодно</p><code> getElementsByClassName(класс без точки впереди);</code><br><p>возвращает живую коллекцию, ищет только в document</p><code>document.getElementsByName(атрибут name);</code><br><p>живая коллекция - содержит в себе всегда актуальную информацию с учетом изменений в дереве DOM<br></p><img src="../img/js/querySelector.png" alt=""><br><p>ищет ближайшего предка, который соответствует указанному css-селектору</p><code>elem.closest(css)</code><br><p>ничего не ищет, проверяет соответствует ли элемент css селектору, возвращает true or false</p><code>elem.matches(css)</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта как есть</p><code>const textEldfnentContent = textElement.innerHTML;</code><p>заменил содержимое объекта</p><code>textElement.innerHTML = `Новое содержимое объекта`;</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта и сам объект</p><code>const textEldfnentContent = textElement.outerHTML;</code><p>заменил сам объект</p><code>textElement.outerHTML = `&lt;p>Новое содержимое объекта&lt;/p>`;</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта без тегов</p><code>const textEldfnentContent = textElement.textContent;</code><p>заменил содержимое объекта, но теги вставляються как текст позволяет записывать получаемый текст безопасно</p><code>textElement.textContent = `&lt;p>Новое содержимое объекта&lt;/p>`;</code><br><p>получил объект с классом .someClass__text</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил следующий объект - комментарий</p><code>const getComment = textElement.nextSibling;</code><p>вывел текст комментария в консоль</p><code>console.log(getComment.data);</code><p>заменил текст комментария</p><code>getComment.data = `Новый текст`;</code><br><p><dfn>Методы поиска элементов в DOM</dfn>:<br>
<em>querySelector</em> - ищет внутри элемента по CSS-selector<br>
<em>querySelectorAll</em> - <br>
<em>getElementById</em> - ищет по id<br>
<em>getElementsByName</em> - возвращает коллекцию, ищет по имени<br>
<em>getElementsByTagName</em> - возвращает коллекцию, ищет внутри элемента по тегу или "*"<br>
<em>getElementsByClassName</em> - возвращает коллекцию, ищет внутри элемента по class<br>
<em>elem.matches(css)</em> - проверяет, удовлетворяет ли элемент CSS-селектору<br>
<em>elem.closest(css)</em> - ищет ближайшего предка<br>
<em>elemA.contains(eldfnB)</em> - вернет true если elemB находится внутри elemA или elemA == elemB<br>
</p></details><details><summary>Document</summary><p><dfn>Document</dfn> - интерфейс доступа к узлам, его реализует объект document.<br>
<dfn>document</dfn> - объект DOM, входная точка в DOM<br></p><br><p>получить объект html со всем его содержимым</p><code>const htmlEldfnent = document.documentEldfnent;</code><p>получить объект head со всем его содержимым</p><code>const headEldfnent = document.head;</code><p>получить объект body со всем его содержимым</p><code>const bodyEldfnent = document.body;</code><br><p><dfn>DOMContentLoaded</dfn> генерируется на document, когда DOM готов и к нему можно применить JS.<br>
Изображения и другие ресурсы (стили и т.п.) всё ещё могут продолжать загружаться.<br>
<em>window.onload</em> - страница и все ресурсы загружены<br>
<em>window.beforeunload</em> - пользователь покидает страницу.<br>
Если отменить событие, то браузер спросит хочет ли пользователь уйти.<br>
<em>window.unload</em> - пользователь окончательно уходит, можно сделать сетевой запрос.<br>
<em>document.readyState</em> - текущее состояние загрузки документа.<br></p><br><p>Изменения можно отследить с помощью события <dfn>readyStateChange</dfn>:<br>
<b>loading</b> - документ грузится<br>
<b>interactive</b> - документ прочитан, происходит перед DOMContentLoaded<br>
<b>complete</b> - документ и ресурсы загружены, происходит перед window.onload<br></p><br><p>Скрипт должен дождаться пока загрузятся стили.<br>
Скрипты <b><&lt;script&gt;... &lt;/script&gt;</b> или <b><&lt;script src="..."&gt; &lt;/script&gt;</b> блокируют DOMContentLoaded.<br>
Скрипты созданные через <b>document.createElement('script')</b>, добавленные на страницу и скрипты с атрибутами async или defer не блокируют DOMContentLoaded.<br>
Динамически загружаемые скрипты по умолчанию ведут себя как async,</p><pre><code>script.async = false; <span>- отмена async-поведения</span>
let script = document.createElement('script');
script.src = "путь/к/скрипту";
document.body.append(script);</code></pre><p><em>async</em> - скрипты выполняются по загрузке, DOMContentLoaded не имеет значения.<br>
<em>defer</em> - скрипты выполняются по расположению в докумете. Скрипт ждёт загружки документа выполняется перед DOMContentLoaded.<br>
<em>defer</em> работает только у внешних скриптов - у которых есть <b>src="..."</b>, все элементы с src="..." дают события:<br>
<b>load</b> - при успешной загрузке,<br>
<b>error</b> - при ошибке<br>
<em>&lt;iframe&gt;</em> - исключение: всегда даёт load, даже при ошибке.<br>
Событие <em>readystatechange</em> также работает для ресурсов.<br>
Обработчики onload/onerror отслеживают только сам процесс загрузки.<br>
<em>Window.onerror</em> - позволяет "поймать" ошибки в скрипте.<br>
Скрипт одного сайта не может получить детали ошибки скрипта с другого сайта, нужно поставить тегу  атрибут crossorigin 
и специальные заголовки на удалённом сервере.<br>
<em>MutationObserver</em> - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.<br></p><code>let observer = newMutationObserver(callback); - создать наблюдатель</code><p><em>observer.observe(node, config)</em>; - прикрепить наблюдателя к DOM-узлу.<br>
<em>observer.disconnect()</em>; - останавливает наблюдение.<br>
<em>observer.takeRecords()</em>; - получает список необработанных записей измененений, которые произошли, 
но колбэк для них ещё не выполнился.<br></p><br><p>В основе выделения лежит <dfn>Range(диапозон)</dfn> - пара граничных точек: начало и конец диапозона.<br>
<dfn>Range</dfn> - общий, объект для управления диапозоном.<br>
Выделение в документе представлено объектом Selection, который можно получить как 
<b>window.getSelection()</b> или <b>document.getSelection()</b>.<br>
<dfn>Selection</dfn> (выделение) имеет начальную границу (якорь) и конечную (фокус).<br></p><br><p>Основные свойства выделения:<br>
<em>anchorNode</em> - узел начала выделения<br>
<em>anchorOffset</em> - смещение в anchorNode, где начинается выделение<br>
<em>focusNode</em> - узел окончания выделения<br>
<em>focusOffset</em> - смещение в focusNode, где выделение заканчивается<br>
<em>inCollapsed</em> - true, если диарозон выделения пуст или не существует<br>
<em>rangeCount</em> - количество диапозонов в выделении<br></p><br><p><dfn>document.cookie</dfn> предоставляет доступ к куки:<br>
- операция записи изменяет только те куки, которые было указано<br>
- имя и значение куки должны быть закодированы<br>
- одно уки вмещает до 4 kb данных, количество куки зависит от браузера.<br></p><br><p><dfn>Настройки куки</dfn>:<br>
<em>path = /</em> - по умолчанию текущий путь, делает куки видимыми только по указанному пути и ниже<br>
<em>domain = site.com</em> - по умолчанию куки видно только на текущем домене, если явно указан домен, 
то куки видно и на поддоменах<br>
<em>expires или max-age</em> - устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.<br>
<em>secure</em> - делает куки доступными только при использовании HTTPS<br>
<em>somesite</em> - запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки<br></p><br><p><dfn>Методы создания узлов</dfn>:
<em>document.createElement(tag)</em> - создаёт элемент с заданным тегом<br>
<em>document.createTextNode(value)</em> - создаёт текстовый узел<br>
<em>document.write(html)</em> - добавляет html на страницу до завершения её загрузки.<br></p><br><p>После загрузки затирает начальный документ.<br>
<em>const newElement = document.createElement(`div`)</em>; - создал элемент: тег div<br>
<em>const newText = document.createTextNode(`Новый текст`)</em>; - создал текстовый узел<br>
<em>elem.cloneNode(deep)</em> - клонирует элемент, если deep == true, то со всеми дочерними элементами.<br></p><br><p>Вставка и удаление узлов:<br>
<em>node.append(...nodes or strings)</em> - вставляет в node в конец<br>
<em>node.prepend(...nodes or strings)</em> - вставляет в node в начало<br>
<em>node.before(...nodes or strings)</em> - вставляет прямо перед node<br>
<em>node.after(...nodes or strings)</em> - вставляет сразу после node<br>
<em>node.replaceWith(...nodes or strings)</em> - заменяет node<br>
<em>node.remove()</em> - удаляет node<br>
<em>elem.beforebegin</em> - вставляет html прямо перед elem<br>
<em>elem.afterbegin</em> - вставляет html в elem в начало<br>
<em>elem.beforeend</em> - вставляет html в elem в конец<br>
<em>elem.afterend</em> - вставляет html сразу после elem<br>
<em>elem.insertAdjacentText</em> - вставляет текстовые строки<br>
<em>elem.insertAdjacentElement</em> - вставляет элементы<br>
<em>textElement.before(newElement)</em>; - вставил newElement перед textElement<br>
<em>textElement.after(newElement)</em>; - вставил newElement после textElement<br>
<em>textElement.prepend(newElement)</em>; - вставил newElement в начало внутри объекта textElement<br>
<em>textElement.append(newElement)</em>; - вставил newElement в конец внутри объекта textElement<br>
либо<br>
<em>textElement.append(newElement, `Новый текст`)</em>; - можно вставлять через запятую, но теги вставляються как текст<br>
<em>textElement.insertAdjacentHTML('pos', `ins`)</em>; - позволяет вставить в DOM что угодно<br>
<b>pos</b> - место вставки по отношению к textElement<br>
<b>beforebegin</b> - вставить перед textElement<br>
<b>afterbegin</b> - вставить в начало textElement<br>
<b>beforeend</b> - вставить в конец textElement<br>
<b>afterend</b> - вставить после textElement<br>
<b>ins</b> - то что вставляем, позволяет вставить теги<br>
<em>insertAdjacentText()</em>;<br>
<em>insertAdjacentElement()</em>;<br>
<em>textElement.append(oldElement)</em>; - перенес существующий oldElement в конец textElement<br>
<em>let cloneOldElement = oldElement.cloneNode()</em>; - клонировал без дочерних элементов<br>
<em>let cloneOldElement = oldElement.cloneNode(true)</em>; - клонировал с дочерними элементами<br>
<em>textElement.remove()</em>; - удаление объекта<br>
<em>const elementClassNames = element.className</em>; - получил все классы объекта element<br>
<em>element.className = "red"</em>; - заменил все классы на класс red<br>
<em>element.classList.add('active')</em>; - добавить класс<br>
<em>element.classList.remove('active')</em>; - удалить класс<br>
<em>element.classList.toggle('active')</em>; - добавить класс если его нет, а если есть, то удалить<br>
<em>element.classList.contains('active')</em>; - проверяет наличие класса, возвращает true or false<br>
<em>element.style.color = "red"</em>; - получаем доступ к атрибуту style HTML-тега и задаём цвет<br>
<em>console.log(element.style.marginBottom)</em>; - вывод в консоль значения css-свойство атрибута style HTML-тега объекта element<br>
<em>element.style.color = ""</em>; - удалил css-свойство из атрибута style HTML-тега<br>
записываю сразу несколько css-свойств в атрибут style, перезаписывает style полностью<br></p><pre><code>element.style.cssText = `
margin-bottom: 30px;
color: red;
`;</code></pre><br><p><em>const elementStyle = getComputedStyle(eldfnent)</em>; - получил вычисленные стили элемента<br>
<em>console.log(elementStyle.fontSize)</em>; - выводим вычисленое значение размера шрифта<br>
<em>const elementBeforeStyle = getComputedStyle(element, "::before")</em>; - получил стили псевдоэлемента<br>
<em>console.log(elementBeforeStyle.backgroundColor)</em>; - выводим цвет фона, который реализован с помощью ::before<br>
<em>getComputedStyle()</em>; - работает только для чтения<br>
<em>const paddingLeft = parseInt(elementStyle.paddingLeft)</em>; - сразу перевожу значение из строки в число<br>
<em>element.style.marginLeft = "20px"</em>; - задавать значения всегда с единицами измерения<br>
<br>
Устаревшие методы (возвращают node):<br>
<em>parent.appendChild(node)</em><br>
<em>parent.insertBefore(node, nextSibling)</em><br>
<em>parent.removeChild(node)</em><br>
<em>parent.replaceChild(newEldfn, node)</em><br>
<br>
<em>document.forms</em> - живая коллекция всех форм на странице <b>document.forms[name/index]</b><br>
Элементы <em>&lt;form&gt;</em> или <em>&lt;fieldset&gt;</em> доступны через <b>form.elements[name/index]</b> или <b>form[name/index]</b>.<br>
Элементы хранят ссылку на свою форму в свойстве <b>element.form</b>.<br>
Значения элементов формы доступны через <b>input.value</b>, <b>textarea.value</b>, <b>select.value</b> и т.д. либо <b>input.cheked</b> для чекбоксов и переключателей.<br>
<br>
Для <em>&lt;select&gt;</em> можно получить индекс выбранного пункта через: <b>select.selectedIndex</b> либо <b>select.options</b>.<br>
Элемент получает фокус когда пользователь кликает по нему или использует Tab.<br>
<br>
HTML-атрибут <b>auto-focus</b> - устанавливает фокус при загрузке страницы.<br>
HTML позволяет делать валидацию с помощью атрибутор required, pattern и т.д.<br>
События <b>focus и blur</b> срабатывают на фокусировке/потере фокуса элемента и не всплывают, но можно использовать фазу перехвата или focusin/focusout.<br>
<b>tabindex</b> делает фокусируемым любой элемент.<br>
<br>
<em>document.activeElement</em> - текущий элемент с фокусом.<br>
<em>const form = document.forms[0]</em> - получить форму по индексу коллекции<br>
<em>const form = document.forms.main</em> - по аттрибуту тега name (name="main")<br>
<br>
<em>document.querySelectorAll('form')</em> - неживая коллекция<br></p><pre><code>const form = document.forms.main<br>
console.log(form.elements) -  вывел элементы формы<br></code></pre><br><p><em>focus, blur</em> - события не всплывают<br>
<br>
<em>focus(), blur()</em> - методы. Аттрибут taindex = -1 на клавишу tab не реагирует, но можно установить фокус на елемент методом<br>
<em>document.activeElement</em> - получаем текущий элемент с фокусом<br>
<em>focusin / focusout</em> - события всплывают<br>
<br>
<dfn>События изменения данных:</dfn><br>
<em>change</em> - значение изменено. срабатывает в текстовом поле при потере фокуса, в остальных полях при выборе.<br>
<em>input</em> - значение изменено. Срабатывает немедлено при каждом изменении текстового поля.<br>
<em>cut/copy/paste</em> - свойство event.clipboardData даёт доступ на чтение/запись в буфер.<br>
<em>cut</em> - событие, срабатывает при вырезании<br>
<em>copy</em> - событие, срабатывает при копировании<br>
<em>paste</em> - событие, срабатывает при вставке<br>
<em>submit</em> - событие отправки данных формы, при <b>form.submit()</b> - форма отправится при потере фокуса<br>
<em>event.preventDefault()</em> - запретит выполнение события<br>
<br>
<dfn>Отправка формы:</dfn><br>
Нажать кнопку <b>&lt;input type="submit"&gt;</b> или <b>&lt;input type="image"&gt;</b><br>
Нажать Enter на любом поле<br>
При отправке формы по нажатию Enter в текстовом поле, генерируется событие <em>click</em> на кнопке <b>&lt;input type="submit"&gt;</b><br>
При отправке формы срабатывает событие <em>submit</em>, оно используется для проверки формы перед её отправкой на сервер 
или для отмены отправки и обработки её с помощью JS.<br>
<b>form.submit()</b> позволяет отправить форму из JS. Используют для создания и отправки собственных форм на сервер, 
при этом событие <em>submit</em> не генерируется.<br>
<br>
<dfn>scroll</dfn> - событие прокрутки позволяет реагировать на прокрутку страницы или элемента.<br></p><pre><code>window.addEventListener('scroll', function() {
  document.getEldfnentById('showScroll').innerHTML = pageYOffset + 'px';
});
</code></pre></details><details><summary>EventTarget</summary><p><dfn>EventTarget</dfn> - это абстрактный класс.<br>
Обеспечивает поддержание DOM-узлами событий.<br>
<br>
<dfn>Event</dfn>(Событие) - сигнал от браузера о том, что что-то произошло.<br>
Событию можно назначить обработчик - функцию, которая сработает, как только событие произошло.<br>
Способы назначения обработчиков событий:<br>
Атрибут HTML: <b>onclick="..."</b>.
DOM-свойство: <b>elem.onclick = function</b>.
Методы: <b>elem.addEventListener(event, handler[, phase])</b> для добавления<br>
<b>event</b> - имя события, например "click".<br>
<b>handler</b> - ссылка на функцию обработчик.<br>
<b>options</b> - дополнительный объект со свойствами:<br>
<b>once</b>: если true, тогда обработчик будет удалён после выполнения.<br>
<b>capture</b>: фаза, на которой должен сработать обработчик (false/true)<br>
<b>passive</b>: если true, то обработчик не вызовет preventDefault()<br>
<br>
Обработчик всегда хранится в свойстве DOM-объекта, а атрибут - лишь один из способов его инициализации.<br>
В DOM-свойстве один обработчик на один тип события, так как одно имя - одно свойство.<br>
Методы - самый гибкий и используемый способ.<br>
<b>addEventListener</b> поддерживает объекты в качестве обработчиков событий, вызывая метод объекта object.handleEvent(event).<br>
Убрать обработчик <b>elem.onclick = null</b>.<br>
Не используй <b>setAttribute</b> для обработчиков.<br>
Регистр DOM-свойства имеет значение, а HTML-атрибута - нет.<br>
Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.<br>
Любой обработчик получает объект события первым аргументом<br>
<em>event.type</em> - тип события, например "click"<br>
<em>event.clientX/event.clientY</em> - координаты курсора для событий мыши в момент клика относительно окна.<br>
<br>
<dfn>События</dfn>:<br>
<em>onclick="JScode"</em> - обработчик события, аттрибут тега.<br></p><code>const button = document.querySelector('.button');</code><p><em>button.onclick = function () {};</em> - нет возможности повесить на одно событие несколько обработчиков<br>
либо<br></p><code>function showClick() {}</code><p><em>button.onclick = showClick;</em> - нет возможности повесить на одно событие несколько обработчиков<br>
<em>button.addEventListener("click", function (e) {});</em> - можно назначить обработчик несколько раз<br>
либо<br></p><code>button.addEventListener("click", func);
function func(e) {}
<br></code><p><em>button.removeEventListener(event, handler);</em> - отключает обработчик<br>
<em>button.addEventListener(event, handler, options);</em> - можно добавить параметры<br></p><pre><code>const options {
  "capture: false", - фаза, на которой должен сработать обработчик (всплытие/погружение)
  "once": false, - если true, тогда обработчик будет удален после выполнения
  "passive": false - если true, то обработчик никогда не вызовет preventDefault()
}
либо
button.addEventListener("click", func, {"once": true});</code></pre><br><p>Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его
в качестве аргумента (event) функции - обработчику:<br>
<em>event.type</em> - тип события<br>
<em>event.target</em> - объект, на котором сработал обработчик<br>
<em>event.currentTarget</em> - объект, которому назначен обработчик<br>
<em>event.clientX</em> - положение курсора по Х<br>
<em>event.clientY</em> - положение курсора по Y<br>
<em>console.log(evant)</em> - посмотреть все детали события<br>
<em>event.stopPropagation()</em>; - остановка всплытия<br>
<br>
<dfn>Делегирование</dfn> - вешаем прослушку на родителя<br>
Отмена действий браузера по умолчанию:<br></p><pre><code>event.preventDefault(); - для addEventListener
либо
button.addEventListener("click", func, {"passive": true});

link.onclick = function () { - для onclick
  return false;
}</code><br></pre><p><dfn>Всплытие и погружение:</dfn><br>
целевой элемент <b>(event.target)</b> - самый глубоко вложенный элемент, над которым произошло событие.<br>
Сначала событие двигается вниз (погружение) от корня документа к event.target, по пути вызывая обработчики, 
поставленные через <b>addEventListener(..., true)</b>,<br>
где true - сокращенно <b>{capture: true}</b><br>
Далее обработчики на целевом элементе.<br>
Потом событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
поставленные через on&lt;event&gt; и addEventListener без третьего аргумента
или с третьим аргументом равным fasle.<br>
Каждый обработчик имеет доступ к свойствам события event:<br>
<em>event.target</em> - самый глубокий элемент, на котором произошло событие<br>
<em>event.currentTarget(=this)</em> - элемент, на котором в данный момент сработал обработчик 
(тот, на котором "висит" конкретный обработчик)<br>
<em>event.eventPhase</em> - не какой фазе он сработал: (погружение = 1, фаза цели = 2, всплытие = 3)<br>
<br>
Любой обработчик может остановить событие вызовом <b>event.stopPropagation()</b>.<br>
Всплытие и погружение являются основой для делегирования событий.<br>
Делегирование событий используется при схожей обработке многих элементов.<br>
Вешаем обработчик на контейнер.<br>
В обработчике проверяем целевой элемент <b>event.target</b>.<br>
Если событие произошло на нужном элементе, то обрабатываем его.<br>
<br>
Использование:<br>
Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.<br>
Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.<br>
Удобство изменений DOM: можно массово добавлять или удалятьэлементы путём изменения innerHTML и ему подобных.<br>
<br>
Событие должно всплывать. Низкоуровневые обработчики не должны вызывать event.stopPropagation().<br>
Два способа отменить действие браузера по умолчанию:<br>
- <em>event.preventDefault()</em> - основной способ<br>
либо
- &lt;a href="/" onclick = "event.preventDefault()"&gt;здесь&lt;/a&gt;<br>
Опция <b>passive</b>: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено.<br>
Это сообщит браузеру, что он не должен ждать выполнения всех обработчиков, 
а ему следует сразу приступать к выполнению действия по умолчанию, например к прокрутке.<br>
event.defaultPrevented равно true если событие по умолчанию отменено, иначе false.<br>
Чтобы сгенерировать событие из кода, вначале нужно создать объект события<br></p><code>let event = newEvent(name[, options]);</code><p>Базовый конструктор <em>Event(name, options)</em> принимает обязательное имя события и options - объект с тремя свойствами:<br>
- <em>bubbles: true</em> - чтобы событие всплывало<br>
- <em>cancelable: true</em> - если нужно, чтобы работал event.preventDefault()<br>
- <em>composed: true/false</em> - если true, то событие будет всплывать наружу за пределы Shadow DOM.<br>
По умолчанию все три свойства - false:<br></p><code>{bubbles: false, canselable: false, composed: false}.</code><p><em>elem.dispatchEvent(event)</em> - запускает объект события на элементе.<br>
<em>event.isTrusted</em> - true для событий от пользователя и false для генерирующих.<br>
<em>on&lt;event&gt;</em> - для встроенных событий.<br>
<em>addEventListener</em> - для генерируемых.<br>
При создании встроенных событий использовать конструкторы встроенных событий (newMouseEvent("click") и др.)<br>
Для пользовательских событий применять конструктор CustomEvent.<br>
event.detail позволяет передавать информацию в объекте события.<br>
Генерировать встроенные события в случаях:<br>
- явный грубый хак, чтобы заставить работать сторонние библиотеки, если нет другого способа.<br>
- скриптом нажать на кнопку для автоматического тестирования.<br>
<br>
<dfn>События мыши:</dfn><br>
<em>click</em> - кликнули на элемент левой кнопкой мыши (на устройсвах с сенсорными экранами - при касании).<br>
contextmenu - происходит, когда кликнули на элемент правой кнопкой мыши<br>
<em>mouseover/mouseout</em> - когда мышь наводится на/покидает элемент.<br>
<em>mousedown/mouseup</em> - когда нажали/отжали кнопку мыши на элементе.<br>
<em>mousemove</em> - при движении мыши.<br>
Комплексные события состоят из простых, обработчики событий вызываются в следующем порядке:<br>
<b>mousedown -> mouseup -> click</b><br>
Свойство события мыши which - какая кнопка мыши нажата:<br>
- <b>event.which == 1</b> - левая кнопка<br>
- <b>event.which == 2</b> - средняя кнопка<br>
- <b>event.which == 3</b> - правая кнопка<br>
Клавиши - модификаторы (true если нажаты): <b>altKey, ctrKey и metaKey (Mac)</b>.<br>
В Мас обычно Cmd вместо ctrl, поэтому лучше проверить: <b>if(e.metaKey || e.ctrlKey)</b>.<br>
Координаты относительно окна: clientX, clientY.<br>
Координаты относительно документа: pageX/pageY.<br>
Запрет копирования:<b> &lt;div oncopy = "alert('Копрование запрещено!'); return false"&gt;</b><br>
При быстром движении мыши события не будут возникать на промежуточных элементах.<br>
Браузер периодически проверяет позицию курсора и при изменении генерирует событие mousemove.<br>
Если был mouseover, то будет и mouseout.<br>
События mouseover/out и mouseenter/leave имеют дополнительное свойство relatedTarget.<br>
Для события mouseover:<br>
<em>event.target</em> - это элемент, на который курсор пришёл.<br>
<em>event.relatedTarget</em> - это элемент, с которого курсор пришёл (target -> relatedTarget)<br>
<em>event.relatedTarget</em> равно null - указатель мыши пришёл из-за или ушёл за пределы окна.<br>
В любой момент времени указатель может быть только над одним элементом - над самым глубоко вложенным.<br>
События <b>mouseover/out</b> возникают, когда происходит переход с родительского элемента на потомка.<br>
События <b>mouseenter/leave</b> не всплывают и генерируются, когда курсор переходит или уходит на элемент в целом (без учёта потомков).<br>
<br>
<dfn>Простые</dfn>:<br>
<em>mousedown / mouseup</em> - кнопка мыши нажата / отпущена над элементом<br>
<em>mouseover / mouseout</em> - курсор мыши появляется над элементом и уходит с него<br>
<br>
<dfn>mouseover</dfn>:<br>
<em>event.target</em> - элемент откуда ушёл курсор<br>
<em>event.relatedTarget</em> - элемент куда ушёл курсор<br><br>
<br>
<dfn>mouseout</dfn>:<br>
<em>event.target</em> - элемент куда пришёл курсор<br>
<em>event.relatedTarget</em> - элемент откуда пришёл курсор<br>
<br>
<em>mousemove</em> - каждое движение мыши над элементом генерирует это событие<br>
<em>contextmenu</em> - вызывается при попытке открытия контекстного меню<br>
<br>
<dfn>Комплексные</dfn>
<em>click - mousedown и mouseup</em> над одним и тем же элементом<br>
<em>dblclick</em> - двойной клик на элементе<br>
<br>
<em>event.which = 1</em> - нажата основная кнопка мыши (левая)<br>
<em>event.which = 2</em> - нажата средняя кнопка мыши (колесо)<br>
<em>event.which = 3</em> - нажата не основная кнопка мыши (правая)<br>
<br>
<em>mouseover / mouseout</em> - всплывают, можно использовать делегирование,<br>
<em>mouseenter / mouseleave</em> - нет<br>
<br>
<dfn>Базовый алгоритм Drag'n'Drop.</dfn><br>
При mousedown - готовим элемент к перемещению (если нужно создаём его копию).<br>
При mousemove передвигаем элемент на новые координаты путём смены left/top и position: absolute.<br>
При mouseup - остановить перенос элемента и произвести окончание Drag'n'Drop.<br>
Ключевые идеи:<br>
<b>object.mousedown -> document.mousemove -> object.mouseup</b><br>
(обязательно отменить браузерный ondragstart)<br>
В начале перетаскивания запоминаем начальное смещение указателя относительно элемента(shiftX/shiftY) и сохраняем его при перетаскивании.<br>
Выявляем потенциальные цели переноса под указателем с помощью <b>document.elementFromPoint</b>.<br>
На mouseup завершить перенос: изменить данные, переместить элементы.<br>
<br>
<dfn>События указателя</dfn> (Pointer events) одновременно обрабатывают действия мыши, касания пера.<br>
Содержат свойства мыши и дополнительно свои:<br>
<em>pointerId</em> - идентификатор указателя, вызвавшего событие, генерируется браузером,
позволяет обрабатывать несколько указателей (стилус и мультитач).<br>
<em>pointerType</em> - тип указывающего устройства. Строка с одним из значений: "mouse", "pen" или "touch".<br>
<em>isPrimary</em> - равно true для основного указателя (первый палец в мультитач).<br>
При обработке переносов и сложных касаний нужно отменить действие браузера и ставить <b>touch-events: none</b> в CSS для элементов.<br>
Можно перенаправить (захватить) все события указателя на определённый элемент до наступления события pointerup/pointercancel.<br>
Два связанных с захватом события:<br>
<b>getpointercapture</b> срабатывает, когда элемент использует <b>setPointerCapture</b> для включения захвата.<br>
<b>lostpointercapture</b> срабатывает при освобождении от захвата:<br>
- явно с помощью <b>releasePointerCapture</b> или<br>
- автоматически при событии <b>pointerup/pointercancel</b>.<br>
<br>
<dfn>Сбытия указателя - мыши</dfn>:<br>
<em>pointerdown - mousedown</em><br>
<em>pointerup - mouseup</em><br>
<em>pointermove - mousdfnove</em><br>
<em>pointerover - mouseover</em><br>
<em>pointerenter - mouseenter</em><br>
<em>pointerleave - mouseleave</em><br>
<em>pointercancel - </em><br>
<em>getpointercapture - </em><br>
<em>lostpointercapture - </em><br>
<br>
<dfn>События клавиатуры</dfn>:<br>
<em>keydown</em> - происходит при нажатии клавиши<br>
<em>keyup</em> - при отпускании клавиши<br>
<em>event.code</em> - код нажатой клавиши ("KeyA", "ArrowLeft" и т.д.)<br>
<em>event.key</em> - клавиша с учетом регистра и раскладки клавиатуры символ ("A", "a" и т.д.)<br>
<em>event.repeat</em> - вернет true при срабатывании повтора на зажатой клавише<br>
Нажатие клавиши всегда генерирует клавиатурное событие, кроме клавиши Fn.<br>
<br>
<dfn>Прокрутка</dfn>:<br>
<em>scroll</em> - событие прокрутки<br>
<em>scrollY</em> - количество прокрученных пикселей по вертикали<br>
<em>scrollX</em> - количество прокрученных пикселей по горизонтали<br>
<br>
<dfn>Загрузка</dfn>:<br>
<em>DOMContentLoaded</em> - браузер полностью загрузил HTML, построил DOM-дерево, 
но внешние ресурсы могут быть ещё не загружены
срабатывает на объекте document<br>
<em>load</em> - браузер полностью загрузил HTML, и внешние ресурсы
срабатывает на объекте window<br>
<em>beforeunload / unload</em> - пользователь покидает сраницу<br>
<em>beforeunload</em> - можем вывести пользователю предупреждение о несохраненных данных в форме<br>
<em>unload</em> - пользователь уже ушёл состраницы, но можно поручить браузеру собрать статистику<br>
<br>
<em>document.readyState</em> - остояние загрузки:<br>
<em>loading</em> - документ загружается<br>
<em>interactive</em> - документ был полностью прочитан<br>
<em>complete</em> - документ был полностью прочитан и все ресурсы загружены<br>
<br>
События, отправленные сервером (SSE), позволяют веб-странице получать обновления с сервера.<br>
В случае событий, отправленных сервером, обновления приходят автоматически.<br>
</p></details><details><summary>Properties</summary><p>Когда браузер загружает страницу, он читает (парсит) HTML и генерирует DOM-объекты.<br>
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся
свойствами DOM-объектов.<br>
У каждого тега свои атрибуты:<br>
Атрибуты написаны в HTML, свойства - в DOM-объектах.<br>
Можно изменять DOM-узлы добавляя своё свойство.<br>
Методы для работы с атрибутами:<br>
<em>elem.hasAttribute(name)</em> - проверить на наличие<br>
<em>elem.getAttribute(name)</em> - получить значение<br>
<em>elem.setAttribute(name, value)</em> - установить значение<br>
<em>elem.removeAttribute(name)</em> - удалить атрибут<br>
<em>elem.attributes</em> - коллекция всех аттрибутов<br>
<br>
<dfn>Свойства</dfn>:<br>
<em>nodeType</em> - тип DOM-узла.<br>
Только для чтения.<br>
Его значение-числовое: 1- элементы, 3 - текстовые узлы и т.д.<br>
<br>
<em>nodeName/tagName</em> - возвращает название тега.<br>
Только для чтения.<br>
Для узлов - неэлементов описывает, что за узел.<br>
<br>
<em>innerHTML</em> - внутренее HTML-содержимое узла-элемента.<br>
Изменяемый.
С innerHTML вставка происходит "как HTML", со всеми HTML-тегами.<br>
<br>
<em>console.dir(element)</em>; - выведет список доступных свйоств DOM-объекта element<br>
<em>element.hasAttribute('some-name')</em>; - проверить наличие аттрибута name<br>
<em>element.getAttribute('some-name')</em>; - получить значение аттрибута name<br>
<em>element.setAttribute('some-name', value)</em>; - создать аттрибут (some-name) и установить в него значение (value)<br>
<em>element.removeAttribute('some-name')</em>; - удалить аттрибут name<br>
<em>element.tagName</em> - показывает какой тег у объекта<br>
<em>element.hidden = true</em>; - скрыть или показать объект<br></p><img src="../img/js/JS58.png" alt=""><br><img src="../img/js/JS59.png" alt=""><br><img src="../img/js/JS60.png" alt=""><br><img src="../img/js/JS61.png" alt=""><br><br><p><dfn>Размеры и координаты</dfn><br>
<em>const mainElement = document.documentElement</em>; - получил объект html<br>
<em>const mainElementWidth = mainElement.clientWidth</em>; - доступная ширина окна без прокрутки<br>
<em>const mainElementHeight = mainElement.clientHeight</em>; - доступная высота окна без прокрутки<br>
<em>const windowWidth = window.innerWidth</em>; - ширина окна с полосой прокрутки<br>
<em>const windowHeight = window.innerHeight</em>; - высота окна с полосой прокрутки<br>
<br>
Ширину и высоту всего документа (включая прокрученную часть) можно найти:<br></p><pre><code>let scrollWidth = Math.max(
  document.body.scrollWidth, document.documentElement.scrollWidth,
  document.body.offsetWidth, document.documentElement.offsetWidth,
  document.body.clientWidth, document.documentElement.clientWidth,
);

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);</code></pre><br><p><dfn>Метрики</dfn><br></p><img src="../img/js/metrics.png" alt=""><p><em>element.offsetParent</em>; - получаем родительский элемент, относительно которого позиционирован eldfnent<br>
<em>element.offsetLeft</em>; - отступ слева от родительского элемента element.offsetParent<br>
<em>element.offsetTop</em>; - отступ сверху от родительского элемента element.offsetParent<br>
<em>element.offsetWidth</em>; - общая ширина element<br>
<em>element.offsetHeight</em>; - общая высота element<br>
<em>element.clientTop</em>; element.clientLeft; - отступы внутренней части element от внешней<br>
<em>element.clientWidth</em>; element.clientHeight; - размеры объекта без рамок и полосы прокрутки<br>
<em>element.scrollWidth</em>; element.scrollHeight; - размеры объекта без рамок и полосы прокрутки, включая прокручиваемую часть внутри объекта<br>
<em>element.scrollLeft</em>; element.scrollTop; - размеры прокрученной области внутри объекта, можно считывать и задавать значения к объекту можно применять scrollBy, scrollTo, scrollIntoView<br>
<em>element.getBoundingClientRect()</em>; - получить координаты относительно окна браузера<br>
<em>element.getBoundingClientRect().top + window.pageYOffset</em>; - получить координаты относительно документа<br>
<em>const elem = document.eldfnentFromPoint(x, y)</em>; - узнать какой элемент находится по указанным координатам (координаты относительно окна браузера)<br>
<br>
<em>data-аттрибут</em> - для ввода нестандартных аттрибутов:<br>
<em>element.dataset.size = "1024"</em>; - установил в аттрибут data-size значение 1024<br>
<em>alert(document.body.innerHTML)</em>; - читаем текущее содержимое<br>
<em>document.body.innerHTML = 'Новый BODY!'</em>; - заменяем содержимое<br>
Если innerHTML вставляет в документ тег  - он становится частью HTML, но не запускается.<br>
<br>
<dfn>outerHTML</dfn> - полный HTML узла-элемента.<br>
Запись в elem.outerHTML заменяет elem во внешнем контексте.<br></p><pre><code>&lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;

alert(elem.outerHTML); - &lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;</code></pre><br><p><dfn>textContent</dfn> - текст внутри элемента: HTML за вычетом всех тегов.<br>
Запись в него помещает текст в элемент, при этом все спецюсимволы и теги интерпретируются как текст.<br>
Можно использовать для защиты от вставки произвольного HTML кода.<br>
<dfn>hidden</dfn> - если true, то скрывает элемент.<br>
<dfn>nodeValue и data</dfn> - содержимое узла-неэлемнта (текст, комментарий).<br>
Обычно используют data. Изменяемый.<br></p><pre><code>&lt;p&gt;Привет&lt;/p&gt;
// Комментарий

let comment = text.nextSibling;
alert(comment.data); - Комментарий

JS может прочитать if из свойства data и обработать инструкции:
// if isAdmin
Добро пожаловать, Админ!
// /if </code></pre><p>Лучше использовать DOM-свойства. Атрибуты используем тогда, когда нужны именно атрибуты.<br>
Например нестандартный атрибут. Если он начинается с data-, то нужно использовать dataset.<br></p><pre><code>&lt;body data-about = "Elephants"&gt;
alert(document.body.dataset.about); - Elephants</code></pre><p>Атрибут из нескольких слов data-order-state это свойство dataset.orderState<br>
Геометрические свойства (метрики) DOM-элементов<br>
<dfn>offsetParent</dfn> - ближайший CSS-позиционированный родитель или td, th, table, body.<br>
<dfn>offsetLeft/offsetTop</dfn> - позиция в пикселях верхнего левого угла offsetParent.<br>
<dfn>offsetWidth/offsetHeight</dfn> - внешняя ширина/высота элемента, включая рамки.<br>
<dfn>clientLeft/clientTop</dfn> - это border - отступ внутренней части элемента от внешней.<br>
<dfn>clientWidth/clientHeight</dfn> - ширина/высота сожержимого вместе <br>
с внутренними отступами padding, но без полосы прокрутки.<br>
<dfn>scrollWidth/scrollHeight</dfn> - ширина/высота содержимого с учетом <br>
прокрученной (невидимой) области элемента.<br>
<dfn>scrollLeft/scrollTop</dfn> - ширина/высота прокрученной сверху части элемента,
считается от верхнего левого угла.<br>
<br>
Все кроме scrollLeft/scrollTop доступны только для чтения.<br>
Если элемент, или любой его родитель, имеет display:none или отсутствует в документе, 
то все его метрики равны нулю (или null если это offsetParent).<br>
Лучше использовать свойства-метрики т.к. CSS-свойства width/height зависят от другого свойства - box-sizing,
которое определяет CSS-ширину/высоту.<br>
Изменение box-sizing сломает код.<br>
CSS-свойства width/height могут быть равны auto.<br>
Ширина/высота видимой части документа:<br>
document.documentElement.clientWidth/Height
Ширина/высота всего документа с прокрученной частью:<br></p><pre><code>let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);</code></pre><p><dfn>Прокрутка</dfn>:<br>
<em>window.pageYOffset/pageXOffset</em> - прокрутка окна.<br>
<em>window.scrollTo(pageX, pageY)</em> - абсолютные координаты.<br>
<em>window.scrollTo(0, 0)</em> - прокрутка в самое начало.<br>
<em>window.scrollBy(x, y)</em> - прокрутка относительно текущего места.<br>
<em>window.scrollBy(0, 10)</em> - прокручивает страницу на 10рх вниз.<br>
<em>window.scrollIntoView(top)</em> - прокрутить страницу, чтобы eldfn стал видимым
(выровнять относительно верхней/нижней части окна).<br>
<br>
Количество прокрученных пикселей (только для чтения):<br>
<em>const windowScrollTop = window.pageYOffset</em>; - количество пикселей прокрученных сверху<br>
<em>const windowScrollLeft = window.pageXOffset</em>; - количество пикселей прокрученных слева<br>
<em>window.scrollBy(x, y)</em>; - прокручивает страницу относительно текущего положения<br>
<em>window.scroll(x, y)</em>; - прокручивает страницу на абсолютные координаты<br>
<em>window.scrollTo(x, y)</em> - прокручивает страницу на абсолютные координаты<br>
<em>element.scrollIntoView(top)</em>; - прокрутит страницу до элемента element.<br>
          Если <b>top = true</b>, то элемент будет вверху страницы<br>
          Если <b>top = false</b>, то элемент будет внизу страницы<br>
Запретить или разрешить прокрутку:<br>
<em>document.body.style.overflow = "hidden"</em>; - добавляет <b>overflow = "hidden"</b> в аттрибут style тега body<br>
либо<br>
<em>document.body.classList.toggle('scroll-lock')</em>; - добавляет класс в тег body,<br>
потом нужно добавить в класс css-свойство <b>overflow = "hidden"</b><br>
<br>
Для прокрутки страницы из JS её DOM должен быть полностью построен.<br></p><code> document.body.style.overflow = "hidden"</code><p>Все координаты в контексте окна считаются от верхнего левого угла.<br>
<em>position: fixed</em>; - для координат относительно окна.<br>
<em>position: absolute</em>; - для координат относительно документа.<br>
Любая точка на странице имеет координаты:<br>
- относительно окна браузера - <b>elem.getBoundingClientRect()</b><br>
- относительно документа - <b>elem.getBoundingClientRect()</b> + прокрутка страницы.<br>
<em>document.elementFromPoint(x, y)</em> - возвращает самый глубоко вложенный элемент по координатам (х, у). <br>
Для координат вне окна возвращает null.<br>
<br>
<dfn>CSS</dfn>:<br>
CSS-событие <em>transitioned</em> - CSS-анимация завершена.<br>
Два способа задания стилей элементу:<br>
&lt;div class=" "&gt; - создать класс в CSS и использовать его<br>
&lt;div style="color:some"&gt; - писать стили в атрибуте style<br>
JS может менять и классы CSS и свойство style.<br>
Лучше использовать классы. Свойство style только если класс не подходит.<br>
Для управления классами существует два DOM-свойства:<br>
<em>className</em> - строковое значение, заменяет всю строку с классами.<br>
<em>classList</em> - объект с методами для управления одним классом.<br>
<br>
<dfn>Методы classList</dfn>:<br>
<em>elem.classList.add/remove("class")</em> - добавить/удалить класс.<br>
<em>elem.classList.toggle("class")</em> - добавит класс если его нет, иначе удалит.<br>
<em>elem.classList.contains("class")</em> - проверка наличия класса, возвращает true/false.<br>
<br>
Свойство style это объект со стилями в camelCase:<br></p><pre><code>background-color - elem.style.backgroundColor
z-index - elem.style.zIndex
border-left-width - elem.style.borderLeftWidth
style = "width: 100px" - elem.style.width = "100px"</code><br></pre><p>Чтобы удалить elem.style.display нужно присвоить пустую строку:<br></p><code>elem.style.display = "".</code><p>Свойство <em>style.cssText</em> - вся строка стилей атрибута style:</p><pre><code>&lt;div id = "div"&gt;Button&lt;/div&gt;

div.style.cssText = `
color: red !important;
background-color: yellow;
width: 100px;
text-align: center;`
alert(div.style.cssText);</code></pre><p><dfn>getComputedStyle(eldfn, [psevdo])</dfn> - возвращает объект для чтения окончательных стилей 
с учетом всех классов, после применения CSS и вычисления окончательных значений.<br>
eldfn - элемент, значения для которого нужно получить.<br>
psevdo - если нужен псевдоэлемент ::before.<br>
Без аргумента означает сам элемент.<br>
</p></details><details><summary>Storage</summary><p><dfn>localStorage и sessionStorage</dfn> - объекты вэб-хранилища, позволяют хранить пары ключ/значение в браузере.<br>
<em>key и value</em> - строки<br>
<em>Лимит 2 Mb</em> - зависит от браузера<br>
Данные не имеют срока хранения<br>
Данные привязаны к источнику (домен/протокол/порт)<br>
<dfn>localStorage</dfn> - используется между всеми вкладками и окнами одного источника совместно. Переживает перезапуск браузера.<br>
<dfn>sessionStorage</dfn> - разделяется в рамках вкладки браузера, среди ифреймов из того же источника.<br>
Переживает перезагрузку страницы, но не закрытие вкладки.<br>
<br>
<dfn>API</dfn>:<br>
<em>setItdfn(key, value)</em> - сохранить пару ключ/значение<br>
<em>getItdfn(key)</em> - получить данные по ключу key<br>
<em>rdfnoveItdfn(key)</em> - удалить значение по ключу key<br>
<em>clear()</em> - удалить всё<br>
<em>key(index)</em> - получить ключ по заданной позиции<br>
<em>length</em> - количество элементов в хранилище<br>
<em>Object.keys</em> - получить все ключи<br>
Если обращаться к ключам как к обычным свойствам объекта, то событие storage не срабатывает.<br>
<br>
<dfn>Событие storage</dfn>:<br>
Срабатывает при вызове <b>setItdfn, rdfnoveItdfn, clear</b><br>
Содержит все данные о произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea<br>
Срабатывает на всех объектах window, которые имеют доспут к хранилищу, кроме того где оно было сгенерировано 
(внутри вкладкидля sessionStorage, глобально для localStorage)<br>
<br>
<dfn>IndexedDB</dfn> - встроенная база данных типа ключ-значение, мощнее localStorage.<br>
Интерфейс для IndexedDB основан на событиях IndexedDB имеет встроенный механизм версионирования схемы, 
который отсутствует в серверных базах данных.<br>
IndexedDB работает на стороне клиента (в браузере) и у нас нет прямого доступа к данным.<br>
При публикации новой версии приложения возможно обновлять базу данных.<br>
<br>
<dfn>Использование</dfn>:<br>
Пoдключить обёртку над промисами (idb)<br>
Открыть базу данных: <b>idb.openDb(name, version, onupgradeneeded)</b><br>
Создание хранилищ объектов и индексов в обработчике onupgradeneeded<br>
Обновление версии - либо сравнивая номера версий, либо проверить что есть, а что нет.<br>
<br>
<dfn>Для запросов</dfn>:<br>
Создать транзакцию <b>db.transaction('books')</b> - можно указать readwrite.<br>
Получить хранилище объектов <b>transaction.objectStore('books')</b>.<br>
Для поиска по ключу вызвать метод непосредственно у хранилища объектов.<br>
Для поиска по любому полю объекта нужно создать индекс.<br>
Если данных не помещаются в памяти, то используй курсор.
</p></details></details></details><details><summary class="menu__submenu_lv1">SQL</summary><a href="https://dbdiagram.io/home">Diagram</a><details><summary>Определение (Definition)</summary><p><dfn>SQL</dfn> — применяется для создания, модификации и управления данными в реляционной базе данных, 
управляемой соответствующей системой управления базами данных.<br>
В базовом варианте SQL является информационно-логическим языком, а не языком программирования. <br>
<br>
<dfn>Система управления базами данных (СУБД)</dfn> — совокупность программных и лингвистических средств
общего или специального назначения, обеспечивающих управление созданием и использованием баз данных. <br>
<br>
<dfn>База данных (БД)</dfn> - под БД (БД) понимают хранилище структурированных данных, 
при этом данные должны быть непротиворечивы, минимально избыточны и целостны. <br>
<br>
<dfn>Реляционная база данных</dfn> — база данных, основанная на реляционной модели данных. <br>
Реляционные БД представляют связанную между собой совокупность таблиц-сущностей БД. <br>
Каждая таблица БД представляется как совокупность строк и столбцов, где строки соответствуют
экземпляру объекта, конкретному событию или явлению, а столбцы - атрибутам (признакам,
характеристикам, параметрам) объекта, события, явления. <br>
При практической разработке БД таблицы-сущности зовутся таблицами, строки-экземпляры - записями,
столбцы-атрибуты - полями. <br>
<br>
<em>Преимущества SQL</em> - наличие стандартов и независимость от конкретной СУБД. <br>
<em>Недостатки SQL</em> - сложность. <br></p><br><p><dfn>Классификация по модели данных:</dfn><br>
<em>Иерархическая</em><br>
<em>Объектная и объектно-ориентированная</em><br>
<em>Объектно-реляционная</em><br>
<em>Реляционная</em><br>
<em>Сетевая</em><br>
<em>Функциональная</em><br>
<br></p><p><dfn>Типы отношений:</dfn><br>
<em>Один к одному (one-to-one)</em> <br>
<em>Один ко многим (one-to-many)</em> <br>
<em>Многие к одному (many-to-one)</em> <br>
<em>Многие ко многим (many-to-many, реализуется через отдельную таблицу)</em> <br></p><img src="../img/sql/SQL12.png" alt=""><p>Источник:<a href="https://drawsql.app/">Рисовать диаграмму БД онлайн</a><a href="https://sql-ex.ru/?Lang=0">sql-ex</a><a href="https://sqlbolt.com/lesson/">sqlbolt</a><a href="https://sql-academy.org/ru/guide">sql-academy</a><a href="https://www.w3schools.com/sql/default.asp">W3Schools SQL Tutorial</a><a href="https://www.w3schools.com/sql/exercise.asp?">w3schools SQL Exercises</a></p></details><details><summary>Операторы определения данных (Data Definition Language, DDL)</summary><p><dfn>CREATE</dfn> - создает объект БД (саму базу, таблицу, представление, пользователя и т. д.)<br>
to create a new SQL database<br>
<dfn>CREATE DATABASE</dfn> database name;<br>
Создать таблицу table со столбцами id, field_1, field_2, field_3.<br>
По каждому столбцу заданы тип и количество символов.<br></p><pre><code><dfn>CREATE TABLE</dfn> table(
  id <dfn>INT PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);</code></pre><p><dfn>DESCRIBE</dfn> table - информация о таблице<br>
<dfn>PRIMARY KEY</dfn> - уникальный идентификатор записей.<br>
<dfn>FOREIGN KEY</dfn> - внешний ключ, значения идентификатора записей в связанной таблице.<br>
<dfn>SERIAL</dfn> - автоинкремент идентификатора в PostgreSQL<br>
<dfn>AUTO_INCREMENT</dfn> - автоинкремент идентификатора в MySQL<br></p><pre><code><dfn>CREATE TABLE</dfn> table(
  id <dfn>SERIAL PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);
</code></pre><p>Ограничения на уровне таблицы:<br>
Значения в столбцах id и field_1 уникальные и не пустые<br>
Значения столбца field_table_2_id - ссылки на id таблицы table_2<br>
Либо RESTRICT - запретить удалять id таблицы table_2<br>
Либо CASCADE -  при удалении id таблицы table_2, удалить соответствующие записи<br>
Ограничение с именем positive_field<br>
Значения в столбце field_3 должны быть положительными<br></p><pre><code><dfn>CREATE TABLE</dfn> table_1(
  id <dfn>PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100) <dfn>UNIQUE NOT NULL</dfn>, 
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>,
  field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id)
  <dfn>ON DELETE RESTRICT</dfn>
  <dfn>CONSTRAINT</dfn> positive_field
  <dfn>CHEK</dfn> (field_3 >= 0)
);</code></pre><p>Уникальный идентификатор состоит из двух столбцов</p><pre><code><dfn>CREATE TABLE</dfn> table_1(
  field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id),
  field_table_3_id <dfn>INT REFERENCES</dfn> table_3(id),
  quantity <dfn>INT</dfn>,
  <dfn>PRIMARY KEY</dfn>(field_table_2_id, field_table_3_id)
);</code></pre><p><dfn>ALTER</dfn> - изменяет объект
Изменить таблицу table, добавить столбец field_4 с типом BOOLEAN</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>ADD COLUMN</dfn> field_4 <dfn>BOOLEAN</dfn>;</code><br></pre><p>Изменить таблицу table, удалить столбец field_4</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>DROP COLUMN</dfn> field_4;</code><br></pre><p>Изменить таблицу table, переименовать столбец field_4 в field_5</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>RENAME COLUMN</dfn> field_4 <dfn>TO</dfn> field_5;</code><br></pre><p>Изменить таблицу table, переименовать в another_table</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>RENAME TO</dfn> another_table;</code><br>     </pre><p><dfn>DROP</dfn> - удаляет объект</p><code><dfn>DROP TABLE</dfn> table </code><p>Скрипт создания таблицы:</p><pre><code><dfn>DROP TABLE IF EXISTS</dfn> table;
<dfn>CREATE TABLE</dfn> table(
  id <dfn>SERIAL PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);</code><br></pre><p><dfn>BACKUP</dfn> - резервное копирование</p><pre><code><dfn>BACKUP DATABASE</dfn> testDB
<dfn>TO DISK</dfn> = 'D:\backups\testDB.bak'; 
</code></pre></details><details><summary>Операторы манипуляции данными (Data Manipulation Language, DML)</summary><details><summary>SELECT</summary><p><dfn>SELECT</dfn> - выбирает данные, удовлетворяющие заданным условиям, </p><code><dfn>SELECT * FROM</dfn> table</code><p>Для примера используем таблицу table со столбцами field_1, field_2 и т.д.
У каждого столбца свои значения value_1, value_2, value_3 и т.д.
Выбираю столбец (field_1) и столбец (field_2) из таблицы (table)</p><pre><code><dfn>SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table;</code></pre><p>Ключевое слово AS назначает псевдоним f1 столбцу field_1</p><pre><code><dfn>SELECT</dfn> field_1 <dfn>AS</dfn> f1
<dfn>FROM</dfn> table;</code></pre><p>Выбрать только уникальные значения столбца field_1</p><pre><code><dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
<dfn>FROM</dfn> table;</code></pre><p>Выбрать первых 10 уникальных значений столбца field_1</p><pre><code><dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
<dfn>FROM</dfn> table
<dfn>LIMIT</dfn> 10;</code></pre><p>Выбрать из таблицы table все строки со значением value в столбце field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2 = 'value';</code></pre><p>Ключевое слово WHERE и фильтр field_2 = 'value'</p><pre>Используем в <dfn>WHERE</dfn>:
  =         Равно
  <>, !=    Неравно
  >         Больше
  >=        Больше или равно
  <         Меньше
  <=        Меньше или равно
  BETWEEN   Значение в диапозоне
  IN        Значение в списке
  LIKE      Соответствие шаблону
  AND       Логическое И
  OR        Логическое ИЛИ
  NOT       Логическое НЕ
</pre><p>Выбрать из таблицы table все строки со значениями от value_1 по value_2 в столбце field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>BETWEEN</dfn> value_1 AND value_2;
</code></pre><p>Выбрать из таблицы table все строки со значениями по списку IN из столбца field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>IN</dfn> (value_1, value_2, value_3);
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбе field_2 значение содержит value</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>LIKE</dfn> '%value%';</code></pre><p>Спец.символы в шаблонах LIKE:<br>
<dfn>%</dfn> - любое количество символов (можно и без символов)<br>
<dfn>_</dfn> - ровно один символ
</p><p>Return all customers starting with "a", "b", "c", "d", "e" or "f":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[a-f]%';
</code></pre><p>Return all customers starting with either "b", "s", or "p":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[bsp]%';
</code></pre><p>Return all customers starting with NOT either "b", "s", or "p":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> City <dfn>LIKE</dfn> '[!bsp]%';
</code></pre><p>Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>AND</dfn> field_2 = value_2;
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 либо в столбце field_2 значение value_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>OR</dfn> field_2 = value_2;
</code></pre><p>Выбрать из таблицы table все строки со значениями вне списка IN из столбца field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>NOT IN</dfn> (value_1, value_2, value_3);
</code></pre><p>Порядок сортировки в ORDER BY:<br>
<dfn>ASC</dfn> (ascending) - сортировка по возрастанию (по умолчанию)<br>
<dfn>DESC</dfn> (descending) - сортировка по убыванию<br>
</p><p>Выбрать из таблицы table все строки и отсортировать их по столбцу field_3
Сортировка данных по столбцу field_3, по умолчанию это ASC</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3</code></pre><p>Сортировка данных по столбцу field_3 по убыванию</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 и отсортировать по столбцу field_3 по убыванию</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
</code></pre><p>Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2 и отсортировать по столбцу field_3 по убыванию и вывести первые пять строк</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>AND</dfn> field_2 = value_2
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>
<dfn>LIMIT</dfn> 5;
</code></pre><p>Выбрать из таблицы table все строки и отсортировать по двум столбцам</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3, field_2;
</code></pre><p>Выбрать из таблицы table столбец field_1 строки в котором не имеют значений</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NULL</dfn>; 
</code></pre><p>Выбрать из таблицы table столбец field_1 строки в котором имеют значения</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NOT</dfn> <dfn>NULL</dfn>;
</code></pre><p>The EXISTS operator is used to test for the existence of any record in a subquery.
The EXISTS operator returns TRUE if the subquery returns one or more records.</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> <dfn>EXISTS</dfn>
(<dfn>SELECT</dfn> field_2
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition); 
</code></pre><p>ANY means that the condition will be true if the operation is true for any of the values in the range.</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = <dfn>ANY</dfn>
(<dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition);
</code></pre><p>ALL means that the condition will be true only if the operation is true for all values in the range.</p><pre><code><dfn>SELECT</dfn> <dfn>ALL</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition;code.
<dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = <dfn>ALL</dfn>
(<dfn>SELECT</dfn> field_2
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition);
</code></pre><p>Copy all columns into a new table</p><pre><code><dfn>SELECT</dfn> *
<dfn>INTO</dfn> newtable [IN externaldb]
<dfn>FROM</dfn> oldtable
<dfn>WHERE</dfn> condition;
</code></pre><p>The following SQL statement uses the IN clause to copy the table into a new table in another database</p><pre><code><dfn>SELECT</dfn> *
<dfn>INTO</dfn> CustomersBackup2017
<dfn>IN</dfn> 'Backup.mdb'
<dfn>FROM</dfn> Customers;
</code></pre><p>The following SQL statement copies only a few columns into a new table</p><pre><code><dfn>SELECT</dfn> CustomerName, ContactName
<dfn>INTO</dfn> CustomersBackup2017
<dfn>FROM</dfn> Customers;</code></pre><br><p><dfn>Агрегатные функции:</dfn>
<br>
<dfn>COUNT</dfn> - Возвращает количество строк источника записей
Считает количество записей в таблице table</p><pre><code><dfn>SELECT</dfn> <dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table</code></pre><p>Считает количество записей в столбцe field_2 таблицы table</p><pre><code><dfn>SELECT</dfn> <dfn>COUNT</dfn>(field_2)
<dfn>FROM</dfn> table</code></pre><p>Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам и посчитать сколько записей каждого вида</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
</code></pre><p>Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать сколько записей каждого вида в столбце field_3 и вывести в новом столбе field_3</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(field_2) AS field_3
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br><p><dfn>SUM</dfn> - Возвращает сумму значений в указанном столбце.
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать сколько записей каждого вида и суммировать значения в столбце field_3 соответствующих сгруппированным видам</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(*),
<dfn>SUM</dfn>(field_3)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br>  <p><dfn>AVG</dfn> - Возвращает среднее значение в указанном столбце.
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать среднее значение по каждому виду в столбце field_3.
Среднее расчитывается со знаками после запятой.</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>AVG</dfn>(field_3) 
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
</code></pre><p>Посчитать среднее без знака после запятой</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>SUM</dfn>(field_3)/<dfn>COUNT</dfn>(*)
<dfn>AS</dfn> average 
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br><p><dfn>MIN</dfn> - Возвращает минимальное значение в указанном столбце
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
определить минимальное и максимальное значение каждого вида в столбце field_3, вывести столбец field_2 
с групированными значениями, столбец минимальных и столбец максимальных значений каждого вида,
отсортировать по убыванию по столбцу максимальных значений</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>MIN</dfn>(field_3),
<dfn>MAX</dfn>(field_3)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
<dfn>ORDER BY MAX</dfn>(field_3) <dfn>DESC</dfn></code></pre><br><p><dfn>MAX</dfn> - Возвращает максимальное значение в указанном столбцe.
Считает все функции в таблице table</p><pre><code><dfn>SELECT COUNT</dfn>(*),
<dfn>MIN</dfn>(field_2),
<dfn>MAX</dfn>(field_2),
<dfn>SUM</dfn>(field_2),
<dfn>AVG</dfn>(field_2)
<dfn>FROM</dfn> table</code></pre><br><p><dfn>LENGTH()</dfn> - возвращает длину строки</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE LENGTH</dfn>(field_2) > 15;
</code></pre><p>Вывести id строк, в которых значение temperature больше temperature предыдущего дня </p><pre><code><dfn>SELECT</dfn> current_day.id
<dfn>FROM</dfn> Weather <dfn>AS</dfn> current_day
<dfn>WHERE EXISTS</dfn> (
  <dfn>SELECT</dfn> 1
  <dfn>FROM</dfn> Weather <dfn>AS</dfn> yesterday
  <dfn>WHERE</dfn> current_day.temperature > yesterday.temperature
  <dfn>AND</dfn> current_day.recordDate = yesterday.recordDate + 1
);</code></pre><br><p><dfn>Подзапросы (subqueries)</dfn>:<br>
Сначала выполняются подзапросы.
Выбрать из таблицы table все строки со значением value_3 в столбце field_1,
отсортировать по видам в столбце field_2, посчитать количество строк по каждому виду,
отсортировать виды, у которых количество строк больше 10.
HAVING работает с результатами группировки</p><pre><code><dfn>SELECT</dfn> field_2, <dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>GROUP BY</dfn> field_2
<dfn>HAVING COUNT</dfn>(*) > 10
</code></pre><p>Выбрать столбцы field_2 и field_3 из таблицы table и выбрать максимальное значение столбца field_3 таблицы table</p><pre><code><dfn>SELECT</dfn> field_2, field_3
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_3 = (
  <dfn>SELECT</dfn> <dfn>MAX</dfn>(field_3) 
  <dfn>FROM</dfn> table)
</code></pre><p>Выбрать столбцы field_2 и field_3 из таблицы table_1 и отобрать строки, id которых есть в столбце field_table_1_id таблицы table_2</p><pre><code><dfn>SELECT</dfn> field_2, field_3
<dfn>FROM</dfn> table_1
<dfn>WHERE</dfn> id <dfn>IN</dfn> (
  <dfn>SELECT</dfn> field_table_1_id 
  <dfn>FROM</dfn> table_2)
</code></pre><p>Выбрать значения id таблицы table_1 у которых в столбце field_3 значение value_1,
увеличить значения столбца field_2 на 500 в строках, 
у которых значение в столбце field_table_1_id равно значениям отобранных id</p><pre><code><dfn>UPDATE</dfn> table_2
<dfn>SET</dfn> field_2 = field_2 + 500
<dfn>WHERE</dfn> field_table_1_id = (
  <dfn>SELECT</dfn> id 
  <dfn>FROM</dfn> table_1
  <dfn>WHERE</dfn> field_3 = value_1)</code></pre><br><p><dfn>Представления</dfn>:<br>
Представление <dfn>VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.<br>
Данные в представлении не хранятся, представление ссылается на таблицу.<br>
Представление можно создавать из нескольких таблиц.<br>
Используется как обычная таблица.<br>
Применяется для ограничения доступа к данным, сокрытия реализации БД,
для избегания повторять выполнение сложных запросов и составных таблиц.<br>
Удалить представление <dfn>DROP VIEW</dfn></p><pre><code><dfn>CREATE VIEW</dfn> table_v field_1, field_2
<dfn>AS SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table</code></pre><p>Материализованное представление <dfn>MATERIALIZED VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.
Поддерживаются не всеми СУБД.
Данные храняться в представлении.
Представление можно создавать из нескольких таблиц.
Используется как обычная таблица.
Применяется для часто используемых запросом с длительным выполнением.
В случае изменения данных в таблице, на которую ссылается материализованное представление, <br>
выполнить <dfn>REFRESH MATERIALIZED VIEW</dfn> table_v <br>
Удалить материализованное представление <dfn>DROP MATERIALIZED VIEW</dfn></p><pre><code><dfn>CREATE MATERIALIZED VIEW</dfn> table_v field_1, field_2
<dfn>AS SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table</code></pre><br><p><dfn>Индексы</dfn>:<br>
Индексы - повышают производительность выполнения запросов <dfn>SELECT</dfn>.<br>
СУБД применяют индексы при выполнении операторов автоматически.<br>
Создать индекс<br>
Название индекса table_field_idx<br>
Индекс создаётся для столбца field таблицы table<br></p><pre><code><dfn>CREATE INDEX</dfn> table_field_idx
<dfn>ON</dfn> table(field)</code></pre><p>Удаление индекса</p><code><dfn>DROP INDEX</dfn> table_field_idx;</code></details><details><summary>CASE</summary><p>The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement).<br>
So, once a condition is true, it will stop reading and return the result.<br>
If no conditions are true, it returns the value in the ELSE clause.<br>
If there is no ELSE part and no conditions are true, it returns NULL.</p><pre><code><dfn>CASE</dfn>
  <dfn>WHEN</dfn> condition1 <dfn>THEN</dfn> result1
  <dfn>WHEN</dfn> condition2 <dfn>THEN</dfn> result2
  <dfn>WHEN</dfn> conditionN <dfn>THEN</dfn> resultN
  <dfn>ELSE</dfn> result
<dfn>END</dfn>; 
</code></pre></details><details><summary>JOIN</summary><p>Внутренее объединение INNER:<br>
Внутренее объединение - это соединение строк из одной таблицы 
для которых есть соответствующие строки из другой таблицы.<br>
<br>
<dfn>Неявное объединение:</dfn><br>
Выбрать все столбцы из таблицы table_1 и table_2,<br>
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p><pre><code><dfn>SELECT</dfn> * 
<dfn>FROM</dfn> table_1, table_2
<dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id</code></pre><p>либо</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> table_1 
<dfn>CROSS</dfn> <dfn>JOIN</dfn> table_2 
<dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id</code></pre><br><p><dfn>Явное объединение:</dfn><br>
Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p><pre><code><dfn>SELECT</dfn> table_1.field.2, table_2.field_3
<dfn>FROM</dfn> table_1 <dfn>JOIN</dfn> table_2 
<dfn>ON</dfn> table_1.id = table_2.field_table_1_id</code></pre><br><p>Псевдонимы</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><p>либо</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 t1 <dfn>JOIN</dfn> table_2 t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><p>Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2,
отобрать строки где значение в столбце field_2 таблицы table_1 равно value_1
и где значение в столбце field_3 таблицы table_2 равно value_4, отсортировать по столбцу field_2 таблицы table_2</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id
<dfn>WHERE</dfn> t1.field_2 = value_1
<dfn>AND</dfn> t2.field_3 = value_4
<dfn>ORDER BY</dfn> t2.field_2 DESC</code></pre><br><p>Внешнее объединение {[LEFT] | [RIGHT] | [FULL]} OUTER:
Внутренее объединение - это соединение строк из одной таблицы 
для которых нет соответствующих строк из другой таблицы.</p><br><p><dfn>LEFT</dfn> - все строки таблицы слева от ключевого слова <dfn>JOIN</dfn></p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>LEFT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p><dfn>RIGHT</dfn> - все строки таблицы справа от ключевого слова <dfn>JOIN</dfn></p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>RIGHT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p><dfn>FULL</dfn> - все строки обеих таблиц</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>FULL OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p>Перекрёсное объединение CROSS:
Перекрёсное объединение - это соединение строк из обоих таблиц 
по принципу каждая с каждой.</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>CROSS JOIN</dfn> table_2
</code></pre></details><details><summary>INSERT</summary><p><dfn>INSERT</dfn> добавляет новые данные
Вставить в таблицу table значение value_2 в столбец field_1, value_4 в столбец field_2</p><pre><code><dfn>INSERT INTO</dfn> table (field_1, field_2)
<dfn>VALUES</dfn> (value_2, value_4);</code></pre><p>Copy all columns from one table to another table</p><pre><code><dfn>INSERT</dfn> <dfn>INTO</dfn> table2
<dfn>SELECT</dfn> * <dfn>FROM</dfn> table1
<dfn>WHERE</dfn> condition;</code></pre><p>Copy only some columns from one table into another table</p><pre><code><dfn>INSERT</dfn>
<dfn>INTO</dfn> table2 (column1, column2, column3, ...)
<dfn>SELECT</dfn> column1, column2, column3, ...
<dfn>FROM</dfn> table1 <dfn>WHERE</dfn> condition;
</code></pre></details><details><summary>UPDATE</summary><p><dfn>UPDATE</dfn> изменяет существующие данные
Обновить значения value_3 в столбец field_2, value_2 в столбец field_3, в строке с id = 1</p><pre><code><dfn>UPDATE</dfn> table
<dfn>SET</dfn> field_2 = value_3, field_3 = value_2
<dfn>WHERE</dfn> id = 1</code></pre><p>Обновить значения во всех строках где в столбце field_2 значение value_1, 
вставить в столбец field_3 значение value_2</p><pre><code><dfn>UPDATE</dfn> table
<dfn>SET</dfn> field_3 = value_2
<dfn>WHERE</dfn> field_2 = value_1
</code></pre></details><details><summary>DELETE</summary><p><dfn>DELETE</dfn> удаляет данные<br>
Удалить из таблицы table строку с id = 2</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> id = 2</code><p>Удалить из таблицы table строки со значением value_1 в столбце field_2</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> field_2 = value_1</code><p>Удалить из таблицы table все данные</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table</code><p>to delete all data inside a table.</p><code><dfn>TRUNCATE</dfn> <dfn>TABLE</dfn> table;</code></details><details><summary>UNION</summary><p><dfn>UNION</dfn> – объединение:<br>
применяется для объединения результатов двух SQL-запросов
в единую таблицу, состоящую из схожих строк.<br> Оба запроса должны
возвращать одинаковое число столбцов и совместимые типы данных
в соответствующих столбцах!!!</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>UNION</dfn> <dfn>ALL</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details><details><summary>INTERSECT</summary><p><dfn>INTERSECT</dfn> - Пересечение:<br>
Пересечение — множество, состоящее из элементов, которые
одновременно принадлежат всем данным множествам.<br>
<dfn>INTERSECT</dfn>, также как и <dfn>UNION</dfn> обладает ограничением на результат
запросов, которые должны быть совместимы по объединению</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>INTERSECT</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details><details><summary>MINUS или EXCEPT</summary><p><dfn>MINUS или EXCEPT</dfn> - Разность:<br>
Разность двух множеств — это операция, результатом которой
является множество, в которое входят все элементы первого
множества, не входящие во второе множество</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>MINUS</dfn> <span>либо</span> <dfn>EXCEPT</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details></details><details><summary>Операторы определения доступа к данным (Data Control Language, DCL)</summary><p><dfn>GRANT</dfn> - предоставляет пользователю (группе) разрешения на определенные операции с объектом<br>
<dfn>REVOKE</dfn> - отзывает ранее выданные разрешения<br>
<dfn>DENY</dfn> - задает запрет, имеющий приоритет над разрешением<br>
</p></details><details><summary>Операторы управления транзакциями (Transaction Control Language, TCL)</summary><p><dfn>Транзакция</dfn> - последовательность команд SQL, 
которые должны быть выполнены полностью или не выполнены вообще.
<br>
Например перевод денег со счёта на счёт</p><pre><code><dfn>START</dfn> <dfn>TRANSACTION</dfn>;
<dfn>UPDATE</dfn> accounts
<dfn>SET</dfn> balance = balance - 15000
<dfn>WHERE</dfn> account_number = 1234567;
<dfn>UPDATE</dfn> accounts
<dfn>SET</dfn> balance = balance + 15000
<dfn>WHERE</dfn> account_number = 9876543;
</code></pre><p><dfn>COMMIT</dfn> применяет транзакцию, записывает изменения в базу данных<br>
либо<br>
<dfn>ROLLBACK</dfn> откатывает все изменения, сделанные в контексте текущей транзакции<br>
В PostgreSQL <dfn>START TRANSACTION</dfn> и <dfn>AUTOCOMMIT</dfn> включён по умолчанию.<br>
<dfn>SET AUTOCOMMIT</dfn> = value; value может быть 1 (ON) либо 0 (OFF)<br>
<dfn>SAVEPOINT</dfn> - делит транзакцию на более мелкие участки
</p></details></details><details><summary>Rust</summary><a href="https://www.rust-lang.org/ru">Rust</a><p><dfn>Rust</dfn> — мультипарадигменный компилируемый язык программирования общего назначения, сочетающий парадигмы функционального и процедурного программирования с объектной системой, основанной на типажах.<br>
<dfn>Esbuild</dfn> - сборщик для фронта<br>
<dfn>Yew</dfn> - framework for building front-end web apps<br>
<dfn>Percy</dfn> - библиотека для rust web apps<br>
<dfn>Seed</dfn> - Rust framework for creating fast and reliable web apps<br>
<dfn>Sycamore</dfn> - library for creating web apps<br>
<dfn>Leptos</dfn> - full-stack framework for building web applications in Rust with WebAssembly (docs.rs/leptos/latest/leptos/)<br>
<dfn>Stork</dfn> - простая библиотека, основанная на фичах, для рекурсивного сканирования источников в стиле поисковой системы.<br>
<dfn>SWC</dfn> - Speedy Web Compiler - Rust-based platform for the Web<br>
</p><details><summary>Introduction</summary><p><dfn>Cargo</dfn> - система сборки и менеджер пакетов.<br>
<b>cargo new name_folder</b> - создать проект name_folder<br>
<b>cargo build</b> - создать исполняемій файл<br>
<b>cargo run</b> - пересобирает исполняемый файл и запускает его<br>
<b>cargo check</b> - проверяет, что код компелируется, но не создаёт исполняемый файл<br>
<b>cargo build -- release</b> - создаёт исполнфемый файл с оптимизаией, собирает финальную версию.<br>
<br>
<dfn>Упорядочивание кода</dfn>:<br>
- группировка связанных функций<br>
- разделение кода по основным функциональностям (фичам, feature).<br>
<br>
<dfn>Модульная система</dfn>:<br>
- <em>Пакеты</em>: функционал Cargo позволяющий собирать, тестировать и делиться крейтами.<br>
- <em>Крейты</em>: дерево модулей, которое создаёт библиотечный или исполняемый файл.<br>
- <em>Модули и use</em>: позволяют вместе контролировать организацию, область видимости и скрытие путей.<br>
- <em>Пути</em>: способ именования элемента, такого как структура, функция или модуль.<br>
<br>
<dfn>Крейт</dfn> - это наименьший объём кода, который компилятор Rust рассматривает за раз.<br>
<dfn>Бинарный крейт</dfn> - обязательно содержит функцию main.<br>Программа, которую можно скомпелировать в исполняемый файл.<br>
<dfn>Библиотечный крейт</dfn> - не имеет функции main и не компелируется в исполняемый файл.<br> Определяет функциональность для совместного использования другими проектами.<br>
<br>
<em>Корневой модуль крейта</em> - исходный файл.<br>
<em>Пакет</em> - набор из одного или нескольких крейтов, представляющий набор функциональности.<br>
Пакет содержит файл Cargo.toml, в котором описывается как собирать эти крейты.<br>
Пакет может содержать любое количество бинарных крейтов, но не более одного библиотечного крейта.<br>
Пакет должен содержать хотябы один крейт, библиотечный или бинарный.<br>
<br>
<em>По умолчанию</em>:<br>
<b>src/main.rs</b> - это корневой модуль бинарного крейта<br>
<b>src/lib.rs</b> - это корневой модуль библиотечного крейта<br>
Cargo передаёт файлы корневого модуля крейта в rustc для сборки этого крейта.<br>
Пакет может иметь несколько бинарных крейтов, помещая их файлы в каталог src/bin: каждый файл будет отдельным бинарным крейтом, с тем же именем, что и пакет.<br>
Несколько бинарных крейтов помещаются в src/bin.<br>
Пакет включает в себя минимум один бинарный крейт, может содержать несколько бинарных и максимум один библиотечный крейты.<br>
Совокупность пакетов образуют рабочее пространство (workspace)<br>
<br>
<em>Правила</em>:<br>
- При компеляции компилятор сначала ищет корневой модуль крейта (src/lib.rs или src/main.rs)<br>
- В файле корневого модуля крейта можно объявить новые модули; при объявлении mod garden компилятор будет искать код модуля в местах:<br>
- в этом же файле, между фигурных скобок, которые заменяют точку с запятой после mod garden<br>
- в файле src/garden.rs<br>
- в файле src/garden/mod.rs<br>
- Если объявить модуль в файле, например объявить mod vegetables в src/garden.rs, то компилятор будет искать код модуля в каталоге родительского модуля:<br>
- в файле где объявили (garden.rs) сразу после mod vegetables, между фигурных скобок, которые заменяют точку с запятой.<br>
- в файле src/garden/vegetables.rs<br>
- в файле src/garden/vegetables/mod.rs<br>
- Обратиться к коду (к типу) можно используя путь: crate::garden::vegetables::Asparagus. Asparagus - это тип, код которого в модуле vegetables.<br>
- Чтобы сделать модуль общедоступным нужно добавить pub впереди объявления: pub mod.<br>
Чтобы сделать элемент общедоступного модуля общедоступным нужно добавить pub перед его объявлением.<br>
- Ключевое слово use создаёт псевдоним для элемента для уменьшения длинных путей: после use crate::garden::vegetables::Asparagus можно просто писать Asparagus.<br>
<br>
Пример:</p><pre><code>src/main.rs
use crate::garden::vegetables::Asparagus;
pub mod garden;

fn main () {
  let plant = Asparagus {};
  println! (“I’m growing {:?}!”, plant);
}

src/garden.rs
pub mod vegetables;
src/garden/vegetables.rs
<derive Debug></derive>
pub struct Asparagus {}</code></pre><br><p>Код внутри модуля по умолчанию закрытый.<br>
Создать библиотечный крейт restaurant:</p><code><b>cargo new restaurant --lib;</b></code><br><p>Получаем <b>src/lib.rs</b>.<br>
<br>
Модуль размещается внутри фигурных скобок.<br>
Модуль может находиться внутри другого модуля или в отдельном файле.<br>
Файли src/main.rs и src/lib.rs называются корневыми модулями крейта.<br>
Содержимое любого из этих файлов образует модуль с именем crate в корне структуры модулей дерево модулей.</p><table><tbody><tr><td>Crate</td><td>- родитель всего дерева (parent)</td></tr><tr><td>A</td><td>B</td></tr><tr><td>- A и B потомки crate (child)</td><td>- A и B братья (siblings)</td></tr></tbody></table><br><p>Чтобы найти элемент в дереве модулей используем путь:<br>
<dfn>абсолютный путь</dfn> - это полный путь, начинающийся от корневого модуля крейта;<br>
для кода из внешнего крейта абсолютный путьначинается с имени крейта, а для кода из текущего крейта он начинается с литерала crate.<br>
<dfn>относительный путь</dfn> - начинается с текущего модуля и использует ключевые слова <b>self</b>, <b>super</b> или идентификатор в текущем модуле.<br>
Абсолютные и относительные пути состоят из одного или нескольких идентификаторов, разделённых двойными двоеточиями(<b>::</b>).<br>
<br>
Чтобы сделать функцию или структуру приватой нужно поместить её в модуль.<br>
Дочерние модули оборачивают и скрывают детали своей реализации, но могут видеть контекст родителей, в котором они определены.<br>
<br>
Дерево модулей должно быть определено в src/lib.rs, тогда любые общедоступные элементы можно использовать в бинарном крейте, начав пути с имени пакета.<br>
С помощью ключевого слова super можно построить относительные пути, которые начинаются в родительском модуле.<br>
<br>
Rust не позволяет подключать оператором use два элемента с одинаковыми именами из разных родительских модулей.<br>
Идиоматические пути с use</p><pre><code>use std::fmt;
use std::io;
fn function1 () -> fmt::Result {
  //--snip--
}

fn function2 () -> io::Result {
  //--snip--
}

<span>С использованием ключевого слова as:</span>
use std::fmt::Result;
use std::io::Result as IoResult;
fn function1 () -> Result {
  //--snip--
}

fn function2 () -> IoResult <()> {
  //--snip--
}</code></pre><br><p><dfn>Реэкспорт pub use</dfn> - подключаем элемент в область видимости и делаем этот элемент доступным для подключения в других областях видимости.<br>
Добавить внешний пакет rand: в файл Cargo.toml написать rand = “0.8.3”</p><pre><code>use rand::Rng;
fn main () {
  let secret_number = rand::thread_rng().gen_range(1..=100);
}</code></pre><br><p>Чтобы указать несколько элементов, определённых в одном крейте или в том же модуле используем вложенные пути:</p><pre><code>use std::cmp::Ordering;
<span>или</span>
use std::{cmp::Ordering, io};
use std::io;

use::io;
use::io::Write;            
<span>или</span>
use std::io::{self, Write};</code></pre><p>Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу.<br>
<b>main.rs</b> занимается запуском программы, а <b>lib.rs</b> обрабатывает всю логику задачи.<br>
Разделите код программы на два файла <b>main.rs</b> и <b>lib.rs</b>. Перенесите всю логику работы программы в файл <b>lib.rs</b>.<br>
Пока ваша логика синтаксического анализа командной строки мала, она может оставаться в файле <b>main.rs</b>.<br>
Когда логика синтаксического анализа командной строки становится сложной, извлеките её из <b>main.rs</b> и переместите в <b>lib.rs</b>.<br>
Функциональные обязанности, которые остаются в функции main после этого процесса должно быть ограничено следующим:<br>
Вызов логики разбора командной строки со значениями аргументов<br>
Настройка любой другой конфигурации<br>
Вызов функции run в lib.rs<br>
Обработка ошибки, если run возвращает ошибку мы запустим программу с помощью > и именем файла<br>
output.txt в который мы хотим перенаправить стандартный поток вывода.<br>
<b>$ cargo run > output.txt</b><br>
Синтаксис > указывает оболочке записывать содержимое стандартного вывода в output.txt вместо экрана.<br>
<br>
Программирование в функциональном стиле зачастую предполагает использование функций в качестве значений, которые передаются в качестве аргументов, возвращаются из других функций, присваиваются переменным для последующего выполнения и так далее.<br>
<br>
Cargo имеет два основных профиля: профиль dev, используемый Cargo при запуске cargo build, и профиль release, используемый Cargo при запуске cargo build --release.<br>
Добавляя секции [profile.*] для любого профиля, который вы хотите настроить, вы переопределяете любое подмножество параметров по умолчанию.<br>
В Rust также есть особый вид комментариев к документации, который обычно называется комментарием к документации, который генерирует документацию HTML.<br>
<br>
<dfn>Комментарии к документации</dfn> используют три слеша, <b>///</b> вместо двух и поддерживают нотацию Markdown для форматирования текста.<br>
Размещайте комментарии к документации непосредственно перед элементом, который они документируют.<br>
Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив cargo doc.
<br>
авторы библиотек обычно используют в своей документации:<br>
<b>Panics</b>:<br>
Сценарии, в которых документированная функция может вызывать панику.<br>
Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих ситуациях.<br>
<br>
<b>Ошибки</b>:<br>
Если функция возвращает Result, описание типов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных типов ошибок разными способами.<br>
<br>
<b>Безопасность</b>:<br>
Если функция является unsafe для вызова, должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.<br>
Добавление примеров кода в комментарии к документации может помочь продемонстрировать, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск cargo test запустит примеры кода в вашей документации как тесты!<br>
<br>
Стиль комментариев к документам //! добавляет документацию к элементу, содержащему комментарии, а не к элементам, следующим за комментариями.<br>
<br>
По мере развития вашего проекта может возникнуть ситуация, когда библиотечный крейт будет становиться все больше, и вы захотите разделить ваш пакет на несколько библиотечных крейтов.<br>
Cargo предоставляет функциональность под названием workspaces, которая помогает управлять несколькими взаимосвязанными пакетами, которые разрабатываются в тандеме.<br>
<br>
<dfn>Workspace</dfn> - это набор пакетов, которые используют один и тот же Cargo.lock и директорию для хранения результатов компиляции.<br>
Команда cargo install позволяет локально устанавливать и использовать исполняемые крейты.<br>
Она не предназначена для замены системных пакетов; она используется как удобный способ Rust разработчикам устанавливать инструменты, которыми другие разработчики поделились на сайте crates.io.<br>
<br>
Если исполняемый файл доступен через переменную окружения $PATH и назван по шаблону cargo-something, то его можно запускать как субкоманду Cargo cargo something.<br>
Пользовательские команды подобные этой также перечисляются в списке доступных через cargo --list.<br>
<br>
В большинстве современных операционных систем программный код выполняется в виде процесса, причём операционная система способна управлять несколькими процессами сразу.<br>
Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно.<br>
Конструкция, благодаря которой эти независимые части выполняются, называется потоком.<br>
Например, веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.<br>
<br>
Для обеспечения отправки многопоточных сообщений в стандартной библиотеке языка Rust реализованы каналы.<br>
<dfn>Канал в программировании</dfn> - это общепринятый механизм, с помощью которого данные из одного потока отправляются другому потоку.<br>
Канал считается закрытым , если либо передающая, либо принимающая его половина уничтожена.<br>
Мы создаём новый канал, используя функцию mpsc::channel; mpsc означает несколько производителей, один потребитель (multiple producer, single consumer).<br>
Несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке.<br></p><br><img src="./img/rust/Rust132.png" alt=""><img src="./img/rust/Rust133.png" alt=""><img src="./img/rust/Rust134.png" alt=""><img src="./img/rust/Rust135.png" alt=""><img src="./img/rust/Rust136.png" alt=""><img src="./img/rust/Rust137.png" alt=""><img src="./img/rust/Rust138.png" alt=""><img src="./img/rust/Rust139.png" alt=""><img src="./img/rust/Rust140.png" alt=""><img src="./img/rust/Rust141.png" alt=""></details><details><summary>Variable</summary><p>Переменные по умолчаню не изменяемые.<br>
<b>let x</b> - объявление переменной<br>
<b>mut</b> - измеяемый, с константами использовать нельзя<br>
<b>let mut x</b> - объявление изменяемой переменной<br>
<b>const</b> - константа, при объявлении константы обязательно указать тип<br>
<b>const THIS_IS_CONSTANT: U32</b> - объявление константы<br>
Затенение - вторая переменная с тем же именем затеняет первую, присваивая себе любое использование имени переменной до тех пор пока либо она сама не будет затенена, либо область действия не закончится.<br>
<b>let x = 5;</b> - Используя слово let, мы создвём новую переменную. Менять тип переменной нельзя.<br>
<b>let x = x + 1;</b> - Затенение<br>
<b>let x = 5;</b> - привязываем значение к переменной<br>
<b>let y = x;</b> - копируем значение в другую переменную. Оба значения помещаются в стек.<br>
<b>let s1 = String::from(“hello”);</b> - привязываем указатель.<br>Указатель находится в стеке.<br>Указатель указывает на память, в которой хранится содержимое строки, длина и емкость.<br>Содержимое строки хранится в куче.<br>
<b>let s2 = s1;</b> - перемещение. Ссылка (указатель) в переменной s1 на данные в куче не действительна.<br>Указатель только в переменной s2.<br>
<b>let s1 = String::from(“hello”);</b><br>
<b>let s2 = s1.clone();</b> - указатель в стеке перемещается, а содержание строки в куче копируется.<br>
Передача переменной в функцию приведет к перемещению или копированию как и при присваивании значения переменной.<br>
Основная разница в том, что значения копируются, находясь в стеке; и доступны обе переменные с одинаковыми значениями, а при копировании указателя, который ссылается на данные в куче, доступной будет только новая переменная, содержащая указатель.<br> То же самое при передачи в функцию.<br>
<b>&</b> - амперсанд (&String) - это ссылка, которая позволяет ссылаться на некоторое значение, не принимая владение им.<br>
Процесс создания ссылки называется заимствованием.<br>
Чтобы можно было изменять по ссылке:<br></p><pre><code>fn main () {
  <span>изменяемая переменная s</span>
  let mut s = String::from (“hello”);
  
  <span>изменяемая перменная s со ссылкой,</span>
  <span>т.е. изменяемая ссылка на изменяемую перменную.</span>
  change (&mut s);
}</code></pre><br><p>Изменяемая ссылка всегда одна в своей области видимости, никаких других ссылок.<br>
В один момент времени в одной области видимости может существовать либо одна изменяемая ссылочная переменная, либо любое количество неизменяемых ссылочных переменных.<br>
Все ссылки должны быть действительны, т.е. ссылаться на существующие в памяти данные.<br>
<br>
Срез позволяет ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию, без права владения.<br>
<b>iter ()</b> - метод, который возвращает каждый елемент в коллекции.<br>
<b>enumerate ()</b> - оборачивает результат iter и возвращает каждый элемент как часть кортежа.<br>Первый элемент кортежа это индекс, а второй - ссылка на элемент (i, &item).<br></p><code>for (i, &item) in bytes.iter().enumerate()</code><p><dfn>Строковые срезы</dfn> (&str - тип “срез строки”).<br>
Строковый срез - это ссылка на часть строки String и он выглядит так:</p><pre><code>let s = String::from (“hello world”);
let hello = &s[0..5];
let world = &s[6..11];
Срез хранит начальную позицию и длину среза.<br></code></pre><pre><code>let slice = &s[0..2]; одно и тожеlet slice = &s[..2];
let len = s.len();
let slice = &s[3..len]; одно и тожеlet slice = &s[3..];
let slice = &s[0..len]; одно и тожеlet slice = &s[..];</code></pre><p>Строковые литералы - это срезы:</p><code>let s = “Hello world!”;</code><p>s имеет тип &str.<br>
s - указывает на место в бинарном файле программы.<br>
Строковый литерал неизменяемый, потому что тип &str - это не изменяемая ссылка.<br>
Строковый срез может быть параметром:</p><code>fn first (s:&str) -> &str {}</code><p>Срезы могут быть разные:</p><pre><code>let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
assert_eq! (slice, &[2, 3]); - тип среза [i32].</code></pre><p>У каждой ссылки в Rust есть своё время жизни - область кода, на протяжении которого данная ссылка действительна (valid).<br>
Мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены компилятором по-разному.<br>
Rust требует от нас объявлять взаимосвязи посредством обобщённых параметров сроков жизни - чтобы убедиться в том, что во время исполнения все действующие ссылки будут корректными.<br>
Основное предназначение сроков жизни — предотвращать появление так называемых "повисших ссылок" (dangling references), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться.<br>
&i32 - a reference<br>
&'a i32 - a reference with an explicit lifetime<br>
&'a mut i32 - a mutable reference with an explicit lifetime</p><code>fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {</code><p>Сигнатура функции сообщает Rust, что для некоторого времени жизни 'a функция принимает два параметра, оба из которых являются срезами строк, которые живут не меньше, чем время жизни 'a.<br>
Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как минимум столько, сколько длится время жизни 'a. На практике это означает, что время жизни ссылки, возвращаемой функцией longest, равно меньшему времени жизни передаваемых в неё ссылок.<br>
Структуры могут содержать и ссылки, но при этом необходимо добавить аннотацию времени жизни для каждой ссылки в определении структуры.</p><pre><code>struct ImportantExcerpt<'a> {
  part: &'a str,
}</code></pre><p>Как и в случае с обобщенными типами данных мы объявляем имя обобщенного параметра времени жизни внутри угловых скобок после имени структуры, чтобы иметь возможность использовать его внутри определения структуры.<br>
Данная аннотация означает, что экземпляр ImportantExcerpt не может пережить ссылку, которую он содержит в своем none part.<br>
Шаблоны, запрограммированные в анализаторе ссылок языка Rust, называются правилами неявного выведения времени жизни.<br>
Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит компилятор, и, если ваш код попадает в эти случаи, вам не нужно будет указывать время жизни явно.<br>
Времена жизни параметров функции или метода называются временем жизни ввода, а времена жизни возвращаемых значений называются временем жизни вывода.<br>
Три правила применяются к объявлениям fn, а также к блокам impl:<br>
Первое правило заключается в том, что каждый параметр являющийся ссылкой, получает свой собственный параметр времени жизни.<br>
Другими словами, функция с одним параметром получит один параметр времени жизни <b>fn foo<'a> (x: &'a i32)</b>;<br>
функция с двумя аргументами получит два отдельных параметра времени жизни: <b>fn foo <'a, 'b> (x: &'a i32, , y: &'b i32)</b>, и так далее.<br>
Второе правило говорит, что если есть ровно один входной параметр времени жизни, то его время жизни назначается всем выходным параметрам: <b>fn foo<'a> (x: &'a i32) -> &'a i32</b>.<br>
Третье правило о том, что если есть множество входных параметров времени жизни, но один из них является ссылкой <b>&self</b> или <b>&mut self</b>, так как эта функция является методом, то время жизни <b>self</b> назначается временем жизни всем выходным параметрам.<br>
Это третье правило делает методы намного приятнее для чтения и записи, потому что требуется меньше символов.<br>
<b>'static</b> означает, что данная ссылка может жить всю продолжительность работы программы.<br>
Все строковые литералы по умолчанию имеют время жизни 'static:</p><code>let s: &'static str = "I have a static lifetime.";</code><p><dfb>Указатель</dfb> — это общая концепция для переменной, которая содержит адрес участка памяти.<br>
Этот адрес «относится к», или «указывает на» некоторые другие данные.<br>
Наиболее общая разновидность указателя в Rust — это ссылка.<br>
<dfb>Умные указатели</dfb>, с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности.<br>
Cсылки только заимствуют данные, умные указатели часто владеют данными, на которые указывают.<br>
Характерной чертой, которая отличает умный указатель от обычной структуры, является то, что для умных указателей реализованы типажи Deref и Drop.<br>
Наиболее простой умный указатель - это <dfn>box</dfn>, чей тип записывается как <b>Box&lt;T&gt;</b>.<br>
Такие переменные позволяют хранить данные в куче, а не в стеке.<br>
То, что остаётся в стеке, является указателем на данные в куче.<br>
Использовать его чаще всего в следующих ситуациях:<br>
Когда у вас есть тип, размер которого невозможно определить во время компиляции, а вы хотите использовать значение этого типа в контексте, требующем точного размера.<br>
Когда у вас есть большой объем данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут скопированы.<br>
Когда вы хотите получить значение во владение и вас интересует только то, что оно относится к типу, реализующему определённый трейт, а не то, является ли оно значением какого-то конкретного типа.<br>
<dfn>Обычная ссылка</dfn> - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте.<br>
<dfn>Box</dfn>-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других специальных возможностей.<br>
Сравнение числа и ссылки на число не допускается, потому что они различных типов.<br>
Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.<br>
<dfn>Сильные ссылки</dfn> - это то с помощью чего вы можете поделиться владением экземпляра Rc&lt;T&gt;.<br>
Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда экземпляр Rc&lt;T&gt; будет очищен.<br>
Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.<br>
Игнорирование неиспользуемой переменной, начинающейся с символа <b>_</b> в имени.<br>
Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</p><pre><code>fn main() {
  let _x = 5;
  let y = 10;
}</code></pre><p>Синтаксис _x по-прежнему привязывает значение к переменной, тогда как _ не привязывает ничего.<br>
Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</p><pre><code>fn main() {
  let s = Some(String::from("Hello!"));
  if let Some(_s) = s {
    println!("found a string");
  }
  println!("{:?}", s);
}

<span>Использование подчёркивания не привязывает значение</span>
fn main() {
  let s = Some(String::from("Hello!"));
  if let Some(_) = s {
    println!("found a string");
  }
    println!("{:?}", s);
}
</code></pre><p><dfn>Связывание @</dfn><br>
Оператор <b>at (@)</b> позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение шаблону.<br>
мы хотим проверить, что перечисление <b>Message::Hello</b> со значением поля id находится в диапазоне 3..=7.<br>
Но мы также хотим привязать такое значение к переменной id_variable, чтобы использовать его внутри кода данной ветки.<br>
Использование @ для привязывания значения в шаблоне, с одновременной его проверкой</p><pre><code>fn main() {
  enum Message {
    Hello { id: i32 },
  }
  let msg = Message::Hello { id: 5 };
  match msg {
    Message::Hello {
      id: id_variable @ 3..=7,
    } => println!("Found an id in range: {}", id_variable),
    Message::Hello { id: 10..=12 } => {
      println!("Found an id in another range")
    }
    Message::Hello { id } => println!("Found some other id: {}", id),
  }
}
</code></pre></details><details><summary>Type</summary><p>Rust статически типизированный язык.</p><table><caption>Целочисленные типы</caption><thead><tr><th>Длина</th><th>Со знаком</th><th>Без знака</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>128 bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p><em>arch</em> - основное использование - это индекация коллекции.<br>Зависит от архитектуры компьютера 34-bit или 64-bit.<br>
Склярный тип представляет единственное значение.<br>В Rust четыре склярных типа:
<b>целые</b> и <b>вещественные числа</b>, <b>логический тип</b> и <b>символ</b>.<br>
<em>Числовые литералы</em>:<br>
<b>Десятиричный</b> - 98222<br>
<b>Шестнадцатиричный</b> - Oxff<br>
<b>Восьмиричный</b> - 0o77<br>
<b>Двоичный</b> - 0b11110000<br>
<b>Байт (только u8)</b> - b'A'<br>
Типы чисел <b>с плавающей запятой</b> f32 и f64<br>
<b>Логистический тип</b> данных bool: true или false<br>
<b>Символический тип</b> данных char.<br>
Литералы char в одинарных кавычках:</p><pre><code>let c = 'Z';
let z:char = 'Z';</code></pre><br><p><em>Сложные типы данных</em>: кортежи и массивы, могут группировать несколько значений в один тип.<br>
<dfn>Кортеж</dfn>: группировка нескольких значений различного типа в единый комбнированный тип фиксированной длины.<br>
<b>Let tup: (i32, f64, u8) = (500, 6.4, 1);</b><br>
<br>
Дуструктуризация: <b>let (x,y,z) = tup;</b><br>
<br>
Обращение к элементу кортежа по индексу: <b>let five_hundred = tup.0;</b>
<br>
<dfn>unit</dfn> - обозначается ( ) и представляет собой пустое значение или пустой возвращаемый тип.<br>
Игнорирование нескольких частей кортежа</p><pre><code>fn main() {
  let numbers = (2, 4, 8, 16, 32);
  match numbers {
    (first, _, third, _, fifth) => {
      println!("Some numbers: {first}, {third}, {fifth}")
    }
  }
}</code></pre><p>Игнорирование оставшихся частейц значения с помощью <b>.</b><br>
Игнорирование полей структуры Point кроме поля x с помощью <b>..</b></p><pre><code>fn main() {
  struct Point {
    x: i32,
    y: i32,
    z: i32,
  }
let origin = Point { x: 0, y: 0, z: 0 };
  match origin {
    Point { x, .. } => println!("x is {}", x),
  }
}

<span>Сопоставление только первого и последнего значений в кортеже</span>
<span>и игнорирование всех других значений</span>
fn main() {
  let numbers = (2, 4, 8, 16, 32);
  match numbers {
    (first, .., last) => {
      println!("Some numbers: {first}, {last}");
    }
  }
}</code></pre><br><p><dfn>Массивы</dfn>: набор значений одного типа и фиксированной длины.</p><pre><code>let a = [1, 2, 3, 4, 5];
[i32; 5] - тип и длина
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];
<span>получим массив</span>
let a = [3, 3, 3, 3, 3];</code></pre><p>Доступ к элементам массива: <b>let first = a [0];</b>
<dfn>Вектор</dfn> - аналогичный массиву тип коллекции без фиксированной величины.<br>
<dfn>String</dfn> - строковый тип управляет данными, выделенными в куче, и поэтому может хранить объем текста, который во время компиляции не известен.<br>
Типы, размер которых известен во время компиляции, полностью храняться в стеке и быстро копируются.<br>
Для указателей на данные в куче происходит перемещение.<br>
Для создания копии данных в куче происходит клонирование.<br>
За копирование типа отвечает типаж Copy.<br>
Он анотирован для типов хранящихся в стеке.<br>
Типаж Copy не совместим с типажем Drop и типами, которые хранятся в куче.<br>
<dfn>Структура (struct)</dfn> - пользовательский тип данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую группу.<br>
Похоже на атрибуты данных объекта.<br>
Структура, как и кортежи, это способы группировки данных.<br>
Каждая часть данных структуры имеет имя и свой тип, типы могут быть разные.<br>
Каждая пара “имя: тип” называется полем.<br>
Объявление струтуры - это шаблон нашего типа, а экземпляр использует этот шаблон, заполняя его данными.<br></p><pre><code>struct User {
  active: bool,
  username: String,
  email: String,
  sign_in_count: u64,
}

<span>Создание экземпляра структуры User:</span>
let user1 = User {
  email: String::from (“someone@example.com”),
  username: String::from (“someusername123”),
  active: true,
  sign_in_count: 1,
};

<span>Доступ к полю через точку: user1.email</span>
User {
  email: email,
  username: username,
  active: true,
  sign_in_count: 1,
}
<span>тоже самое</span>
User {
  email,
  username,
  active: true,
  sign_in_count: 1,
}</code></pre><p>Синтаксис <b>..</b> указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного экземпляра:</p><pre><code>let user2 = User {
  email: String::from (“another@example.com”),
  ..user1
};</code></pre><p><b>..user1</b> должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в user1.<br>
Кортежные структуры - именованные кортежи:<br>
<b>struct Color (i32, i32, i32);</> - картежная структура.<br>
<b>let black = color (0, 0, 0);</b> - экземпляр типа color.<br>
Экземпляры кортежных структур можно как кортежи деструктурировать и использовать точку с индексом для доступа к значению.<br>
Единично-подобные структуры - структуры, которые не имеют полей. Требуются когда нужно реализовать типаж для типа, но нет данных, которые нужно хранить в типе:<br>
<b>struct AlwaysEqual;</b><br>
По умолчанию фигурные скобки в <b>println!</b> означают использование форматирования, известного как типаж <b>Display</b>.<br>
Структуры не имеют встроенной реализации Display, поэтому можно распечатать в <b>Debug:println! ({:?})</b>.
Макрос <b>dbg!</b> распечатывает значение в формате Debug. Для этого нужно подключить атрибут derive:<br>
<b><derive Debug></derive></b><br>
Структуры создают типы, позволяют хранить связанные данные и давать названия частям данных.<br>
Методы позволяют определить поведение экземпляров структур, а ассоциированные функции привязывают функциональность к вашей структуре, не обращаясь к её экземпляру.<br>
Метод - поведение экземпляра<br>
Ассоциированная функция - поведение структуры<br>
Перечисления (enumerations, enums) дают способ сказать, что значение является одним из возможных наборов значений, структура данных enum.<br>
В любой из вариантов перечисления можно поместить данные:</p><pre><code>enum IpAddr {
  V4(String),
  V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));</code></pre><br><p>Каждый вариант перечисления (V4, V6) - это функция, которая создаёт экземпляр перечисления, т.е. принимает String и возвращает экземпляр типа IpAddr, это функция-конструктор.<br>
В отличии от структуры (struct) перечисление (enum) может иметь разное количество данных в разных типах, можно включать перечисления в другие перечсления.<br></p><pre><code>enum IpAddr {
  V4(u8, u8, u8, u8),
  V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));</code></pre><br><p>С помощью impl блока, мы можем определять методы для перечисления.<br>
Тип Option кодирует сценарий, в котором значение может быть чем-то, а может быть ничем.</p><pre><code>enum Option < T> {
  None,
  Some (T),
}</code></pre><br><p>Нужно познакомиться с методами перечисления <b>Option &lt;T&gt;</b> в документации.<br>
Перечисление <b>Option &lt;T&gt;</b> и его варианты <b>Some</b> и <b>None</b> включены в прелюдию.<br>
Поэтому Option не нужно вводить в область видимости, а Some и None используем без префикса <b>Option::</b>.<br>
Чтобы иметь значение, которое может быть <b>null</b> его тип нужно явно описать с помощью <b>Option &lt;T&gt;</b> и явно обрабатывать случай, когда значение равно null.<br>
Значение может быть равно null только имея тип Option &lt;T&gt;, в остальных случаях (с другими типами) значение всегда not-null.<br>
Если использовать pub перед определением структуры, то это делает структуру публичной, но поля этой структуры остаются приватными.<br>
Чтобы поле структуры стало публичным добавляем pub.<br>
Если сделать перечисление общедоступным pub enum, то все его варианты будут общедоступными.<br>
Коллекция хранит множество однотипных значений в куче, т.е. размер коллекции может быть не известен в момент компиляции, может изменяться в размере во время работы программы.<br>
Каждый вид коллекции имеет свои возможности:<br>
<dfn>Вектор (Vector)</dfn> - сохраняет различное количество последовательно хранящихся значений.<br>
<dfn>Строка (String)</dfn> - последовательность символов.<br>
<dfn>Хеш-таблица (hash map)</dfn> - коллекция, которая позволяет хранить перечень ассоциаций значения с ключом (перечень пар ключ: значение).<br>
Коллекция вектор (vector): Vec &lt;T&gt;<br>
<br>
Создание пустого вектора для хранения значений типа i32:</p><code>let v: Vec< i32> = Vec::new();</code><p>Макрос vec! - создает новый вектор.
новый вектор целочисленного типа i32 со значениями 1, 2, 3</p><pre><code>let v = vec![1, 2, 3];

<span>Создать новый вектор и добавить значения:</span>
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);</code></pre><p>Доступ к элементу вектора:<br>
<b>v.[2]</b> - индекс (нумерация индексов с 0)<br>
<b>v.get(2)</b> - метод get, получаем тип <b>Option<&T></b><br>
При обращении по индексу за пределами вектора, произойдет паника.<br>
При обращении к индексу за пределами вектора через get - вернется None без паники.<br>
Получение неизменяемых ссылок на каждый элемент в векторе:</p><pre><code>let v = vec![100, 32, 57];
for i in &v {
  println!(“{}”, i);
}

<span>Добавление к каждому элементу вектора:</span>
let mut v = vec![100, 32, 57];
for i in &mut v {
  *i += 50;
}</code></pre><p>*i - получение значения переменной i с помощью оператора разыменовывания ссылки *.<br>
Строки (String) реализованы в виде набора байтов.<br>
В Rust есть только один строковый тип в ядре языка - срез строки &str.<br>
Тип String предоставляется стандартной библиотекой.<br>
И String и строковые срезы &str кодируются в UTF-8.<br>
String фактически реализован как обертка вокруг вектора байтов.<br>
СТАНДАРТНУЮ БИБЛИОТЕКУ ВЫУЧИТЬ!!!<br>
Индексирование строк это плохая идея, т.к. не ясно каким должен быть возвращаемый тип такой операции:<br>
байтовым значением (код UTF-8), символом (char), кластером графем или срезом строки.<br>
Коллекция hash map (хеш карта).<br>
Тип HashMap &lt;K, V&gt; хранит ключ типа К на значение типа V.<br>
Организует и хранит данные с помощью функции хеширования.<br>
Как и векторы, HashMap однородны: все ключи должны иметь одинаковый тип и все значения должны иметь одинаковый тип.<br>
По умолчанию HashMap использует функцию хеширования SipHach, который может противостоять Dos-атакам с использованием таблиц siphash.<br>
Обобщённые типы данных generics - это абстрактные подставные типы на место которых возможно поставить какой-либо конкретный тип или другое свойство.<br>
(Option&lt;T>, Vec&lt;T&gt;, HashMap&lt;K, V&gt;, Result&lt;T, E&gt;).<br>
Мы используем обобщённые типы данных для объявления функций или структур, которые затем можно использовать с различными конкретными типами данных.<br>
<b>fn largest&lt;T&gt;(list: &[T]) -> &T {}</b><br>
Объявление читается так: функция largest является обобщённой по типу T.<br>
Эта функция имеет один параметр с именем list, который является срезом значений с типом данных T.<br>
Функция largest возвращает значение этого же типа T.<br>
Синтаксис использования обобщённых типов в определении структуры такой же как у функции.<br>
Объявляем имена типов параметров внутри треугольных скобок сразу после названия структуры.<br>
Мы также можем определить структуры, использующие обобщённые типы в одном или нескольких своих полях, с помощью синтаксиса <b><></b>.<br>
Поля структуры с обопщенным типом имеют одинаковый тип, каким бы он не являлся.<br>
Чтобы определить структуру Point, где оба значения x и y являются обобщёнными, но различными типами, можно использовать несколько параметров обобщённого типа.</p><pre><code>struct Point< T, U> {
  x: T,
  y: U,
}</code></pre><br><p>Определение методов может использовать обобщённые типы: <b>impl&lt;T&gt; Point&lt;T&gt; {}</b><br>
Мономорфизация — это процесс превращения обобщённого кода в конкретный код путём подстановки конкретных типов, использующихся при компиляции.<br>
<dfn>&lt;Т&gt;</dfn> - обопщенный тип.<br>
Bы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей внутренней структуры, используя pub use.<br>
<dfn>Box&lt;T&gt;</dfn> для распределения значений в куче (памяти).<br>
<dfn>Rc&lt;T&gt;</dfn> тип счётчика ссылок, который допускает множественное владение.<br>
Типы Ref&lt;T&gt; и RefMut&lt;T&gt;, доступ к которым осуществляется через тип RefCell&lt;T&gt;, который обеспечивает правила заимствования во время выполнения вместо времени компиляции.<br>
Тип Box&lt;T&gt; является умным указателем, поскольку он реализует трейт <b>Deref</b>, который позволяет обрабатывать значения Box&lt;T&gt; как ссылки. Когда значение Box&lt;T&gt; выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря реализации типажа <b>Drop</b>.<br>
Устанавливаем y как экземпляр Box&lt;T&gt;, указывающий на скопированное значение x, а не как ссылку, указывающую на значение x.<br>
Без типажа Deref компилятор может только разыменовывать & ссылки.<br>Метод deref даёт компилятору возможность принимать значение любого типа, реализующего Deref и вызывать метод deref чтобы получить ссылку &, которую он знает, как разыменовывать.<br>
Когда типаж Deref определён для задействованных типов, Rust проанализирует типы и будет использовать Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра.<br>
Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх случаях:<br>
Из типа &T в тип &U когда верно T: Deref&lt;Target=U&gt;<br>
Из типа &mut T в тип &mut U когда верно T: DerefMut&lt;Target=U&gt;<br>
Из типа &mut T в тип &U когда верно T: Deref&lt;Target=U&gt;<br>
Rust также приводит изменяемую ссылку к неизменяемой.<br>
Но обратное не представляется возможным:<br>
неизменяемые ссылки никогда не приводятся к изменяемым ссылкам.<br>
Drop позволяет регулировать, что происходит, когда значение вот-вот выйдет из области видимости.<br>
Тело функции drop - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда экземпляр вашего типа выйдет из области видимости.<br>
Rust автоматически вызывал функцию drop в момент выхода наших экземпляров из области видимости, тем самым выполнив заданный нами в drop код.<br>
Переменные ликвидируются в обратном порядке их создания.<br>
Rust не позволяет вызвать метод типажа Drop вручную;<br> вместо этого вы должны вызвать функцию <b>std::mem::drop</b> предоставляемую стандартной библиотекой, если хотите принудительно удалить значение до конца области видимости.<br>
Тип Rc&lt;T&gt; отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё.<br>
Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.<br>
Тип Rc&lt;T&gt; используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время компиляции, какая из частей завершит использование данных последней.<br>
Обратите внимание, что Rc&lt;T&gt; используется только в одно поточных сценариях.<br>
Вызов <b>Rc::clone</b> только увеличивает счётчик ссылок, что не занимает много времени.<br>
Внутренняя изменяемость - это паттерн проектирования Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования.<br>
RefCell&lt;T&gt; предоставляет единоличное владение данными, которые он содержит.<br>
С помощью ссылок и типа Box&lt;T&gt; инварианты правил заимствования применяются на этапе компиляции.<br>
С помощью RefCell&lt;T&gt; они применяются во время работы программы.<br>
Тип RefCell&lt;T&gt; полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но компилятор не может понять и гарантировать этого.<br>
Вот список причин выбора типов Box&lt;T&gt;, Rc&lt;T&gt; или RefCell&lt;T&gt;:<br>
Тип <b>Rc&lt;T&gt;</b> разрешает множественное владение одними и теми же данными; типы Box&lt;T&gt; и RefCell&lt;T&gt; разрешают иметь единственных владельцев.<br>
Тип <b>Box&lt;T&gt;</b> разрешает неизменяемые или изменяемые владения, проверенные при компиляции;
тип <b>Rc&lt;T&gt;</b> разрешает только неизменяемые владения, проверенные при компиляции;<br>
тип <b>RefCell&lt;T&gt;</b> разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.<br>
Поскольку RefCell&lt;T&gt; разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри RefCell&lt;T&gt; даже если RefCell&lt;T&gt; является неизменным.<br>
Изменение значения внутри неизменного значения является шаблоном внутренней изменяемости (interior mutability).<br>
Инсценировочные (Mock) объекты - это особый тип тестовых дублёров, которые сохраняют данные происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.<br>
Вызвать образование ссылочной зацикленности не просто, но и не невозможно.<br>
Если у вас есть значения RefCell&lt;T&gt; которые содержат значения Rc&lt;T&gt; или аналогичные вложенные комбинации типов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте зацикленность.<br>
Тип <b>Box&lt;T&gt;</b> имеет известный размер и указывает на данные размещённые в куче.<br>
Тип <b>Rc&lt;T&gt;</b> отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев.<br>
Тип <b>RefCell&lt;T&gt;</b> с его внутренней изменяемостью предоставляет тип, который можно использовать при необходимости неизменного типа, но необходимости изменить внутреннее значение этого типа; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время компиляции.<br>
<dfn>Mutex</dfn> - это сокращение от взаимное исключение (mutual exclusion), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой момент времени.<br>
Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая блокировку (lock) мьютекса.<br>
<dfn>Блокировка</dfn> - это структура данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным.<br>
Поэтому мьютекс описывается как объект защищающий данные, которые он хранит через систему блокировки.<br>
<b>Mutex&lt;T&gt;</b> является умным указателем, точнее, вызов lock возвращает умный указатель, называемый <b>MutexGuard</b>, обёрнутый в <b>LockResult</b>, который мы обработали с помощью вызова unwrap.<br>
Умный указатель типа MutexGuard реализует типаж Deref для указания на внутренние данные;<br>
умный указатель также имеет реализацию типажа Drop, автоматически снимающего блокировку, когда MutexGuard выходит из области видимости.<br>
Arc&lt;T&gt; является типом аналогичным типу Rc&lt;T&gt;, который безопасен для использования в ситуациях многопоточности.<br>
Буква А означает атомарное, что означает тип ссылка подсчитываемая атомарно.<br>
<dfn>Atomics</dfn> - работают как примитивные типы, но безопасны для совместного использования между потоками: дополнительную информацию смотрите в документации стандартной библиотеки для <b>std::sync::atomic</b>.
Cтандартные типы библиотек не реализованы для использования вместе с типом Arc&lt;T&gt; по умолчанию.<br>
Причина в том, что безопасность потоков сопровождается снижением производительности.<br>
типы Arc&lt;T&gt; и Rc&lt;T&gt; имеют одинаковый API.<br>
Mutex&lt;T&gt; сопряжён с риском создания взаимных блокировок (deadlocks).<br>
Это происходит, когда операции необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно.<br>
В язык встроены две концепции многопоточности: <b>std::marker</b> типажи <b>Sync</b> и <b>Send</b>.<br>
Маркерный типаж Send указывает, что владение типом реализующим Send, может передаваться между потоками.<br>
Почти каждый тип Rust является типом Send, но есть некоторые исключения, вроде Rc&lt;T&gt;:<br>
он не может быть Send, потому что если вы клонировали значение Rc&lt;T&gt;<br>
и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно.<br>
По этой причине Rc&lt;T&gt; реализован для использования в однопоточных ситуациях, когда вы не хотите платить за снижение производительности.<br>
Маркерный типаж Sync указывает, что на тип реализующий Sync можно безопасно ссылаться из нескольких потоков.<br>
Другими словами, любой тип T является типом Sync, если &T (ссылка на T) является типом Send, что означает что ссылку можно безопасно отправить в другой поток.<br>
Подобно Send, примитивные типы являются типом Sync, а типы полностью скомбинированные из типов Sync, также являются Sync типом.<br>
Умный указатель Rc&lt;T&gt; не является Sync типом по тем же причинам, по которым он не является Send.<br>
Тип RefCell&lt;T&gt; и семейство связанных типов Cell&lt;T&gt; не являются Sync.<br>
Этот код позволяет нам разбивать сложные типы на составные части, чтобы мы могли использовать интересующие нас значения по отдельности.<br>
Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений, таких как как значение из каждого поля в структуре, по отдельности друг друга.<br>
<dfn>Ассоциированные типы</dfn> (Associated types) связывают заполнитель типа с типажом, таким образом, что объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах.<br>
С ассоциированными типами не нужно аннотировать типы, потому что мы не можем реализовать типаж у типа несколько раз.<br>
Тип по умолчанию указывается при объявлении обобщённого типа с помощью синтаксиса &lt;PlaceholderType=ConcreteType&gt;.<br>
Rust не позволяет создавать собственные операторы или перегружать произвольные операторы.<br>
Но можно перегрузить перечисленные операции и соответствующие им типажи из <b>std::ops</b> путём реализации типажей, связанных с этими операторами.<br></p><pre><code><span>Integer addition</span>
assert!(1u32 + 2u32 == 3u32);

<span>Integer subtraction</span>
assert!(1i32 - 2 == -1);
assert!(1i32 - 2 == -1); 
assert!(3 * 50 == 150);
assert!(9.6f32 / 3.2f32 == 3.0);
assert!(24 % 5 == 4);

<span>Short-circuiting boolean logic</span>
assert!(true && false == false);
assert!(true || false == true);
assert!(!true == false);
</code></pre></details><details><summary>Function</summary><p>fn - объявление функции<br>
fn main ( ) { } - точка входа в программу<br>
fn another_function ( ); - определение функции<br>
another_function ( ); - вызов функции<br>
another_function (5); - вызов функции с передачей значения “5” как аргумент (параметр) функции.<br>
Объявлять тип каждого параметра сигнатуры функции обязательно:<br></p><code>fn another_function (valu: i32, label: char) { };</code><p>Методы как и функции:<br>
- ключевое слово fn<br>
- имеют параметры и возвращаемое значение<br>
- содержат код, который выполняется при вызове<br>
Методы - это функции, которые определяются в контексте структуры.<br>
Первый параметр метода всегда self - экземпляр структуры, на который вызывается метод.<br></p><pre><code>impl Rectangle {
  fn area (&self) -> u32 (
    self.width * self.height
  }
}</code></pre><p>Создание блока <dfn>impl</dfn> (implementation - реализация) определяет функцию area в контексте типа Rectangle.<br>
rect1.area() - вызов метода area на экземпляре rect1 типа Rectangle.<br>
Всё, что хотим сделать с экземпляром типа, помещаем в один блок impl.<br>
Методу можно давать имя такое же как и у поля структуры.<br>
Отличие в обращении - это наличие круглых скобок у метода.<br>
Как правило, метод с таким же именем как у поля возвращает значение этого поля.<br>
Такие методы называются геттерами.<br>
Все функции определенные в блоке impl, называются ассоциированными функциями, потому что они ассоциированы с типом, указанным после ключевого слова impl.<br>
Можно определить ассоциированные функции без self в качестве первого параметра.<br>
Такие функции не являются методами и их часто используют для конструкторов, возвращающих новый экземпляр структуры.<br>
Вызвать ассоциированную функцию можно через ::.<br>
<dfn>::</dfn> - это синтаксис для обращения к ассоциированным функциям и к пространству имен, созданое модулем.<br>
<dfn>Ассоциированная функция</dfn> - в блоке impl<br>
<dfn>Ассоциированная функция</dfn> в контексте структуры - метод<br>
<dfn>Ассоциированная функция</dfn> без параметра self - конструктор<br>
<dfn>Замыкания</dfn> - конструкции, подобные функциям, которые можно помещать в переменные<br>
<dfn>Замыкания</dfn>: анонимные функции, которые запечатлевают ("захватывают") своё окружение.<br>
<dfn>Замыкания</dfn> в Rust - это анонимные функции, которые можно сохранять в переменных или передавать в качестве аргументов другим функциям.<br>
В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены.<br></p><pre><code>fn giveaway(&self, user_preference: Option< ShirtColor>) -> ShirtColor {
  user_preference.unwrap_or_else(|| self.most_stocked())
}</code></pre><p><b>|| self.most_stocked()</b> - замыкание<br>
|| - между вертикальными линиями указываются параметры<br>
self.most_stocked() - тело замыкания<br>
Замыкания, как правило, короткие и уместны только в узком контексте, а не в произвольном сценарии.<br>
Определение функции и замыкания:<br>
<b>fn add_one_v1 (x: u32) -> u32 { x + 1 }</b> - функция<br>
<b>let add_one_v2 = |x: u32| -> u32 { x + 1 };</b> - замыкание с полной аннотацией<br>
<b>let add_one_v3 = |x|</b><br>
<b>{ x + 1 };</b> - замыкание без аннотации типа<br>
<b>let add_one_v4 = |x|</b><br>
<b>x + 1 ;</b> - в теле замыкания одна операция, скобки не нужны.<br>
Строки add_one_v3 и add_one_v4 требуют, чтобы замыкания были вычислены до компиляции, поскольку типы будут выведены из их использования.<br>
Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать параметры:<br> заимствование неизменяемых, заимствование изменяемых и получение владения.<br>
Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.<br>
Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать ключевое слово move перед списком параметров.<br>
Замыканиям автоматически присваивается реализация одного, двух или всех трёх из нижеперечисленных трейтов Fn, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:<br>
<dfn>FnOnce</dfn> применяется к замыканиям, которые могут быть вызваны один раз.<br>
Все замыкания реализуют по крайней мере этот трейт, потому что все замыкания могут быть вызваны.<br>
Замыкание, которое перемещает захваченные значения из своего тела, реализует только FnOnce и ни один из других признаков Fn, потому что оно может быть вызвано только один раз.<br>
<dfn>FnMut</dfn> применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но
могут изменять захваченные значения.<br>
Такие замыкания могут вызываться более одного раза.<br>
<dfn>Fn</dfn> применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не модифицируют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения.<br>
Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.<br>
<dfn>Трейты Fn</dfn> важны при определении или использовании функций или типов, использующих замыкания.<br>
<dfn>Итераторы</dfn> — способ обработки последовательности элементов.<br>
Использование паттерна Итератор помогает при необходимости поочерёдного выполнения какой-либо операции над элементами последовательности.<br>
Итератор отвечает за логику перебора элементов и определение момента завершения последовательности.<br>
Все итераторы реализуют типаж Iterator, который определён в стандартной библиотеке.<br>
Метод iter создаёт итератор по неизменяемым ссылкам.<br>
Если мы хотим создать итератор, который становится владельцем v1 и возвращает принадлежащие ему значения, мы можем вызвать into_iter вместо iter.<br>
Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать iter_mut вместо iter.<br>
Методы, вызывающие next, называются потребляющими адаптерами, поскольку их вызов потребляет итератор.<br>
<dfn>Адаптеры итераторов</dfn> - это методы, определённые для трейта Iterator, которые не потребляют итератор.<br>
Вместо этого они создают различные итераторы, изменяя некоторые аспекты исходного итератора.<br>
В Rust итераторы ленивые (lazy), то есть они не делают ничего, пока вы не вызовете специальные методы, потребляющие итератор, чтобы задействовать его.<br>
Вы можете выстроить цепочку из нескольких вызовов адаптеров итератора для выполнения сложных действий в удобочитаемом виде.<br>
Но поскольку все итераторы являются "ленивыми", для получения результатов вызовов адаптеров итератора необходимо вызвать один из методов потребляющего адаптера.<br>
<dfn>Разворачивание</dfn> - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.<br>
Реализации замыканий <b>(closures)</b> и итераторов <b>(iterators)</b> таковы, что нет влияния на производительность выполнения кода.<br>
Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).<br>
Чтобы создать новый поток, мы вызываем функцию <b>thread::spawn</b> и передаём ей замыкание, содержащее код, который мы хотим запустить в новом потоке.<br>
Вызовы <b>thread::sleep</b> заставляют поток на короткое время останавливать своё выполнение, позволяя
выполняться другим потокам.<br>
Тип возвращаемого значения <b>thread::spawn — JoinHandle</b>.<br>
<dfn>JoinHandle</dfn> — это владеющее значение, которое, при вызове метода join, будет ждать завершения своего потока.<br>
Мы будем часто использовать ключевое слово <b>move</b> с замыканиями, переданными в thread::spawn, потому что замыкание будет затем владеть значениями, взятыми из окружающего кода, а значит передаст владение этими значениями от одного потока к другому.<br>
Добавляя ключевое слово move перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Rust вывести необходимость заимствования значения.<br>
<br>
Игнорирование значений в шаблоне.<br>
Есть несколько способов игнорировать целые значения или части значений в шаблоне:<br>
используя шаблон <b>_</b> внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя <b>..</b>, чтобы игнорировать оставшиеся части значения.<br>
Игнорирование всего значения с помощью шаблона <b>_</b><br>
Использование <b>_</b> в сигнатуре функции<br></p><pre><code>fn foo(_: i32, y: i32) {
  println!("This code only uses the y parameter: {}", y);
}
fn main() {
  foo(3, 4);
}</code></pre><p>Игнорирование параметра функции может быть особенно полезно в случаях когда, например, вы реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в одном из параметров.<br>
Игнорирование частей значения с помощью вложенного <b>_</b><br>
Использование подчёркивания в шаблонах, соответствующих вариантам <b>Some</b>, когда нам не нужно использовать значение внутри Some<br></p><pre><code>fn main() {
  let mut setting_value = Some(5);
  let new_setting_value = Some(10);
  match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
      println!("Can't overwrite an existing customized value");
    }
    _ => {
      setting_value = new_setting_value;
    }
  }
  println!("setting is {:?}", setting_value);
}</code></pre><p>Бизнес-требования заключаются в том, что пользователь не должен иметь права перезаписывать существующую настройку параметра, но может сбросить параметр и присвоить ему значение, если он в данный момент не установлен.</p></details><details><summary>Operator</summary><p><dfn>Операторы</dfn> - это инструкции, которые выполняют действие и не возвращают значение.<br>
<dfn>Выражения</dfn> - вычесляют результирующее значение.<br>
<b>{ }</b> - создают область видимости (scope).<br>
<b>let</b> - это оператор<br>
<b>fn</b> - это оператор<br>
<b>let y = 6;</b> - оператор<br>
<b>6</b> - выражение<br>
<b>;</b> - окончание оператора<br>
<b>fn main ( ) {let y = 6;}</b> - оператор<br>
<b>{let y = 6;}</b> - выражение<br></p><p>Вызов функции, вызов макроса - это выражение.<br>
Если добавить точку с запятой в конец выражения, то оно превратится в оператор и не вернет значение.<br>
<b>fn five ( ) -> i32 {5}</b> - функция возвращает значение.<br>
<b>-> i32 {5}</b> - объявляет тип возвращаемого значения.<br>
<b>//</b> - комментарий только однострочный<br>
Область видимости - это диапозон внутри программы, для которого допустим элемент.<br>
Когда переменная появляется в области видимости, она считается действительной до момента выхода за границы этой области.<br>
<b>let s = String::from(“hello”);</b> - создать String из строкового литерала.<br>
Оператор <b>::</b> позволяет использовать пространство имен функции from под типом String.<br>
<br>
<dfn>Связанное понятие</dfn> - это область видимости: вложенный контекст в котором написан код имеющий набор имён, которые определены “в текущей области видимости”.<br>
<b>Оператор * (glob)</b> - включает в область видимости все общедоступные элементы, определенные в пути:<br>
<b>use std::collections::*;</b><br>
Сокращение для проброса ошибок: оператор <b>?</b><br>
Оператор <b>?</b> может использоваться только в функциях, тип возвращаемого значения которых совместим со значением, для которого используется ?.<br>
Исполняемые файлы, написанные на C, при выходе возвращают целые числа:<br> успешно завершённые программы возвращают целое число 0, а программы с ошибкой возвращают целое число, отличное от 0.<br>
Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.<br></p><pre><code>0011 AND 0101 is 0001
0011 OR 0101 is 0111
0011 XOR 0101 is 0110
1 << 5 is 32
0x80 >> 2 is 0x20
</code></pre></details><details><summary>Construction</summary><p>Условие всегда типа <b>bool</b>:</p><code>if number < 5 {println!(“Hi!”);} else {println!(“Buy”);}</code><p><b>if</b> - выражение<br>
<b>number < 5</b> - условие<br>
<b>{println!(“Hi!”);}</b> - ответвление<br>
<b>println!(“Hi!”);</b> - макрос<br>
<b>else</b> - выражение<br>
<b>{println!(“Buy”);}</b> - ответвление<br>
<b>println!(“Buy”);</b> - макрос<br>
По очереди проверяется каждое выражение if и выполняется первое тело, для которого условие истино, остальные блоки уже не проверяет.<br>
<br>
Управляющая конструкция match:<br>
Механизм управления потоком, который сравнивает значение с различными шаблонами и выполняет код в зависимости от того, какой из шаблонов совпал.<br></p><pre><code>enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}
fn value_in_cents (coin: Coin) -> u8 {
  match coin {
    Coin::Penny => 1,
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter => 25,
  }
}</code></pre><p><b>match coin:</b><br>
<b>match</b> - ключевое слово<br>
<b>coin</b> - - выражение, которое возвращает любой тип. В данном случае значение coin.<br>
<b>Coin::Penny => 1</b>, - ветка<br>
<b>Coin::Penny</b> - шаблон. В данном случае значение Coin::Penny.<br>
<b>=></b> - оператор<br>
<b>1</b> - выражение, код для выполнения. В данном случае значение 1.<br>
Код, связанный с каждой веткой, является выражением, а полученное значение выражения в соответствующей ветке - это значение, которое возвращается для всего выражения match.<br>
Если код для выполнения больше одной строки, то в фигурные скобки { } - запятая не обязательно.<br>
Универсальный шаблон:<br></p><pre><code>let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  <span>универсальный шаблон с привязкой к значению</span>
  other => move_player(other),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn move_player(num_spaces: u8) {}</code></pre><p>Для последней ветки шаблоном является переменная, которая передаётся в функцию move_player.<br>
Последняя ветка является универсальным шаблоном с привязкой к значению переменной шаблона.<br>
Заполнитель _ - специальный шаблон, который используется если не нужно привязываться к значению.<br></p><pre><code>let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  <span>универсальный шаблон без привязки к значению</span>
  _=> reroll (),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn reroll () {}</code></pre><p>Используем пустой кортеж - единичное значение, чтобы обозначить, что не используем никакое другое значение, кроме предыдущих веток и не запускаем никакого кода:</p><pre><code>let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  _=> (),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}</code></pre><p>if let - не запускается если значение не соответствует шаблону.<br>
Шаблон и выражение разделены знаком равенства.</p><pre><code>let config_max = Some (3u8);
if let Some (max) = config_max {
  println! (“The maximum is configured to be { }”, max);
}

<span>Ветки match</span>
match VALUE {
  PATTERN => EXPRESSION,
  PATTERN => EXPRESSION,
  PATTERN => EXPRESSION,
}</code></pre><p>Value - значение<br>
Pattern - шаблон<br>
Expression - выражение<br>
Одно из требований к выражениям match состоит в том, что они должны быть исчерпывающими (exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении match.<br>
Шаблон <b>_</b> может быть полезен, если вы, например, хотите игнорировать любое не указанное значение.<br>
Дополнительные условия оператора сопоставления <b>(Match Guards)</b><br>
Условие сопоставления (match guard) является дополнительным условием if, указанным после шаблона в ветке match, которое также должно быть выполнено, чтобы ветка была выбрана.<br>
Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.<br>
Добавление условия сопоставления в шаблон</p><pre><code>fn main() {
  let num = Some(4);
  match num {
    Some(x) if x % 2 == 0 => println!("The number {} is even", x),
    Some(x) => println!("The number {} is odd", x),
    None => (),
  }
}</code></pre><p>Использование условия сопоставления для проверки на равенство со значением внешней переменной</p><pre><code>fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("Got 50"),
    Some(n) if n == y => println!("Matched, n = {n}"),
    _ => println!("Default case, x = {:?}", x),
  }
  println!("at the end: x = {:?}, y = {y}", x);
}</code></pre><p>Комбинирование нескольких шаблонов с условием сопоставления</p><pre><code>fn main() {
  let x = 4;
  let y = false;
  match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
  }
}</code></pre><p>приоритет условия сопоставления по отношению к шаблону ведёт себя так:<br>
<b>(4 | 5 | 6) if y => ...</b><br>
а не так:<br>
<b>4 | 5 | (6 if y) => ...</b><br>
Можно также смешивать и сопоставлять выражения <b>if let, else if</b> и <b>else if let</b>.<br>
Это даёт больше гибкости, чем match выражение, в котором можно выразить только одно значение для сравнения с шаблонами.<br>
Недостатком использования if let выражений является то, что компилятор не проверяет полноту (exhaustiveness) всех вариантов, в то время как с помощью выражения match это происходит.<br>
<b>let PATTERN = EXPRESSION;</b><br>
Шаблоны бывают двух форм: опровержимые и неопровержимые.<br>
Шаблоны, которые будут соответствовать любому возможному переданному значению, являются неопровержимыми (irrefutable).<br>
Примером может быть x в выражении let x = 5;, потому что x соответствует чему-либо и, следовательно, не может не совпадать.<br>
Шаблоны, которые могут не соответствовать некоторому возможному значению, являются опровержимыми (refutable).<br>
Примером может быть Some(x) в выражении if let Some(x) = a_value, потому что если значение в переменной a_value равно None, а не Some, то шаблон Some(x) не будет совпадать.<br>
Сопоставление с литералом</p><pre><code>fn main() {
  let x = 1;
  match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}</code></pre><p>Сопоставление именованных переменных</p><pre><code>fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("Got 50"),
    Some(y) => println!("Matched, y = {y}"),
    _ => println!("Default case, x = {:?}", x),
  }
  println!("at the end: x = {:?}, y = {y}", x);
}</code></pre><p>Поскольку match начинает новую область видимости, то переменные, объявленные как часть шаблона внутри выражения match, будут затенять переменные с тем же именем вне конструкции match как и в случае со всеми переменными.<br>
Группа шаблонов</p><pre><code>fn main() {
  let x = 1;
  match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}
Сопоставление диапозонов с помощью &lt;b&gt;..=&lt;/b&gt;

fn main() {
  let x = 5;
  match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
  }
}</code></pre><p>Деструктуризация структуры</p><pre><code>struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  let Point { x: a, y: b } = p;
  assert_eq!(0, a);
  assert_eq!(7, b);
}
<span>Или</span>
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  let Point { x, y } = p;
  assert_eq!(0, x);
  assert_eq!(7, y);
}</code></pre><p>Деструктуризация и сопоставление с литералами в одном шаблоне</p><pre><code>struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  match p {
    Point { x, y: 0 } => println!("On the x axis at {x}"),
    Point { x: 0, y } => println!("On the y axis at {y}"),
    Point { x, y } => {
      println!("On neither axis: ({x}, {y})");
    }
  }
}</code></pre><p>Вместо создания переменных для всех полей мы также можем деструктурировать с помощью литеральных значений являющихся частью структуры.<br></p><pre><code>struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  match p {
    Point { x, y: 0 } => println!("On the x axis at {x}"),
    Point { x: 0, y } => println!("On the y axis at {y}"),
    Point { x, y } => {
      println!("On neither axis: ({x}, {y})");
    }
  }
}</code></pre><p>Деструктуризация перечислений</p><pre><code>enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
fn main() {
  let msg = Message::ChangeColor(0, 160, 255);
  match msg {
    Message::Quit => {
      println!("The Quit variant has no data to destructure.");
    }
    Message::Move { x, y } => {
      println!("Move in the x direction {x} and in the y direction {y}");
    }
    Message::Write(text) => {
      println!("Text message: {text}");
    }
    Message::ChangeColor(r, g, b) => {
      println!("Change the color to red {r}, green {g}, and blue {b}",)
    }
  }
}</code></pre><p>Этот код напечатает Change the color to red 0, green 160, and blue 255.<br>
Деструктуризация вложенных структур и перечислений<br>
До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами!<br></p><pre><code>enum Color {
  Rgb(i32, i32, i32),
  Hsv(i32, i32, i32),
}
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(Color),
}
fn main() {
  let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
  match msg {
    Message::ChangeColor(Color::Rgb(r, g, b)) => {
      println!("Change color to red {r}, green {g}, and blue {b}");
    }
    Message::ChangeColor(Color::Hsv(h, s, v)) => {
      println!("Change color to hue {h}, saturation {s}, value {v}")
    }
    _ => (),
  }
}
</code></pre></details><details><summary>Memory</summary><p>Владение позволяет обеспечивать безопасность памяти без использования сборщика мусора.<br>
<dfn>Владение</dfn> - это набор правил, определяющих как программа на Rust управляет памятью.<br>
<dfn>Стек</dfn> - часть памяти, который хранит значения в порядке их получения, а удаляет - в обратном.<br>
“Последний пришёл, первый вышел”.<br>
Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер.<br>
Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче.<br>
<dfn>Куча</dfn> - часть памяти, в которой распределитель памяти находит для данных подходящее место, помечает его как используемое и возвращает указатель - адрес этого места. Это выделение в куче или просто выделение.<br>
<em>Правила владения</em>:<br>
У каждого значения в Rust есть владелец.<br>
У значения может быть только один владелец в один момент времени.<br>
Когда владелец покидает область видимости, значение удаляется.<br>
При вызове <b>String::from</b> происходит запрос необходимой памяти.<br>
Память автоматически возвращается, как только владеющая памятью переменная выходит из области видимости { }.<br>
Rust автоматически вызывает функцию drop после закрывающей фигурной скобки и очищает память.<br>
Вектор освобождает память когда выходит из области видимости, при этом удаляются все значения, которые он содержит.<br>
</p></details><details><summary>Cycle</summary><p><em>loop, while, for</em><br>
<dfn>loop</dfn> - выполняет блок кода пока нет команды остановиться (break)<br>
<dfn>break</dfn> - прерывает выполнение цикла и выходит из него<br>
<dfn>continue</dfn> - пропустить оставшийся код в данной итерации цикла и перейти к следующей итерации<br>
break counter*2 - останавливает выполнение цикла и возвращает значение выражения counter*2<br>
break и continue применяется к самому внутреннему циклу внутри цепочки циклов.<br>
Метка цикла <b>'</b> :</p><pre><code>'counting_up: loop {
  ...
  loop {
  ...
    if count == 2 {
      <span>выход из цикла к 'counting_up в начале цикла</b>
      break 'counting_up;
    }
  }
  ...
}</code></pre><p><b>while number! = 0 {...}</b> - пока условие истинно, код выполняется, в противном случае происходит выход из цикла.<br>
Конструкция условного цикла while let позволяет повторять цикл while до тех пор, пока шаблон продолжает совпадать.<br>
В цикле for значение, которое следует непосредственно за ключевым словом for , является шаблоном.<br>
Например, в for x in y выражение x является шаблоном.<br>
Цикл for:</p><pre><code>fn main () {
  let a = [10, 20, 30, 40, 50];
  for element in a {
    println! (“the value is: {element}”);
  }
}
fn main () {
  for number in (1..4).rev() {
    println! (“{number}!”);
  }
    println! (“LIFTOFF !!!”);
}
</code></pre></details><details><summary>Error</summary><p>В Rust ошибки группируются на две основные категории: исправимые (recoverable) и неисправимые (unrecoverable).<br>
Rust имеет тип Result&lt;T, E&gt; для обрабатываемых (исправимых) ошибок и макрос panic!, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку.<br>
На практике существует два способа вызвать панику: путём выполнения действия, которое вызывает панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного вызова макроса panic!.<br>
По умолчанию, когда происходит паника, программа начинает процесс раскрутки стека, означающий в Rust проход обратно по стеку вызовов и очистку данных для каждой обнаруженной функции.<br>
Rust как альтернативу предоставляет вам возможность немедленного прерывания (aborting), которое завершает работу программы без очистки.<br>
Память, которую использовала программа, должна быть очищена операционной системой.<br>
Добавьте panic = 'abort' в раздел [profile] вашего Cargo.toml файла.<br>
Мы можем использовать обратную трассировку вызовов функций которые вызвали panic! чтобы выяснить, какая часть нашего кода вызывает проблему.<br>
Получить обратную трассировку можно с помощью установки переменной среды RUST_BACKTRACE в любое значение, кроме 0.<br>
Обратная трассировка создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения программы.<br>
Другие строки, которые выше над  строками с упоминанием наших файлов, - это код, который вызывается нашим кодом;<br>
строки ниже являются кодом, который вызывает наш код.</p><pre><code>enum Result<T, E> {
  Ok(T),
  Err(E),
}</code></pre><p>T представляет тип значения, которое будет возвращено в случае успеха внутри варианта Ok, а E представляет тип ошибки, которая будет возвращена при сбое внутри варианта Err.<br>
Метод <dfn>unwrap/<dfn> - это метод быстрого доступа к значениям.<br> Если значение Result является вариантом Ok, unwrap возвращает значение внутри Ok.<br>
Если Result - вариант Err, то unwrap вызовет для нас макрос panic!.<br>
Метод expect позволяет указать сообщение об ошибке для макроса panic!.<br>
expect используется так же как и unwrap: либо возвращается дескриптор файла либо вызывается макрос panic!.<br>
Наше сообщение об ошибке в expect будет передано в panic! и заменит стандартное используемое сообщение.<br>
Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать.<br>
Такой приём известен как распространение ошибки (propagating the error).
</p></details><details><summary>Trait</summary><p>Типаж сообщает компилятору Rust о функциональности, которой обладает определённый тип и которой он может поделиться с другими типами.<br>
Можно использовать типажи, чтобы определять общее поведение абстрактным способом.<br>
Мы можем использовать ограничение типажа (trait bounds) чтобы указать, что общим типом может быть любой тип, который имеет определённое поведение.<br>
<dfn>Определение типажей</dfn> - это способ сгруппировать сигнатуры методов вместе для того, чтобы описать общее поведение.<br></p><pre><code>pub trait Summary {
  fn summarize(&self) -> String;
}</code></pre><p>После сигнатуры метода, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой.<br>
Каждый тип, реализующий данный типаж, должен предоставить своё собственное поведение для данного метода.<br>
Реализация типожа у типа</p><pre><code>impl Summary for NewsArticle {
  fn summarize(&self) -> String {}

impl Summary for Tweet {
  fn summarize(&self) -> String {}</code></pre><p>Мы не можем реализовать внешние типажи для внешних типов.<br>
Это ограничение является частью свойства называемого согласованность (coherence), а ещё точнее сиротское правило (orphan rule), которое называется так потому что не представлен родительский тип.<br>
Без этого правила два крейта могли бы реализовать один типаж для одинакового типа и Rust не сможет понять, какой реализацией нужно пользоваться.<br>
Типажи как параметры</p><pre><code>pub fn notify(item: &impl Summary) {
  println!("Breaking news! {}", item.summarize());
}</code></pre><p>Вместо конкретного типа у параметра item указывается ключевое слово impl и имя типажа.<br>
Этот параметр принимает любой тип, который реализует указанный типаж.<br>
Обе записи одинаковы:</p><pre><code>pub fn notify(item1: &impl Summary, item2: &impl Summary) {
pub fn notify&lt;T: Summary&gt;(item1: &T, item2: &T) {</code></pre><p>Более одного типажа</p><code>pub fn notify(item: &(impl Summary + Display)) {</code><p>Это выражение:</p><code>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &T, u: &U) -> i32 {</code><p>Можно записать так:</p><pre><code>fn some_function&lt;T, U&gt;(t: &T, u: &U) -> i32
<span>where</span>
T: Display + Clone,
U: Clone + Debug,
{
  fn returns_summarizable() -> impl Summary {</code></pre><p>Используя <b>impl Summary</b> для возвращаемого типа, мы указываем, что функция returns_summarizable возвращает некоторый тип, который реализует типаж Summary без обозначения конкретного типа.<br>
Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать метод to_string определённый типажом ToString для любого типа, который реализует типаж Display:</p><pre><code>impl&lt;T: Display&gt; ToString for T {
// --snip--
}</code></pre><p>Общие реализации приведены в документации к типажу в разделе "Implementors".<br>
Типажи и ограничения типажей позволяют писать код, который использует параметры обобщённого типа для уменьшения дублирования кода, а также указывая компилятору, что мы хотим обобщённый тип, чтобы иметь определённое поведение.<br>
Затем компилятор может использовать информацию про ограничения типажа, чтобы проверить, что все конкретные типы, используемые с нашим кодом, обеспечивают правильное поведение.<br>
В Rust применяется подход с использованием типажей-объектов вместо наследования.<br>
Мы можем использовать типаж-объекты вместо универсального или конкретного типа.<br>
Везде, где мы используем типаж-объект, система типов Rust проверит во время компиляции, что любое значение, используемое в этом контексте, будет реализовывать нужный типаж у типаж-объекта.<br>
Следовательно, нам не нужно знать все возможные типы во время компиляции.<br>
В структуре или перечислении данные в полях структуры и поведение в блоках impl разделены, тогда как в других языках данные и поведение объединены в одну концепцию, часто обозначающуюся как объект.<br>
Тем не менее, типаж-объекты являются более похожими на объекты на других языках, в том смысле, что они сочетают в себе данные и поведение.<br>
Но типаж-объекты отличаются от традиционных объектов тем, что не позволяют добавлять данные к типаж-объекту.<br>
Типаж-объекты обычно не настолько полезны, как объекты в других языках:<br>
их конкретная цель - обеспечить абстракцию через общее поведение.<br>
Когда мы используем типаж-объекты, Rust должен использовать динамическую диспетчеризацию.<br>
Компилятор не знает всех типов, которые могут быть использованы с кодом, использующим типаж-объекты, поэтому он не знает, какой метод реализован для какого типа при вызове.<br>
Вместо этого, во время выполнения, Rust использует указатели внутри типаж-объекта, чтобы узнать какой метод вызвать.<br>
Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при статической диспетчеризации.<br>
Деструктуризация структур и кортежей</p><pre><code>fn main() {
  struct Point {
    x: i32,
    y: i32,
  }
  let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
}
</code></pre></details><details><summary>Test</summary><p><dfn>Тесты</dfn> - это функции Rust, которые проверяют, что не тестовый код работает ожидаемым образом.<br>
Содержимое тестовых функций обычно выполняет следующие три действия:<br>
1. Установка любых необходимых данных или состояния.<br>
2. Запуск кода, который вы хотите проверить.<br>
3. Утверждение, что результаты являются теми, которые вы ожидаете.<br>
Чтобы превратить функцию в тестирующую функцию добавьте <test></test> в строку перед fn.<br>
Когда вы запускаете тесты командой cargo test, Rust создаёт бинарный модуль выполняющий функции аннотированные атрибутом test и сообщающий о том, успешно или нет прошла каждая тестирующая функция.<br>
Макрос <b>assert!</b> доступен из стандартной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в тесте вычисляется в значение true.<br>
Когда проверка не срабатывает, макросы печатают значения аргументов с помощью отладочного форматирования и это означает, что значения сравниваемых аргументов должны реализовать типажи <b>PartialEq</b> и <b>Debug</b>.<br>
Все примитивные и большая часть типов стандартной библиотеки Rust реализуют эти типажи.<br>
Для структур и перечислений, которые вы реализуете сами будет необходимо реализовать типаж PartialEq для сравнения значений на равенство или неравенство.<br>
Для печати отладочной информации в виде сообщений в строку вывода консоли необходимо реализовать типаж Debug.<br>
Так как оба типажа являются выводимыми типажами, то эти типажи можно реализовать добавив аннотацию <b><derive PartialEq Debug></derive></b> к определению структуры или перечисления.<br>
Общим способом проверки функциональности является использование сравнения результата тестируемого кода и ожидаемого значения, чтобы убедиться в их равенстве.<br>
Для этого можно использовать макрос assert!, передавая ему выражение с использованием оператора ==.<br>
Cтандартная библиотека предлагает пару макросов assert_eq! и assert_ne!, чтобы сделать тестирование более удобным.<br>
Эти макросы сравнивают два аргумента на равенство или неравенство соответственно.<br>
Макросы также печатают два значения входных параметров, если тест завершился ошибкой, что позволяет легче увидеть почему тест ошибочен.<br>
Противоположно этому, макрос assert! может только отобразить, что он вычислил значение false для выражения ==, но не значения, которые привели к результату false.<br>
В своей работе макросы assert_eq! и assert_ne! неявным образом используют операторы == и != соответственно.<br>
Другой атрибут тест-функции <b><should_panic></should_panic></b>.<br>
Этот атрибут сообщает системе тестирования, что тест проходит, когда метод генерирует ошибку.<br></p><pre><code><cfg test></cfg>
mod tests {
  use super::*;
  <test></test>
  <should_panic></should_panic>
  fn greater_than_100() {</code></pre><p>Тест с атрибутом should_panic пройдёт, даже если тест паникует по причине, отличной от той, которую мы ожидали.<br>
Чтобы сделать тесты с should_panic более точными, мы можем добавить необязательный параметр expected для атрибута should_panic.</p><pre><code><cfg test></cfg>
mod tests {
  use super::*;
  <test></test>
  <should_panic expected="less than or equal to 100"></should_panic>
  fn greater_than_100() {</code></pre><p>Написание тестов так, чтобы они возвращали Result&lt;T, E&gt; позволяет использовать оператор "вопросительный знак" в теле тестов, который может быть удобным способом писать тесты, которые должны выполниться не успешно, если какая-либо операция внутри них возвращает вариант ошибки Err.</p><pre><code><cfg test></cfg>
mod tests {
  <test></test>
  fn it_works() -> Result<(), String> {
    if 2 + 2 == 4 {
      Ok(())
    } else {
      Err(String::from("two plus two does not equal four"))
    }
  }
}</code></pre><p>Поскольку тесты выполняются параллельно, вы должны убедиться, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий каталог или переменные окружения.<br>
<b>cargo test -- --test-threads=1</b><br>
Мы устанавливаем количество тестовых потоков равным 1, указывая программе не использовать параллелизм.<br>
Выполнение тестов с использованием одного потока займёт больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.<br>
Если мы хотим видеть напечатанные результаты прохождения тестов, мы можем сказать Rust, чтобы он также показывал результаты успешных тестов с помощью <b>--show-output</b>.<br>
<b>cargo test -- --show-output</b><br>
Запустить только несколько тестов, используя команду cargo test, передав в качестве аргумента имена тестов.<br>
<b>cargo test it_works</b><br>
Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому значению.<br>
Можно аннотировать тесты атрибутом ignore, чтобы исключить их из исполнения:</p><pre><code><test></test>
fn it_works() {
  assert_eq!(2 + 2, 4);
}
<test></test>
<ignore></ignore>
fn expensive_test() {
  // code that takes an hour to run
}</code></pre><p>Если вы хотите выполнить только проигнорированные тесты, вы можете воспользоваться командой <b>cargo test -- --ignored</b><br>
Если вы хотите запустить все тесты независимо от того, игнорируются они или нет, выполните cargo <b>test -- --include-ignored</b>.<br>
Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные интерфейсы.<br>
Интеграционные тесты являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные интерфейсы и потенциально выполняя тестирование нескольких модулей в одном тесте.<br>
Целью модульных тестов является тестирование каждого блока кода, изолированное от остального функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается.<br>
Аннотация <b><cfg test></cfg></b> у модуля с тестами указывает Rust компилировать и запускать только код тестов, когда выполняется команда cargo test, а не когда запускается cargo build.<br>
Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете использовать <b><cfg test></cfg></b> чтобы указать, что они не должны быть включены в скомпилированный результат.<br>
Мы создаём папку tests в корневой папке вашего проекта, рядом с папкой src.<br>
Cargo знает, что искать файлы с интеграционными тестами нужно в этой директории.<br>
Нам не нужно комментировать код в tests/integration_test.rs с помощью <b><cfg test></cfg></b>.<br>
Cargo специальным образом обрабатывает каталог tests и компилирует файлы в этом каталоге только тогда, когда мы запускаем команду cargo test.<br>
Выходные данные представлены тремя разделами:<br>
модульные тесты, интеграционные тесты и тесты документации.<br>
Чтобы запустить все тесты в конкретном файле интеграционных тестов, используйте аргумент --test сопровождаемый именем файла у команды cargo test:<br>
<b>cargo test --test integration_test</b><br>
Файлы в подкаталогах каталога tests не компилируются как отдельные крейты или не появляются в результатах выполнения тестов.<br>
Если наш проект является бинарным крейтом, который содержит только src/main.rs и не содержит src/lib.rs, мы не сможем создать интеграционные тесты в папке tests и подключить функции определённые в файле src/main.rs в область видимости с помощью оператора use.<br>
Только библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах;<br>
бинарные крейты предназначены только для самостоятельного запуска.<br>
Процесс разработки через тестирование (TDD), который следует этим шагам:<br>
Напишите тест, который не прошёл и запустите его, чтобы убедиться, что он не прошёл по той причине, которую вы ожидаете.<br>
Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.<br>
Выполните рефакторинг кода, который вы только что добавили или изменили, и убедитесь, что тесты продолжают проходить.<br>
Повторите с шага 1!<br>
</p></details><details><summary>Unsafe Rust</summary><p>Чтобы переключиться на небезопасный Rust, используйте ключевое слово <dfn>unsafe</dfn>, а затем начните новый блок, содержащий небезопасный код.<br>
В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем небезопасными супер силами.<br>
Эти супер силы включают в себя следующее:<br>
- Разыменование сырого указателя<br>
- Вызов небезопасной функции или небезопасного метода<br>
- Доступ или изменение изменяемой статической переменной<br>
- Реализация небезопасного типажа<br>
- Доступ к полям в union<br>
Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных операции внутри блоков, помеченных как unsafe, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри unsafe блоков.<br>
Делайте unsafe блоки маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.<br>
Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом.<br>
Создание необработанных указателей из ссылок</p><pre><code>fn main() {
  let mut num = 5;
  let r1 = &num as *const i32;
  let r2 = &mut num as *mut i32;
}</code></pre><p>В отличие от ссылок и умных указателей, сырые указатели:<br>
- могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти<br>
- не гарантируют что ссылаются на действительную память<br>
- могут быть null<br>
- не реализуют автоматическую очистку памяти<br>
Разыменование сырых указателей в блоке unsafe</p><pre><code>fn main() {
  let mut num = 5;
  let r1 = &num as *const i32;
  let r2 = &mut num as *mut i32;
  unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
  }
}</code></pre><p>Вызов небезопасной функции или метода</p><pre><code>fn main() {
  unsafe fn dangerous() {}
  unsafe {
    dangerous();
  }
}</code></pre><p>обёртывание небезопасного кода в безопасную функцию - это обычная абстракция.<br>
Использование небезопасного кода в реализации функции split_at_mut</p><pre><code>use std::slice;
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  let len = values.len();
  let ptr = values.as_mut_ptr();
  assert!(mid <= len);
  unsafe {
    (
      slice::from_raw_parts_mut(ptr, mid),
      slice::from_raw_parts_mut(ptr.add(mid), len - mid),
    )
  }
}
fn main() {
  let mut vector = vec![1, 2, 3, 4, 5, 6];
  let (left, right) = split_at_mut(&mut vector, 3);
}</code></pre><p>мы можем быть уверены, что все сырые указатели, используемые в unsafe блоке будут действительными указателями на данные внутри среза.<br>
Это приемлемое и правильное использование unsafe.<br>
Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке.<br>
Для этого в Rust есть ключевое слово extern, которое облегчает создание и использование интерфейса внешних функций (<dfn>Foreign Function Interface - FFI</dfn>).<br>
<dfn>FFI</dfn> - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.</p><pre><code>extern "C" {
  fn abs(input: i32) -> i32;
}
fn main() {
  unsafe {
    println!("Absolute value of -3 according to C: {}", abs(-3));
  }
}</code></pre><p>мы делаем функцию call_from_c доступной из кода на языке C, после того как она скомпилирована в разделяемую библиотеку и прилинкована из C</p><pre><code>#![allow(unused)]
fn main() {
  <no_mangle></no_mangle>
  pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
  }
}</code></pre><p>Определение и использование неизменяемой статической (глобальной) переменной</p><pre><code>static HELLO_WORLD: &str = "Hello, world!";
fn main() {
  println!("name is: {}", HELLO_WORLD);
}</code></pre><p>Имена статических переменных по общему соглашению пишутся в нотации SCREAMING_SNAKE_CASE, и мы должны указывать тип переменной, которым в данном случае является &'static str.<br>
Чтение из изменяемой статической переменной или запись в неё небезопасны</p><pre><code>static mut COUNTER: u32 = 0;
fn add_to_count(inc: u32) {
  unsafe {
    COUNTER += inc;
  }
}
fn main() {
  add_to_count(3);
  unsafe {
    println!("COUNTER: {}", COUNTER);
  }
}</code></pre><p>Мы можем использовать unsafe для реализации небезопасного трейта.<br>
Трейт является небезопасным, если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить.</p><pre><code>unsafe trait Foo {
// methods go here
}
unsafe impl Foo for i32 {
// method implementations go here
}
fn main() {}
</code></pre></details><details><summary>Syntax</summary><table><caption>Syntax</caption><thead><tr><th>Syntax</th><th>Meta</th></tr></thead><tbody><tr><td>let</td><td>ключевое слово для объявления переменной</td></tr><tr><td>{}</td><td>Scope - блок кода, в котором живёт объявленная переменная</td></tr><tr><td>Shadowing</td><td>затенение - позволяет переобъявить переменную в том же блоке кода под тем же именем</td></tr><tr><td>let x: i32;</td><td>объявление переменной х типа интежер 32-бита тип указывать желательно</td></tr><tr><td>;</td><td>если есть ; то не возвращаем <br>
Statment: let x = 3; - ничего не вернём, т.к. есть ; - это Statment.<br>
Если есть = то это всегда statment.
Expression: x += 1 - вернем значение 4, т.к. нет ; - это Expression</td></tr><tr><td>let x: i32 = 5;</td><td>инициализация переменной - присваиваем переменной значение <br>
значения, размер которых известен храняться в стэке, если размер не известен то в куче.                </td></tr><tr><td>assert_eq!(x, 5);</td><td>assert - утверджать, equal - равенство. Макрос (!), который проверяет на равенство.</td></tr><tr><td>println!("Success"):</td><td>Макрос (!), который выводит в стандартный вывод (терминал) то, что в "" и переводит курсор на новую строку</td></tr><tr><td>format!("{}", x)</td><td>возвращает String</td></tr><tr><td>let _y: i32;</td><td>_y означает неиспользуемая переменная</td></tr><tr><td><allow unused_variables></allow></td><td>говорит компелатору позволить неиспользуемые переменные <br>
при такой записи имена переменных можно без _                </td></tr><tr><td><derive Debug></derive></td><td>говорит компилятору использовать анотацию "{:?}". dbg!(x) - выводит значение переменной х в режиме дебага                </td></tr><tr><td><derive Display></derive></td><td>говорит компилятору использовать анотацию "{}"                </td></tr><tr><td>let (x, y);</td><td>объявление сразу нескольких переменных let x; и let y;                </td></tr><tr><td>let mut x;</td><td>mut означает что значение переменной можно изменять                </td></tr><tr><td>x += 2;</td><td>короткая запись х = х + 2;                </td></tr><tr><td>let &x = y;</td><td>&x ссылка по имени х ссылается на у                </td></tr><tr><td>let &mut x = mut y;</td><td>изменяемая ссылка х ссылается на изменяемую переменную у                </td></tr><tr><td>let &<'a> x</td><td><'a> время жизни ссылки &                </td></tr><tr><td>*x</td><td>Если х содержит ссылку &x, то * даёт нам значение по ссылке &x                </td></tr><tr><td>let t = (2, "hello", 6.4);</td><td>tuple - коллекция разнотипных значенией, доступ t.0, println!((только до 12 значений));                </td></tr><tr><td>let (x, y) = (1, 2);</td><td>Деструктуризация tuple (1, 2) - х = 1, у = 2                </td></tr><tr><td>let (x, y); <br>
(x, ..) = (3, 4);<br>
[.., y] = [1, 2];                    </td><td>Деструктуризация: х принимает значение 3, .. означает пропустить, у принимает значение 2. <br>
[x, y] = [3, 2]                </td></tr><tr><td>Integers: i32 <br>
Floats: f64</td><td>По умолчанию целое число i32, а число с плавающей точкой - f64 <br>
при операциях с f64 большая точность выявляет погрешность чисел, поэтому равенства могут на работать <br>
в таких случаях нужно использовать f32: 0.1 + 0.2 == 0.300000000000000001.</td></tr><tr><td>let x: u16 = 38_u8 as u16;</td><td>объявил переменную х типа u16 и присваиваю ей значение 38 типа u8 <br>
но т.к. присваивать можно значения только того же типа, то меняем тип as u16</td></tr><tr><td>()</td><td>unit тип, который не имеет значения, размер 0 байт. let _v: () = ();<br>
представляет собой пустой tuple, возвращается когда функция ничего не возвращает.</td></tr><tr><td>bool</td><td>логический тип false и true, иметт размер 1 байт</td></tr><tr><td>char</td><td>тип символа имеет размер 4 байта. обозначается одинарной кавычкой ''.</td></tr><tr><td>String</td><td>тип строки - набор символов в виде вектора байт. обозначается двойной кавычкой "". let x = String::from("hello");<br>
переменная x хранит ярлык с длиной, ёмкостью и указателем на адрес памяти в куче где хранится "hello"<br>
Методы приведения к типу String: String::from("hallo"); "hello".to_string(); s.replace("word1", "word2"); - заменяет word1 на word2 в строке s<br>
s.push_str("hello, world"); - когда добавляем в строку другую строку, s.push('!'); - когда добавляем в строку один символ
s3: String = s1: String + s2.as_str(); - при конкатенации строк второе слагаемое должно быть &str. Метод s.clear() - делает строку пустой.</td></tr><tr><td>str</td><td>тип строкового литерала "hello", используется только по ссылке &str <br>
хранится в стэке и является представлением (фотографией на данный момет) строки типа String,<br>
которая храниться в куче. <br>
Т.е. при инициализации переменной типа &str мы идём в кучу делаем срез нужной строки <br>
и сохраняем его в стэке под именем инициализируемой переменной</td></tr><tr><td>\</td><td>экранирование символов в стоке</td></tr><tr><td>let row_str = r"\x3F";</td><td>в row строке экранирование не работает, конвертации в символ не будет</td></tr><tr><td>let s = &s1[0..1];</td><td>доступ к символам в строке s только через срез. В срезе указываетс диапозон байт строки в котором находится нужный символ</td></tr><tr><td><b>=</b></td><td>Присваивание. Значение, которое имеет фиксированный размер живёт в стеке и принадлежит переменной.<br>
значение, которое может изменяться живёт в куче, на его адрес в куче указывает переменная,<br>
в которй хранится указатель, длина значения и количество памяти зарезервированное под это значение.<br>
При присваивании значения переменной из стэка другой переменной происходит копирование значения.<br>
При присваивании значения переменной из кучи другой переменной происходит перемещение указателя,<br>
длины и количества памяти из старой переменной в новую. Старая переменная уничтожается.<br>
let new_var = old_var.clone(); - копия значения в куче и указатель на копию в новой переменной</td></tr><tr><td>::</td><td>обращение к ассоциированной функции String::from("hello");<br>
ассоциированная - это функция без аргумента self</td></tr><tr><td>.</td><td>обращение к методу "hello".to_string();<br>
метод - это функция первый аргумент которой self</td></tr><tr><td>0xff</td><td>16-ти ричное значение 255</td></tr><tr><td>0o77</td><td>8-ти ричное значение 63</td></tr><tr><td>0b1111_1111</td><td>бинарное (0 и 1) значение 255 </td></tr><tr><td>for i in 'a'..='z' {<br>
  println!("{}", i);}</td><td>for _ in _ {} - цикл. 'a'..='z' - диапозон от..до. если есть =, значит включительно. <br>
"{}", i - вставить в стоку значение i</td></tr><tr><td>for c in "hello".chars() {<br>
  println!("{}", c) }</td><td>Метод chars() переведёт символы строки в итератор (в последовательность для итерирования). <br>
Цикл for пройдёт по всей последовательности и выведет каждый символ на печать</td></tr><tr><td>Function</td><td>именованный блок кода, который используется несколько раз</td></tr><tr><td>fn name(x: i32, y: i32) -> i32 {<br>
    x + y<br>
}</td><td>fn - ключевое слово для объявления функции; name(x: i32, y: i32) - имя функции с параметрами х и у, анотация типа параметра обязательна;<br>
если в параметр передается переменная, которая указывает на значение в куче,<br>
то эта переменная перемещается из своей области видимости в область видимости функции. <br>
если в параметр передается переменная со значением в стэке, то переменная остается в своей области видимости, <br>
а в область видимости функции передается её копия.
-> i32 - возвращает значение типа i32, обязательно указывать если функция что-нибудь возвращает; <br>
{} - scope, блок кода, область видимости функции; <br>
x + y - выражение, результат которого возвращает функция</td></tr><tr><td>fn never_return() -> ! { <br>
    panic!() <br>
}</td><td>функция, которая никогда не вернет поток. Макрос panic!() вызовет ошибку и завершение программы. <br>
unimplemented!() - макрос для функций, которые пока ещё не имплементированы. <br>
todo!() - <br></td></tr><tr><td>Option<.i32></td><td>Some() None</td></tr><tr><td>Result<.Res, Err></td><td>Ok() Err()</td></tr><tr><td>match x {<br>
    1 => { } <br>
    _ => { } <br>
}</td><td> </td></tr><tr><td>let x: Box<.i32> = Box::new(5);</td><td>Box позволяет разместить любое значение в куче.</td></tr><tr><td>let s: Box<.str> = "hello, world".into();</td><td>Метод into() переводит значение, на которои его вызвали в указанный тип переменной.</td></tr><tr><td>struct Person {<br>
    name: String,
    age: Box<.u8>, <br>
}</td><td>создаёт сруктуру с полями. Так создаются новые пользовательские типы.</td></tr><tr><td>let person: Person = struct Person {<br>
    name: String::from("Alice"),<br>
    age: Box::new(20), <br>
};</td><td>инициализируем сруктуру с конкретными значенями. Переменная person имеет тип Person.</td></tr><tr><td>let Person {name, age} = person;</td><td>деструктуризируем переменную. Получаем переменные name и age с указателями на значения.</td></tr><tr><td>let arr = [];</td><td>let arr: [i32, 3] = [1, 2, 3]; let arr: [i32, 10] = [1; 10]; // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>
arr[0], arr.get(0).unwrap();<br>
get(0) - возвращает Option&lt;T&gt;td
</td></tr></tbody></table></details></details></details><details><summary class="menu__submenu">Framewrks</summary><details><summary class="menu__submenu_lv1">WordPress</summary><details><summary class="menu__submenu">Источники</summary><a href="https://developer.wordpress.org/">WordPress<br></a><a href="https://developer.wordpress.org/block-editor/reference-guides/">Guides<br></a><a href="https://developer.wordpress.org/reference/functions/">wp core functions<br></a><a href="https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page/">wp story book<br></a><a href="https://codex.wordpress.org/">Codex<br></a><a href="https://codex.wordpress.org/Theme_Unit_Test">Theme_Unit_Test<br></a><a href="https://wordpress.org/plugins/theme-check/">Theme-check<br></a><a href="https://wordpress.org/plugins/debug-bar/">Debug-bar<br></a><a href="https://wordpress.org/plugins/query-monitor/">Query-monitor<br></a><a href="https://wordpress.org/plugins/cmb2/">custom fields & metaboxes classic theme PHP adding<br></a><a href="https://gutenberg.10up.com/">custom fields & metaboxes block theme React adding<br></a><a href="https://happyprime.github.io/wphtml-converter/">Convert WordPress block HTML to its JavaScript object or PHP array forms.<br></a><a href="https://wp-kama.ru">WP-Kama<br></a><a href="https://developer.woocommerce.com/docs/">Woocommerce<br></a><a href="https://github.com/ndiego/editor-curation-examples">Отключение и блокировка блоков</a><a href="https://www.briancoords.com/">Brian Coords</a><p>Plugins:<br>
Advanced Custom Fields PRO<br>
Contact Form 7<br>
Site Kit by Google<br>
SVG Support<br>
UpdraftPlus - Backup/Restore<br>
Wordfence Security<br>
Select Yoast SEO<br>
Yoast SEO<br>
Cyr to lat<br>
Show current template<br>
</p></details><details><summary class="menu__submenu">ACF</summary><a href="https://www.youtube.com/watch?v=Q5zcWpRMl9s">ACF</a><p>Стандартный вывод информации из ACF (текст, ссылка на картинку и т.п.):</p><code>&lt;?php the_field('имя_поля'); ?&gt;</code><br><p>Вывод повторителя:</p><pre><code>&lt;?php if(get_field('имя_повторителя')): ?&gt;
  &lt;?php while(has_sub_field('имя_повторителя')) : ?&gt;
    &lt;div&gt;
      &lt;img(src="&lt;?php the_sub_field('имя_поля'); ?&gt;"&gt;
    &lt;/div&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Повторитель в повторителе:</p><pre><code>&lt;?php if(get_field('имя_повторителя_1')): ?&gt;
  &lt;?php while(has_sub_field('имя_повторителя_1')) : ?&gt;
    &lt;div&gt;
      &lt;mg(src="&lt;?php the_sub_field('имя_поля_повторителя_1'); ?&gt;"&gt;
      &lt;ul&gt;
        &lt;?php if(get_sub_field('имя_повторителя_2')): ?&gt;
        &lt;?php while(has_sub_field('имя_повторителя_2')) : ?&gt;
          &lt;?php the_sub_field('имя_поля_повторителя_2'); ?&gt;
        &lt;?php endwhile; ?&gt;
        &lt;?php endif; ?&gt;
    &lt;/div&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Вывод группы полей:</p><pre><code>&lt;?php if( have_rows('имя_группы') ): ?&gt;
&lt;?php while( have_rows('имя_группы') ): the_row(); ?&gt;
  &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
    &lt;i class="fa fa-vk" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
  &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
    &lt;i class="fa fa-facebook" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
&lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Галерея”</p><pre><code>&lt;?php if ($img_gallery = get_field("имя_галереи")) : ?&gt;
  &lt;?php foreach ($img_gallery as $img) : ?&gt;
    &lt;?php if ($img) : ?&gt;
      &lt;?= "&lt;img
        src="&lt;?= esc_url($img['sizes']['thumbnail']) ?&gt;"
        alt="&lt;?= esc_attr($img['alt']) ?&gt;"
        loading="lazy"
        width="&lt;?= esc_attr($image_array['width']) ?&gt;"
        height="&lt;?= esc_attr($image_array['height']) ?&gt;"
      /&gt;" ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endforeach; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Объект записи”</p><pre><code>&lt;?php if ($post_objects = get_field("имя_объекта_записи")) : ?&gt;
  &lt;?php
  foreach ($post_objects as $post) : setup_postdata($post); ?&gt;
    &lt;?php if ($post) : ?&gt;
      &lt;?php the_title(); ?&gt;
      &lt;?php the_excerpt(); ?&gt;
      &lt;?php the_field("имя_поля_объекта_записи"); ?&gt;
      &lt;?php the_permalink(); ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endforeach; ?&gt;
  &lt;?php wp_reset_postdata(); ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Гибкое содержание”</p><pre><code>&lt;?php if (have_rows('имя_гибкого_содержания')) : ?&gt;
  &lt;?php while (have_rows('имя_гибкого_содержания')) : the_row(); ?&gt;
    &lt;?php if (get_row_layout() == 'hero') : ?&gt;
      &lt;?php get_template_part("template-parts/hero-section") ?&gt;
    &lt;?php elseif (get_row_layout() == 'about') : ?&gt;
      &lt;?php get_template_part("template-parts/about-section") ?&gt;
    &lt;?php elseif (get_row_layout() == 'contacts') : ?&gt;
      &lt;?php get_template_part("template-parts/contacts-section") ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Ссылка”</p><pre><code>&lt;?php if (get_field('имя_ссылки')) : ?&gt;
  &lt;a
    href="&lt;?= get_field('имя_ссылки')['url'] ?&gt;"
    target="&lt;?= get_field('имя_ссылки')['target'] ?&gt;"&gt;
    &lt;?= get_field('имя_ссылки')['title'] ?&gt;
  &lt;/a&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Вывод поля ACF только если оно заполнено</p><pre><code>&lt;?php if (get_field("имя_поля")) { ?&gt;
  &lt;?php the_field("имя_поля"); ?&gt;
&lt;?php } ?&gt;</code></pre><br><p>Страница опций ACF</p><pre><code>if (function_exists("acf_add_options_page")) {
  acf_add_options_page(array(
    "page_title" => "Опции темы",
    "menu_title" => "Опции темы",
    "menu_slug"  => "theme_settings",
  ));
}</code></pre><br><p>Вывод полей из страницы с опций</p><code>&lt;?php the_field("имя_поля", "option"); ?&gt;</code><p>Для нумерации строк в плагине Advanced Custom Fields (ACF) необходимо использовать функцию get_field(), которая позволяет извлечь данные из поля.<br>
В примере ниже строки будут нумероваться с помощью цикла for:</p><pre><code>&lt;?php if( have_rows('service') ): $i = 0; ?&gt;
&lt;?php while ( have_rows('service') ) : the_row(); $i++; ?&gt;
  &lt;?php echo $i; ?&gt;
&lt;? endwhile; endif; ?&gt;
</code></pre></details><details><summary class="menu__submenu">functions.php</summary><p>Есть несколько причин, по которым вы можете увидеть сломанный сайт с белым экраном.<br>
Одна из таких причин — когда файл functions.php(или любой файл PHP) имеет пробел после закрывающего ?></p><pre><code>&lt;?php
add_action( 'after_setup_theme', function () {
  add_theme_support( 'wp-block-styles' );
});
<span>подключить файл из родительской темы</span>
include get_parent_theme_file_path( 'inc/helpers.php' );
<span>подключить файл из дочерней темы</span>
include get_theme_file_path( 'inc/helpers.php' );
<span>функция загрузки таблиц стилей для каждого блока в редакторе и на фронтенде wp_enqueue_block_style()</span>   
add_action( 'wp_enqueue_scripts', function () {
  <span>ставлю в очередь navigation.js</span>
  wp_enqueue_script( 'theme-slug-navigation',
    get_parent_theme_file_uri( 'assets/js/navigation.js' ),
    array(),
    wp_get_theme()->get( 'Version' ),
    true
  );
  <span>добавляю JS в head область на фронтенде</span>
  wp_add_inline_script( 'theme-slug-navigation',
    'console.log( "Testing" );'
  );
});
<span>JS для редактора блоков</span>
add_action( 'enqueue_block_editor_assets',
  'theme_slug_enqueue_editor_scripts', function () {
    <span>ставлю в очередь editor.js для редактора</span>
    wp_enqueue_script('theme-slug-editor',
      get_parent_theme_file_uri( 'assets/js/editor.js' ),
      array(),
      wp_get_theme()->get( 'Version' ),
      true
    );
  });</code></pre><p>Список включенных скриптов - wp-includes/script-loader.php<br>
Обращение к файлу изображения:<br></p><code>&lt;img(src="&lt;?php echo esc_url( get_theme_file_uri( 'assets/img/example.webp' ) ); ?&gt;" alt="" /&gt;</code><p>Шрифты подключать через theme.json</p></details><details><summary class="menu__submenu">wp-config.php</summary><pre><code>if ( ! defined( 'WP_DEBAG' ) ) {
  define('WP_DEBAG', true);
}

if ( ! defined( 'SCRIPT_DEBUG' ) ) {
  define('SCRIPT_DEBUG', true);
}

if ( ! defined( 'WP_DEBUG_DISPLAY' ) ) {
  define('WP_DEBUG_DISPLAY', false);
}

if ( ! defined( 'WP_DEBUG_LOG' ) ) {
  define('WP_DEBUG_LOG', ABSPATH . '/wp-content/' . date('Y-m-d', strtotime('now')) . '-debug.log');
}

if ( ! defined( 'WP_DEVELOPMENT_MODE' ) ) {
  define('WP_DEVELOPMENT_MODE', 'all');
}
</code></pre></details><details><summary class="menu__submenu">block</summary><details><summary>Создать блок</summary><p>Создать блок</p><code>npx @wordpress/create-block kweblock --namespace=kweb --variant=dynamic</code><p>Чтобы добавить ещё блок добавить --no-plugin</p><p>Автоформат добавить в package.json</p><code>"prettier": "@wordpress/prettier-config"</code><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/registration-of-a-block/--><p><dfn>register_block_type()</dfn> - регистрация нового блока php,<br>
возвращает WP_Block_Type, с данными:<br>
$attributes: Массив атрибутов блока.<br>
$content: разметка блока, хранящаяся в базе данных, если таковая имеется.<br>
$block: Экземпляр класса WP_Block, который представляет отображаемый блок (метаданные блока).<br>
генерит разметку на фронте либо<br>
render_block и render_callback() указывают что отобразить<br>
<dfn>registerBlockType()</dfn> - регистрация нового блока index.js (@wordpress/blocks),<br>
возвращает WPBlock и регистрирует edit.js в редакторе<br>
<dfn>wp_register_script()</dfn> - регистрация скрипта, пакет @wordpress/scripts<br>
<dfn>wp_register_style()</dfn> - регистрация стиля
</p><p>установить @wordpress/scripts отдельно</p><code>npm install --save-dev @wordpress/scripts</code><p>добавить скрипты в package.json</p><pre><code>"scripts": {
  "build": "wp-scripts build",
  "format": "wp-scripts format",
  "lint:js": "wp-scripts lint-js",
  "start": "wp-scripts start"
}</code></pre><p>Минимальный набор:<br>
в папке wp-content/plugins/my-app создать<br>
- my-app.php – для создания страницы плагина<br>
- src/index.js – для JavaScript-приложения<br>
- src/style.css – для стилей<br>
- package.json – для процесса сборки<br>
В файле package.json<br></p><pre><code>{
  "name": my-app",
  "version": "1.1.0",
  "private": true,
  "description": "My App",
  "author": "Me",
  "license": "GPL-2.0-or-later",
  "keywords": [
    "WordPress",
    "block"
  ],
  "homepage": "https://github.com/WordPress/gutenberg-examples/",
  "repository": "git+https://github.com/WordPress/gutenberg-examples.git",
  "bugs": {
    "url": "https://github.com/WordPress/gutenberg-examples/issues"
  },
  "main": "build/index.js",
  "devDependencies": {
    "@wordpress/scripts": "^24.0.0"
  },
  "scripts": {
    "build": "wp-scripts build",
    "format": "wp-scripts format",
    "lint:js": "wp-scripts lint-js",
    "packages-update": "wp-scripts packages-update",
    "start": "wp-scripts start"
  }
}
</code></pre><p>регистрирую блок в index.js<br>
переопределять реализацию save() не нужно<br>
edit() отображает блок в редакторе</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useSelect } from '@wordpress/data';
import { useBlockProps } from '@wordpress/block-editor';

registerBlockType( 'gutenberg-examples/example-dynamic', {
  apiVersion: 3,
  title: 'Example: last post',
  icon: 'megaphone',
  category: 'widgets',

  edit: () => {
    const blockProps = useBlockProps();
    const posts = useSelect( ( select ) => {
      return select( 'core' ).getEntityRecords( 'postType', 'post' );
    }, [] );

    return (
      &lt;div { ...blockProps }&gt;
        { ! posts && 'Loading' }
        { posts && posts.length === 0 && 'No Posts' }
        { posts && posts.length > 0 && (
          &lt;a href={ posts[ 0 ].link }&gt;
            { posts[ 0 ].title.rendered }
          &lt;/a&gt;
        ) }
      &lt;/div&gt;
    );
  },
} );</code></pre><p>регистрирую блок в plugin.php<br>
разметку возвращаю из gutenberg_examples_dynamic_render_callback()</p><pre><code>&lt;?php
/**
* Plugin Name: Gutenberg examples dynamic
*/
function gutenberg_examples_dynamic_render_callback( $block_attributes, $content ) {
  $recent_posts = wp_get_recent_posts( array(
    'numberposts' => 1,
    'post_status' => 'publish',
  ) );
  if ( count( $recent_posts ) === 0 ) {
    return 'No posts';
  }
  $post = $recent_posts[ 0 ];
  $post_id = $post['ID'];
  return sprintf(
    '&lt;a class="wp-block-my-plugin-latest-post" href="%1$s"&gt;%2$s&lt;/a&gt;',
    esc_url( get_permalink( $post_id ) ),
    esc_html( get_the_title( $post_id ) )
  );
}

function gutenberg_examples_dynamic() {
  <span>automatically load dependencies and version</span>
  $asset_file = include( plugin_dir_path( __FILE__ ) . 'build/index.asset.php');
  wp_register_script(
    'gutenberg-examples-dynamic',
    plugins_url( 'build/block.js', __FILE__ ),
    $asset_file['dependencies'],
    $asset_file['version']
  );
  register_block_type( 'gutenberg-examples/example-dynamic', array(
    'api_version' => 3,
    'editor_script' => 'gutenberg-examples-dynamic',
    'render_callback' => 'gutenberg_examples_dynamic_render_callback'
  ) );
}
add_action( 'init', 'gutenberg_examples_dynamic' );</code></pre><p>Рендеринг на стороне сервера рассматривается как запасной вариант;<br>
рендеринг на стороне клиента в JavaScript всегда предпочтительнее;<br>
использует пакет wp-server-side-render</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import ServerSideRender from '@wordpress/server-side-render';
import { useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-dynamic', {
  apiVersion: 3,
  title: 'Example: last post',
  icon: 'megaphone',
  category: 'widgets',
  edit: function ( props ) {
    const blockProps = useBlockProps();
    return (
      &lt:div { ...blockProps }&gt;
        &lt:ServerSideRender
          block="gutenberg-examples/example-dynamic"
          attributes={ props.attributes }
        /&gt;
      &lt:/div&gt;
    );
  },
} );
</code></pre></details><details><summary>InnerBlocks</summary><p>один блок может содержать только один InnerBlocks компонент.</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { InnerBlocks, useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-06', {
  // ...
  edit: () => {
    const blockProps = useBlockProps();
    return (
      &lt;div { ...blockProps }&gt;
        &lt;InnerBlocks /&gt;
      &lt;/div&gt;
    );
  },
  save: () => {
    const blockProps = useBlockProps.save();
    return (
      &lt;div { ...blockProps }&gt;
        &lt;InnerBlocks.Content /&gt;
      &lt;/div&gt;
    );
  },
} );</code></pre><p>ограничитель какие блоки могут быть прямыми потомками</p><pre><code>const { allowedBlocks } = attributes;
//...
&lt;InnerBlocks allowedBlocks={ allowedBlocks } /&gt;;</code></pre><p>allowedBlocks - указывает какие потомки могут быть прямыми потомками<br>
parent - для вложенного блока, может быть только прямым потомком<br>
ancestor - для вложенного блока, может быть только потомком</p><pre><code>{
  "title": "Column",
  "name": "core/column",
  "parent": [ "core/columns" ],
}
//...
{
  "title": "Comment Author Name",
  "name": "core/comment-author-name",
  "ancestor": [ "core/comment-template" ],
}
//...
{
  "title": "Navigation",
  "name": "core/navigation",
  "allowedBlocks": [ "core/navigation-link", "core/search", "core/social-links", "core/page-list", "core/spacer" ],
}</code></pre><p>useInnerBlocksProps - хук для большего контроля над разметкой внутренних областей блоков</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useBlockProps, useInnerBlocksProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-06', {
  edit: () => {
    const blockProps = useBlockProps();
    const { children, ...innerBlocksProps } = useInnerBlocksProps( blockProps );
    return (
      &lt;div {...innerBlocksProps}&gt;
        { children }
        <!-- Insert any arbitrary html here at the same level as the children -->
      &lt;/div&gt;
    );
  },
} );</code></pre><p>по умолчанию блоки в InnerBlocks отображаются вертикально<br>
горизонтально их ориентировать с помощью css</p><code>&lt;InnerBlocks orientation="horizontal" /&gt;</code><p>отображает значки перемещения блоков в дочерних блоках горизонтально и обеспечивает правильную работу перетаскивания.</p><p>блок по умолчанию из списка дозволенных</p><code>&lt;InnerBlocks defaultBlock={['core/paragraph', {placeholder: "Lorem ipsum..."}]} directInsert /&gt;</code><p>набор блоков, которые предварительно заполняют компонент InnerBlocks, пока нет своего содержимого.</p><pre><code>const MY_TEMPLATE = [
  [ 'core/image', {} ],
  [ 'core/heading', { placeholder: 'Book Title' } ],
  [ 'core/paragraph', { placeholder: 'Summary' } ],
];
//...
edit: () => {
  return (
    &lt;InnerBlocks
      template={ MY_TEMPLATE }
      templateLock="all"
    /&gt;
  )&gt;
},</code></pre><p>templateLock - свойство, чтобы заблокировать шаблон</p><!-- https://github.com/WordPress/gutenberg/tree/HEAD/packages/block-editor/src/components/inner-blocks/README.md#templatelock--></details><details><summary>Изменить блок</summary><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/javascript-in-the-block-editor/--><p>Создать файл webpack.config.js и добавить свой код для выполнения webpack</p><pre><code>const defaultConfig = require("@wordpress/scripts/config/webpack.config");
var config = {
  ...defaultConfig,
  entry: {
    ...defaultConfig.entry(),
    "custom/index": "./src/custom/index.js",
  },
};</code></pre><p>Внутри папки src создать папку custom и в ней файл index.js</p><pre><code>import { unregisterBlockType } from "@wordpress/blocks";
import domReady from "@wordpress/dom-ready";
const unregisterBlocks = ["core/verse"];
domReady(function () {
  unregisterBlocks.forEach(block) => {
    unregisterBlockType(block);
  });
});</code></pre><p>В файле kweblock.php добавить код для подключения функционала из custom/index.js</p><pre><code>function kweblock_enqueue_editor_modifications() {
  $asset_file = include plugin_dir_path( __FILE__ ) . 'build/custom/index.assets.php';
  wp_enqueue_script(
    'kweblock_enqueue_editor_modifications',
    plugins_url( '/build/custom/index.js', __FILE__ ),
    $asset_file['dependencies'],
    $asset_file['version'],
    true
  );
}
add_action( 'enqueue_block_editor_assets', 'kweblock_enqueue_editor_modifications' );</code></pre><!-- new variation for the Media & Text block--><pre><code>function example_enqueue_block_variations() {
  wp_enqueue_script(
    'example-enqueue-block-variations',
    get_template_directory_uri() . '/assets/js/variations.js',
    array( 'wp-blocks' ),
    wp_get_theme()->get( 'Version' ),
    false
  );
}
add_action( 'enqueue_block_editor_assets', 'example_enqueue_block_variations' );</code></pre><!-- in variations.js file:--><pre><code>wp.blocks.registerBlockVariation(
  'core/media-text',
  {
    name: 'media-text-custom',
    title: 'Media & Text Custom',
    attributes: {
      align: 'wide',
      backgroundColor: 'tertiary'
    },
  }
);</code></pre><p>создать шаблон блока типа post сразу с подгрузкой других блоков</p><pre><code>add_action( 'init', function() {
  $post_type_object = get_post_type_object( 'post' );
  $post_type_object->template = array(
    array( 'core/image' ),
    array( 'core/heading' )
  );
} );</code></pre><!-- https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/extending-the-query-loop-block/--><a href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-variations/">Вариации Query Loop block</a><p>Для того чтобы вариация цикла запросов работала правильно, нам необходимо:
– Зарегистрировать вариацию блока для core/query блока с некоторыми значениями по умолчанию
– Определить макет для вариации блока
– Использовать namespaceатрибут в isActiveсвойстве вариации блока</p><pre><code>const MY_VARIATION_NAME = 'my-plugin/books-list';
registerBlockVariation( 'core/query', {
  name: MY_VARIATION_NAME,
  title: 'Books List',
  description: 'Displays a list of books',
  <span>указываю активную вариацию, можно итак: isActive: [ 'namespace' ],</span>
  isActive: ( { namespace, query } ) => {
    return (
      namespace === MY_VARIATION_NAME
      && query.postType === 'book'
    );
  },
  icon: <span>An SVG icon can go here</span>,
  attributes: {
    namespace: MY_VARIATION_NAME,
    query: {
      perPage: 6,
      pages: 0,
      offset: 0,
      <span>предопределил тип записи для цикла запросов</span>
      postType: 'book',
      order: 'desc',
      orderBy: 'date',
      author: '',
      search: '',
      exclude: [],
      sticky: '',
      inherit: false,
    },
  },
  <span>включил отображение блока в редакторе</span>
  scope: [ 'inserter' ],
  }
);</code></pre><p>Блок Query Loop определяет, есть ли активная вариация и есть ли для неё шаблоны.<br>
Если есть, то эти шаблоны будут единственными, если нет - шаблоны по умолчанию.</p><a href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-patterns/">привязать шаблон</a><p>отключить элементы управления запросами allowedControls<br>
inherit – переключатель наследованияя запроса непосредственно из шаблона.<br>
postType – список доступных типов сообщений.<br>
order – список для выбора порядка запроса.<br>
sticky – список для выбора способа обработки прикрепленных сообщений.<br>
taxQuery – фильтры таксономий для текущего выбранного типа записи.<br>
author – Показывает поле ввода для фильтрации запроса по автору.<br>
search – Показывает поле ввода для фильтрации запроса по ключевым словам.<br>
format – Показывает поле ввода для фильтрации запроса по массиву/коллекции форматов .<br>
parents – Показывает поле ввода для фильтрации запроса с использованием родительской(их) сущности(ей).</p><pre><code>{
  <span>variation properties</span>
  allowedControls: [ 'inherit', 'order', 'taxQuery', 'search' ],
}</code></pre><p>пустой массив скроет все элементы управления<br>
<br>
Подключить пользовательские элементы управления через хук React подключенный к фильтру блока</p><pre><code>import { InspectorControls } from '@wordpress/block-editor';
export const withBookQueryControls = ( BlockEdit ) => ( props ) => {
  <span>We only want to add these controls if it is our variation,</span>
  <span>so here we can implement a custom logic to check for that, similar</span>
  <span>to the `isActive` function described above.</span>
  <span>The following assumes that you wrote a custom `isMyBooksVariation`</span>
  <span>function to handle that.</span>
  return isMyBooksVariation( props ) ? (
    &lt;&gt;
      &lt;BlockEdit key="edit" { ...props } /&gt;
      &lt;InspectorControls&gt;
        &lt;BookAuthorSelector /&gt; { /** Our custom component */ }
      &lt;/InspectorControls&gt;
    &lt;/&gt;
  ) : (
    &lt;BlockEdit key="edit" { ...props } /&gt;
  );
};
addFilter( 'editor.BlockEdit', 'core/query', withBookQueryControls );</code></pre><p>Подключить пользовательские элементы управления через фильтр query_loop_block_query_vars</p><pre><code>{
  <span>variation properties</span>
  attributes: {
    <span>variation attributes</span>
    query: {
      <span>more query settings if needed</span>
      postType: 'book',
      <span>Our custom query parameter</span>
      bookAuthor: 'J. R. R. Tolkien'
    }
  }
}</code></pre><p>подключаюсь к фильтру на фронте (когда есть доступ к блоку)</p><pre><code>if( 'my-plugin/books-list' === $block[ 'attrs' ][ 'namespace' ] ) {
  add_filter(
    'query_loop_block_query_vars',
    function( $query ) {
      <span>You can read your block custom query parameters here and build your query</span>
    },
  );
}</code></pre><p>подключаюсь к запросу API записи в редакторе через фильтр rest_{$this->post_type}_query</p><pre><code>add_filter(
  'rest_book_query',
  function( $args, $request ) {
    <span>We can access our custom parameters from here</span>
    $book_author = $request->get_param( 'bookAuthor' );
    <span>your custom query logic</span>
  }
);</code></pre><!-- https://developer.wordpress.org/block-editor/reference-guides/filters/block-filters/--><p>изменить поведение или отключить блок</p><!-- https://developer.wordpress.org/block-editor/reference-guides/packages/packages-plugins/--><!-- https://developer.wordpress.org/block-editor/reference-guides/packages/packages-edit-post/--><p>registerPlugin - определить все элементы пользовательского интерфейса плагина в одном месте</p><!-- https://developer.wordpress.org/block-editor/reference-guides/filters/editor-filters/--><p>отфильтровать редактор</p></details><details><summary>CSS</summary><!-- https://github.com/WordPress/block-development-examples--><p>Inline style - передаю стили в хук React useBlockProps</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-02-stylesheets', {
  edit() {
    const greenBackground = {
      backgroundColor: '#090',
      color: '#fff',
      padding: '20px',
    };
    const blockProps = useBlockProps( { style: greenBackground } );
    return (
      &lt;p { ...blockProps }&gt;Hello World (from the editor, in green).&lt;/p&gt;
    );
  },
  save() {
    const redBackground = {
      backgroundColor: '#900',
      color: '#fff',
      padding: '20px',
    };
    const blockProps = useBlockProps.save( { style: redBackground } );
    return (
      &lt;p { ...blockProps }&gt;Hello World (from the frontend, in red).&lt;/p&gt;
    );
  },
} );</code></pre><!-- useBlockProps - обёртка блока--><!-- https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#block-wrapper-props--><p>Хук useBlockProps автоматически включает имя класса для блока,
генерирует имя для каждого блока, используя имя блока с префиксом wp-block-,
заменет / разделитель пространства имен символом -.</p><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/block-in-the-editor/--><p><dfn>useBlockProps()</dfn> - позволяет изменить аттрибуты в оболочке блока,
определяет внешнюю разметку блока в редакторе
(это хук из @wordpress/block-editor)
<dfn>useBlockProps.save()</dfn> - добавляет классы и атрибуты при сохранении в базу
<dfn>get_block_wrapper_attributes()</dfn> - добавляет классы и атрибуты при динамическом рендере
wp-block - класс с общими для блоков настройками</p><!-- то же самое, но через отдельные файлы--><p>block.json</p><pre><code>{
  "apiVersion": 3,
  "name": "gutenberg-examples/example-02-stylesheets",
  "title": "Example: Stylesheets",
  "icon": "universal-access-alt",
  "category": "layout",
  "editorScript": "file:./block.js",
  "editorStyle": "file:./editor.css",
  "style": "file:./style.css"
}</code></pre><p>editor.css - green background</p><pre><code>.wp-block-gutenberg-examples-example-02-stylesheets {
  background: #090;
  color: white;
  padding: 20px;
}</code></pre><p>style.css - red background</p><pre><code>.wp-block-gutenberg-examples-example-02-stylesheets {
  background: #900;
  color: white;
  padding: 20px;
}</code></pre><p>Если использовать `@wordpress/scripts`, то необходимо импортировать таблицу стилей в соответствующий файл JavaScript<br>
В `edit.js` - `import './editor.scss';`<br>
В `index.js` - `import './style.scss';`<br>
В `view.js` - `import './view.scss';`</p><p>для включения нескольких файлов использовать wp_enqueue_style на хуках:<br>
enqueue_block_editor_assets – загружать только в режиме редактора<br>
enqueue_block_assets – загружается как в интерфейсе, так и в редакторе<br>
переменная стиля из theme.json в style.scss:</p><code>var(--wp--preset--color--contrast)</code><p>переменная стиля из theme.json в json файле:</p><code>var:preset|color|contrast</code></details><details><summary>Editor</summary><p>@wordpress/block-editor - пакет позволяет создавать автономные редакторы блоков,
библиотека JavaScript, которая обеспечивает основную функциональность редактора.</p><a href="https://developer.wordpress.org/block-editor/how-to-guides/platform/custom-block-editor/">Собственный редактор блоков</a><p>@wordpress/components and @wordpress/block-editor - пакеты для редактора<br>
для отдельной установки:</p><code>npm install --save @wordpress/components</code><p>storybook - https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page<br>
Block Toolbar - компонент BlockControls (@wordpress/block-editor)<br>
Settings Sidebar - компонент InspectorControls (@wordpress/block-editor)<br>
CSS компонентов находится по адресу node_modules/@wordpress/components/build-style/style.css<br>
в консоле браузера wp.data.select('core/editor').getBlocks() - вернет все доступные блоки
</p></details><details><summary>Работа с данными</summary><p>@wordpress/core-data - предоставляет resolvers, selectors и actions для работы с API ядра WordPress
</p></details></details><details><summary class="menu__submenu_lv1">jQuery</summary><p>(function( $ ) {alert($.fn.jquery);}) - проверить версию<br>
<br>
Подключить<br></p><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;</code><p><b>compressed</b> - сжатая и минифицированная, поключают к готовому сайту<br>
<b>uncompressed</b> - обычная, удобочитаемая, поключают при разработке<br>
<b>slim</b> - без анимации и без Ajax<br>
<br>
<em>Скрипт</em></p><pre><code><span>запускать скрипт только после загрузки страницы</span>
$(document).ready(function() {
  <span>при нажатии кнопки</span>
  $("button").on("click", function() {
    <span>скрыть заголовок в течении 3-х секунд</span>
    $("h1").hide(3000);
  });
});</code></pre><br><p><em>Селекторы</em> - все как в CSS</p><pre><code>$('a'); = document.querySelectorAll("a");
$('sel').method();

<span>выбрать элементы по атрибуту - target</span>
$('a[target]');

<span>выбрать элементы с атрибутом target равное _blank</span>
$('a[target="_blank"]')</code></pre><br><p>По элементам форм:<br>
:button<br>
:password<br>
:disabled<br>
:file<br>
<br>
CSS</p><code>$("p").css("background-color", "#2ecc71");</code><br><p>Пример:<br>
&lt;a href="https://ya.ru" target="_blank" title="Переход на Яндекс"&gt;Yandex&lt;/a&gt<br>
<br>
Выбрать элементы, у которых значение атрибута:<br>
<b>$('a[href^="https"]')</b> - href начинается с https<br>
<b>$('a[href$=".ru"]')</b> - href заканчивается на .ru<br>
<b>$('a[title~="Яндекс"]')</b> - title содержит слово Яндекс<br>
<b>$('a[title*="epe"]')</b> - title содержит подстроку ере<br>
<b>$('a[href!="https://www.google.com"]')</b> - выберет элементы, у которых либо нет указанного атрибута, либо у атрибута другое значение
<br>
<em>Фильтры</em><br>
<b>$("li:first").css("color", "green")</b>;<br> 
- <b>:first, :last, :even, :odd</b> - первый, последний, чётный, нечётный из выборки<br>
- <b>:eq(), :gt(), :lt()</b> - индексы элемнтов выборки<br>
- <b>:root, :header, :focus, :lang()</b>, :target - HTML-элементы<br>
- <b>:not()</b>, :animated - отрицанние и анимирование<br>
<br>
<b>$("li").filter(":first").css("color", "green")</b>; - :first - не является частью языка css, поэтому через метод filter()</p><br><a href="https://jquery.com">jQuery</a><a href="https://www.w3schools.com/jquery/default.asp">W3schools</a><a href="https://core.trac.wordpress.org/query">Wordpress jQuery</a></details></details><details><summary class="menu__submenu_lv1">Laravel</summary><details><summary>Framework</summary><details><summary>Concepts</summary><p>Laravel - это фреймворк MVC, который использует шаблон проектирования MVC (Model-View-Controller).<br>
Он разделяет приложение на три основных компонента:<br>
- Модель (Model) - отвечает за работу с данными и бизнес-логикой приложения.<br>
- Представление (View) - отвечает за отображение данных пользователю.<br>
- Контроллер (Controller) - связывает модель и представление, обрабатывает запросы и управляет логикой приложения.<br>
- Создается экземпляр приложения, регистрируются сервис-провайдеры, запрос передается приложению для обработки.<br>
<br>
Шаг 1: создать приложение<br>
Веб-сервер (Apache / Nginx) направляет запрос из браузера в public/index.php, который запускает автозагрузчик.<br>
Автозагрузчик создаёт экземпляр приложения: создаёт сервис-контейнер и регистрирует в нём всех сервис-провайдеров из bootstrap/app.php.<br>
<br>
Шаг 2: настроить приложение<br>
Метод экземпляра приложения handleRequest передаёт запрос HTTP-ядру, а метод handleCommand - ядру консоли.<br>
HTTP-ядро/ядро консоли получает запрос, передаёт его по маршруту через посредников в обработку и возвращает браузеру ответ.<br>
HTTP-ядро определяет массив загрузчиков (bootstrappers), которые необходимо выполнить до обработки запроса.<br>
Массив загрузчиков (bootstrappers) настраивают обработку ошибок, логирование, определяют среду окружения, конфигурации и стек посредников.<br>
Маршрутизатор вернет либо ответ либо отправит запрос на обработку в консоль или контроллер и запустит посредник для маршрута.<br>
<br>
Шаг 3: обработка запроса<br>
Стек посредников фильтрует запросы и ответы (Middlewares), обрабатывают чтение и запись сеанса HTTP (Session),
определяет, находится ли приложение в режиме обслуживания, проверяет токен CSRF.<br>
Middleware либо отклонит запрос и перенаправит пользователя либо позволит запросу продолжить работу в приложении.<br>
Middleware позволяет внести изменения и провести проверки ответа.<br>
Ответ из middleware поступает в метод handle HTTP-ядра, который вызовит метод send для ответа.<br>
Метод send отправит содержимое ответа в веб-браузер пользователя.<br>
</p></details><details><summary>Service provider</summary><p>Автозагрузчик для каждого провайдера по списку из bootstrap/app.php, создаст его экземпляр, вызовет метод register и метод boot.<br>
Сервис-провайдеры отвечают за начальную настройку компонентов фреймворка: база данных, очереди, валидация, маршрутизация и т.д.<br>
Сервис-провайдеры инициализируют и настраивают множество функций, предоставляемых фреймворком.<br>
Список пользовательских или сторонних сервис-провайдеров в bootstrap/providers.php<br>
Пользовательские сервис-провайдеры хранятся в каталоге app/Providers.<br>
Провайдер по умолчанию AppServiceProvider для добавления собственной инициализации и связываний контейнера служб приложения.<br>
</p></details><details><summary>Service container</summary><p></p></details><details><summary>Facades</summary><p>Фасады - статический интерфейс для классов, доступных в контейнере служб приложения.
</p></details><details><summary>Helpers</summary><p></p><pre><code></code></pre></details><details><summary>Folder structure</summary><p>- app - основная папка приложения, код приложения<br>
- bootstrap - начальная загрузка приложения и кеширование<br>
- config - конфигурация приложения<br>
- database - миграции, фабрики, наполнители (seeders), sqlite<br>
- public - публичная папка приложения, точка входа всех запросов: index.php, оптимизированные ресурсы и автозагрузка<br>
- resources - неотимизированные и нескомпилированные ресурсы: шаблоны, images, js, css<br>
- routes - маршруты приложения на указанный метод<br>
- storage - временные файлы приложения: логи, скомпилированные шаблоны, файлы сессий и кеша<br>
- tests - тесты приложения<br>
- vendor - сomposer-зависимости приложения<br>
- node_modules - node-зависимости приложения<br>
- .gitignore - файл игнорирования git<br>
- .gitattributes - файл атрибутов git<br>
- .dockerignore - файл игнорирования docker<br>
- .docker-compose.yml - файл конфигурации docker<br>
- .env - файл окружения приложения<br>
- .env.example - пример файла окружения приложения<br>
- .editorconfig - файл конфигурации редактора<br>
- artisan - консольная команда приложения<br>
- composer.json - файл сomposer-зависимостей приложения<br>
- package.json - файл node-зависимостей приложения<br>
- phpunit.xml - файл конфигурации тестов приложения<br>
- vite.config.js - файл конфигурации vite приложения<br>
Жизненный цикл:<br>
- Браузер - запрос пользователя<br>
- Apache / Nginx - веб сервер<br>
- public/index.php - загружает автозагрузчик<br>
- bootstrap/app.php - создаёт экземпляр фреймворка<br>
- laravel - создаёт экземпляр приложения и сервис-контейнер (регистрация всех сервис-провайдеров bootstrap/providers.php)<br>
- НТТР-ядро - запрос поступает НТТР-ядру (либо ядру консоли)<br>
- bootstrappers - массив загрузчиков для обработки ошибок, логирования, среда окружения, middleware<br>
- маршрутизатор - направляет запрос на указанный метод по маршруту<br>
- middleware - фильтрация НТТР-запросов<br>
- контроллер или представление - выполнение метода<br>
- middleware - фильтрация НТТР-ответов<br>
- НТТР-ядро - возвращает объект ответа в экзепмляр приложения<br>
- экземляр приложения - отправляет содержимое ответа в браузер<br>
- Браузер - рендеринг ответа<br></p><pre><code>Браузер
  Apache / Nginx -> public/index.php -> bootstrap/app.php
    laravel -> экземляр приложения
      НТТР-ядро -> bootstrappers
        маршрутизатор
          middleware
            контроллер -> представление
          middleware
      НТТР-ядро
    экземляр приложения
Браузер
</code></pre></details><details><summary>Create app</summary><pre><code>php artisan list    // списка всех доступных команд Artisan
php artisan help migrate    // вызвать справку
php artisan tinker    // взаимодействовать с приложением из командной строки
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"    // конфигурационный файл Tinker
'commands' => [App\Console\Commands\ExampleCommand::class]    // добавление команд в config/tinker.php
'dont_alias' => [App\Models\User::class]    //    черный список псевдонимов классов в config/tinker.php
php artisan make:command SendEmails   // сгенерировать новую команду в app/Console/Commands
- определить команду artisan в виде класса
namespace App\Console\Commands;
use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Console\Command;
class SendEmails extends Command {
  protected $signature = 'mail:send {user}';    // имя команды и вводимые данные
  protected $description = 'Отправка письма пользователю';  // описание команды для list
  public function handle(DripEmailer $drip): void
  {$drip->send(User::find($this->argument('user')));}}    // выполнение команды
- коды завершения команды:
0 - команда выполнена успешно
// вернуть ошибку из public function handle()
$this->error('Что-то пошло не так.');
return 1;
// прервать выполнение комады и вернуть код завершения 1
$this->fail('Что-то пошло не так.');
- определить команду artisan в routes/console.php
Artisan::command('mail:send {user}', function (string $user) {$this->info("Отправка почты на: {$user}!");});
- типизация зависимостей
use App\Models\User;
use App\Support\DripEmailer;
Artisan::command('mail:send {user}', function (DripEmailer $drip, string $user) {$drip->send(User::find($user));});
- добавить описание команды
Artisan::command('mail:send {user}', function (string $user) { })->purpose('Отправка письма пользователю');
- изолированные команды: одновременно выполняется только один экземпляр команды
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Contracts\Console\Isolatable;
class SendEmails extends Command implements Isolatable { }
// выполнить изолированную команду: блокировка других экземпляров этой команды в кэш-драйвере
php artisan mail:send 1 --isolated
// указать код статуса завершения, если команда не может выполниться
php artisan mail:send 1 --isolated=12
// задать id команды для изоляции в кэше (по умолчанию - имя команды)
public function isolatableId(): string {return $this->argument('user');}
// время блокировки истекает либо по завершению команды либо через час после прерывания выполнения команды
  настроить время блокировки
use DateTimeInterface;
use DateInterval;
public function isolationLockExpiresAt(): DateTimeInterface|DateInterval {return now()->addMinutes(5);}
- вводимые данные (использовать пакет Prompts)
protected $signature = 'mail:send {user}';    // один обязательный аргумент user
protected $signature = 'mail:send {user?}';    // один необязательный аргумент user
protected $signature = 'mail:send {user=foo}';    // один необязательный аргумент user со значением по умолчанию
protected $signature = 'mail:send {user} {--queue}';    // параметр {--queue} как логический переключатель
php artisan mail:send 1   // вызов команды: user = 1, --queue = false
php artisan mail:send 1 --queue   // вызов команды: user = 1, --queue = true
protected $signature = 'mail:send {user} {--queue=}';   //  параметр {--queue=} ожидает значение
php artisan mail:send 1   // вызов команды: user = 1, --queue = null
php artisan mail:send 1 --queue=foo   // вызов команды: user = 1, --queue = foo
protected $signature = 'mail:send {user} {--queue=default}';   // параметр --queue со значением по умолчанию
protected $signature = 'mail:send {user} {--Q!queue}';   // назначить псевдоним Q для параметра --queue
php artisan mail:send 1 -Qfoo  // вызов команды: user = 1, --queue = foo
- назначить описания входным аргументам и параметрам
protected $signature = 'mail:send {user : Идентификатор пользователя} {--queue : Поставить ли задание в очередь}';
- массивы вводимых данных
protected $signature = 'mail:send {user*}'    // аргумент ожидает массив данных
php artisan mail:send 1 2   // вызов команды: user = [1, 2]
protected $signature = 'mail:send {user?*}'    // необязательный аргумент ожидает массив данных
protected $signature = 'mail:send {--id*}'    // параметр ожидает массив данных
php artisan mail:send --id=1 --id=2   // вызов команды: id = [1, 2]
- запрос отсутствующего ввода
// запросить у пользователя ввод значения аргумента
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Contracts\Console\PromptsForMissingInput;
class SendEmails extends Command implements PromptsForMissingInput {
  protected $signature = 'mail:send {user}';}
// настроить вопрос для пользователя
protected function promptForMissingArgumentsUsing(): array {
  return ['user' => 'Какой идентификатор пользователя должен получать почту?'];}
// настроить вопрос для пользователя с заполнителем
return ['user' => 'Какой идентификатор пользователя должен получать почту?', 'Например: 123'];}
// полный контроль запроса на ввод данных пользователем
use App\Models\User;
use function Laravel\Prompts\search;
return [
  'user' => fn () => search(
    label: 'Найдите пользователя:',
    placeholder: 'Например: Тейлор Отвелл',
    options: fn ($value) => strlen($value) > 0
      ? User::where('name', 'like', "%{$value}%")->pluck('name', 'id')->all() : [])];
// запрашивать у пользователя только после автоматического запроса ввести отсутствующие аргументы
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use function Laravel\Prompts\confirm;
protected function afterPromptingForMissingArguments(InputInterface $input, OutputInterface $output): void {
  $input->setOption('queue', confirm(
    label: 'Хотите поставить почту в очередь?',
    default: $this->option('queue')));}
- получить доступ к значениям введенных аргументов и параметров (методы argument и option)
public function handle(): void {$userId = $this->argument('user');}
$arguments = $this->arguments();    // получить все аргументы в виде массива
$queueName = $this->option('queue');    // получить параметр
$options = $this->options();    // получить массив
// запросить у пользователя данные во время выполнения команды
public function handle(): void {$name = $this->ask('Как вас зовут?');}
$name = $this->ask('Как вас зовут?', 'Тейлор');   // со значением по умолчанию
$password = $this->secret('Какой пароль?');   // вводимые символы не отображаются
if ($this->confirm('Хотите продолжить?')) { }   // запрос подтверждения «yes or no»
if ($this->confirm('Хотите продолжить?', true)) { }   // со значением по умолчанию
// возможные варианты автоматического завершения
$name = $this->anticipate('Как вас зовут?', ['Тейлор', 'Дэйл']);
// принимать введенные пользователем данные, и возвращать массив вариантов для автозавершения
$name = $this->anticipate('Какой у вас адрес?', function (string $input) { // возврнуть массив вариантов... });
// предопределенный набор вариантов 
$name = $this->choice(
  'Как вас зовут?',       // вопрос пользователю
  ['Тейлор', 'Дэйл'],     // массиив предопределенных вариантов
  $defaultIndex,          // индекс значения по умолчанию из массива вариантов
  $maxAttempts = null,    // максимальное количество попыток
  $allowMultipleSelections = false);    // множественный выбор
- вывод данных в консоль (методы line, info, comment, question, warn и error)
public function handle(): void {$this->info('Команда выполнена успешно!');}
$this->error('Something went wrong!');
$this->line('Отобразить это на экране');
$this->newLine();   // отобразить пустую строку
$this->newLine(3);   // отобразить 3 пустые строки
// форматирование нескольких строк / столбцов данных ('Name', 'Email' - имена столбцов)
use App\Models\User;
$this->table(['Name', 'Email'], User::all(['name', 'email'])->toArray());
// отображать индикатор выполнения
use App\Models\User;
$users = $this->withProgressBar(User::all(), function (User $user) {$this->performTask($user);});
// настроить индикатор вручную
$users = App\Models\User::all();
$bar = $this->output->createProgressBar(count($users));
$bar->start();
foreach ($users as $user) {
  $this->performTask($user);
  $bar->advance();}
$bar->finish();
- в bootstrap/app.php
// сканировать каталоги на наличие команд (по умолчанию в app/Console/Commands)
->withCommands([__DIR__.'/../app/Domain/Orders/Commands'])
// зарегистрировать команду вручную
use App\Domain\Orders\Commands\SendEmails;
->withCommands([SendEmails::class])
- запустить команду Artisan в маршруте или контроллере
use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function (string $user) {
  $exitCode = Artisan::call('mail:send', ['user' => $user, '--queue' => 'default']);});
либо
Artisan::call('mail:send 1 --queue=default');
либо с массивом
Route::post('/mail', function () {$exitCode = Artisan::call('mail:send', ['--id' => [5, 13]]);});
либо с логическим переключателем
$exitCode = Artisan::call('migrate:refresh', ['--force' => true,]);
- поставить команды Artisan в очередь для обработки в фоновом режиме
use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function (string $user) {
  Artisan::queue('mail:send', ['user' => $user, '--queue' => 'default']);});
// указать соединение или очередь, в которую должна быть отправлена команда
Artisan::queue('mail:send', ['user' => 1, '--queue' => 'default'])
  ->onConnection('redis')->onQueue('commands');
// вызвать другие команды из существующей
public function handle(): void {$this->call('mail:send', ['user' => 1, '--queue' => 'default']);}
// вызвать команду в тихом режиме
$this->callSilently('mail:send', ['user' => 1, '--queue' => 'default']);
- прослушивать сигналы операционных систем в командах Artisan и выполнять код при их возникновении
public function handle(): void {
  $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);
  while ($this->shouldKeepRunning) { }}
// прослушивания нескольких сигналов сразу
$this->trap([SIGTERM, SIGQUIT], function (int $signal) {
  $this->shouldKeepRunning = false;
  dump($signal);});
- опубликовать заготовки создания классов командой make для их изменения
php artisan stub:publish
- Artisan запускает три события при выполнении команд:
Illuminate\Console\Events\ArtisanStarting - после запуска Artisan
Illuminate\Console\Events\CommandStarting - перед запуском команды
Illuminate\Console\Events\CommandFinished - после завершения команды
</code></pre></details><details><summary>Create app</summary><pre><code>laravel new example-app
cd example-app
php artisan sail:install</code></pre><p>добавить псевдоним в ~/.zshrc</p><pre><code>alias sail='zsh $([ -f sail ] && echo sail || echo vendor/bin/sail)'
alias sailar='zsh $([ -f sail ] && echo sail artisan || echo vendor/bin/sail artisan)'
sailar list
sail up -d
sailar migrate
http://localhost</code></pre><p>остановить контейнеры</p><code>sail stop </code><p>удалить контейнеры</p><code>sail down</code><p>удалить контейнеры и тома</p><code>sail down -v</code><p>удалить контейнеры, тома и образы</p><code>sail down --rmi all</code><p>удалить только тома</p><code>sail down --volumes</code><p>удалить контейнеры, которые не определены в docker-compose.yml</p><code>sail down --remove-orphans</code><p>пересобрать контейнеры</p><code>sail build</code><p>пересобрать контейнеры без кеша</p><code>sail build --no-cache</code><p>пересобрать контейнеры с обновлением образов без кеша</p><code>sail build --pull --no-cache</code><p>запуск очереди</p><code>sail artisan queue:work --queue=default --tries=3 --timeout=90 --sleep=3 --delay=0 --max-jobs=1000 --max-time=3600</code><p>версия php</p><code>sail php --version</code><p>выполнить скрипт php</p><code>sail php script.php</code><p>установить пакет</p><code>sail composer require laravel/sanctum</code><p>запустить скрипт npm</p><code>sail npm run dev</code><p>запустить yarn</p><code>sail yarn</code><p>запустить сервер на указанном хосте</p><code>sail artisan serve --host=yourhost</code><p>Обновить образы:</p><pre><code>docker compose down -v
sail build --no-cache
sail up -d</code></pre><p>установить пакет Telescope</p></details><details><summary>Configuration</summary><p>- config/app.php - конфигурация приложения<br>
- config/database.php - конфигурация БД<br>
- config/queue.php - конфигурация очередей<br>
- config/mail.php - конфигурация почты<br>
- config/broadcasting.php - конфигурация широковещательных каналов<br>
- config/filesystems.php - конфигурация файловых систем<br>
- config/logging.php - конфигурация логирования<br>
- config/session.php - конфигурация сессий<br>
- config/services.php - конфигурация сервисов<br>
- config/queue.php - конфигурация очередей<br>
- config/cors.php - конфигурация CORS<br>
- config/sanctum.php - конфигурация Sanctum<br>
- config/schedule.php - конфигурация планировщика задач<br>
<br>
- .env - файл окружения приложения<br>
- .env.example - пример файла окружения приложения<br>
- .env.testing - файл окружения для тестов<br>
- .env.dusk.local - файл окружения для Dusk-тестов<br>
- .env.dusk.example - пример файла окружения для Dusk-тестов<br>
- .env.dusk.testing - файл окружения для Dusk-тестов<br>
<br>
- php artisan about - обзор конфигурации<br>
- php artisan about --only=environment - обзор определенного раздела конфигурации<br>
- php artisan config:show database - обзор  определенного файла конфигурации<br>
- $_ENV - суперглобальная переменная содержит все переменные, перечисленные в файле .env<br>
- 'debug' => env('APP_DEBUG', false) - использовать только в конфигурационных файлах для получения значений переменных конфигурации, второй параметр - значение по умолчанию если нет значения переменной<br>
- текущее окружение<br></p><pre><code>use Illuminate\Support\Facades\App;
$environment = App::environment();</code></pre><p>- php artisan env:encrypt - шифрование файла .env<br>
- доступ к значениям конфигурации<br></p><pre><code>use Illuminate\Support\Facades\Config;
$value = Config::get('app.timezone');
$value = config('app.timezone');</code></pre><p>- php artisan config:cache - кешировать все конфигурационные файлы в один файл при деплое<br>
- php artisan config:clear - очистки кэша конфигурации<br>
- php artisan config:publish - публикация файлов конфигурации для модификации<br>
- php artisan down - включить режим обслуживания<br>
- php artisan up - отключить режим обслуживания<br>
- php artisan optimize - оптимизация приложения<br>
- php artisan optimize:clear - очистка кеша приложения<br>
</p></details><details><summary>Logging</summary><p>- логирование - запись сообщений в журнал<br>
- лог-файл - файл, в который записываются сообщения<br>
- уровень логирования - уровень важности сообщения<br>
- канал (драйвер) логирования - способ записи сообщений в журнал<br>
- драйверы логирования: single, daily, syslog, errorlog, monolog, null, custom<br>
- конфигурация ведения журнала config/logging.php<br>
- изменить имя канала<br></p><pre><code>'stack' => [
  'driver' => 'stack',
  'name' => 'channel-name',
  'channels' => ['single', 'slack'],
],</code></pre><p>конфигурация для продакшина</p><pre><code>'channels' => [
  'stack' => [
    'driver' => 'stack',
    'channels' => ['syslog', 'slack'],  
    'ignore_exceptions' => false,
  ],
  'syslog' => [
    'driver' => 'syslog',
    'level' => env('LOG_LEVEL', 'debug'),
    'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
    'replace_placeholders' => true,
  ],
  'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
    'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
    'level' => env('LOG_LEVEL', 'critical'),
    'replace_placeholders' => true,
  ],
],</code></pre><p>- уровни журнала в порядке убывания критичности: emergency, alert, critical, error, warning, notice, info, и debug<br>
- уровень по умолчанию - debug<br>
- методы записи по уровням<br></p><pre><code>use Illuminate\Support\Facades\Log;
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);</code></pre><p>в контроллере</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Support\Facades\Log;
use Illuminate\View\View;
class UserController extends Controller
{
  - Показать профиль конкретного пользователя.
  public function show(string $id): View
  {
    Log::info('Showing the user profile for user: {id}', ['id' => $id]);
    return view('user.profile', [
      'user' => User::findOrFail($id)
    ]);
  }
}</code></pre><p>регистрировать в журнале id каждого запроса</p><pre><code>namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class AssignRequestId
{
  - Обработчик входящего запроса
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    $requestId = (string) Str::uuid();
    Log::withContext([
      'request-id' => $requestId
    ]);
    $response = $next($request);
    $response->headers->set('Request-Id', $requestId);
    return $response;
  }
}</code></pre><p>регистрировать id каждого запроса по всем каналам</p><pre><code>public function handle(Request $request, Closure $next): Response
  {
    $requestId = (string) Str::uuid();
    Log::shareContext([
      'request-id' => $requestId
    ]);
  }</code></pre><p>запись в указанный канал</p><pre><code>use Illuminate\Support\Facades\Log;
Log::channel('slack')->info('Something happened!');</code></pre><p>запись в несколько каналов</p><code>Log::stack(['single', 'slack'])->info('Something happened!');</code><p>создать канал по запросу</p><pre><code>use Illuminate\Support\Facades\Log;
Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
])->info('Something happened!');</code></pre><p>создать канал по запросу и включить в стэк</p><pre><code>use Illuminate\Support\Facades\Log;
$channel = Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
]);
Log::stack(['slack', $channel])->info('Something happened!');</code></pre><p>настроить канал вручную через свой класс</p><pre><code>'single' => [
  'driver' => 'single',
  'tap' => [App\Logging\CustomizeFormatter::class],
  'path' => storage_path('logs/laravel.log'),
  'level' => env('LOG_LEVEL', 'debug'),
  'replace_placeholders' => true,
],</code></pre><p>свой класс</p><pre><code>namespace App\Logging;
use Illuminate\Log\Logger;
use Monolog\Formatter\LineFormatter;
class CustomizeFormatter
{
  - Настроить переданный экземпляр регистратора.
  public function __invoke(Logger $logger): void
  {
    foreach ($logger->getHandlers() as $handler) {
      $handler->setFormatter(new LineFormatter(
        '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'
      ));
    }
  }
}</code></pre><p>указать обработчик</p><pre><code>'logentries' => [
  'driver'  => 'monolog',
  'handler' => Monolog\Handler\SyslogUdpHandler::class,
  'with' => [
    'host' => 'my.logentries.internal.datahubhost.company.com',
    'port' => '10000',
  ],
],</code></pre><p>задать форматирование</p><pre><code>'browser' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\BrowserConsoleHandler::class,
  'formatter' => Monolog\Formatter\HtmlFormatter::class,
  'formatter_with' => [
    'dateFormat' => 'Y-m-d',
  ],
],

либо
'newrelic' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\NewRelicHandler::class,
  'formatter' => 'default',
],</code></pre><p>обрабатывать сообщения перед их записью в журнал</p><pre><code>'memory' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\StreamHandler::class,
  'with' => [
    'stream' => 'php://stderr',
  ],
  'processors' => [
    // Simple syntax
    Monolog\Processor\MemoryUsageProcessor::class,

    // With options
    [
    'processor' => Monolog\Processor\PsrLogMessageProcessor::class,
    'with' => ['removeUsedContextFields' => true],
    ],
  ],
],</code></pre><p>создать канал через фабрику</p><pre><code>'channels' => [
  'example-custom-channel' => [
    'driver' => 'custom',
    'via' => App\Logging\CreateCustomLogger::class,
  ],
],</code></pre><p>класс фабрика</p><pre><code>namespace App\Logging;
use Monolog\Logger;
class CreateCustomLogger
{
  - Создать экземпляр собственного регистратора Monolog
  public function __invoke(array $config): Logger
  {
    return new Logger(/* ... */);
  }
}</code></pre><p>просмотр сообщений в журнале</p><pre><code>composer require laravel/pail
php artisan pail

либо
php artisan pail -v</code></pre><p>фильтровать вывод инфы</p><code>php artisan pail --filter="QueryException"</code><p>фильтровать по сообщениям</p><code>php artisan pail --message="User created" created"</code><p>фильтровать по уровням</p><code>php artisan pail --level=error</code><p>фильтровать по пользователю</p><code>php artisan pail --user=1</code></details><details><summary>Packages</summary><p>- Cashier (Stripe) - платежная система Stripe<br>
- Cashier (Paddle) - платежная система Paddle<br>
- Dusk - автоматизация и тестирование браузеров<br>
- Envoy - выполнение задач на удаленных серверах<br>
- Fortify - backend реализация authentication<br>
- Folio - роутер, основанный на страницах для упрощения маршрутизации<br>
- Homestead - локальная среда разработки на Vagrant<br>
- Horizon - панель управления и конфигурацию для Redis системы очередей<br>
- Mix - компиляция и минимизация файлов CSS и JavaScript<br>
- Octane - увеличивает производительность приложения<br>
- Passport - обеспечивает полную реализацию OAuth2 сервера для приложения<br>
- Pennant - комплект флагов без крафт. Флаги позволяют постепенно внедрять новые функции приложений, А/Б тестировать новые интерфейсы, дополнять стратегию развития на основе ствола<br>
- Pint - стиль кода, устанавливается по умолчанию<br>
- Precognition - предвидеть результат будущего HTTP-запроса, выполнит всю промежуточную обработку маршрута и разрешит зависимости контроллера, включая валидацию запросов формы без выполнения метода контроллера.<br>
- Prompts - добавление красивых и удобных форм и подсказок к приложениям командной строки с функциями браузера<br>
- Pulse - сведения о производительности и использовании приложения<br>
- Reverb - масштабируемый в реальном времени WebSocket коммуникаций<br>
- Sail - взаимодействие со средой разработки Docker<br>
- Sanctum - система аутентификации для SPA (приложения с одной страницей), мобильные приложения и простые токены-API<br>
- Scout - полнотекстовоый поиск<br>
- Socialite аутентификация через соц.сети<br>
- Telescope предоставляет информацию о поступающих запросах, исключениях, записях записей, баз данных, задаваемых заданий, почтовых сообщений, уведомлениях, операциях кэша, запланированных задачах, переменных дампов и т.д.<br>
- Valet среда разработки для мак
</p></details><details><summary>Testing</summary><p>- pest: это обёртка для phpunit.<br>
- файл tests/Pest.php - конфигурация тестов<br>
- создаю тест</p><code>php artisan make:test</code><p>запускаю тест</p><code>php artisan test</code><p>- создание теста в tests/Feature</p><code>php artisan make:test UserTest</code><p>- создание теста в tests/Unit</p><code>php artisan make:test UserTest --unit</code><p>- создание юнит-теста с использованием Pest, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода</p><code>php artisan make:test UserTest --pest --unit --force --quiet --no-interaction --no-ansi</code><p>- php artisan test - запуск тестов<br>
- ./vendor/bin/phpunit - запуск тестов<br>
- ./vendor/bin/pest - запуск тестов<br>
<br>
- ./vendor/bin/phpunit tests/Feature/UserTest.php::testBasic<br>
- ./vendor/bin/phpunit tests/Unit/UserTest.php::testBasic<br>
<br>
- настроить переменные окружения testing можно в phpunit.xml<br>
- после внесения изменений выполнить очистку кэша<br></p><code>php artisan config:clear</code><p>- при тесторовании вместо .env можно использовать .env.testing<br>
- сгенерировать новый тестовый файл .env.testing<br></p><code>cp .env.example .env.testing</code><p>в UserTest</p><pre><code>test('basic', function () {
    expect(true)->toBeTrue();
});</code></pre><p>передать аргументы</p><code>php artisan test --testsuite=Feature --stop-on-failure</code><p>запуск тестов в командной строке</p><pre><code>./vendor/bin/phpunit
либо
./vendor/bin/pest
либо
php artisan test</code></pre><p>параллельный запуск тестов</p><pre><code>composer require brianium/paratest --dev
php artisan test --parallel
// настроить количество процессов - не более количества ядер ЦП на компьюторе
php artisan test --parallel --processes=4
// пересоздать тестовые БД
php artisan test --parallel --recreate-databases</code></pre><p>хуки параллельного тестирования:<br>
подготовка определенные ресурсы, используемые тестами<br>
$token - токен процесса<br>
$testCase - текущий тестовый класс<br></p><pre><code>namespace App\Providers;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\ParallelTesting;
use Illuminate\Support\ServiceProvider;
use PHPUnit\Framework\TestCase;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    ParallelTesting::setUpProcess(function (int $token) {});
    ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {});
    // Выполнится при создании тестовой БД...
    ParallelTesting::setUpTestDatabase(function (string $database, int $token) {
      Artisan::call('db:seed');
    });
    ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {});
    ParallelTesting::tearDownProcess(function (int $token) {});
  }
}</code></pre><p>доступ к текущему “токену” параллельного процесса из любого места приложения</p><code>$token = ParallelTesting::token();</code><p>отчет о покрытии тестами (требуется Xdebug или PCOV.)</p><code>php artisan test --coverage</code><p>задать минимальный порог покрытия тестами</p><code>php artisan test --coverage --min=80.3</code><p>получить список десяти самых медленных тестов</p><code>php artisan test --profile</code><p>- сделать запрос к приложению - вызвать в тесте методы get, post, put, patch, или delete<br>
- один тест - один запрос<br></p><pre><code>test('the application returns a successful response', function () {
  $response = $this->get('/');
  $response->assertStatus(200);
});</code></pre><p>настройки заголовков запроса</p><pre><code>test('interacting with headers', function () {
  $response = $this->withHeaders([
    'X-Header' => 'Value',
  ])->post('/user', ['name' => 'Sally']);
  $response->assertStatus(201);
});</code></pre><p>установить значения файлов Cookies</p><pre><code>test('interacting with cookies', function () {
  $response = $this->withCookie('color', 'blue')->get('/');
  $response = $this->withCookies([
    'color' => 'blue',
    'name' => 'Taylor',
  ])->get('/');
});</code></pre><p>установить данные сессии</p><pre><code>test('interacting with the session', function () {
  $response = $this->withSession(['banned' => false])->get('/');
});</code></pre><p>actingAs – аутентифицировать указанного пользователя как текущего</p><pre><code>use App\Models\User;
test('an action that requires authentication', function () {
  $user = User::factory()->create();
  $response = $this->actingAs($user)
            ->withSession(['banned' => false])
            ->get('/');
});</code></pre><p>с использованием гэйта</p><code>$this->actingAs($user, 'web')</code><p>проверка и отладка содержимого ответа</p><pre><code>test('basic test', function () {
  $response = $this->get('/');
  $response->dumpHeaders();
  $response->dumpSession();
  $response->dump();
});
либо
test('basic test', function () {
  $response = $this->get('/');
  $response->ddHeaders();
  $response->ddSession();
  $response->dd();
});</code></pre><p>тесты исключений</p><pre><code>use App\Exceptions\InvalidOrderException;
use Illuminate\Support\Facades\Exceptions;
test('exception is thrown', function () {
  Exceptions::fake();
  $response = $this->get('/order/1');
  Было ли выброшено исключение InvalidOrderException
  Exceptions::assertReported(InvalidOrderException::class);
  Было ли выброшено исключение InvalidOrderException с заданным сообщением
  Exceptions::assertReported(function (InvalidOrderException $e) {
    return $e->getMessage() === 'The order was invalid.';
  });
});</code></pre><p>указанное исключение и никаких исключений не было создано во время запроса</p><pre><code>Exceptions::assertNotReported(InvalidOrderException::class);
Exceptions::assertNothingReported();</code></pre><p>отключить обработку исключений для данного запроса</p><code>$response = $this->withoutExceptionHandling()->get('/');</code><p>проверить, что приложение не использует устаревшие функции</p><code>$response = $this->withoutDeprecationHandling()->get('/');</code><p>проверить, что код внутри замыкания генерирует исключение указанного типа</p><pre><code>$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  OrderInvalid::class
);</code></pre><p>проверить, что код внутри замыкания генерирует исключение указанного типа, а исключение равно заданому значению</p><pre><code>$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  fn (OrderInvalid $e) => $e->orderId() === 123;
);</code></pre><p>тесты JSON API<br>
методы для тестирования API-интерфейсов JSON и их ответов: json, getJson, postJson, putJson, patchJson, deleteJson, и optionsJson<br>
сделать запрос POST к /api/user<br></p><pre><code>test('making an api request', function () {
  $response = $this->postJson('/api/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    // метод assertJson используется для подтверждения наличия фрагмента JSON в ответе JSON
    ->assertJson([
      'created' => true,
    ]);
});</code></pre><p>получить доступ к данным ответа JSON как к массиву</p><code>expect($response['created'])->toBeTrue();</code><p>проверить, что массив в точности соответствует JSON</p><pre><code>test('asserting an exact json match', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertExactJson([
      'created' => true,
    ]);
});</code></pre><p>убедиться, что ответ JSON содержит данные по указанному пути</p><pre><code>test('asserting a json path value', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertJsonPath('team.owner.name', 'Darian');
});</code></pre><p>динамическое определение, должно ли утверждение выполниться</p><code>$response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);</code><p>последовательное тестирование ответов JSON</p><pre><code>use Illuminate\Testing\Fluent\AssertableJson;
test('fluent json', function () {
  $response = $this->getJson('/users/1');
  $response
    ->assertJson(fn (AssertableJson $json) =>
      $json->where('id', 1)
        // where - для присутствующего атрибута 
        ->where('name', 'Victoria Faith')
        ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
        ->whereNot('status', 'pending')
        // missing - для отсутствующего атрибута JSON
        ->missing('password')
        // etc - в объекте JSON могут присутствовать другие атрибуты
        ->etc()
      );
});</code></pre><p>проверить, что атрибут присутствует или отсутствует (has и missing)</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->has('data')
    ->missing('message')
);</code></pre><p>наличие или отсутствие нескольких атрибутов (hasAll и missingAll)</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->hasAll(['status', 'data'])
    ->missingAll(['message', 'code'])
);</code></pre><p>присутствует ли хотя бы один из заданного списка</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->has('status')
    ->hasAny('data', 'message', 'code')
);</code></pre><p>проверить маршрут, который возращает всех пользователей</p><pre><code>Route::get('/users', function () {
  return User::all();
});</code></pre><p>тест по первому пользователю</p><pre><code>$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has(3)
      ->first(fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );</code></pre><p>проверить маршрут, который возвращает коллекцию JSON с именованными ключами</p><pre><code>Route::get('/users', function () {
  return [
    'meta' => [...],
    'users' => User::all(),
  ];
})
тест
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3)
      ->has('users.0', fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );
либо
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3, fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );</code></pre><p>проверить тип</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('id', 'integer')
    ->whereAllType([
      'users.0.name' => 'string',
      'meta' => 'array'
    ])
);</code></pre><p>проверить наличие одного из типов, допустимые типы: string, integer, double, boolean, array, и null</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('name', 'string|null')
    ->whereType('id', ['string', 'integer'])
);</code></pre><p>тесты загрузки файлов<br>
протестировать форму загрузки аватара<br>
метод fake есть у класса UploadedFile и у фасада Storage<br></p><pre><code>use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
test('avatars can be uploaded', function () {
  Storage::fake('avatars');
  $file = UploadedFile::fake()->image('avatar.jpg');
  $response = $this->post('/avatar', [
    'avatar' => $file,
  ]);
  Storage::disk('avatars')->assertExists($file->hashName());
});</code></pre><p>подтвердить, что переданный файл не существует</p><pre><code>Storage::fake('avatars');
Storage::disk('avatars')->assertMissing('missing.jpg');</code></pre><p>указать ширину, высоту и размер изображения (в килобайтах)</p><code>UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);</code><p>создать pdf</p><code>UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);</code><p>явно определить MIME-тип файла</p><pre><code>UploadedFile::fake()->create(
  'document.pdf', $sizeInKilobytes, 'application/pdf'
);</code></pre><p>тесты шаблонов: assertSee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee и assertDontSeeText</p><pre><code>test('a welcome view can be rendered', function () {
  $view = $this->view('welcome', ['name' => 'Taylor']);
  $view->assertSee('Taylor');
});</code></pre><p>получить необработанное отрисованное содержимое шаблона</p><code>$contents = (string) $this->view('welcome');</code><p>добавить в глобальную коллекцию ошибок сообщения об ошибках</p><pre><code>$view = $this->withViewErrors([
  'name' => ['Please provide a valid name.']
])->view('form');
$view->assertSee('Please provide a valid name.');</code></pre><p>метод blade возвращает экземпляр Illuminate\Testing\TestView</p><pre><code>$view = $this->blade(
  '&lt;x-component :name="$name" /&gt;',
  ['name' => 'Taylor']
);
$view->assertSee('Taylor');</code></pre><p>метод component возвращает экземпляр Illuminate\Testing\TestComponent</p><pre><code>$view = $this->component(Profile::class, ['name' => 'Taylor']);
$view->assertSee('Taylor');</code></pre><a href="http://laravel.su/docs/12.x/http-tests#utverzdeniia-otvetov">доступные утверждения ответов</a><p>тесты аутентификации<br>
пользователь аутентифицирован<br></p><code>$this->assertAuthenticated($guard = null);</code><p>пользователь не аутентифицирован</p><code>$this->assertGuest($guard = null);</code><p>конкретный пользователь аутентифицирован</p><code>$this->assertAuthenticatedAs($user, $guard = null);</code><p>тесты валидации<br>
ответ содержит ошибки валидации для указанных ключей<br></p><pre><code>$response->assertInvalid(['name', 'email']);
// либо
$response->assertInvalid([
  'name' => 'The name field is required.',
  'email' => 'valid email address',
]);</code></pre><p>тесты консоли<br>
метод artisan для вызова Artisan-команды из теста,<br>
метод assertExitCode, проверить, что команда завершилась с указанным кодом (код 0 - успех, остальное - нет)<br></p><pre><code>test('console command', function () {
  $this->artisan('inspire')->assertExitCode(0);
});</code></pre><p>команда не завершилась с заданным кодом</p><pre><code>$this->artisan('inspire')->assertNotExitCode(1);
// либо
$this->artisan('inspire')->assertSuccessful();
$this->artisan('inspire')->assertFailed();</code></pre><p>тесты ввода/вывода<br>
метод expectsQuestion - имитировать ввод пользователя в консольных командах<br>
метод assertExitCode - ожидаемый код завершения команды<br>
метод expectsOutput - ожидаемый при выполнении команды текст<br></p><p>консольная команда</p><pre><code>Artisan::command('question', function () {
  $name = $this->ask('What is your name?');
  $language = $this->choice('Which language do you prefer?', [
    'PHP',
    'Ruby',
    'Python',
  ]);
  $this->line('Your name is '.$name.' and you prefer '.$language.'.');
});</code></pre><p>проверить команду</p><pre><code>test('console command', function () {
  $this->artisan('question')
    ->expectsQuestion('What is your name?', 'Taylor Otwell')
    ->expectsQuestion('Which language do you prefer?', 'PHP')
    ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')
    ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')
    ->assertExitCode(0);
});</code></pre><p>expectsSearch, чтобы имитировать ввод пользователя, результаты поиска и выбор</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->expectsSearch('What is your name?', search: 'Tay', answers: [
      'Taylor Otwell',
      'Taylor Swift',
      'Darian Taylor'
    ], answer: 'Taylor Otwell')
    ->assertExitCode(0);
});</code></pre><p>проверить, что команда не генерирует никакого вывода</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->doesntExpectOutput()
    ->assertExitCode(0);
});</code></pre><p>проверить часть вывода</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->expectsOutputToContain('Taylor')
    ->assertExitCode(0);
});</code></pre><p>команды ожидает ответа «да» или «нет»</p><pre><code>$this->artisan('module:import')
  ->expectsConfirmation('Do you really wish to run this command?', 'no')
  ->assertExitCode(1);</code></pre><p>проверить таблицу</p><pre><code>$this->artisan('users:all')
  ->expectsTable([
    'ID',
    'Email',
  ], [
    [1, 'taylor@example.com'],
    [2, 'abigail@example.com'],
  ]);</code></pre><p>включить генерацию консольных событий при выполнении тестов</p><pre><code>use Illuminate\Foundation\Testing\WithConsoleEvents;
uses(WithConsoleEvents::class);</code></pre><p>тесты БД<br>
сброс БД после каждого теста<br></p><pre><code>use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('basic example', function () {
  $response = $this->get('/');
});</code></pre><p>полностью сбросить БД
- использовать трейты Illuminate\Foundation\Testing\DatabaseMigrations или Illuminate\Foundation\Testing\DatabaseTruncation<br>
- использовать фабрику в тестах<br></p><pre><code>use App\Models\User;
test('models can be instantiated', function () {
    $user = User::factory()->create();
});</code></pre><p>использовать наполнитель в тестах</p><pre><code>use Database\Seeders\OrderStatusSeeder;
use Database\Seeders\TransactionStatusSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('orders can be created', function () {
  // Run the DatabaseSeeder...
  $this->seed();
  // Run a specific seeder...
  $this->seed(OrderStatusSeeder::class);
  Run an array of specific seeders...
    $this->seed([
      OrderStatusSeeder::class,
      TransactionStatusSeeder::class,
  ]);
});</code></pre><p>автоматически заполнять базу данных перед каждым тестом</p><pre><code>namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
  - Указывает, следует ли запускать наполнитель по умолчанию перед каждым тестом.
  - @var bool
  protected $seed = true;
}
либо
use Database\Seeders\OrderStatusSeeder;
protected $seeder = OrderStatusSeeder::class;</code></pre><p>таблица в базе данных содержит указанное количество записей</p><code>$this->assertDatabaseCount('users', 5);</code><p>таблица в базе данных не содержит записей</p><code>$this->assertDatabaseEmpty('users');</code><p>таблица в базе данных содержит записи, соответствующие переданным ключ/значение</p><pre><code>$this->assertDatabaseHas('users', [
  'email' => 'sally@example.com',
]);</code></pre><p>таблица в базе данных не содержит записей, соответствующих переданным ключ/значение</p><pre><code>$this->assertDatabaseMissing('users', [
  'email' => 'sally@example.com',
]);</code></pre><p>модель была «программно удалена»</p><code>$this->assertSoftDeleted($user);</code><p>модель не была «программно удалена»</p><code>$this->assertNotSoftDeleted($user);</code><p>данная модель существует в базе данныхuse App\Models\User;</p><pre><code>$user = User::factory()->create();
$this->assertModelExists($user);</code></pre><p>данной модели не существует в базе данных</p><pre><code>use App\Models\User;
$user = User::factory()->create();
$user->delete();
$this->assertModelMissing($user);</code></pre><p>ожидаемое числа запросов к базе данных во время выполнения теста</p><code>$this->expectsDatabaseQueryCount(5);</code><p>имитация:<br>
использовать подставной экземпляр объекта вместо создания самого объекта<br></p><pre><code>use App\Service;
use Mockery;
use Mockery\MockInterface;
test('something can be mocked', function () {
  $this->instance(
    Service::class,
    Mockery::mock(Service::class, function (MockInterface $mock) {
      $mock->shouldReceive('process')->once();
    })
  );
});
// либо
use App\Service;
use Mockery\MockInterface;
$mock = $this->mock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});</code></pre><p>имитировать несколько методов объекта</p><pre><code>use App\Service;
use Mockery\MockInterface;
$mock = $this->partialMock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});</code></pre><p>шпионы записывают любое взаимодействие между шпионом и тестируемым кодом</p><pre><code>use App\Service;
$spy = $this->spy(Service::class);
$spy->shouldHaveReceived('process');</code></pre><p>для контроллера</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller
{
  - Получить список всех пользователей приложения
  public function index(): array
  {
    $value = Cache::get('key');
    return [];
  }
}</code></pre><p>имитировать вызов фасада Cache</p><pre><code>use Illuminate\Support\Facades\Cache;
test('get index', function () {
  Cache::shouldReceive('get')
        ->once()
        ->with('key')
        ->andReturn('value');
  $response = $this->get('/users');
});</code></pre><p>шпионить за фасадом</p><pre><code>use Illuminate\Support\Facades\Cache;
test('values are be stored in cache', function () {
  Cache::spy();
  $response = $this->get('/');
  $response->assertStatus(200);
  Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);
});</code></pre><p>управлять текущим временем</p><pre><code>test('time can be manipulated', function () {
  // Travel into the future...
  $this->travel(5)->milliseconds();
  $this->travel(5)->seconds();
  $this->travel(5)->minutes();
  $this->travel(5)->hours();
  $this->travel(5)->days();
  $this->travel(5)->weeks();
  $this->travel(5)->years();
  // Travel into the past...
  $this->travel(-5)->hours();
  // Travel to an explicit time...
  $this->travelTo(now()->subHours(6));
  // Return back to the present time...
  $this->travelBack();
});
либо
$this->travel(5)->days(function () {
  // Test something five days into the future...
});
$this->travelTo(now()->subDays(10), function () {
  // Test something during a given moment...
});
либо
use Illuminate\Support\Carbon;
// Freeze time and resume normal time after executing closure...
$this->freezeTime(function (Carbon $time) { });
// Freeze time at the current second and resume normal time after executing closure...
$this->freezeSecond(function (Carbon $time) { })</code></pre><p>блокировка неактивных сообщений на форуме</p><pre><code>use App\Models\Thread;
test('forum threads lock after one week of inactivity', function () {
  $thread = Thread::factory()->create();
  $this->travel(1)->week();
  expect($thread->isLockedByInactivity())->toBeTrue();
});</code></pre><p>тесты событий</p><pre><code>use App\Events\OrderFailedToShip;
use App\Events\OrderShipped;
use Illuminate\Support\Facades\Event; 
test('orders can be shipped', function () {
  Event::fake();    // вызвать после использования фабрик
  Event::assertDispatched(OrderShipped::class);   // подтвердить, что событие было отправлено
  Event::assertDispatched(OrderShipped::class, 2);    // подтвердить, что событие было отправлено дважды
  Event::assertNotDispatched(OrderFailedToShip::class);   // подтвердить, что событие не было отправлено
  Event::assertNothingDispatched();   // подтвердить, что не было отправлено ни одного события});
либо подтвердить, что было отправлено событие, которое соответствует данному условию
Event::assertDispatched(function (OrderShipped $event) use ($order) {return $event->order->id === $order->id;});
либо подтвердить, что слушатель слушает указанное событие
Event::assertListening(OrderShipped::class, SendShipmentNotification::class);
- подменить слушателей событий только для указанного набора событий
test('orders can be processed', function () {
  Event::fake([OrderCreated::class]);
  $order = Order::factory()->create();
  Event::assertDispatched(OrderCreated::class);
  $order->update([...]);});
либо подменить все события, кроме указанных
Event::fake()->except([OrderCreated::class]);
- подменить слушателей событий только в определенной части теста: метод fakeFor()
use App\Events\OrderCreated;
use App\Models\Order;
use Illuminate\Support\Facades\Event;
test('orders can be processed', function () {
  $order = Event::fakeFor(function () {
    $order = Order::factory()->create();
    Event::assertDispatched(OrderCreated::class);
    return $order;});
  $order->update([...]);});
</code></pre><p>тесты браузера</p></details><details><summary>Exceptions</summary><p>- метод withExceptions в bootstrap/app.php управляет исключениями и выводом сообщений о них<br>
- $exceptions - экземпляр Illuminate\Foundation\Configuration\Exceptions<br>
- debug в config/app.php определяет сколько показать информации об ошибке<br>
- переменная окружения APP_DEBUG в .env при разработке = true, на продакшине false<br>
- выполняться, когда необходимо сообщить об исключении определенного типа<br>
- сообщения об исключениях записываются в журнал с указанием уровня серьезности и важности<br>
- по умолчанию Laravel преобразует исключения в HTTP-ответ<br></p><pre><code>- создать исключения с методами render и report, если файл уже существует, без вывода сообщений в консоль,
  без интерактивного ввода и без ANSI-вывода
php artisan make:exception CustomException --render --report --force --quiet --no-interaction --no-ansi</code></pre><p>опубликовать стандартные шаблоны страниц ошибок</p><code>php artisan vendor:publish --tag=laravel-errors</code><p>шаблоны страниц ошибок если нет страницы для нужного кода ошибки</p><pre><code>resources/views/errors/4xx.blade.php
resources/views/errors/5xx.blade.php</code></pre><p>вывести ошибку в resources/views/errors/404.blade.php</p><code>&lt;h2&gt;{{ $exception->getMessage() }}&lt;/h2&gt;</code><p>вызвать исключение</p><pre><code>abort(404);
abort(403, 'Unauthorized action.');
abort(403, 'Unauthorized action.', ['X-Header' => 'Value']);</code></pre><p>управлять исключениями в bootstrap/app.php</p><pre><code>->withExceptions(function (Exceptions $exceptions) {$exceptions->report(function (InvalidOrderException $e) { });})
- остановить регистрацию исключения в стек журналов логирования по умолчанию
->withExceptions(function (Exceptions $exceptions) {$exceptions->report(function (InvalidOrderException $e) { })->stop();})
либо
$exceptions->report(function (InvalidOrderException $e) {return false;});
- определить свои собственные глобальные контекстные данные
->withExceptions(function (Exceptions $exceptions) {$exceptions->context(fn () => ['foo' => 'bar']);})
- об одном экземпляре исключения сообщать только один раз
->withExceptions(function (Exceptions $exceptions) {$exceptions->dontReportDuplicates();})
применить
$original = new RuntimeException('Whoops!');
report($original); // сообщено
try {throw $original;} catch (Throwable $caught) {report($caught);} // проигнорировано
report($original); // проигнорировано
report($caught); // проигнорировано
- задать сообщению уровень для записи
use PDOException;
use Psr\Log\LogLevel;
->withExceptions(function (Exceptions $exceptions) {$exceptions->level(PDOException::class, LogLevel::CRITICAL);})
- игнорировать исключения
use App\Exceptions\InvalidOrderException;
->withExceptions(function (Exceptions $exceptions) {$exceptions->dontReport([InvalidOrderException::class]);})
либо
namespace App\Exceptions;
use Exception;
use Illuminate\Contracts\Debug\ShouldntReport;
class PodcastProcessingException extends Exception implements ShouldntReport { }
- прекратить игнорировать определенный тип исключения
use Symfony\Component\HttpKernel\Exception\HttpException;
->withExceptions(function (Exceptions $exceptions) {$exceptions->stopIgnoring(HttpException::class);})
- изменить тип исключения
use App\Exceptions\InvalidOrderException;
use Illuminate\Http\Request;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (InvalidOrderException $e, Request $request) {
    return response()->view('errors.invalid-order', status: 500);
  });
})
либо
use Illuminate\Http\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (NotFoundHttpException $e, Request $request) {
    if ($request->is('api/*')) {return response()->json(['message' => 'Record not found.'], 404);}
  });
})
- отобразить исключение в формате JSON
use Illuminate\Http\Request;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->shouldRenderJsonWhen(function (Request $request, Throwable $e) {
    if ($request->is('admin/*')) {return true;}
    return $request->expectsJson();
  });
})
- настроить HTTP-ответ на исключение
use Symfony\Component\HttpFoundation\Response;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->respond(function (Response $response) {
    if ($response->getStatusCode() === 419) {
      return back()->with(['message' => 'The page expired, please try again.']);
    }
    return $response;
  });
})
- выбрать случайное количество исключений
use Illuminate\Support\Lottery;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->throttle(function (Throwable $e) {return Lottery::odds(1, 1000);});
})
- выбрать исключения определённого типа
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->throttle(function (Throwable $e) {
    if ($e instanceof BroadcastException) {return Limit::perMinute(300);}
  });
})
либо
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->throttle(function (Throwable $e) {
    if ($e instanceof BroadcastException) {return Limit::perMinute(300)->by($e->getMessage());}
  });
})
либо
use App\Exceptions\ApiMonitoringException;
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Lottery;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->throttle(function (Throwable $e) {
    return match (true) {
      $e instanceof BroadcastException => Limit::perMinute(300),
      $e instanceof ApiMonitoringException => Lottery::odds(1, 1000),
      default => Limit::none(),
    };
  });
})</code></pre><p>добавить уникальный контекст для конкретного исключения</p><pre><code>namespace App\Exceptions;
use Exception;
class InvalidOrderException extends Exception
{
  public function context(): array
  {return ['order_id' => $this->orderId];}
}</code></pre><p>сообщить об исключении и продолжить обработку текущего запроса, не отображая страницу с ошибкой</p><pre><code>public function isValid(string $value): bool
{
  try {
    // Проверка `$value`
  } catch (Throwable $e) {
    report($e);
    return false;
  }
}</code></pre><p>поведение отчетов и отображение ошибок определено методами report и render</p><pre><code>namespace App\Exceptions;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
class InvalidOrderException extends Exception
{
  public function report(): void { }    // отчитаться об исключении
  public function render(Request $request): Response    // преобразовать исключение в HTTP-ответ
  {return response();}
}
</code></pre></details><details> <summary>Queue</summary><a href="https://laravel.su/docs/12.x/queues#dopolnitelnye-zavisimosti-draiverov">зависимости драйверов</a><p>Laravel позволяет создавать задания (jobs) в очереди (queue), которые могут обрабатываться в фоновом режиме.<br>
Конфигурации очереди в config/queue.php.<br>
Драйвер sync является драйвером очереди по-умолчанию.<br>
Пакет Horizon - панель мониторинга и система настройки для очередей на базе Redis.<br>
Соединение может иметь несколько очередей и определяет параметры подключения к серверным службам очередей,
таким как Amazon SQS, Beanstalk или Redis.<br>
Очередь - это стек или пачка заданий.<br>
Бинарные данные, например, необработанное содержимое изображения, передавать заданию через функцию base64_encode.</p><pre><code>use App\Jobs\ProcessPodcast;
ProcessPodcast::dispatch();   // Это задание отправляется в очередь `default` соединения по умолчанию
ProcessPodcast::dispatch()->onQueue('emails');    // Это задание отправляется в очередь `emails` соединения по умолчанию
- artisan
php artisan queue:work --queue=high,default   // определить приоритет обработки очередей
php artisan make:queue-table    // создать таблицу БД для драйвера очереди database (создаётся по умолчанию)
php artisan make:job ProcessPodcast   // сгенерировать новое задание в app/Jobs
- в App\Providers\AppServiceProvider
// сервис-контейнер автоматически внедряет зависимости, внедрять зависимости вручную:
use App\Jobs\ProcessPodcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Foundation\Application;
$this->app->bindMethod([ProcessPodcast::class, 'handle'], function (ProcessPodcast $job, Application $app) {
  return $job->handle($app->make(AudioProcessor::class));});</code></pre><p>Драйвер</p><pre><code>- чтобы использовать драйвер очереди database нужна таблица БД 0001_01_01_000002_create_jobs_table.php
- Чтобы использовать драйвер очереди redis, настроить соединение с БД Redis в config/database.php
'redis' => [
  'driver' => 'redis',
  'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),
  'queue' => env('REDIS_QUEUE', '{default}'),
  'retry_after' => env('REDIS_QUEUE_RETRY_AFTER', 90),
  'block_for' => null,
  'after_commit' => false]
'block_for' => 5,   //  драйвер блокируется на пять секунд, ожидая, пока задание станет доступным
// предотвратить обработку сигнала SIGTERM пока не будет обработано следующее задание.
'block_for' => 0,   //  обработчики очереди блокируются пока задание не станет доступным.</code></pre><p>посредник (middleware) задания позволяет обернуть пользовательскую логику вокруг выполнения заданий в очереди</p><pre><code>// при использовании Redis лучше использовать посредника Illuminate\Queue\Middleware\RateLimitedWithRedis
// ограничения частоты в методе handle
use Illuminate\Support\Facades\Redis;
public function handle(): void {
  Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {
    info('Lock obtained...');
    // Обработка задания
    }, function () {
    // Не удалось получить блокировку
    return $this->release(5);});}   // обрабатывать только одно задание каждые пять секунд
// определить посредника задания
namespace App\Jobs\Middleware;
use Closure;
use Illuminate\Support\Facades\Redis;
class RateLimited {
  public function handle(object $job, Closure $next): void {
    Redis::throttle('key')->block(0)->allow(1)->every(5)
      ->then(function () use ($job, $next) {
        // Блокировка получена
        $next($job);
      }, function () use ($job) {
        // Не удалось получить блокировку
        $job->release(5);});}}
// применить посредника
use App\Jobs\Middleware\RateLimited;
public function middleware(): array {return [new RateLimited];}
- в App\Providers\AppServiceProvider
// ограничить частоту выполнения задания
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;
public function boot(): void {
  RateLimiter::for('backups', function (object $job) {
    return $job->user->vipCustomer()
      ? Limit::none() : Limit::perHour(1)->by($job->user->id);});}
либо
  return Limit::perMinute(50)->by($job->user->id);
// применить ограничение
use Illuminate\Queue\Middleware\RateLimited;
public function middleware(): array {return [new RateLimited('backups')];}
// чтобы задание не возвращалось в очередь
public function middleware(): array {return [(new RateLimited('backups'))->dontRelease()];}
- предотвращение дублирования задания
use Illuminate\Queue\Middleware\WithoutOverlapping;
public function middleware(): array {return [new WithoutOverlapping($this->user->id)];}
// время до повторной попытки выполнения возвращенного в очередь задания
public function middleware(): array {
  return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];}
// удалить все дублирующиеся задания
public function middleware(): array {
  return [(new WithoutOverlapping($this->order->id))->dontRelease()];}
// определить время истечения блокировки
public function middleware(): array {
    return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];}
// применять ключ блокировки ко всем классам заданий
use Illuminate\Queue\Middleware\WithoutOverlapping;
class ProviderIsDown {
  public function middleware(): array {
    return [(new WithoutOverlapping("status:{$this->provider}"))->shared()];}}
class ProviderIsUp {
  public function middleware(): array {
    return [(new WithoutOverlapping("status:{$this->provider}"))->shared()];}}
- ограничение частоты генерации исключений
// после вызова указанного количества исключений выполнение задания на время откладывается
use DateTime;
use Illuminate\Queue\Middleware\ThrottlesExceptions;
// после 10 исключений подряд, прервать выполнение на 5 минут
public function middleware(): array {return [new ThrottlesExceptions(10, 5 * 60)];}
// пытаться выполнить задание в течении 30 минут
public function retryUntil(): DateTime {return now()->addMinutes(30);}
// после каждого исключения повторить попытку выполнить задание через 5 минут
public function middleware(): array {return [(new ThrottlesExceptions(10, 5 * 60))->backoff(5)];}
// по умолчанию имя класса задания - это ключ кеша, переопределить ключ кеша
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {return [(new ThrottlesExceptions(10, 10 * 60))->by('key')];}
// применить посредника по условию
use Illuminate\Http\Client\HttpClientException;
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 10 * 60))->when(
    fn (Throwable $throwable) => $throwable instanceof HttpClientException)];}
либо
use Illuminate\Http\Client\HttpClientException;
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 10 * 60))->report(
    fn (Throwable $throwable) => $throwable instanceof HttpClientException)];}
// более эффективно управление ограничениями исключений с помощью Redis
  класс Illuminate\Queue\Middleware\ThrottlesExceptionsWithRedis</code></pre><p>Задание</p><pre><code>- метод handle, который вызывается, когда задание обрабатывается очередью
namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct(public Podcast $podcast) { }    // создать новый экземпляр задания
  public function handle(AudioProcessor $processor): void { }}    // Выполнить задание
- отношения в очереди
// предотвратить сериализацию отношений
public function __construct(Podcast $podcast) {$this->podcast = $podcast->withoutRelations();}
либо
use Illuminate\Queue\Attributes\WithoutRelations;
public function __construct(
  <WithoutRelations></WithoutRelations>
  public Podcast $podcast) {}
- для уникальных заданий требуется драйвер кеша, поддерживающий блокировки
// уникальность заданий не учитывается при пакетной обработке
// интерфейс ShouldBeUnique гарантирует, что только один экземпляр задания находится в очереди
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique { }
// определить идентификатор или время уникальности задания
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique {
  public $product;    // экземпляр продукта
  // количество секунд, по истечении которых уникальная блокировка задания будет снята
  public $uniqueFor = 3600;
  // получить уникальный идентификатор продукта, задания с тем же идентификатором продукта будут игнорироваться
  public function uniqueId(): string {return $this->product->id;}}
// разблокировать уникальное задание перед его обработкой
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing { }
// использовать другой драйвер для получения блокировки уникального задания
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Support\Facades\Cache;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique {
  public function uniqueVia(): Repository {return Cache::driver('redis');}}
- шифрование данных задания
use Illuminate\Contracts\Queue\ShouldBeEncrypted;
use Illuminate\Contracts\Queue\ShouldQueue;
class UpdateSearchIndex implements ShouldQueue, ShouldBeEncrypted { }
- пропуск заданий
// Skip::when удаляет задание, если условие  true, а Skip::unless если условие false
use Illuminate\Queue\Middleware\Skip;
public function middleware(): array {return [Skip::when($someCondition)];}
либо
use Illuminate\Queue\Middleware\Skip;
public function middleware(): array
{return [Skip::when(function (): bool {return $this->shouldSkip();})];}
- отправка заданий
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast);
    return redirect('/podcasts');}}
// отправить задание по условию
ProcessPodcast::dispatchIf($accountActive, $podcast);
ProcessPodcast::dispatchUnless($accountSuspended, $podcast);
// отложенная отправка
задание будет доступно для обработки через 10 минут после его отправки
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->delay(now()->addMinutes(10));
    return redirect('/podcasts');}}
// отправить задание на немедленную обработку
ProcessPodcast::dispatch($podcast)->withoutDelay();
// отправка задания после отправки ответа в браузер
use App\Jobs\SendNotification;
SendNotification::dispatchAfterResponse();
либо
use App\Mail\WelcomeMessage;
use Illuminate\Support\Facades\Mail;
dispatch(function () {Mail::to('taylor@example.com')->send(new WelcomeMessage);})->afterResponse();
// синхронная отправка: задание не будет поставлено в очередь, а выполнено немедленно в текущем процессе
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatchSync($podcast);
    return redirect('/podcasts');}}
- задания и транзакции базы данных
// Laravel отправит задание после завершения родительской транзакции БД
  в config/database.php
'redis' => ['driver' => 'redis', 'after_commit' => true]
либо
use App\Jobs\ProcessPodcast;
ProcessPodcast::dispatch($podcast)->afterCommit();
// отправить задание не дожидаясь завершения транзакций БД
ProcessPodcast::dispatch($podcast)->beforeCommit();   // при 'after_commit' => true в config/database.php
- цепочка заданий - список заданий в очереди,
  которые должны выполняться друг за другом после успешного выполнения основного задания
// Bus - компонент нижнего уровня, на котором построена диспетчеризация заданий в очереди
use App\Jobs\OptimizePodcast;
use App\Jobs\ProcessPodcast;
use App\Jobs\ReleasePodcast;
use Illuminate\Support\Facades\Bus;
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])->dispatch();
либо
Bus::chain([new ProcessPodcast, new OptimizePodcast, function () {Podcast::update( ... );}])->dispatch();
// соединения и очередь цепочки заданий
  указать соединение и очередь для связанных заданий
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])
  ->onConnection('redis')->onQueue('podcasts')->dispatch();
// добавить задание в существующую цепочку
public function handle(): void {
  $this->prependToChain(new TranscribePodcast);
  $this->appendToChain(new TranscribePodcast);}
// указать функцию, которая вызываеться, если задание в цепочке провалилось
use Illuminate\Support\Facades\Bus;
use Throwable;
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])
  ->catch(function (Throwable $e) { })->dispatch();
- Настройка соединения и очереди
// отправка заданий в разные очереди, позволяет группировать задания и определять приоритеты,
  назначать разные обработчики в разные очереди.
namespace App\Http\Controllers;
use App\Http\Controllers\Controller, App\Jobs\ProcessPodcast, App\Models\Podcast;
use Illuminate\Http\RedirectResponse, Illuminate\Http\Request;
class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->onQueue('processing');
    return redirect('/podcasts');}}
либо
namespace App\Jobs;
use Illuminate\Contracts\Queue\ShouldQueue, Illuminate\Foundation\Queue\Queueable;
class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onQueue('processing');}}
// указать, на какое соединение отправить задание
namespace App\Http\Controllers;
use App\Http\Controllers\Controller, App\Jobs\ProcessPodcast, App\Models\Podcast;
use Illuminate\Http\RedirectResponse, Illuminate\Http\Request;
class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->onConnection('sqs');
    return redirect('/podcasts');}}
либо
ProcessPodcast::dispatch($podcast)->onConnection('sqs')->onQueue('processing');
либо в задании
namespace App\Jobs;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onConnection('sqs');}}
- максимальное количество попыток
php artisan queue:work --tries=3    // применяеться ко всем заданиям обработчика
--tries=0 - задание будет повторяться бесконечно
// указанное количество попыток в классе задания имеет приоритет над значением --tries
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue {public $tries = 5;}
// управлять динамически числом попыток выполнения задания из класса задания
public function tries(): int {return 5;}
- максимальное время для попыток выполнения задания
// для таймаута необходимо расширение pcntl, а значение таймаута в задании всегда меньше “retry after”
php artisan queue:work --timeout=30   // максимальное количество секунд для выполнения задания
// таймаут указанный в классе задания имеет приоритет над значением --timeout
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue {public $timeout = 120;}
public $failOnTimeout = true;   // пометить задание как failed по истечении таймаута
либо через DateTime
use DateTime;
public function retryUntil(): DateTime {return now()->addMinutes(10);}
- максимальное количество исключений
namespace App\Jobs;
use Illuminate\Support\Facades\Redis;
class ProcessPodcast implements ShouldQueue {
  public $tries = 25;   // 25 попыток выполнения с интервалом в 10 секунд
  public $maxExceptions = 3;    // до трёх необработанных исключений
  public function handle(): void {
    Redis::throttle('key')->allow(10)->every(60)->then(function () {
      // Блокировка получена, обрабатываем подкаст
    }, function () {
      // Невозможно получить блокировку
      return $this->release(10);
    });}}
- обработка ошибок
public function handle(): void {$this->release();}   // вернуть задание в очередь вручную
// обработать задание через указанное количество секунд
$this->release(10);
$this->release(now()->addSeconds(10));
public function handle(): void {$this->fail();}   // пометить задание как «неудачное» вручную
$this->fail($exception);    // передать исключение 
$this->fail('Something went wrong.');   // передать строковое сообщение об ошибке
- анонимные очереди
// вместо задания в очередь можно отправить функцию для быстрых и простых задач вне текущего цикла запроса
$podcast = App\Podcast::find(1);
dispatch(function () use ($podcast) {$podcast->publish();});
// catch определяет функцию для обработки неудачного завершения анонимной очереди
use Throwable;
dispatch(function () use ($podcast) {$podcast->publish();})->catch(function (Throwable $e) { });</code></pre><p>пакетная обработка заданий позволяет совершить действия после выполнения пакета заданий</p><a href="https://laravel.su/docs/12.x/queues#xranenie-paketov-v-dynamodb"> Хранение пакетов в Amazon DynamoDB</a><pre><code>php artisan make:queue-batches-table  // построить таблицу с метаинформацией о пакетах заданий
php artisan migrate
// определить задание с возможностью пакетной передачи
namespace App\Jobs;
use Illuminate\Bus\Batchable;     // обеспечивает доступ к методу batch
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
class ImportCsv implements ShouldQueue {
  use Batchable, Queueable;
  // batch используется для получения текущего пакета, в котором выполняется задание
  public function handle(): void {
    if ($this->batch()->cancelled()) {return;}    // был ли пакет отменен
    // выполняю задание}}
// отправить в очередь пакет заданий
use App\Jobs\ProcessPodcast;
use Illuminate\Support\Facades\Bus;
Bus::batch([
  new ProcessPodcast($podcast),
  new ProcessPodcast($podcast2),
  new ProcessPodcast($podcast3),
])->dispatch();
// отправить в очередь пакет заданий, каждое из которых обрабатывает часть строк из файла CSV
use App\Jobs\ImportCsv;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;
$batch = Bus::batch([
  new ImportCsv(1, 100),
  new ImportCsv(101, 200),
  new ImportCsv(201, 300),
  new ImportCsv(301, 400),
  new ImportCsv(401, 500),
])->before(function (Batch $batch) {
  // Пакет заданий создан, но не добавлено ни одно задание
})->progress(function (Batch $batch) {
  // Одна задача успешно завершена
})->then(function (Batch $batch) {
  // Все задания успешно завершены
})->catch(function (Batch $batch, Throwable $e) {
  // Обнаружено первое проваленное задание из пакета
})->finally(function (Batch $batch) {
  // Завершено выполнение пакета
})->dispatch();
return $batch->id;
$batch->id    // получить доступ к идентификатору пакета
// присвоить пакету произвольное имя
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->name('Import CSV')->dispatch();
// указать соединение и очередь, все пакетные задания выполняются в одном соединении и в одной очереди
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->onConnection('redis')->onQueue('imports')->dispatch();
// определить набор связанных заданий в пакете
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
Bus::batch([    // выполнить две цепочки заданий параллельно и после выполнить замыкание
  [new ReleasePodcast(1), new SendPodcastReleaseNotification(1)],
  [new ReleasePodcast(2), new SendPodcastReleaseNotification(2)]])
  ->then(function (Batch $batch) {...})->dispatch();
// объединить пакеты в цепочку
use App\Jobs\FlushPodcastCache;
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Support\Facades\Bus;
Bus::chain([
  new FlushPodcastCache,
  Bus::batch([new ReleasePodcast(1), new ReleasePodcast(2)]),
  Bus::batch([new SendPodcastReleaseNotification(1), new SendPodcastReleaseNotification(2)])])->dispatch();
// добавлять задания в пакет можно только из задания, которое принадлежит к тому же пакету
$batch = Bus::batch([
  new LoadImportBatch,
  new LoadImportBatch,
  new LoadImportBatch,
])->then(function (Batch $batch) {...})->name('Import Contacts')->dispatch();
// add метод экземпляра пакета, к которому можно получить доступ через метод batch задания
use App\Jobs\ImportContacts;
use Illuminate\Support\Collection;
public function handle(): void {
  if ($this->batch()->cancelled()) {return;}
  $this->batch()->add(Collection::times(1000, function () {return new ImportContacts;}));}
// экземпляр Illuminate\Bus\Batch передается замыканиям по завершению пакета и предоставляет:
$batch->id;   // UUID пакета
$batch->name;   // Название пакета (если применимо)
$batch->totalJobs;    // Количество заданий, назначенных пакету
$batch->pendingJobs;    // Количество заданий, которые не были обработаны очередью
$batch->failedJobs;   // Количество неудачных заданий
$batch->processedJobs();    // Количество заданий, обработанных на данный момент
$batch->progress();   // Процент завершения пакетной обработки (0-100)
$batch->finished();   // Указывает, завершено ли выполнение пакета
$batch->cancel();   // Отменить выполнение пакета
$batch->cancelled();    // Указывает, был ли пакет отменен
// возврат пакетов заданий из маршрутов
use Illuminate\Support\Facades\Bus, Illuminate\Support\Facades\Route;
Route::get('/batch/{batchId}', function (string $batchId) {return Bus::findBatch($batchId);});
// отменить выполнение пакета
public function handle(): void {
  if ($this->user->exceedsImportLimit()) {return $this->batch()->cancel();}
  if ($this->batch()->cancelled()) {return;}}   // был ли соответствующий пакет отменен
// определять был ли соответствующий пакет отменен в посреднике
use Illuminate\Queue\Middleware\SkipIfBatchCancelled;
public function middleware(): array {return [new SkipIfBatchCancelled];}
// разрешить невыполнение задания в пакете
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->allowFailures()->dispatch();
// повторить все неудачные задания для пакета с UUID 32dbc76c-4f82-4749-b610-a639fe0099b5
php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5
// запланировать очистку таблицы job_batches от записей о пакетах
use Illuminate\Support\Facades\Schedule;
Schedule::command('queue:prune-batches')->daily();
либо очищать каждые 48 часов
Schedule::command('queue:prune-batches --hours=48')->daily();
// либо очистить записи о невыполненых и незавершённых пакетах
Schedule::command('queue:prune-batches --hours=48 --unfinished=72')->daily();
// либо очистить записи об отмененных пакетах
Schedule::command('queue:prune-batches --hours=48 --cancelled=72')->daily();</code></pre><p>обработчики очереди – это долгоживущие процессы, которые хранят состояние загруженного приложения в памяти.</p><pre><code>php artisan queue:work  // запускает обработчика очереди и обрабатывает новые задания пока не остановят
php artisan queue:work -v   // выводить идентификаторы обработанных заданий
php artisan queue:listen  // менее эффективна, чем queue:work, но учитывает обновленный код и состояние приложения
php artisan queue:work redis    // указать обработчику соединение (одно из config/queue.php)
php artisan queue:work redis --queue=emails   // обрабатывать только очередь emails из соединения redis
php artisan queue:work --once   // обработать только одно задание из очереди
php artisan queue:work --max-jobs=1000    // обработать 1000 заданий и выйти
php artisan queue:work --stop-when-empty    // обработать все задания и затем корректно завершить работу
php artisan queue:work --max-time=3600    // обрабатывать задания в течение заданных секунд и выйти
php artisan queue:work --sleep=3    // сколько секунд обработчик будет «спать», если нет заданий
php artisan queue:work --force    // обрабатывать задания в очереди, даже если включён режим обслуживания
dispatch((new Job)->onQueue('high'));   // поместить задание в очередь с «высоким» (high) приоритетом
php artisan queue:work --queue=high,low   // задания очереди high будут обработаны, прежде чем в очереди low
php artisan queue:restart   // ерезапустить всех обработчиков, нужен диспетчер процессов Supervisor для запуска
- сроки и таймауты задания
// параметр retry_after в config/queue.php указывает сколько секунд ждать до повторной попытки выполнения задания
php artisan queue:work --timeout=60   // количество секунд на обработку задания
--timeout всегда должно быть меньше, чем значение retry_after
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-jobs=1000
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-time=3600
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-failures=5
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-batches=10
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-batch-size=1000</code></pre><p>Supervisor - диспетчер процессов: запускать одновременно и перезапускает процессы queue:work</p><a href="https://supervisord.org/index.html">Supervisor</a><pre><code>sudo apt-get install supervisor   // установить Supervisor
// создать файл конфигурации laravel-worker.conf в /etc/supervisor/conf.d для запуска и отслеживания queue:work
[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600  // подключить соединение
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=forge
numprocs=8      // запустить и отслеживать 8 процессов queue:work
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600   // должно быть большего самого продолжительного задания
// обновить конфигурацию Supervisor и запустить процессы
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start "laravel-worker:*"</code></pre><p>Неудачные задания</p><a href="https://laravel.su/docs/12.x/queues#xranenie-neudacnyx-zadanii-v-dynamodb">хранение а Amazon DynamoDB</a><pre><code>// неудачное асинхронное задание будет помещено в таблицу БД failed_jobs
// исключения синхронного задания обрабатываются немедленно
// таблица БД failed_jobs создаётся по умолчанию
// создать таблицу БД failed_jobs вручную
php artisan make:queue-failed-table
php artisan migrate
php artisan queue:failed    // просмотреть таблицу БД failed_jobs
// повторить неудачное задание с идентификатором ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece
либо повторить два
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d
php artisan queue:retry --queue=name    // повторить все из очереди name
php artisan queue:retry all   // повторить все
php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d   // удалить неудачное задание
php artisan queue:flush   // удалить все неудачные задания из таблицы failed_jobs
php artisan queue:prune-failed    // удалить все записи в таблице failed_jobs
php artisan queue:prune-failed --hours=48   // удалить записи старше 48 часов в таблице failed_jobs
php artisan queue:work redis --tries=3    // максимальное количество попыток выполнения задания
php artisan queue:work redis --tries=3 --backoff=3    // сколько секунд ждать перед повторной попыткой
либо в классе задания в виде переменной
public $backoff = 3;
либо в классе задания в виде функции
public function backoff(): int {return 3;}
либо повторная попытка для первой попытки через 1 секунду, для второй через 5, для третьей и последующих через 10
public function backoff(): array {return [1, 5, 10];}
// отправить предупреждение о сбое и отменить действия частично выполненые заданием
namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
use Throwable;
class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct(public Podcast $podcast) { }  // создать новый экземпляр задания
  public function handle(AudioProcessor $processor): void { выполнить задание }
  public function failed(?Throwable $exception): void { обработать провал задания }}
public $deleteWhenMissingModels = true;   // автоматическое удаление заданий с отсутствующими моделями
// отбрасывать невыполненные задания без сохранения: установить параметр конфигурации queue.failed.driver
QUEUE_FAILED_DRIVER=null
- удалить задания из очереди
php artisan queue:clear   // удалить все задания из соединения и очереди по умолчанию
php artisan queue:clear redis --queue=emails   // удалить все задания из соединения redis и очереди emails</code></pre><p>события и слушатели в очереди</p><pre><code>use App\Events\OrderShipped;
use App\Listeners\SendOrderShippedNotification;
Event::listen(OrderShipped::class, SendOrderShippedNotification::class);    
- зарегистрировать слушатель событий, который будет вызываться при сбое задания
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobFailed;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void {
    Queue::failing(function (JobFailed $event) {
      // $event->connectionName
      // $event->job
      // $event->exception});}}
- указать функции, которые будут выполняться до или после обработки задания в очереди
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void {
    Queue::before(function (JobProcessing $event) {
      // $event->connectionName
      // $event->job
      // $event->job->payload()
    });
    Queue::after(function (JobProcessed $event) {
      // $event->connectionName
      // $event->job
      // $event->job->payload()
    });}}
- отправить событие если количество заданий в очереди больше заданного
php artisan queue:monitor redis:default,redis:deployments --max=100
// прослушать это событие
use App\Notifications\QueueHasLongWaitTime;
use Illuminate\Queue\Events\QueueBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;
public function boot(): void {Event::listen(function (QueueBusy $event) {
  Notification::route('mail', 'dev@example.com')->notify(new QueueHasLongWaitTime(
    $event->connection,
    $event->queue,
    $event->size));});}
- выполнить функцию до того, как обработчик попытается получить задание из очереди
// откат любых транзакций, оставшихся открытыми из-за ранее неудачного задания
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Queue;
Queue::looping(function () {while (DB::transactionLevel() > 0) {DB::rollBack();}});</code></pre><p>тестирование</p><pre><code>// предотвратить фактическую отправку заданий очередь
use App\Jobs\AnotherJob;
use App\Jobs\FinalJob;
use App\Jobs\ShipOrder;
use Illuminate\Support\Facades\Queue;
test('orders can be shipped', function () {
  Queue::fake();
  Queue::assertNothingPushed();   // Assert that no jobs were pushed
  Queue::assertPushedOn('queue-name', ShipOrder::class);  // Assert a job was pushed to a given queue
  Queue::assertPushed(ShipOrder::class, 2);   // Assert a job was pushed twice
  Queue::assertNotPushed(AnotherJob::class);    // Assert a job was not pushed
  Queue::assertClosurePushed();   // Assert that a Closure was pushed to the queue
  Queue::assertCount(3);    // Assert the total number of jobs that were pushed});
либо
Queue::assertPushed(function (ShipOrder $job) use ($order) {return $job->order->id === $order->id;});
// передать имена классов заданий, которые нужно имитировать
test('orders can be shipped', function () {
  Queue::fake([ShipOrder::class]);
  Queue::assertPushed(ShipOrder::class, 2);});   // Assert a job was pushed twice
// имитировать все задания, кроме указанных
Queue::fake()->except([ShipOrder::class]);
// протестировать цепочки заданий
use App\Jobs\RecordShipment;
use App\Jobs\ShipOrder;
use App\Jobs\UpdateInventory;
use Illuminate\Support\Facades\Bus;
Bus::fake();
Bus::assertChained([
  ShipOrder::class,
  RecordShipment::class,
  UpdateInventory::class]);
либо
Bus::assertChained([
  new ShipOrder,
  new RecordShipment,
  new UpdateInventory]);
// подтвердить, что задание было отправлено без цепочки заданий
Bus::assertDispatchedWithoutChain(ShipOrder::class);
// подтвердить, что задание имеет ожидаемую цепочку оставшихся заданий
$job = new ProcessPodcast;
$job->handle();
$job->assertHasChain([
  new TranscribePodcast,
  new OptimizePodcast,
  new ReleasePodcast]);
// подтвердить, что оставшаяся цепочка задания пуста
$job->assertDoesntHaveChain();
// тестирование цепочки пакетов
use App\Jobs\ShipOrder;
use App\Jobs\UpdateInventory;
use Illuminate\Bus\PendingBatch;
use Illuminate\Support\Facades\Bus;
Bus::assertChained([
  new ShipOrder,
  Bus::chainedBatch(function (PendingBatch $batch) {return $batch->jobs->count() === 3;}),
  new UpdateInventory]);
// подтвердить, что пакет заданий был отправлен
use Illuminate\Bus\PendingBatch;
use Illuminate\Support\Facades\Bus;
Bus::fake();
Bus::assertBatched(function (PendingBatch $batch) {
  return $batch->name == 'import-csv' && $batch->jobs->count() === 10;});
// подтвердить, что было отправлено заданное количество пакетов
Bus::assertBatchCount(3);
// подтвердить, что никакие пакеты не были отправлены
Bus::assertNothingBatched();
// протестировать взаимодействие отдельного задания с его базовым пакетом
[$job, $batch] = (new ShipOrder)->withFakeBatch();    // назначить заданию поддельный пакет
$job->handle();
$this->assertTrue($batch->cancelled());
$this->assertEmpty($batch->added);
// протестировать взаимодействие задания с очередью
use App\Exceptions\CorruptedAudioException;
use App\Jobs\ProcessPodcast;
$job = (new ProcessPodcast)->withFakeQueueInteractions();   // поддельное взаимодействие
$job->handle();
$job->assertReleased(delay: 30);
$job->assertDeleted();
$job->assertNotDeleted();
$job->assertFailed();
$job->assertFailedWith(CorruptedAudioException::class);
$job->assertNotFailed();</code></pre><p>обработка заданий в очереди с помощью Horizon</p><pre><code>php artisan horizon:forget 91401d2c-0784-4f43-824c-34f94a33c24d   // удаления неудачного задания
php artisan horizon:clear   // удалить все задания из соединения и очереди по умолчанию
</code></pre></details><details> <summary>Events</summary><p>Классы событий обычно хранятся в каталоге app/Events, а их слушатели – в app/Listeners.</p><pre><code>php artisan make:event PodcastProcessed   // сгенерировать событие
php artisan make:listener SendPodcastNotification --event=PodcastProcessed    // сгенерировать слушателя
php artisan event:list    // список всех слушателей</code></pre><p>в bootstrap/app.php</p><code>->withEvents(discover: [__DIR__.'/../app/Domain/Orders/Listeners'])   // искать слушатели в указаном каталоге</code><p>в AppServiceProvider</p><pre><code>- регистрация вручную событий и соответствующих им слушателей
namespace App\Providers;
use App\Domain\Orders\Events\PodcastProcessed;
use App\Domain\Orders\Listeners\SendPodcastNotification;
use Illuminate\Support\Facades\Event;
public function boot(): void {Event::listen(PodcastProcessed::class, SendPodcastNotification::class);}
либо
Event::listen(function (PodcastProcessed $event) { });
- выполнить слушателя с использованием очереди
use function Illuminate\Events\queueable;
Event::listen(queueable(function (PodcastProcessed $event) { }));
// детализация выполнения слушателя в очереди
Event::listen(queueable(function (PodcastProcessed $event) { })
  ->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));
// обрабатывать сбои анонимного слушателя в очереди
use Throwable;
Event::listen(queueable(function (PodcastProcessed $event) { })
  ->catch(function (PodcastProcessed $event, Throwable $e) { // Событие в очереди завершилось неудачно...}));
// перехватывать несколько событий на одном слушателе
Event::listen('event.*', function (string $eventName, array $data) { });    // $data - массив данных события
- регистрация вручную подписчика на события
use App\Listeners\UserEventSubscriber;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void {Event::subscribe(UserEventSubscriber::class);}}</code></pre><p>- события позволяют использовать хуки жизненного цикла модели: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleting, forceDeleted, restoring, restored и replicating.<br>
- события, заканчивающиеся на -ing, инициируются до сохранения изменений в модели, а события, заканчивающиеся на -ed, инициируются после сохранения изменений в модели.<br>
- события saved, updated, deleting, и deleted при массовом обновлении или удалении не будут инициированы<br></p><pre><code>- прослушивание событий модели
namespace App\Models;
use App\Events\UserDeleted;
use App\Events\UserSaved;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {
  use Notifiable;
  protected $dispatchesEvents = ['saved' => UserSaved::class, 'deleted' => UserDeleted::class];
}
либо через функции
protected static function booted(): void {static::created(function (User $user) {});}   // метод «booted» модели
// выполнить слушателя событий модели в фоновом режиме, используя очередь
use function Illuminate\Events\queueable;
static::created(queueable(function (User $user) {}));
- наблюдатель, чтобы сгруппировать слушателей в одном классе
php artisan make:observer UserObserver --model=User   // создать наблюдателя в app/Observers
namespace App\Observers;
use App\Models\User;
class UserObserver
{
  public function created(User $user): void {}    // обработать событие «created»
  public function updated(User $user): void {}    // обработать событие «updated»
  public function deleted(User $user): void {}    // обработать событие «deleted»
  public function restored(User $user): void {}   // обработать событие «restored»
  public function forceDeleted(User $user): void {}   // обработать событие «forceDeleted»
}
// наблюдатель выполнит свои обработчики событий только после фиксирования транзакции БД
use Illuminate\Contracts\Events\ShouldHandleEventsAfterCommit;
class UserObserver implements ShouldHandleEventsAfterCommit
{public function created(User $user): void { }}
// регистрации наблюдателя
use App\Observers\UserObserver;
use Illuminate\Database\Eloquent\Attributes\ObservedBy;
<ObservedBy [UserObserver::class]></ObservedBy>
class User extends Authenticatable {}
либо в App\Providers\AppServiceProvider
use App\Models\User;
use App\Observers\UserObserver;
public function boot(): void {User::observe(UserObserver::class);}
- заглушить все события, запускаемые моделью
$user = User::withoutEvents(function () {
  User::findOrFail(1)->delete();
  return User::find(2);
});
- операции с моделью, не вызывая никаких событий
$user = User::findOrFail(1);
$user->name = 'Victoria Faith';
$user->saveQuietly();
$user->deleteQuietly();
$user->forceDeleteQuietly();
$user->restoreQuietly();</code></pre><p>Событие</p><pre><code>- Класс событий – это контейнер данных о событии
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;
class OrderShipped {
  use Dispatchable, InteractsWithSockets, SerializesModels;
  public function __construct(public Order $order) { }}
- отправить событие (метод dispatch)
namespace App\Http\Controllers;
use App\Events\OrderShipped;
use App\Http\Controllers\Controller;
use App\Models\Order;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class OrderShipmentController extends Controller {
  public function store(Request $request): RedirectResponse {
    $order = Order::findOrFail($request->order_id);
    OrderShipped::dispatch($order);
    return redirect('/orders');}}
- отправить событие по условию
OrderShipped::dispatchIf($condition, $order);
OrderShipped::dispatchUnless($condition, $order);
- отправлять событие только после завершения активной транзакции в БД
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Events\ShouldDispatchAfterCommit;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;
class OrderShipped implements ShouldDispatchAfterCommit {
  use Dispatchable, InteractsWithSockets, SerializesModels;
  public function __construct(public Order $order) {}}</code></pre><p>Слушатель</p><pre><code>- Слушатели полезны для выполнения медленной задачи: отправка электронной почты или выполнение HTTP-запроса
// слушатель одного события
use App\Events\PodcastProcessed;
class SendPodcastNotification {public function handle(PodcastProcessed $event): void { }}
// слушатель двух событий
public function handle(PodcastProcessed|PodcastPublished $event): void { }
- слушатели получают экземпляры событий в методе handle
namespace App\Listeners;
use App\Events\OrderShipped;
class SendShipmentNotification {
  public function __construct() { }
  public function handle(OrderShipped $event): void {// Доступ к заказу с помощью `$event->order` ...}}
// остановить распространение события среди других слушателей
public function handle(OrderShipped $event): void { return false}}
- интерфейс ShouldQueue: обеспечивает постановку слушателя в очередь
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
class SendShipmentNotification implements ShouldQueue { }
- настроить соединение очереди, имя очереди или время задержки очереди для слушателя событий
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
class SendShipmentNotification implements ShouldQueue {
  public $connection = 'sqs';   // имя соединения, на которое должно быть отправлено задание
  public $queue = 'listeners';    // имя очереди, в которую должно быть отправлено задание
  public $delay = 60;}    // время (в секундах) до обработки задания
// определить соединение очереди слушателя или имя очереди слушателя во время выполнения
public function viaConnection(): string {return 'sqs';}   // получить имя подключения очереди
public function viaQueue(): string {return 'listeners';}   // получить имя очереди
public function withDelay(OrderShipped $event): int
{return $event->highPriority ? 0 : 60;}   // получить количество секунд до того, как задача должна быть выполнена
- отправить слушателя в очередь по условию
namespace App\Listeners;
use App\Events\OrderCreated;
use Illuminate\Contracts\Queue\ShouldQueue;
class RewardGiftCard implements ShouldQueue {
  public function handle(OrderCreated $event): void { }
    public function shouldQueue(OrderCreated $event): bool
    {return $event->order->subtotal >= 5000;}}   // следует ли ставить слушателя в очередь
- получить доступ к методам delete и release базового задания в очереди слушателя
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  public function handle(OrderShipped $event): void {if (true) {$this->release(30);}}}
- указать, что слушатель в очереди должен быть выполнен после завершения всех транзакций в БД
namespace App\Listeners;
use Illuminate\Contracts\Queue\ShouldQueueAfterCommit;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueueAfterCommit {use InteractsWithQueue;}
- обработка невыполненных заданий
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Throwable;
class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  public function handle(OrderShipped $event): void { }   // обработать событие
  public function failed(OrderShipped $event, Throwable $exception): void { }}    // обработать провал задания
- указать, сколько раз и как долго можно пытаться выполнить слушатель
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  public $tries = 5;}   // количество попыток слушателя в очереди
либо
use DateTime;
public function retryUntil(): DateTime {return now()->addMinutes(5);} // время, через которое слушатель должен отключиться
либо
public $backoff = 3;    // количество секунд ожидания перед повторной попыткой
либо
public function backoff(): int {return 3;}
либо
// задержка повтора 1 секунда для первой попытки, 5 секунд для второй, 10 секунд для третьей и каждой последующей попытки
public function backoff(): array {return [1, 5, 10];}</code></pre><p>Подписчики событий – это классы, которые могут подписываться на несколько событий.<br>
Это позволяет определять несколько обработчиков событий в одном классе. </p><pre><code>namespace App\Listeners;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
use Illuminate\Events\Dispatcher;
class UserEventSubscriber {
  public function handleUserLogin(Login $event): void {}  // обработать событие входа пользователя в систему
  public function handleUserLogout(Logout $event): void {}  // обработать событие выхода пользователя из системы
  // методу subscribe передан экземпляр диспетчера событий
  public function subscribe(Dispatcher $events): void {
    // зарегистрировать слушателей для подписчика
    $events->listen(Login::class, [UserEventSubscriber::class, 'handleUserLogin']);
    $events->listen(Logout::class, [UserEventSubscriber::class, 'handleUserLogout']);}}
либо
class UserEventSubscriber {
  public function handleUserLogin(Login $event): void {}
  public function handleUserLogout(Logout $event): void {}
  public function subscribe(Dispatcher $events): array
    {return [Login::class => 'handleUserLogin', Logout::class => 'handleUserLogout'];}}
</code></pre></details><details> <summary>Broadcasting</summary><p>WebSocket — это независимый протокол, основанный на протоколе TCP.<br>
Он делает возможным более тесное взаимодействие между браузером и веб-сайтом, способствуя распространению интерактивного содержимого и созданию приложений реального времени.<br>
Когда некоторые данные обновляются на сервере, тогда обычно отправляется сообщение через соединение WebSocket для обработки клиентом.<br>
Широковещание используется для отправки события от сервера к клиенту, которое будет получено в JavaScript приложения без обновления страницы.<br>
Клиенты подключаются к именованным каналам во внешнем интерфейсе, Laravel транслирует события для этих каналов во внутреннем интерфейсе.<br>
Вся трансляция событий выполняются через задания в очереди.<br>
Трансляция событий на стороне сервера (конфигурация config/broadcasting.php)<br>
Драйвера трансляции: Laravel Reverb, Pusher Channels, и Ably<br></p><a href="https://laravel.su/docs/12.x/reverb">пакет Laravel Reverb</a><pre><code>// драйвер log для локальной разработки и отладки, драйвер null - отключить трансляцию во время тестирования
php artisan install:broadcasting    // включить трансляцию (создаст config/broadcasting.php и routes/channels.php)
// установить Reverb вручную
composer require laravel/reverb
php artisan reverb:install</code></pre><a href="https://pusher.com/channels/">Pusher Channels</a><pre><code>composer require pusher/pusher-php-server   // установить PHP SDK Pusher Channels
// настроить учетные данные в config/broadcasting.php
PUSHER_APP_ID="your-pusher-app-id"
PUSHER_APP_KEY="your-pusher-key"
PUSHER_APP_SECRET="your-pusher-secret"
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME="https"
PUSHER_APP_CLUSTER="mt1"
BROADCAST_CONNECTION=pusher   // в .env</code></pre><a href="https://ably.io/">Ably<br></a><a href="https://github.com/ably/laravel-broadcaster">Ably laravel</a><pre><code>composer require ably/ably-php    // установить PHP SDK Ably
// настроить учетные данные Ably в config/broadcasting.php
// в .env
ABLY_KEY=your-ably-key
BROADCAST_CONNECTION=ably</code></pre><p>Установка на стороне клиента</p><a href="https://github.com/laravel/echo">Laravel Echo — библиотека JS для подписки на каналы и прослушивания событий от сервера</a><pre><code>php artisan install:broadcasting    // автоматически устанавливает пакеты laravel-echo и pusher-js
// установить пакеты laravel-echo и pusher-js вручную
npm install --save-dev laravel-echo pusher-js // Echo использует протокол Pusher для подписок, каналов и сообщений WebSocket
- Reverb
// в resources/js/bootstrap.js либо в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'reverb',
  key: import.meta.env.VITE_REVERB_APP_KEY,
  wsHost: import.meta.env.VITE_REVERB_HOST,
  wsPort: import.meta.env.VITE_REVERB_PORT,
  wssPort: import.meta.env.VITE_REVERB_PORT,
  forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
  enabledTransports: ['ws', 'wss'],
});
- Pusher Channels
// в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'pusher',
  key: import.meta.env.VITE_PUSHER_APP_KEY,
  cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
  forceTLS: true
});
// использовать существующий экземпляр клиента Pusher Channelsimport Echo from 'laravel-echo';
import Pusher from 'pusher-js';
const options = {broadcaster: 'pusher', key: 'your-pusher-channels-key'}
window.Echo = new Echo({...options, client: new Pusher(options.key, options)});
// в .env
PUSHER_APP_ID="your-pusher-app-id"
PUSHER_APP_KEY="your-pusher-key"
PUSHER_APP_SECRET="your-pusher-secret"
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME="https"
PUSHER_APP_CLUSTER="mt1"
VITE_APP_NAME="${APP_NAME}"
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
- Ably
// включить поддержку протокола Pusher в разделе настроек «Protocol Adapter Settings» панели Ably
// в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'pusher',
  key: import.meta.env.VITE_ABLY_PUBLIC_KEY,    // часть ключа Ably перед символом :
  wsHost: 'realtime-pusher.ably.io',
  wsPort: 443,
  disableStats: true,
  encrypted: true,
});
npm run dev   // скомпилировать ресурсы</code></pre><p>Пример: статус доставки заказов в интернет-магазине</p><pre><code>use App\Events\OrderShipmentStatusUpdated;
OrderShipmentStatusUpdated::dispatch($order);   // событие запускается при обновлении статуса доставки
- ShouldBroadcast: транслировать событие при его запуске
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast {public $order;}
// получить каналы трансляции события в классе события
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\PrivateChannel;
// транслировать событие на частном канале, привязанном к конкретному заказу
public function broadcastOn(): Channel {return new PrivateChannel('orders.'.$this->order->id);}
// передать событие по нескольким каналам
use Illuminate\Broadcasting\PrivateChannel;
public function broadcastOn(): array {return [new PrivateChannel('orders.'.$this->order->id)];}
- определить правила авторизации каналов в файле routes/channels.php
use App\Models\Order;
use App\Models\User;
    // прослушивать канал может только создатель заказа
Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;});
- прослушивать событие: метод private для подписки на частный канал
Echo.private(`orders.${orderId}`).listen('OrderShipmentStatusUpdated', (e) => {console.log(e.order);});</code></pre><p>Транслируемые события</p><pre><code>- для трансляции события интерфейс ShouldBroadcast и метод broadcastOn
// экземпляры Channel - публичные каналы, на которые может подписаться любой пользователь,
// PrivateChannels и PresenceChannels - частные каналы, для которых требуется авторизация канала
namespace App\Events;
use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class ServerCreated implements ShouldBroadcast {
  use SerializesModels;
  public function __construct(public User $user) {}   // создать новый экземпляр события
  // получить каналы трансляции события
  public function broadcastOn(): array {return [new PrivateChannel('user.'.$this->user->id)];}}
// после запуска события, задание в очереди автоматически транслирует событие, используя указанный драйвер трансляции
- изменить имя транслируемого события (по умолчанию имя класса события)
public function broadcastAs(): string {return 'server.created';}
// слушатель с ведущим символом . чтобы не добавлять пространство имен приложения к событию
.listen('.server.created', function (e) { });
- при трансляции события, все его публичные свойства автоматически сериализуются
{
  "user": {
    "id": 1,
    "name": "Patrick Stewart"
  }
}
// получить массив данных в качестве полезной нагрузки при трансляции события
public function broadcastWith(): array {return ['id' => $this->user->id];}
- изменить соединение очереди и имя очереди для транслируемого события
public $connection = 'redis';
public $queue = 'default';
либо имя очереди трансляции
public function broadcastQueue(): string {return 'default';}
// транслировать событие с помощью очереди sync вместо драйвера очереди по умолчанию
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;
class OrderShipmentStatusUpdated implements ShouldBroadcastNow { }
- транслировать событие по условию
public function broadcastWhen(): bool {return $this->order->value > 100;}
- транслируемое событие будет отправлено после фиксации всех транзакций БД
namespace App\Events;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Events\ShouldDispatchAfterCommit;
use Illuminate\Queue\SerializesModels;
class ServerCreated implements ShouldBroadcast, ShouldDispatchAfterCommit {use SerializesModels;}
- для авторизации каналов маршрут /broadcasting/auth автоматически помещается в группу посредников web
// определить логику может ли текущий аутентифицированный пользователь прослушивать канал в routes/channels.php
use App\Models\User;
Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;});
php artisan channel:list    // просмотреть список замыканий авторизации вещания
- привязка модели к маршруту канала
use App\Models\Order;
use App\Models\User;
Broadcast::channel('orders.{order}', function (User $user, Order $order) {return $user->id === $order->user_id;});
- назначить своих охранников для аутентификации входящего запроса
Broadcast::channel('channel', function () { }, ['guards' => ['web', 'admin']]);
- вместо использования замыканий для авторизации каналов можно использовать классы каналов
php artisan make:channel OrderChannel   // сгенерировать новый класс канала в app/Broadcasting
// зарегистрировать канал в routes/channels.php
use App\Broadcasting\OrderChannel;
Broadcast::channel('orders.{order}', OrderChannel::class);
// логику авторизации для канала в методе join
namespace App\Broadcasting;
use App\Models\Order, App\Models\User;
class OrderChannel {
  public function __construct() { }
  public function join(User $user, Order $order): array|bool {return $user->id === $order->user_id;}}
- запустить трансляцию события
use App\Events\OrderShipmentStatusUpdated;
OrderShipmentStatusUpdated::dispatch($order);
// трансляция события всем подписчикам канала, кроме текущего пользователя
use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->toOthers();
// для toOthers() глобальный экземпляр Axios прикрепляет идентификатор сокета к каждому исходящему запросу в заголовке X-Socket-ID
var socketId = Echo.socketId();   // получить идентификатор сокета
// указать, на какое соединение отправлять событие
use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');
либо указать широковещательное соединение события в конструкторе события
namespace App\Events;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithBroadcasting;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast {
  use InteractsWithBroadcasting;
  public function __construct() {$this->broadcastVia('pusher');}}
- анонимные события
//  транслировать простое событие без создания специального класса событий
Broadcast::on('orders.'.$order->id)->send();
  // будет транслироваться
{
  "event": "AnonymousEvent",
  "data": "[]",
  "channel": "orders.1"
}
// настроить имя и данные события
Broadcast::on('orders.'.$order->id)->as('OrderPlaced')->with($order)->send();
  // будет транслироваться
{
  "event": "OrderPlaced",
  "data": "{ id: 1, total: 100 }",
  "channel": "orders.1"
}
// транслировать анонимное событие на частном канале или канале присутствия
Broadcast::private('orders.'.$order->id)->send();
Broadcast::presence('channels.'.$channel->id)->send();
// немедленно транслировать событие без постановки в очередь
Broadcast::on('orders.'.$order->id)->sendNow();
// транслировать событие всем подписчикам канала, кроме текущего аутентифицированного пользователя
Broadcast::on('orders.'.$order->id)->toOthers()->send();</code></pre><p>Приём трансляций</p><pre><code>- прослушивание событий
// метод channel для получения экземпляра канала, метод listen для прослушивания события
Echo.channel(`orders.${this.order.id}`).listen('OrderShipmentStatusUpdated', (e) => {console.log(e.order.name);});
// прослушивать несколько событий на частном канале
Echo.private(`orders.${this.order.id}`).listen(/* ... */).listen(/* ... */).listen(/* ... */);
// прекратить прослушивание данного события не покидая канал
Echo.private(`orders.${this.order.id}`).stopListening('OrderShipmentStatusUpdated')
// покинуть канал, а также связанные с ним частные каналы и каналы присутствия
Echo.leave(`orders.${this.order.id}`);
// Echo автоматически предполагает, что события находятся в пространстве имен App\Events
// изменить пространство имен при создании экземпляра Echo
window.Echo = new Echo({broadcaster: 'pusher', namespace: 'App.Other.Namespace'});
// префикс . позволяет указывать полное имя класса
Echo.channel('orders').listen('.Namespace\\Event\\Class', (e) => { });</code></pre><p>Каналы присутствия</p><pre><code>// основаны на безопасности частных каналов и позволяют уведомление пользователей,
  когда другой пользователь просматривает ту же страницу, или перечисление пользователей комнаты чата.
- авторизация каналов присутствия
// если пользователь авторизован для присоединения к каналу, то вернуть массив данных о пользователе,
  если не авторизован, то вернуть false или null
use App\Models\User;
Broadcast::channel('chat.{roomId}', function (User $user, int $roomId) {
  if ($user->canJoinRoom($roomId)) {return ['id' => $user->id, 'name' => $user->name];}});
- присоединиться к каналу присутствия
// метод join вернет реализацию PresenceChannel, с методом listen, чтобы подписаться на события here, joining и leave
Echo.join(`chat.${roomId}`).here((users) => { }).joining((user) => {console.log(user.name);})
  .leaving((user) => {console.log(user.name);}).error((error) => {console.error(error);});
- трансляция на каналы присутствия
// получить канал трансляции события
public function broadcastOn(): array {return [new PresenceChannel('chat.'.$this->message->room_id)];}
// отправить событие
broadcast(new NewMessage($message));
либо
broadcast(new NewMessage($message))->toOthers();
// прослушивать события
Echo.join(`chat.${roomId}`).here(/* ... */).joining(/* ... */).leaving(/* ... */).listen('NewMessage', (e) => { });</code></pre><p>Трансляция моделей</p><pre><code>- обычно транслируются события, когда модели Eloquent создаются, обновляются или удаляются
  чтобы не создавать классы событий с единственной целью их широковещательной передачи,
  модель Eloquent может автоматически транслировать изменения своего состояния
namespace App\Models;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Database\Eloquent\BroadcastsEvents;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Post extends Model {
  use BroadcastsEvents, HasFactory;
  // получить пользователя, которому принадлежит сообщение
  public function user(): BelongsTo {return $this->belongsTo(User::class);}
  // получите каналы, по которым должны транслироваться события модели
  public function broadcastOn(string $event): array {return [$this, $this->user];}}
  // аргумент $event - тип события, которое произошло: created, updated, deleted, trashed или restored
// определить, на какие каналы (если есть) модель должна транслировать конкретное событие
public function broadcastOn(string $event): array {
  return match ($event) {'deleted' => [], default => [$this, $this->user]};}
// настроить создание базового события трансляции модели
use Illuminate\Database\Eloquent\BroadcastableModelEventOccurred;
protected function newBroadcastableEvent(string $event): BroadcastableModelEventOccurred {
  return (new BroadcastableModelEventOccurred($this, $event))->dontBroadcastToCurrentUser();}
- соглашение о трансляции моделей
// Laravel автоматически создаст экземпляр частного канала для модели,
  используя имя класса модели и идентификатор первичного ключа для названия канала
App\Models\User с id равным 1 вернёт экземпляр Illuminate\Broadcasting\PrivateChannel с именем App.Models.User.1
либо вручную
для модели App\Models\User с id равным 1 метод $user->broadcastChannel() вернёт App.Models.User.1
либо возвращать полные экземпляры Channel для трансляции события модели вручную
use Illuminate\Broadcasting\PrivateChannel;
public function broadcastOn(string $event): array {return [new PrivateChannel('user.'.$this->id)];}
// передать экземпляр модели Eloquent в конструктор канала
return [new Channel($this->user)];
- соглашение о событиях
// обновление модели App\Models\Post будет транслировать событие PostUpdated с полезной нагрузкой
{
  "model": {"id": 1, "title": "Мой первый пост"},
  "socket": "someSocketId",
}
// определить собственное имя трансляции и полезную нагрузку
public function broadcastAs(string $event): string|null {
  return match ($event) {'created' => 'post.created', default => null};}
public function broadcastWith(string $event): array {
  return match ($event) {'created' => ['title' => $this->title], default => ['model' => $this]};}
- прослушивание трансляций моделей
// имя события должно иметь префикс ., чтобы указать, что оно не принадлежит определенному пространству имен
  метод private для получения экземпляра канала, метод listen для прослушивания указанного события,
  свойство model, содержит все транслируемые свойства модели
Echo.private(`App.Models.User.${this.user.id}`).listen('.PostUpdated', (e) => {console.log(e.model);});</code></pre><p>Клиентские события</p><pre><code>- транслировать событие другим подключенным клиентам, не затрагивая приложение Laravel
// предупредить пользователей приложения, что другой пользователь печатает сообщение
Echo.private(`chat.${roomId}`).whisper('typing', {name: this.user.name});   // транслировать клиентские события
Echo.private(`chat.${roomId}`).listenForWhisper('typing', (e) => {console.log(e.name);}); // слушать клиентские события</code></pre><p>Уведомления</p><pre><code>- связать трансляцию событий с уведомлениями, чтобы получать новые уведомления без обновления страницы
// уведомления App\Models\User через канал broadcast получены в замыкании
  авторизация канала App.Models.User.{id} включена в файл routes/channels.php
Echo.private(`App.Models.User.${userId}`).notification((notification) => {console.log(notification.type);});
</code></pre></details><details><summary>Concurrency</summary><p></p><pre><code></code></pre></details><details><summary>Context</summary><p></p><pre><code></code></pre></details><details><summary>Contracts</summary><p></p><pre><code></code></pre></details><details><summary>File Storage</summary><p></p><pre><code></code></pre></details><details><summary>Localization</summary><p></p><pre><code></code></pre></details><details><summary>Strings</summary><p></p><pre><code></code></pre></details><details><summary>Package Development</summary><p></p><pre><code></code></pre></details><details><summary>Processes</summary><p></p><pre><code></code></pre></details><details><summary>Task Scheduling</summary><p></p><pre><code></code></pre></details><details><summary>Routes</summary><p>маршрут это URI и поведение при запросе этого URI<br>
ананимные функции маршрутов - это альтернатива контроллеров и консольных команд в виде классов<br>
routes/console.php не определяет HTTP-маршруты, он определяет консольные точки входа<br>
- api.php - маршруты API<br>
- channels.php - маршруты широковещательной передачи<br>
- console.php - маршруты консоли<br>
- web.php - маршруты веб-приложения<br></p><pre><code>use Illuminate\Support\Facades\Route;
Route::get('/greeting', function () {return 'Hello World';});   // вернуть 'Hello World'
Route::get('/jobs', [JobController::class, 'index']);    // вызывать метод index JobController при переходе на /jobs</code></pre><p>маршруты НТТР-методов</p><pre><code>Route::get($uri, $callback);    // маршрут с методом get всегда указывать первым
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);
Route::any('/', function () {});   // все методы на одном маршруте
Route::match(['get', 'post'], '/', function () {});    // несколько методов на одном маршруте
Route::redirect('/here', '/there', 301);   // перенаправить маршрут, третий необязательный параметр (301)
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);    // вернуть шаблон 'welcome' с переменной 'name'
// маршруты поддоменов указывать перед маршрутами корневого домена
Route::domain('{account}.example.com')->group(function () {
  Route::get('/user/{id}', function (string $account, string $id) {});
});</code></pre><p>artisan для маршрутов</p><pre><code>// кеш маршрутов
php artisan route:cache    // кешировать
php artisan route:clear    // очистить
// список маршрутов
php artisan route:list -v    // просмотреть список маршрутов с малой информацией
php artisan route:list -vv    // просмотреть список маршрутов с подробной информацией
php artisan route:list --path=api    // просмотреть список api-маршрутов
php artisan route:list --except-vendor    // просмотреть список маршрутов без встроенных
php artisan route:list --only-vendor    // просмотреть список только встроенных маршрутов
// API-маршруты
php artisan install:api   // установить пакет Sanctum и создать routes/api.php</code></pre><p>настройка маршрутизации в bootstrap/app.php</p><pre><code>// параметры и зависимости маршрута
Route::get('/posts/{post}/comments/{comment}', function (Request $request, string $postId, string $commentId) {});
// изменить ключ
Route::get('/posts/{post:slug}', function (Post $post) {return $post;});
// у необязательного параметра должно быть значение по умолчанию
Route::get('/user/{name?}', function (?string $name = 'John') {return $name;});
// формат маршрута в регулярном выражении
Route::get('/user/{id}/{name}', function (string $id, string $name) { })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);
// методы типовых шаблонов регулярных выражений
whereNumber('id')
whereAlpha('name')
whereAlphaNumeric('name')
whereUuid('id')
whereUlid('id')
whereIn('category', ['movie', 'song', 'painting'])
whereIn('category', CategoryEnum::cases())</code></pre><p>в App\Providers\AppServiceProvider</p><pre><code>// глобальный шаблон
use Illuminate\Support\Facades\Route;
public function boot(): void
{Route::pattern('id', '[0-9]+');}
// связывание модели и URI
{Route::model('user', User::class);}  // в маршруте: Route::get('/users/{user}', function (User $user) { });
// поменять логику связывания модели и URI
{Route::bind('user', function (string $value) {return User::where('name', $value)->firstOrFail();});}
// ограничение частоты запросов
{RateLimiter::for('api', function (Request $request) {return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());});}
// ограничение частоты запросов и своё сообщение
{RateLimiter::for('global', function (Request $request) {
  return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
    return response('Custom response...', 429, $headers);
  });
});}
// ограничение частоты запросов по статусу пользователя
{RateLimiter::for('uploads', function (Request $request) {
  return $request->user()->vipCustomer() ? Limit::none() : Limit::perMinute(100);
});}
// ограничение частоты запросов отдельно по ip и id
{RateLimiter::for('uploads', function (Request $request) {
  return $request->user() ? Limit::perMinute(100)->by($request->user()->id) : Limit::perMinute(10)->by($request->ip());
});}
// ограничение частоты запросов по маршрутам
{Route::middleware(['throttle:uploads'])->group(function () {
  Route::post('/audio', function () {});
  Route::post('/video', function () {});
});}</code></pre><p>маршрут и модель</p><pre><code>- wildcard {user} and parametr function (User $user): привязка модели к маршруту,
  по умолчанию {user} - это id, но можно задать название столба таблицы {user:name}
// привязка модели
Route::get('/users/{user}', function (User $user) {return $user->email;});
либо
Route::get('/users/{user}', function (User $user) {return view('users.show', ['user' => $user]);});
// привязка дочерней модели к родительской
Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {return $post;})->scopeBindings();
// с группировкой
Route::scopeBindings()->group(function () {
  Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {return $post;});
});
// не использовать область действия привязоки
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {return $post;})->withoutScopedBindings();</code></pre><p>маршрут и контроллер</p><pre><code>Route::get('/user/{id}', [UserController::class, 'show']);    // к методу
Route::post('/server', ProvisionServer::class);   // контроллер одиночного действия
Route::get('/profile', [UserController::class, 'show'])->middleware('auth');   // с middleware
Route::put('/post/{id}', function (string $id) {})->middleware(EnsureUserHasRole::class.':editor,publisher');    // с параметром для middleware
Route::get('/user/profile', [UserProfileController::class, 'show'])->name('profile');    // именованный маршрут
// именованный маршрут с параметрами
Route::get('/user/{id}/profile', function (string $id) { })->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);
if ($request->route()->named('profile')) {} // был ли запрос на маршрут
// ресурсный маршрут должен быть последним 
Route::resource('photos', PhotoController::class);   // к ресурсному контроллеру
// выбор методов в ресурсном контроллере
Route::resource('photos', PhotoController::class)->only(['index', 'show']);
Route::resource('photos', PhotoController::class)->except(['create', 'store', 'update', 'destroy']);
// редирект при отсутствии модели
Route::resource('photos', PhotoController::class)->missing(function (Request $request) {
  return Redirect::route('photos.index');
});
Route::resource('photos', PhotoController::class)->withTrashed();    // использовать программно удалённые модели
Route::resource('photos.comments', PhotoCommentController::class);    // вернёт: /photos/{photo}/comments/{comment}
Route::resource('photos.comments', CommentController::class)->shallow();   // при уникальных идентификаторах вернёт: /photos/{photo}/comments
Route::resource('photos', PhotoController::class)->names(['create' => 'photos.build']);  // именованный ресурсный маршрут
Route::resource('users', AdminUserController::class)->parameters(['users' => 'admin_user']);  // вернёт: /users/{admin_user}
Route::resource('photos.comments', PhotoCommentController::class)->scoped(['comment' => 'slug']);   // вернёт: /photos/{photo}/comments/{comment:slug}
Route::apiResource('photos', PhotoController::class);   // ресурсные api-маршруты - маршруты без create и edit</code></pre><p>создание URL-адреса и перенаправление по именованному маршруту</p><pre><code>$url = route('profile');
return redirect()->route('profile');
return to_route('profile');</code></pre><p>группировка маршрутов</p><pre><code>// маршруты c общим контроллером
  Route::controller(JobController::class)->group( function()
  {
    Route::get('/jobs', 'index');
    Route::get('/jobs/create', 'create');
    Route::get('/jobs/{job}', 'show');
    Route::get('/jobs/{job}/edit', 'edit');
    Route::post('/jobs', 'store');
    Route::patch('/jobs/{job}', 'update');
    Route::delete('/jobs/{job}', 'destroy');
  });
Route::middleware(['first', 'second'])->group(function () {Route::get('/', function () {});});  // по middleware `first` и `second`
Route::prefix('admin')->group(function () {Route::get('/users', function () {});});   // по преффиксу: /admin/users
Route::name('admin')->group(function () {Route::get('/users', function () {})->name('users');});  // по имени маршрута: admin.users</code></pre><p>middleware can(действие, маршрут) - на этот маршрут разрешено тому, кому политикой разрешено совершать указанное действие</p><pre><code>// обновить пост
Route::put('/post/{post}', function (Post $post) { })->middleware('can:update,post');
либо
Route::put('/post/{post}', function (Post $post) { })->can('update', 'post');</code></pre><p>определить названия маршрутов в Enums</p><pre><code>namespace App\Enums;
enum Category: string {
  case Fruits = 'fruits';
  case People = 'people';
}
// в маршруте
use App\Enums\Category;
use Illuminate\Support\Facades\Route;
Route::get('/categories/{category}', function (Category $category) {return $category->value;});
Route::fallback(function () {});   // резевный маршрут, если запрос не соответствует ни одному маршруту</code></pre><p>перенаправить</p><pre><code>Route::get('/dashboard', function () {
  return redirect('/home/dashboard');    // на указанную страницу
});
Route::post('/user/profile', function () {
  return back()->withInput();   // перенаправить обратно с записью в сессию данных ввода и фильтром middleware
})->middleware('web');
return redirect()->away('https://www.google.com');  // на внешний домен
return redirect()->action([UserController::class, 'profile'], ['id' => 1]); // на метод контроллера
return redirect()->route('profile', ['id' => 1]);   // на именованный маршрут
return redirect()->route('profile', [$user]);       // на именованный маршрут с указанием модели
// на именованный маршрут с указанием столбца как ключа
return redirect()->route('/profile/{id:slug}', [$user]);
- задать ключ маршрута в модели
public function getRouteKey(): mixed                
{return $this->slug;}
// с записью указанных данных в сессию
return redirect('/dashboard')->with('status', 'Profile updated!');
- отобразить запись в шаблоне
@if (session('status'))
    &lt;div class="alert alert-success"&gt;{{ session('status') }}&lt;/div&gt;
@endif
// перенаправить на ответ
return response()->view('hello', $data, 200)->header('Content-Type', $type);    // с HTML
return response()->json(['name' => 'Abigail', 'state' => 'CA'])->withCallback($request->input('callback'));   // с JSON
return response()->download($pathToFile, $name, $headers);    // заставить браузер пользователя загрузить файл
return response()->file($pathToFile, $headers);   // отображение файла в браузере без загрузки</code></pre><p>выполнить тест</p><pre><code>Route::get('test', function () {
  $job = Job::first();
  TranslateJob::dispatch($job);
  return 'Done';
});</code></pre><p>ресурсный маршрут</p><pre><code>Route::resource('uri', controller);
Route::resource('jobs', JobController::class);
// сформирует для методов класса контроллера маршруты:
jobs.index <span>- показать всё списком</span>
jobs.show <span>- показать один</span>
jobs.create <span>- создать</span>
jobs.edit <span>- редактировать</span>
jobs.store <span>- сохранить</span>
jobs.update <span>- обновить</span>
jobs.destroy <span>- уничтожить</span>
// маршруты только для 'index' и 'show'
Route::resource('jobs', JobController::class, ['only' => ['index', 'show']]);
// все маршруты кроме 'edit'
Route::resource('jobs', JobController::class, ['except' => ['edit']]);
</code></pre></details></details><details><summary>Application</summary><details><summary>Catalog namespace App</summary><p>- Broadcasting - классы широковещательных каналов<br>
- Console - пользовательские команды Artisan<br>
- Events - классы событий<br>
- Notifications - уведомления о событиях, которые происходят в приложении<br>
- Exceptions - классы исключений<br>
- Http - логика обработки поступающих запросов: классы контроллеров, middleware и запросов<br>
- Jobs - планировщики заданий<br>
- Listeners - обработчики событий<br>
- Controllers - логика обработки запросов<br>
- Middleware - фильтрация запросов<br>
- Mail - классы для работы с почтой<br>
- Models - классы моделей Eloquent для взаимодействия с таблицами БД<br>
- Policies - классы политик авторизации определяют возможные действия пользователя<br>
- Providers - классы поставщиков служб: таких как база данных, очереди, валидация и маршрутизация<br>
- Rules - классы правил валидации<br>
- Requests - правила валидации запроса<br>
- Resources - классы ресурсов API<br>
- Services - классы сервисов, которые реализуют бизнес-логику приложения<br>
- Traits - классы трейтов, которые могут быть использованы в других классах<br>
</p></details><details><summary>Middleware</summary><p>middleware - класс для проверки и фильтрации HTTP-запросов, HTTP-ответов, HTTP-заголовков, HTTP-тел, HTTP-методов</p><pre><code>// создать
php artisan make:middleware MyMiddleware
либо указать путь
php artisan make:middleware App\Http\Middleware\MyMiddleware
либо указать путь и пространство имен
php artisan make:middleware App\Http\Middleware\MyMiddleware --namespace=App\Http\Middleware</code></pre><p>получает запрос, сравнивает значение токена из запроса и либо перенаправляет на домашнюю страницу, либо пропускает запрос дальше в приложение</p><pre><code>namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
class MyMiddleware
{
  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    if ($request->input('token') !== 'my-secret-token') {return redirect('/home');} // выполняется до обработки запроса приложением
    return $next($request);
  }
}
либо
  public function handle(Request $request, Closure $next): Response
  {
    return $next($request);
    // выполняется после обработки запроса приложением
    return $response;
  }
// с параметром
class EnsureUserHasRole
{
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next, string $role): Response
  {
    if (! $request->user()->hasRole($role)) {}
    return $next($request);
  }
}</code></pre><p>в bootstrap/app.php</p><pre><code>// группировка
->withMiddleware(function (Middleware $middleware) {
  $middleware->appendToGroup('group-name', [
    First::class,
    Second::class,
  ]);
  $middleware->prependToGroup('group-name', [
    First::class,
    Second::class,
  ]);
})
// добавить к группе
->withMiddleware(function (Middleware $middleware) {
  $middleware->web(append: [EnsureUserIsSubscribed::class]);  // применяется к routes/web.php
  $middleware->api(prepend: [EnsureTokenIsValid::class]);  // применяется к routes/api.php
})
// заменить middleware в группе
$middleware->web(replace: [StartSession::class => StartCustomSession::class]);
// удалить middleware из группы
$middleware->web(remove: [StartSession::class]);
// псевдоним для middleware
->withMiddleware(function (Middleware $middleware) {
  $middleware->alias(['subscribed' => EnsureUserIsSubscribed::class]);
})
Route::get('/profile', function () { })->middleware('subscribed'); // применить псевдоним middleware
// перенаправить пользователя если он гость
->withMiddleware(function (Middleware $middleware) {
  $middleware->redirectGuestsTo('/login');
  либо
  $middleware->redirectGuestsTo(fn (Request $request) => route('login'));
})
// перенаправить пользователя если он аутентифицирован
->withMiddleware(function (Middleware $middleware) {
  $middleware->redirectUsersTo('/panel');
  либо
  $middleware->redirectUsersTo(fn (Request $request) => route('panel'));
})</code></pre><p>в маршруте</p><pre><code>Route::get('/flights', function () { })->middleware('auth');    // доступ только для аутентифицированных
Route::get('/profile', function () { })->middleware(['auth', 'verified']);   // доступ только с подтверждённым email
Route::get('/flights', function () { })->middleware('auth:admin');    // доступ только для аутентифицированных по guard 'admin' из config/auth.php</code></pre><p>метод share может возвращать общие данные для всех страниц Inertia</p><pre><code>namespace App\Http\Middleware;
use App\Models\Post;
use Illuminate\Http\Request;
use Inertia\Middleware;
class HandleInertiaRequests extends Middleware
{
  public function share(Request $request)
  {
    return [...parent::share($request), 'auth' => [
      'user' => $request->user(),
      'permissions' => ['post' => ['create' => $request->user()->can('create', Post::class)]],
    ]];
  }
}</code></pre><p>форматирование значений поля ввода input настраивается Illuminate\Foundation\Http\Middleware\TrimStrings и Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull в bootstrap/app.php</p><p>доверенные прокси указать в bootstrap/app.php</p><pre><code>->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(at: [
    '192.168.1.1',
    '10.0.0.0/8',
  ]);
})
заголовки доверенных прокси
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(headers: Request::HEADER_X_FORWARDED_FOR |
    Request::HEADER_X_FORWARDED_HOST |
    Request::HEADER_X_FORWARDED_PORT |
    Request::HEADER_X_FORWARDED_PROTO |
    Request::HEADER_X_FORWARDED_AWS_ELB
  );
})
доверять всем прокси
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(at: '*');
})</code></pre><p>доверенный host</p><pre><code>имя хоста, на которого реагировать указать в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: ['laravel.test']);
})
не доверять поддоменам хоста
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: ['laravel.test'], subdomains: false);
})
указать доверенные хосты в файле конфигурации
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: fn () => config('app.trusted_hosts'));
})
</code></pre></details><details><summary>Controllers</summary><p>контроллеры - классы, которые обрабатывают HTTP-запросы и возвращают HTTP-ответы, view, JSON, файлы и редиректы</p><pre><code>php artisan make:controller UserController    // создать контроллер
php artisan make:controller ProvisionServer --invokable    // создать контроллер одного действия
// создать ресурсный контроллер
php artisan make:controller PhotoController --resource
либо
php artisan make:controller PhotoController -r
php artisan make:controller PhotoController --model=Photo --resource --requests   // с привязкой к моделе и валидацией
php artisan make:controller PhotoController --api    // api-контроллер контроллер без create и edit</code></pre><table><caption>Methods</caption><thead><tr><th>Controller Method </th><th>Action</th></tr></thead><tbody><tr><td>index</td><td>view all</td></tr><tr><td>show</td><td>view one</td></tr><tr><td>create</td><td>show form for create</td></tr><tr><td>store</td><td>create</td></tr><tr><td>edit</td><td>show form for edit</td></tr><tr><td>update</td><td>update</td></tr><tr><td>destroy</td><td>delete</td></tr></tbody></table><p>контроллере</p><pre><code>// избежать проблему n+1: with([ ])
public function __invoke()
{
  $jobs = Job::query()->with(['employer', 'tags'])->where('title', 'LIKE', '%'.request('q').'%')->get();
  return view('results', ['jobs' => $jobs]);
}
// указать middleware в контроллере
class UserController extends Controller implements HasMiddleware
{
  public static function middleware(): array
  {
    return [
      'auth',
      new Middleware('log', only: ['index']),
      new Middleware('subscribed', except: ['store']),
    ];
  }
}
// реализовать middleware в контроллере
public static function middleware(): array
{
  return [
    function (Request $request, Closure $next) {
      return $next($request);
    },
  ];
}
// внедрить зависимости через конструктор
use App\Repositories\UserRepository;
class UserController extends Controller
{
  public function __construct(protected UserRepository $users) { }
}
// внедрить зависимости через параметры функции
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class UserController extends Controller
{
  public function store(Request $request): RedirectResponse
  {
    $name = $request->name;
    return redirect('/users');
  }
}
// получить параметр из маршрута
- маршрут
use App\Http\Controllers\UserController;
Route::put('/user/{id}', [UserController::class, 'update']);
- контроллер
class UserController extends Controller
{
  public function update(Request $request, string $id): RedirectResponse
  {
    // действия с пользователем
    return redirect('/users');
  }
}
</code></pre></details><details><summary>Authentication</summary><p>- аутентификация - процесс проверки подлинности пользователя, чтобы убедиться, что он тот, за кого себя выдает<br>
- конфигурация в config/auth.php, в массиве guards "охранники" для аутентификации пользователя<br>
- информацию об аутентифицированном пользователе хранится в сессии пользователя<br>
- файл cookie, отправленный браузеру, содержит идентификатор сессии, чтобы последующие запросы к приложению могли связать пользователя с правильной сессией<br>
- встроенные службы аутентификации Laravel для запросов из веб-браузеров и доступны через фасады Auth и Session<br>
- встроенные службы аутентификации ориентированы на web-аутентификацию на основе файлов cookie<br>
- Fortify - серверная служба аутентификации<br>
- при каждом запросе к API удаленная служба отправляет API-токен, приложение проверяет входящий токен по таблице допустимых API-токенов и «аутентифицирует» запрос как выполняемый пользователем, связанным с этим API-токеном<br>
- библиотеки Passport и Sanctum ориентированы на аутентификацию токена API
- Passport – надежный и сложный пакет для аутентификации API, когда нужен весь функционал OAuth2<br>
- Sanctum –  простое и полное решение для аутентификации API, аутентификации SPA и мобильной аутентификации, включая поддержку «scopes» или «abilities»<br>
- Laravel автоматически хеширует пароли пользователей при аутентификации<br>
- настроить сложность хеширования в config/hashing.php или в BCRYPT_ROUNDS из .env<br></p><pre><code>php artisan config:publish hashing    // опубликовать config/hashing.php
'rehash_on_login' => false    // отключить автоматическое хеширование</code></pre><p>встроенная аутентификация: use Illuminate\Support\Facades\Auth;<br>
"запомнить меня" - аутентифирован до выхода из системы вручную, столбец remember_token в таблице users<br></p><pre><code>$user = Auth::user();   // получить текущего аутентифицированного пользователя
$id = Auth::id();   // получить текущего аутентифицированного пользователя по идентификатору
$user = $request->user();   // получить текущего аутентифицированного пользователя из запроса
if (Auth::check()) { }    // проверить что пользователь аутентифицировался
if (Auth::guard('admin')->attempt($credentials)) { }   // С указанием guard из config/auth.php
if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) { }   // параметр "запомнить меня"
if (Auth::viaRemember()) { }   // есть ли "запомнить меня"
if (Auth::once($credentials)) { }    // аутентификации пользователя только для одного запроса без сессии и cookie
Auth::login($user);   // передать пользователя на аутентификацию
Auth::login($user, $remember = true);   // передать пользователя на аутентификацию с "запомнить меня"
Auth::guard('admin')->login($user);   // передать пользователя на аутентификацию с указанием guard
Auth::loginUsingId(1);    // аутентификация по id
Auth::loginUsingId(1, remember: true);    // аутентификация по id с "запомнить меня"</code></pre><p>Basic HTTP - аутентификация без cookie и страницы входа</p><pre><code>Route::get('/profile', function () { })->middleware('auth.basic');
- добавить в .htaccess для HTTP Basic и PHP FastCGI
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
- использовать в middleware
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;
class AuthenticateOnceWithBasicAuth
{
  public function handle(Request $request, Closure $next): Response
  {return Auth::onceBasic() ?: $next($request);}
}
далее
Route::get('/api/user', function () { })->middleware(AuthenticateOnceWithBasicAuth::class);</code></pre><p>выход пользователя из приложения</p><pre><code>public function logout(Request $request): RedirectResponse
{
  Auth::logout();   // удалить информацию аутентификации из сессии пользователя
  $request->session()->invalidate();    // аннулировать сессию пользователя
  $request->session()->regenerateToken();   // повторно сгенерировать токен CSRF пользователя
  return redirect('/');
}</code></pre><p>аннулировать сессии на других устройствах, без аннулирования сессии на текущем устройстве</p><pre><code>// в маршруте
Route::middleware(['auth', 'auth.session'])->group(function () {
    Route::get('/', function () { });
});
// в контроллере
Auth::logoutOtherDevices($currentPassword);</code></pre><p>настроить время, через которое нужно повторно ввести пароль: password_timeout в config/auth.php</p><pre><code>// форма подтверждения пароля
Route::get('/confirm-password', function () {
    return view('auth.confirm-password');
})->middleware('auth')->name('password.confirm');
- далее
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Redirect;
Route::post('/confirm-password', function (Request $request) {
  if (! Hash::check($request->password, $request->user()->password)) {
    return back()->withErrors([
      'password' => ['Предоставленный пароль не соответствует нашим записям.']
    ]);
  }
  $request->session()->passwordConfirmed();
  return redirect()->intended();
})->middleware(['auth', 'throttle:6,1']);
- далее
Route::get('/settings', function () { })->middleware(['password.confirm']);
Route::post('/settings', function () { })->middleware(['password.confirm']);</code></pre><p>добавить свой guard</p><pre><code>namespace App\Providers;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    Auth::viaRequest('custom-token', function (Request $request) {
      return User::where('token', (string) $request->token)->first();
    });
  }
}
// в config/auth.php
'guards' => [
  'api' => [
    'driver' => 'jwt',
    'provider' => 'users',
  ],
],
либо
'guards' => [
  'api' => [
    'driver' => 'custom-token',
  ],
],
// в маршруте
Route::middleware('auth:api')->group(function () { });</code></pre><p>свой провайдер аутентификации пользователей для нереляционной БД</p><pre><code>namespace App\Providers;
use App\Extensions\MongoUserProvider;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    Auth::provider('mongo', function (Application $app, array $config) {
      return new MongoUserProvider($app->make('mongo.connection'));
    });
  }
}
// в config/auth.php
'providers' => [
  'users' => [
    'driver' => 'mongo',
  ],
],
'guards' => [
  'web' => [
    'driver' => 'session',
    'provider' => 'users',
  ],
]</code></pre><p>собственная аутентификации пользователей<br></p><pre><code>namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;
class LoginController extends Controller
{
  public function authenticate(Request $request): RedirectResponse
  {
    $credentials = $request->validate([
      'email' => ['required', 'email'],
      'password' => ['required'],
    ]);
    if (Auth::attempt($credentials)) {
      $request->session()->regenerate();
      return redirect()->intended('dashboard');
    }
    return back()->withErrors([
      'email' => 'Предоставленные учетные данные не соответствуют нашим записям.',
    ])->onlyInput('email');
  }
}
// Дополнительные условия аутентификации
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) { }
либо
use Illuminate\Database\Eloquent\Builder;
if (Auth::attempt([
  'email' => $email,
  'password' => $password,
  fn (Builder $query) => $query->has('activeSubscription'),
])) { }
либо
if (Auth::attemptWhen([
  'email' => $email,
  'password' => $password,
], function (User $user) {return $user->isNotBanned();})) { }
</code></pre><details> <summary>Email verification</summary><p>автоматическая отправка электронного письма со ссылкой для подтверждения</p><pre><code>namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    use Notifiable;
}</code></pre><p>при регистрации пользователя вручную</p><pre><code>use Illuminate\Auth\Events\Registered;
event(new Registered($user));</code></pre><p>- в таблице users миграции 0001_01_01_000000_create_users_table.php столбец столбец email_verified_at для даты и времени подтверждения email<br>
- Чтобы правильно реализовать подтверждение электронной почты, необходимо определить три маршрута:<br>
- отображения пользователю уведомления об отправке ссылки подтверждения<br></p><pre><code>Route::get('/email/verify', function () {
    return view('auth.verify-email');
})->middleware('auth')->name('verification.notice');</code></pre><p>обработки запроса при нажатии на ссылку подтверждения</p><pre><code>use Illuminate\Foundation\Auth\EmailVerificationRequest;

Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
    $request->fulfill();

    return redirect('/home');
})->middleware(['auth', 'signed'])->name('verification.verify');</code></pre><p>повторная отправка ссылки подтверждения</p><pre><code>use Illuminate\Http\Request;

Route::post('/email/verification-notification', function (Request $request) {
    $request->user()->sendEmailVerificationNotification();

  return back()->with('message', 'Verification link sent!');
})->middleware(['auth', 'throttle:6,1'])->name('verification.send');</code></pre><p>изменить сообщение о подтверждении в App\Providers\AppServiceProvider</p><pre><code>use Illuminate\Auth\Notifications\VerifyEmail;
use Illuminate\Notifications\Messages\MailMessage;

public function boot(): void
{
    VerifyEmail::toMailUsing(function (object $notifiable, string $url) {
        return (new MailMessage)
            ->subject('Verify Email Address')
            ->line('Click the button below to verify your email address.')
            ->action('Verify Email Address', $url);
    });
}
</code></pre></details><details> <summary>Fortify</summary><p>установить Fortify<br></p><code>./sail composer require laravel/fortify<br></code><p>создать папки и роуты Fortify<br></p><code>./sail artisan fortify:install<br></code><p>обновить БД<br></p><code>./sail artisan migrate<br></code></details></details><details><summary>Session</summary><p>сессия - это способ хранения данных между запросами в виде массива, JSON и отдельных переменных в файлах, базе данных, кэше или в памяти<br>
по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
драйверы кеша и БД могут быть использованы для хранения данных сессии<br></p><pre><code>php artisan session:table
php artisan migrate</code></pre><p>по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
драйверы кеша и БД могут быть использованы для хранения данных сессии<br></p><pre><code>php artisan session:table
php artisan migrate</code></pre><p>настройка хранения сессии в config/session.php<br>
- file – сессии хранятся в storage/framework/sessions.<br>
- cookie – сессии хранятся в безопасных, зашифрованных файлах Cookies.<br>
- database – сессии хранятся в реляционной базе данных.<br>
- memcached / redis – сессии хранятся в одном из этих быстрых хранилищ на основе кеша.<br>
- dynamodb – сессии хранятся в AWS DynamoDB.<br>
- array – сессии хранятся в массиве PHP и не будет сохранены.<br>
- по умолчанию database, данные сессии в таблице sessions в 0001_01_01_000000_create_users_table.php<br>
получить данные из сессии<br></p><pre><code>- через экземпляр Request
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\View\View;
class UserController extends Controller
{
  public function show(Request $request, string $id): View
  {
    $value = $request->session()->get('key', 'default');
    $user = $this->users->find($id);
    return view('user.profile', ['user' => $user]);
  }
}
- через глобальный помощник session
Route::get('/home', function () {
  $value = session('key');    // получить часть данных из сессии
  $value = session('key', 'default');   // получить часть данных из сессии с указанием значения по умолчанию
  session(['key' => 'value']);    // сохранить часть данных в сессию
});
$data = $request->session()->all();   // получить все данные сессии
$data = $request->session()->only(['username', 'email']);   // получить только указанные данные сессии
$data = $request->session()->except(['username', 'email']);   // получить данные сессии без указанных
$value = $request->session()->pull('key', 'default');   // получает и удаляет элемент из сессии
if ($request->session()->has('users')) { }   // наличие элемента в сессии не равного null
if ($request->session()->exists('users')) { }    // наличие элемента в сессии в т.ч. null
if ($request->session()->missing('users')) { }    // элемент в сессии либо null, либо отсутствует</code></pre><p>данные в сессии</p><pre><code>$request->session()->put('key', 'value');   // сохранить через экземпляр запроса
session(['key' => 'value']);    // сохранить через глобальный помощник «session»
$request->session()->push('user.teams', 'developers');    // вставка нового значения
// увеличение и уменьшение целочисленных значений в сессии
$request->session()->increment('count');
$request->session()->increment('count', $incrementBy = 2);
$request->session()->decrement('count');
$request->session()->decrement('count', $decrementBy = 2);
$request->session()->now('status', 'Задача выполнена успешно!');    // сохранить только для текущего запроса
$request->session()->flash('status', 'Задача выполнена успешно!');    // сохранить только для следующего запроса
$request->session()->reflash();   // для нескольких запросов одновременно, потом удаление
$request->session()->keep(['username', 'email']);   // сохранить отдельные данные для следующего запроса
$request->session()->forget('name');    // удалить единственный ключ
$request->session()->forget(['name', 'status']);    // удалить несколько ключей
$request->session()->flush();   // удалить все данные из сессии
$request->session()->regenerate();    // повторно сгенерировать идентификатор сессии
$request->session()->invalidate();    // удалить идентификатор сессии все её данные</code></pre><p>блокировка сессии</p><pre><code>// по умолчанию блокировка 10 сек и ожидание получения блокировки 10 сек
Route::post('/profile', function () { })->block();
Route::post('/profile', function () { })->block($lockSeconds = 10, $waitSeconds = 10);
Route::post('/order', function () { })->block($lockSeconds = 10, $waitSeconds = 10);
</code></pre></details><details><summary>CSRF</summary><p>- CSRF - это атака, при которой злоумышленник отправляет запрос от имени пользователя без его ведома<br>
- Laravel использует токены CSRF для защиты от атак CSRF<br>
- токены CSRF хранятся в сессии пользователя и проверяются при каждом запросе<br>
- токены CSRF могут быть использованы только для POST, PUT, PATCH и DELETE запросов<br></p><pre><code>Route::get('/token', function (Request $request) {
  $token = $request->session()->token();    // доступ к токену CSRF
  либо
  $token = csrf_token();
});</code></pre><p>в каждой форме с методом «POST», «PUT», «PATCH» или «DELETE» должен быть токен</p><pre><code>&lt;form method="POST" action="/profile"&gt;
  @csrf
  либо
  &lt;input type="hidden" name="_token" value="{{ csrf_token() }}" /&gt;
&lt;/form&gt;</code></pre><p>исключить маршруты из проверки токена в файле bootstrap/app.php</p><pre><code>->withMiddleware(function (Middleware $middleware) {
  $middleware->validateCsrfTokens(except: [
    'stripe/*',
    'http://example.com/foo/bar',
    'http://example.com/foo/*',
  ]);
})</code></pre><p>добавить токен</p><pre><code>&lt;meta name="csrf-token" content="{{ csrf_token() }}"&gt;    // в HTML-заголовок X-CSRF-TOKEN
&lt;meta name="x-xsrf-token" content="{{ csrf_token() }}"&gt;    // в заголовок X-XSRF-TOKEN</code></pre><p>По умолчанию файл resources/js/bootstrap.js включает HTTP-библиотеку Axios, которая автоматически отправляет заголовок X-XSRF-TOKEN.</p></details><details><summary>Autherization</summary><p>авторизация - проверка прав доступа пользователя, основаная на политиках и шлюзах, может быть выполнена с помощью:<br>
- middleware, контроллеров, моделей и шаблонов<br>
- фасадов, классов и функций<br>
- политик и шлюзов, которые могут быть определёны в любом месте приложения и использоваться вместе<br>
</p><details><summary>Gates</summary><p>Gate (шлюз) - это функция проверки прав пользователя без использования модели или ресурса, например просмотр панели управления администратора.<br>
- объявляется в App\Providers\AppServiceProvider методом boot()<br>
- исспользуется для простых ограничений ролей<br>
- аргументом всегда принимает пользователя, к которому применяет ограничения<br>
- методы шлюза для авторизации полномочий: allows, denies, check, any, none, authorize, can, cannot<br>
- директивы авторизации Blade: @can, @cannot, @canany<br>
- дополнительные аргументы по необходимости.<br></p><pre><code>namespace App\Providers;
use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
class AppServiceProvider extends ServiceProvider
- может ли пользователь обновить модель
public function boot(): void
{
  Gate::define('update-post', function (User $user, Post $post) {
    return $user->id === $post->user_id;
  });
}
либо вынести логику в отдельный класс (политику) и объявить в App\Providers\AppServiceProvider
use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;
public function boot(): void
{
  Gate::define('update-post', [PostPolicy::class, 'update']);
}</code></pre><p>Gate::define - объявляю Gate,<br>
'update-post' - название возможности предоставляемой пользователю<br>
function (User $user, Post $post) - вернёт true/false,<br>
true - этому пользователю можно пользоваться этой возможностью<br>
false - этому пользователю нельзя пользоваться этой возможностью<br>
После этого в любом контроллере можем проверять роль конкрено указав пользователя</p><pre><code>if (Gate::forUser($user)->allows('update-post', $post)) { }   // если может редактировать пост
if (Gate::forUser($user)->denies('update-post', $post)) { }   // если не может редактировать пост
if (Gate::allows('update-post', $post)) { }               // если разрешено
if (Gate::denies('update-post', $post)) {abort(403);}     // если запрещено
if (Gate::any(['update-post', 'delete-post'], $post)) { }   // если может редактировать и удалять
if (Gate::none(['update-post', 'delete-post'], $post)) { }    // если не может редактировать и удалять
if (Gate::check('create-post', [$category, $pinned])) { }   // дополнительный контекст для check
Gate::authorize('update-post', $post);   // проверить роль текущего пользователя встроенным методом
Gate::authorize('update', App\Models\Post::class);   // 'update' - действие, $post - объект модели, либо класс модели
Gate::allowIf(fn (User $user) => $user->isAdministrator());   // встроенная роверка авторизации
Gate::denyIf(fn (User $user) => $user->banned());   // встроенная роверка авторизации</code></pre><p>авторизация действий через шлюзы</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;
class PostController extends Controller
{
  public function update(Request $request, Post $post): RedirectResponse
  {
    if (! Gate::allows('update-post', $post)) {abort(403);}
    return redirect('/posts');
  }
}
либо
public function update(Request $request, Post $post): RedirectResponse
{
  Gate::authorize('update', $post);   // если пользователь не авторизован для 'update', то выбросит исключение
  return redirect('/posts');
}
либо
public function create(Request $request): RedirectResponse
{
  Gate::authorize('create', Post::class);   // класс определяет какую политику использовать при авторизации
  return redirect('/posts');
}
// дополнительный контекст при принятии решений об авторизации
Gate::define('create-post', function (User $user, Category $category, bool $pinned) {
  if (! $user->canPublishToGroup($category->group)) {return false;}
  elseif ($pinned && ! $user->canPinPosts()) {return false;}
  return true;
});</code></pre><p>ответ шлюза</p><pre><code>use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::deny('Вы должны быть администратором.');
});
- полный возвращенный шлюзом ответ
$response = Gate::inspect('edit-settings');
if ($response->allowed()) { }
else {echo $response->message();}
- код статуса HTTP-ответа вручную
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::denyWithStatus(404);
});
- ответ 404
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::denyAsNotFound();
});
- before выполняется перед всеми другими проверками авторизации
Gate::before(function (User $user, string $ability) {
  if ($user->isAdministrator()) {return true;}
});
- after выполненяется после всех других проверок авторизации
Gate::after(function (User $user, string $ability, bool|null $result, mixed $arguments) {
  if ($user->isAdministrator()) {return true;}
});
</code></pre></details><details><summary>Policies</summary><p>политики - это классы с логикой авторизации пользователя на действия с конкретной моделью или ресурсом.<br>
по конвенции название политики содержит название модели.<br></p><code>php artisan make:policy PostPolicy --model=Post   // создать политику с привязкой к модели: создаст методы для модели Post</code><table><caption>Methods</caption><thead><tr><th>Policy Method </th><th>Action</th></tr></thead><tbody><tr><td>viewAny</td><td>view all</td></tr><tr><td>view</td><td>view one</td></tr><tr><td>create</td><td>create & store</td></tr><tr><td>update</td><td>edit</td></tr><tr><td>delete</td><td>mark as delete</td></tr><tr><td>restore</td><td>unmark as delete</td></tr><tr><td>forceDelete</td><td>permanently delete</td></tr></tbody></table><p>Laravel проверит наличие политик в app/Models/Policies, а затем в app/Policies. Назвать политику не по конвенции:</p><pre><code>namespace App\Providers;
use App\Models\ModelName;
use App\Policies\PolicyName;
use Illuminate\Support\Facades\Gate;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void
  {
    Gate::policy(Order::class, OrderPolicy::class);
  }
}
- использовать
Gate::guessPolicyNamesUsing(function (string $modelClass) { });</code></pre><p>политика</p><pre><code>namespace App\Policies;
use App\Models\Post;
use App\Models\User;
class PostPolicy
{
  public function update(User $user, Post $post): bool
  {
    return $user->id === $post->user_id;
  }
}
return $user->id === $post->user_id ? Response::allow() : Response::deny('You do not own this post.');    // подробный ответ
return $user->id === $post->user_id ? Response::allow() : Response::denyWithStatus(404);    // настроить HTTP-ответ
return $user->id === $post->user_id ? Response::allow() : Response::denyAsNotFound();   // встроенный ответ 404
return $user->role == 'writer';   // имеет ли пользователь право создавать посты
return $user?->id === $post->user_id;   // $user типа User либо null: авторизация для не аутентифицированных пользователей
return $user->id === $post->user_id && $user->canUpdateCategory($category);   // проверка id и роли пользователя
Gate::authorize('update', [$post, $request->category]);   // передать методу дополнительный контекст в массиве
// before будет выполнен перед любыми другими методами в политике
public function before(User $user, string $ability): bool|null
{
  if ($user->isAdministrator()) {return true;}    // выполнить предварительную авторизацию
  return null;
}</code></pre><p>контроллер<br>
- модель App\Models\User включает два метода авторизации: can и cannot<br>
- если для модели зарегистрирована политика, то can вызовет политику,<br>
- если нет политики, то can вызовет шлюз<br></p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class PostController extends Controller
{
  public function update(Request $request, Post $post): RedirectResponse
  {
    if ($request->user()->cannot('update', $post)) {abort(403);}
    return redirect('/posts');
  }
}
public function store(Request $request): RedirectResponse
{
  if ($request->user()->cannot('create', Post::class)) {abort(403);}    // имя класса определяет используемую политику
  return redirect('/posts');
}
</code></pre></details></details><details><summary>Requests</summary><p>запросы позволяют создавать правила валидации, авторизации и преобразования данных в контроллерах, маршрутах и сервисах</p><pre><code>php artisan make:request StoreUserRequest    // создать запрос
php artisan make:request StoreUserRequest --rules=store    // создать запрос с правилами валидации
php artisan make:request App\Http\Requests\StoreUserRequest   // указать путь к классу
php artisan make:request App\Http\Requests\StoreUserRequest --namespace=App\Http\Requests   // указать путь к классу и пространство имен</code></pre><p>в запросе App/Http/Requests</p><pre><code>public function authorize(): bool {return true;}    // если логика авторизации обрабатывается в другом месте
- авторизация запросов
use App\Models\Comment;
public function authorize(): bool
{
  $comment = Comment::find($this->route('comment'));    // route() - доступ к параметрам URI
  return $comment && $this->user()->can('update', $comment);  // user() - текущй аутентифицированный пользователь
}
return $this->user()->can('update', $this->comment);    // либо с привязкой модели к маршруту
- изменить сообщения об ошибках
public function messages(): array
{
  return [
    'title.required' => 'A title is required',
    'body.required' => 'A message is required',
  ];
}
- изменить имя атрибута
public function attributes(): array
{return ['email' => 'email address'];}
- подготовить данные из запроса для валидации
use Illuminate\Support\Str;
protected function prepareForValidation(): void
{$this->merge(['slug' => Str::slug($this->slug)]);}
- получить отвалидированные данные
$validated = $request->validated();
либо через валидатор
$validated = $validator->validated();
либо метод safe вернёт экземпляр Illuminate\Support\ValidatedInput с методами only, except, и all
$validated = $request->safe()->only(['name', 'email']);
$validated = $request->safe()->except(['name', 'email']);
$validated = $request->safe()->all();
- итерировать проверенные данные
foreach ($request->safe() as $key => $value) { }
- доступ к проверенным данным как в массиве
$validated = $request->safe();
$email = $validated['email'];
- добавить поля к проверенным данным
$validated = $request->safe()->merge(['name' => 'Taylor Otwell']);
- получить проверенные данные в виде экземпляра collection
$collection = $request->safe()->collect();
- нормализовать данные после валидации
protected function passedValidation(): void
{$this->replace(['name' => 'Taylor']);}
- данные формы ввода
$input = $request->all();   // все данные в виде массива
$input = $request->collect();   // все данные в виде коллекции
$input = $request->input();   // все данные как ассоциированный массив
$name = $request->input('name', 'Sally');   // данные одного поля, второй параметр - значение по умолчанию
$name = $request->input('products.0.name');   // получить элемент из массива данных формы
$names = $request->input('products.*.name');  // получить по указанному фильтру массив из массива данных формы
$query = $request->query();   // все данные из строки запроса в виде ассоциативного массива
$name = $request->query('name', 'Helen');   // данные отдельного параметра из строки запроса, второй параметр - значение по умолчанию
$name = $request->string('name')->trim();   // в виде объекта String
$perPage = $request->integer('per_page');   // в виде целого числа
$archived = $request->boolean('archived');  // в логическом виде
$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');    // дата - имя параметра, формат вывода и часовой пояс
$status = $request->enum('status', Status::class);    // перечисление - имя параметра и класс перечислений
$products = $request->enums('products', Product::class);    // перечесления в виде массива
$input = $request->only(['username', 'password']);    // получить только указанный массив
$input = $request->only('username', 'password');    // получить только указанный список
$input = $request->except(['credit_card']);   // получить всё кроме указанного массива
$input = $request->except('credit_card');   // получить всё кроме указанного списка
if ($request->has('name')) { }    // если есть параметр в запросе
if ($request->has(['name', 'email'])) { }    // если есть в запросе все параметры из массива
if ($request->hasAny(['name', 'email'])) { }    // если есть в запросе любой параметр из массива
$request->whenHas('name', function (string $input) { });    // выполнить функцию если в запросе параметр есть
$request->whenHas('name', function (string $input) { }, function () { });    // выполнить первую функцию если в запросе параметр есть, вторую если нет
if ($request->filled('name')) { }   // проверить есть ли значение
if ($request->isNotFilled('name')) { }    // проверить отсутствие значения или пустая строка
if ($request->isNotFilled(['name', 'email'])) { }   // все ли отсутствуют или пустые
if ($request->anyFilled(['name', 'email'])) { }   // true если хоть один не пустой
$request->whenFilled('name', function (string $input) { });   // если не пустой, то выполнит действие
$request->whenFilled('name', function (string $input) { }, function () { });    // если нет значения, то выполнить второе действие
if ($request->missing('name')) { }    // проверить существует ли ключ параметра в запросе
$request->whenMissing('name', function () { }, function () { });    // если отсутствует, то первое действие, если присутствует - то второе
$request->merge(['votes' => 0]);    // объединить существующие данные запроса с данными из ввода с перезаписью по ключу
$request->mergeIfMissing(['votes' => 0]);   // добавить в запрос данные из ввода если в запросе такого ключа нет
$request->flash();    // сохранить входные данные запроса в сессии, для доступа только во время следующего запроса
$request->flashOnly(['username', 'email']);   // сохранить в сессии входные данные запроса только по указанным ключам
$request->flashExcept('password');   // сохранить в сессии входные данные запроса кроме указанного ключа
return redirect('/form')->withInput();    // сохранить в сессии входные данные запроса и вернуть к форме
return redirect()->route('user.create')->withInput();    // сохранить в сессии входные данные запроса и перенаправить по маршруту
return redirect('/form')->withInput($request->except('password'));  // сохранить в сессии входные данные запроса кроме указанного ключа и вернуть к форме
$username = $request->old('username');    // получить данные предыдущего запроса
&lt;input type="text" name="username" value="{{ old('username') }}"&gt;    // получить данные предыдущего запроса в шаблоне Blade
$value = $request->cookie('name');   // получить значение cookie
$file = $request->file('photo');    // получить файл из запроса
$file = $request->photo;    // получить файл из запроса динамически
if ($request->hasFile('photo')) { }   // проверить если файл в запросе
if ($request->file('photo')->isValid()) { }   // валидация загрузки файла
$path = $request->photo->path();    // доступ к пути файла
$extension = $request->photo->extension();    // доступ к расширению файла
- сохранить файл из запроса
$path = $request->photo->store('images', 's3'); // имя файла автоматически, 's3' - имя диска сохранения (необязательный)
$path = $request->photo->storeAs('images', 'filename.jpg', 's3');   // задать имя файла</code></pre><p>сообщение об ошибке</p><pre><code>$validator - экземпляр Illuminate\Support\Facades\Validator
$errors = $validator->errors();   // вернёт экземпляр Illuminate\Support\MessageBag
echo $errors->first('email');   // получить первое сообщение об ошибке для указанного поля
- Illuminate\Support\MessageBag - набор методов для работы с сообщениями об ошибках
foreach ($errors->get('email') as $message) { }    // получить массив всех сообщений для указанного поля
foreach ($errors->get('attachments.*') as $message) { }    // получить все сообщения для каждого из элементов массива
foreach ($errors->all() as $message) { }   // получить массив всех сообщений для всех полей
if ($errors->has('email')) { }   // проверить наличие сообщений об ошибках для указанного поля</code></pre><p>при ошибке, Laravel запишет ошибки и входящие данные запроса в массив $errors сессии</p><pre><code>- /resources/views/post/create.blade.php
&lt;h1&gt;Создание поста блога&lt;/h1&gt;
@if ($errors->any())
  &lt;div class="alert alert-danger"&gt;
    &lt;ul&gt;
      @foreach ($errors->all() as $error)
        &lt;li&gt;{{ $error }}&lt;/li&gt;
      @endforeach
    &lt;/ul&gt;
  &lt;/div&gt;
@endif
- проверить наличие ошибок и вывести
&lt;label for="title"&gt;Название сообщения&lt;/label&gt;
&lt;input
  id="title"
  type="text"
  name="title"
  class="@error('title') is-invalid @enderror"
/&gt;
@error('title')
  &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;
@enderror
- перезаполнить форму данными предыдущего запроса из сессии
$title = $request->old('title');
либо
&lt;input type="text" name="title" value="{{ old('title') }}"&gt;</code></pre><p>доступ к запросу</p><pre><code>- в контроллере
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class UserController extends Controller
{
  public function store(Request $request): RedirectResponse
  {
    $name = $request->input('name');
    return redirect('/users');
  }
}
- в маршруте
Route::get('/', function (Request $request) { });</code></pre><p>путь запроса</p><pre><code>$uri = $request->path();    // получить путь запроса
if ($request->is('admin/*')) {}   // соответствие пути запроса шаблону
if ($request->routeIs('admin.*')) {}    // соответствие пути запроса именованному маршруту
$url = $request->url();   // получить URL для входящего запроса
$urlWithQueryString = $request->fullUrl();   // получить полный URL для входящего запроса
$request->fullUrlWithQuery(['type' => 'phone']);   // добавить строку запроса в массив переменных строки запроса
$request->fullUrlWithoutQuery(['type']);   // получить строку запроса без указанного параметра</code></pre><p>получить host входящего запроса</p><pre><code>$request->host();
$request->httpHost();
$request->schemeAndHttpHost();</code></pre><p>метод запроса</p><pre><code>- данные формы могут быть отправлены в запросе с помощью метода GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD, TRACE, CONNECT<br>
$method = $request->method();   // получить
if ($request->isMethod('post')) { }   // проверить</code></pre><p>заголовок запроса</p><pre><code>- получить из запроса данные JSON: заголовок Content-Type = application/json<br>
- получить из запроса данные формы: заголовок Content-Type = application/x-www-form-urlencoded<br>
$value = $request->header('X-Header-Name', 'default');    // второй параметр не обязательный
if ($request->hasHeader('X-Header-Name')) { }    // проверить наличие заголовка
$token = $request->bearerToken();    // получить токен из заголовка Authorization
$ipAddress = $request->ip();    // получить ip-адрес клиента, который сделал запрос
$ipAddresses = $request->ips();   // все ip-адреса с перенаправлением и прокси</code></pre><p>тип контента в заголовке Accept</p><pre><code>$contentTypes = $request->getAcceptableContentTypes();   // получить массив типов контента, принятые запросом
if ($request->accepts(['text/html', 'application/json'])) { }    // true если один из типов контента принят запросом, иначе false
$preferred = $request->prefers(['text/html', 'application/json']);   // указать предпочитаемый для запроса тип контента из массива
if ($request->expectsJson()) {}    // если ждём только JSON</code></pre><p>получить запрос в формате PSR-7</p><pre><code>- установить зависимости
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7
- интерфейс в маршрут или контроллер
use Psr\Http\Message\ServerRequestInterface;
Route::get('/', function (ServerRequestInterface $request) { });          
</code></pre><details><summary>Validate</summary><p>валидация - проверка данных на соответствие встроенным и пользовательских правилам</p><pre><code>- валидация и авторизация данных
namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class StoreUserRequest extends FormRequest
{
  public function authorize(): bool
  {return true;}
  public function rules(): array
  {return [
    'name' => 'required|string|max:255',
    'email' => 'required|string|email|max:255|unique:users',
    'password' => 'required|string|min:8|confirmed',
  ]};
}
- применение в контроллере
use App\Http\Requests\StoreUserRequest;
class UserController extends Controller
{
  public function store(StoreUserRequest $request): RedirectResponse
  {
    // использую уже валидированые данные
    return redirect('/users');
  }
}
- применение в маршруте
use App\Http\Requests\StoreUserRequest;
Route::post('/user', function (StoreUserRequest $request) {
  // использую уже валидированые данные
  return redirect('/users');
});
- применение в middleware
use App\Http\Requests\StoreUserRequest;
class StoreUserMiddleware
{
  public function handle(Request $request, Closure $next): Response
  {
    $request->validateWithBag('user', (new StoreUserRequest())->rules());
    return $next($request);
  }
}</code></pre><p>валидация в контроллере</p><pre><code>- routes/web.php
use App\Http\Controllers\PostController;
Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);
- App\Http\Controllers\PostController.php
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;
class PostController extends Controller
{
  // показать форму для создания нового сообщения в блоге
  public function create(): View
  {return view('post.create');}
  // сохранить новую запись в блоге
  public function store(Request $request): RedirectResponse
  {
  $validated = $request->validate([
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
  ]);
  либо
  $validatedData = $request->validate([
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
  ]);
  либо сохранение любых сообщений об ошибках в именованную коллекцию ошибок
  $validatedData = $request->validateWithBag('post', [
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
  ]);
  return redirect('/posts');
  }
}
- bail: прекратить выполнение правил валидации для атрибута после первой ошибки
$request->validate([
  'title' => 'bail|required|unique:posts|max:255',
  'body' => 'required',
]);
- вложенные поля в HTTP-запросе
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'author.name' => 'required',
  'author.description' => 'required',
]);
- экранировать символ
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'v1\.0' => 'required',
]);
- необязательные поля помечать nullable
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
  'publish_at' => 'nullable|date',
]);</code></pre><p>создать свой валидатор</p><pre><code>$validator = Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
]);
if ($validator->fails()) {return redirect('/post/create')->withErrors($validator)->withInput();} // withErrors() - передать ошибки в $errors сессии
if ($validator->stopOnFirstFailure()->fails()) { }   // прекратить валидацию всех атрибутов после возникновения первой ошибки
$validated = $validator->validated();   // получить проверенные данные
$validated = $validator->safe()->only(['name', 'email']);   // получить только указанные данные
$validated = $validator->safe()->except(['name', 'email']);   // получить все данные кроме указанных
- для автоматического перенаправления вызвать validate()
Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
])->validate();
- свои сообщения об ошибках в валидаторе
$validator = Validator::make($input, $rules, $messages = [
  'required' => 'Поле :attribute является обязательным.',
]);
- сохранить сообщения об ошибках в именованной коллекции ошибок
Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
])->validateWithBag('post');
- свои имена для атрибутов валидатора
$validator = Validator::make($input, $rules, $messages, [
  'email' => 'Адрес электронной почты',
]);
- дополнительная валидация after()
$validator = Validator::make(/* ... */);
$validator->after(function ($validator) {
  if ($this->somethingElseIsInvalid()) {
    $validator->errors()->add('field', 'Что-то не так с этим полем!');
  }
});
- exclude_if - не проверять это поле, если указанное поле имеет заданное значение
$validator = Validator::make($data, [
  'has_appointment' => 'required|boolean',
  'appointment_date' => 'exclude_if:has_appointment,false|required|date',
  'doctor_name' => 'exclude_if:has_appointment,false|required|string',
]);
- exclude_unless - не проверять это поле, если указанное поле не имеет заданное значение
$validator = Validator::make($data, [
  'has_appointment' => 'required|boolean',
  'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
  'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
]);
- sometimes - проверить поле если оно существует
$validator = Validator::make($data, [
    'email' => 'sometimes|required|email',
]);
$validator = Validator::make($request->all(), ['photos.profile' => 'required|image']);  // HTTP-запрос содержит поле photos[profile]
//проверить каждый элемент массива
$validator = Validator::make($request->all(), [
  'person.*.email' => 'email|unique:users',
  'person.*.first_name' => 'required_with:person.*.last_name',
]);</code></pre><p>правила валидации</p><pre><code>php artisan make:rule Uppercase   // создать правило
php artisan make:rule Uppercase --implicit   // создать правило для обязательного атрибута
- в app/Rules/Uppercase.php
namespace App\Rules;
use Closure;
use Illuminate\Contracts\Validation\ValidationRule;
class Uppercase implements ValidationRule
{
  public function validate(string $attribute, mixed $value, Closure $fail): void
  {if (strtoupper($value) !== $value) {$fail('The :attribute must be uppercase.');}}
}
- применить правило
use App\Rules\Uppercase;
$request->validate(['name' => ['required', 'string', new Uppercase]]);
if (strtoupper($value) !== $value) {$fail('validation.uppercase')->translate();}  // вызвать локализацию сообщения об ошибке
либо
$fail('validation.location')->translate(['value' => $this->value], 'fr')
- доступ к внешним данным из класса правил
namespace App\Rules;
use Illuminate\Contracts\Validation\DataAwareRule;
use Illuminate\Contracts\Validation\ValidationRule;
class Uppercase implements DataAwareRule, ValidationRule
{
  protected $data = [];
  public function setData(array $data): static
  {
    $this->data = $data;
    return $this;
  }
}
- доступ к экземпляру валидатора, выполняющему проверку
namespace App\Rules;
use Illuminate\Contracts\Validation\ValidationRule;
use Illuminate\Contracts\Validation\ValidatorAwareRule;
use Illuminate\Validation\Validator;
class Uppercase implements ValidationRule, ValidatorAwareRule
{
  protected $validator;
  public function setValidator(Validator $validator): static
  {
    $this->validator = $validator;
    return $this;
  }
}
- правило без создания класса через $fail
use Illuminate\Support\Facades\Validator;
use Closure;
$validator = Validator::make($request->all(), [
  'title' => ['required', 'max:255',
    function (string $attribute, mixed $value, Closure $fail) {
      if ($value === 'foo') {$fail("The {$attribute} is invalid.");}
    },
  ],
]);
protected $stopOnFirstFailure = true;   // прекратить валидацию всех атрибутов после первой ошибки
- перенаправить при ошибке вручную
protected $redirect = '/dashboard';
либо
protected $redirectRoute = 'dashboard';</code></pre><p>именованные коллекции ошибок позволяют делить ошибки валидации на разные группы (экземпляр MessageBag)</p><pre><code>return redirect('/register')->withErrors($validator, 'login');    // задать имя коллекции ошибок
{{ $errors->login->first('email') }}    // получить доступ к именованной коллекции из переменной $errors сессии</code></pre><p>каждое встроенное правило валидации Laravel содержит текст сообщения об ошибке в файле lang/en/validation.php</p><pre><code>// свой перевод - скопируй lang/en/validation.php и отредактируй
php artisan lang:publish    // опубликовать сообщения по умолчанию
- в resources/lang/ru/validation.php
'custom' => [
  'email' => [
    'required' => 'Нам нужно знать ваш адрес электронной почты!',
    'max' => 'Ваш адрес электронной почты слишком длинный!'
  ],
],
'attributes' => ['email' => 'email address']    // заменить имя атрибута по умолчанию
// пользовательские имена для атрибутов
Validator::make($request->all(), ['credit_card_number' => 'required_if:payment_type,cc']);
'values' => ['payment_type' => ['cc' => 'кредитная карта']],    // в resources/lang/ru/validation.php
// использование одного сообщения валидации для полей на основе массива
'custom' => [
  'person.*.email' => [
    'unique' => 'Each person must have a unique email address',
  ]
]    </code></pre><p>проверка полей при условии</p><pre><code>- создать валидатор
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($request->all(), [
  'email' => 'required|email',
  'stars' => 'required|numeric',
]);
- условие проверки: reason - поле проверки, required|max:500 - правила проверки,
- function (Fluent $input) - условие, при котором проверяем
use Illuminate\Support\Fluent;
$validator->sometimes('reason', 'required|max:500', function (Fluent $input) {return $input->stars >= 100;});
либо
$input = [
  'channels' => [
    ['type' => 'email', 'address' => 'abigail@example.com'],
    ['type' => 'url', 'address' => 'https://example.com'],
  ],
];
$validator->sometimes('channels.*.address', 'email', function (Fluent $input, Fluent $item) {
    return $item->type === 'email';
});
$validator->sometimes('channels.*.address', 'url', function (Fluent $input, Fluent $item) {
    return $item->type !== 'email';
});</code></pre><p>валидация массивов</p><pre><code>use Illuminate\Support\Facades\Validator;
$input = [
  'user' => [
    'name' => 'Taylor Otwell',
    'username' => 'taylorotwell',
    'admin' => true,
  ],
];
Validator::make($input, ['user' => 'array:name,username']);   // правило array - список разрешенных ключей массива</code></pre><p>применить правила проверки к каждому элементу массива подлежащего проверке атрибута</p><pre><code>use App\Rules\HasPermission;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
$validator = Validator::make($request->all(), [
  'companies.*.id' => Rule::forEach(function (string|null $value, string $attribute) {
    return [
      Rule::exists(Company::class, 'id'),
      new HasPermission('manage-company', $value),
    ];
  }),
]);</code></pre><p>указать индекс или позицию элемента массива в сообщении об ошибке</p><pre><code>use Illuminate\Support\Facades\Validator;
$input = [
  'photos' => [
    ['name' => 'BeachVacation.jpg', 'description' => 'Фото моего пляжного отдыха!'],
    ['name' => 'GrandCanyon.jpg', 'description' => '']
  ],
];
Validator::validate(
  $input,
  ['photos.*.description' => 'required'],
  ['photos.*.description.required' => 'Пожалуйста, укажите описание для фото № :position.']
);</code></pre><p>валидация файлов</p><pre><code>- для файла
Validator::validate($input, ['attachment' => [
  'required', File::types(['mp3', 'wav'])->min(1024)->max(12 * 1024)],
]);
либо с размерами kb, mb, gb и tb
File::image()->min('1kb')->max('10mb')
- для изображения
Validator::validate($input, [
  'photo' => ['required',   // dimensions - размер изображения
    File::image()->min(1024)->max(12 * 1024)->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500))],
]);</code></pre><p>валидация паролей</p><pre><code>use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\Password;
$validator = Validator::make($request->all(), ['password' => ['required', 'confirmed', Password::min(8)],]);
Password::min(8)    // не менее 8 символов
Password::min(8)->letters()   // хотя бы одна буква
Password::min(8)->mixedCase()   // хотя бы одна заглавная и одна строчная буква
Password::min(8)->numbers()   // хотя бы одна цифра
Password::min(8)->symbols()   // хотя бы один символ
Password::min(8)->uncompromised()   // убедиться, что пароль не был скомпрометирован
Password::min(8)->letters()->mixedCase()->numbers()->symbols()->uncompromised()   // все вместе</code></pre><p>указать правила проверки паролей по умолчанию в одном месте приложения</p><pre><code>namespace App\Providers
use Illuminate\Validation\Rules\Password;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void
  {
    Password::defaults(function () {
      $rule = Password::min(8);
      return $this->app->isProduction() ? $rule->mixedCase()->uncompromised() : $rule;
    });
  }
}
- применить правила проверки паролей по умолчанию
'password' => ['required', Password::defaults()],
</code></pre></details></details><details><summary>HTTP Client</summary><p>API для HTTP-клиента Guzzle ориентированное на наиболее распространенные варианты использования.</p><pre><code>- для отправки использовать методы head, get, post, put, patch и delete фасада Http
use Illuminate\Support\Facades\Http;
$response = Http::get('http://example.com');
// получать доступ к данным ответа JSON
return Http::get('http://example.com/users/1')['name'];
// формировать URL-запросы с использованием шаблонов
Http::withUrlParameters([
  'endpoint' => 'https://laravel.com',
  'page' => 'docs',
  'version' => '11.x',
  'topic' => 'validation',
])->get('{+endpoint}/{page}/{version}/{topic}');
// получить информацию о сформированном экземпляре исходящего запроса
return Http::dd()->get('http://example.com');
// при запросах POST, PUT и PATCH обычно отправляются данные
use Illuminate\Support\Facades\Http;
$response = Http::post('http://example.com/users', [
  'name' => 'Steve',
  'role' => 'Network Administrator']);
// строка запроса в виде массива пар ключ/значение
$response = Http::get('http://example.com/users', ['name' => 'Taylor', 'page' => 1]);
либо
Http::retry(3, 100)->withQueryParameters(['name' => 'Taylor', 'page' => 1])->get('http://example.com/users')
// запросы с передачей данных в URL-кодированной строке
$response = Http::asForm()->post('http://example.com/users', ['name' => 'Sara', 'role' => 'Privacy Consultant']);
// отправка необработанного тела запроса
$response = Http::withBody(base64_encode($photo), 'image/jpeg')->post('http://example.com/photo');
// отправлять файлы в запросах, состоящих из нескольких частей
первый аргумент имя файла, второй - его содержимое, третий - будет считаться именем файла, четвертый - заголовки
$response = Http::attach(
  'attachment', file_get_contents('photo.jpg'), 'photo.jpg', ['Content-Type' => 'image/jpeg']
)->post('http://example.com/attachments');
// передать потоковый ресурс
$photo = fopen('photo.jpg', 'r');
$response = Http::attach('attachment', $photo, 'photo.jpg')->post('http://example.com/attachments');
// дополнительные параметры для исходящего запроса
$response = Http::withOptions(['debug' => true])->get('http://example.com/users');
- заголовки могут быть добавлены к запросам с помощью метода withHeaders
$response = Http::withHeaders(['X-First' => 'foo', 'X-Second' => 'bar'])
  ->post('http://example.com/users', ['name' => 'Taylor']);
// указать тип контента, который ожидаем в ответ
$response = Http::accept('application/json')->get('http://example.com/users');
// указать, что приложение ожидает тип содержимого application/json
$response = Http::acceptJson()->get('http://example.com/users');
// заменить все заголовки
$response = Http::withHeaders(['X-Original' => 'foo'])->replaceHeaders(['X-Replacement' => 'bar'])
  ->post('http://example.com/users', ['name' => 'Taylor']);
- аутентификация
// Basic HTTP-аутентификация
$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);
// Digest HTTP-аутентификациия
$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);
// добавить токен в заголовок Authorization запроса
$response = Http::withToken('token')->post(/* ... */);
- время ожидания ответа в секундах (по умолчанию 30)
$response = Http::timeout(3)->get(/* ... */);
// время ожиидания при подключению к серверу
$response = Http::connectTimeout(3)->get(/* ... */);
- автоматический повтор запроса
$response = Http::retry(3, 100)->post(/* ... */);
// количество миллисекунд между повторами
use Exception;
$response = Http::retry(3, function (int $attempt, Exception $exception) {return $attempt * 100;})->post(/* ... */);
либо
$response = Http::retry([100, 200])->post(/* ... */);
// следует ли повторить попытку
use Exception;
use Illuminate\Http\Client\PendingRequest;
$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {
  return $exception instanceof ConnectionException;})->post(/* ... */);
// внести изменение в запрос перед новой попыткой
use Exception;
use Illuminate\Http\Client\PendingRequest;
use Illuminate\Http\Client\RequestException;
$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {
if (! $exception instanceof RequestException || $exception->response->status() !== 401) {return false;}
$request->withToken($this->getNewToken());
return true;})->post(/* ... */);
// отключить выброс исключения если все запросы неуспешные
$response = Http::retry(3, 100, throw: false)->post(/* ... */);
- метод get возвращает экземпляр Illuminate\Http\Client\Response со своими методами
$response->body() : string;
$response->json($key = null, $default = null) : mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->resource() : resource;
$response->status() : int;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;
// имеет ли ответ заданный код состояния
$response->ok() : bool;                  // 200 OK
$response->created() : bool;             // 201 Created
$response->accepted() : bool;            // 202 Accepted
$response->noContent() : bool;           // 204 No Content
$response->movedPermanently() : bool;    // 301 Moved Permanently
$response->found() : bool;               // 302 Found
$response->badRequest() : bool;          // 400 Bad Request
$response->clientError() : bool;         // 400 Client Error
$response->unauthorized() : bool;        // 401 Unauthorized
$response->paymentRequired() : bool;     // 402 Payment Required
$response->forbidden() : bool;           // 403 Forbidden
$response->notFound() : bool;            // 404 Not Found
$response->requestTimeout() : bool;      // 408 Request Timeout
$response->conflict() : bool;            // 409 Conflict
$response->unprocessableEntity() : bool; // 422 Unprocessable Entity
$response->tooManyRequests() : bool;     // 429 Too Many Requests
$response->serverError() : bool;         // 500 Internal Server Error
$response->successful();                 // имеет ли ответ код состояния >= 200 and < 300
$response->failed();                     // имеет ли ответ код состояния >= 400
$response->onError(callable $callback);  // выполнить функцию обратного вызова, если произошла ошибка
// выбросить исключение
use Illuminate\Http\Client\Response;
$response = Http::post(/* ... */);
$response->throw();                      // если произошла ошибка клиента или сервера
$response->throwIf($condition);          // если произошла ошибка и данное условие истинно
$response->throwIf(fn (Response $response) => true);  // если произошла ошибка и данное замыкание принимает значение true
$response->throwUnless(fn (Response $response) => false); // если произошла ошибка и данное замыкание принимает значение false
$response->throwUnless($condition);      // если произошла ошибка и заданное условие равно false
$response->throwIfStatus(403);           // если ответ имеет определенный код состояния
$response->throwUnlessStatus(200);       // если только ответ не содержит определенного кода состояния
return $response['user']['id'];
// throw возвращает экземпляр ответа, если ошибки не произошло
return Http::post(/* ... */)->throw()->json();
// выполнить дополнительную логику до того, как будет сгенерировано исключение
use Illuminate\Http\Client\Response;
use Illuminate\Http\Client\RequestException;
return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) { })->json();
- настроить длину сообщения об ошибке в bootstrap/app.php (по умолчанию 120 символов)
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->truncateRequestExceptionsAt(240);    // Truncate request exception messages to 240 characters
  $exceptions->dontTruncateRequestExceptions();})   // Disable request exception message truncation</code></pre><p>Guzzle Middleware</p><pre><code>- для изменения исходящего запроса
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\RequestInterface;
$response = Http::withRequestMiddleware(
  function (RequestInterface $request) {
    return $request->withHeader('X-Example', 'Value');})->get('http://example.com');
- для анализа входящего ответа
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\ResponseInterface;
$response = Http::withResponseMiddleware(
  function (ResponseInterface $response) {
    $header = $response->getHeader('X-Example');
    return $response;})->get('http://example.com');</code></pre><p>параллельные запросы</p><pre><code>use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
  $pool->get('http://localhost/first'),
  $pool->get('http://localhost/second'),
  $pool->get('http://localhost/third')]);
return $responses[0]->ok() && $responses[1]->ok() && $responses[2]->ok();
либо
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
  $pool->as('first')->get('http://localhost/first'),
  $pool->as('second')->get('http://localhost/second'),
  $pool->as('third')->get('http://localhost/third')]);
return $responses['first']->ok();
- пользовательские заголовки или middleware к пулу запросов
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$headers = ['X-Example' => 'example'];
$responses = Http::pool(fn (Pool $pool) => [
  $pool->withHeaders($headers)->get('http://laravel.test/test'),
  $pool->withHeaders($headers)->get('http://laravel.test/test'),
  $pool->withHeaders($headers)->get('http://laravel.test/test')]);</code></pre><p>в App\Providers\AppServiceProvider</p><pre><code>- зарегистрировать middleware для всех исходящих запросов и входящих ответов
use Illuminate\Support\Facades\Http;
Http::globalRequestMiddleware(fn ($request) => $request->withHeader('User-Agent', 'Example Application/1.0'));
Http::globalResponseMiddleware(fn ($response) => $response->withHeader('X-Finished-At', now()->toDateTimeString()));
- настроить параметры по умолчанию для каждого исходящего запроса
use Illuminate\Support\Facades\Http;
public function boot(): void {Http::globalOptions(['allow_redirects' => false]);}
- определить макрос
use Illuminate\Support\Facades\Http;
public function boot(): void {
  Http::macro('github', function () {
    return Http::withHeaders(['X-Example' => 'example'])->baseUrl('https://github.com');});}
// вызвать макрос в любом месте приложения
$response = Http::github()->get('/');</code></pre><p>Тестирование</p><pre><code>- возвращать пустые ответы с кодом состояния 200 на каждый запрос
use Illuminate\Support\Facades\Http;
Http::fake();
$response = Http::post(/* ... */);
либо
Http::fake([
  'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),    // заглушка JSON ответа для адресов GitHub
  'google.com/*' => Http::response('Hello World', 200, $headers)]);   // заглушка строкового ответа для адресов Google
либо
Http::fake([
  'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),   // заглушка JSON ответа для адресов GitHub
  '*' => Http::response('Hello World', 200, ['Headers'])]);   // заглушка строкового ответа для всех остальных адресов
либо сгенерировать простую строку, JSON и пустые ответы, указав в качестве ответа строку, массив или целое число
Http::fake([
  'google.com/*' => 'Hello World',
  'github.com/*' => ['foo' => 'bar'],
  'chatgpt.com/*' => 200]);
- имитация исключений соединения
Http::fake(['github.com/*' => Http::failedConnection()]);
- фальсификация серии ответов
Http::fake(['github.com/*' => Http::sequence()->push('Hello World', 200)->push(['foo' => 'bar'], 200)->pushStatus(404)]);
либо с ответом по умолчанию
Http::fake(['github.com/*' => Http::sequence()->push('Hello World', 200)->push(['foo' => 'bar'], 200)->whenEmpty(Http::response())]);
либо без указания конкретного шаблона URL
Http::fakeSequence()->push('Hello World', 200)->whenEmpty(Http::response());
- запросы без поддельного ответа, вызовут исключение
use Illuminate\Support\Facades\Http;
Http::preventStrayRequests();
Http::fake(['github.com/*' => Http::response('ok')]);
Http::get('https://github.com/laravel/framework');    // "ok" response is returned
Http::get('https://laravel.com');   // exception is thrown
- проверить запросы, которые получает клиент
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::withHeaders(['X-First' => 'foo'])
  ->post('http://example.com/users', ['name' => 'Taylor', 'role' => 'Developer']);
Http::assertSent(function (Request $request) {
  return $request->hasHeader('X-First', 'foo') &&
  $request->url() == 'http://example.com/users' &&
  $request['name'] == 'Taylor' && $request['role'] == 'Developer';});
- утверждать, что указанный запрос не был отправлен
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::post('http://example.com/users', ['name' => 'Taylor', 'role' => 'Developer']);
Http::assertNotSent(function (Request $request) {return $request->url() === 'http://example.com/posts';});
- определить, сколько запросов было отправлено во время теста
Http::fake();
Http::assertSentCount(5);
- утверждать, что во время теста не было отправлено никаких запросов
Http::fake();
Http::assertNothingSent();
- запись Запросов/Ответов
Http::fake([
  'https://laravel.com' => Http::response(status: 500),
  'https://nova.laravel.com/' => Http::response()]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded();
[$request, $response] = $recorded[0];
- фильтрация пар запрос/ответ
use Illuminate\Http\Client\Request;
use Illuminate\Http\Client\Response;
Http::fake([
  'https://laravel.com' => Http::response(status: 500),
  'https://nova.laravel.com/' => Http::response()]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded(function (Request $request, Response $response) {
  return $request->url() !== 'https://laravel.com' && $response->successful();});</code></pre><p>События</p><pre><code>RequestSending - до отправки запроса, содержит общедоступное свойство $request
ResponseReceived - после получения ответа, содержит общедоступные свойства $request и $response
ConnectionFailed - ответ не получен, содержит общедоступное свойство $request
- создать прослушиватели событий для этих событий
use Illuminate\Http\Client\Events\RequestSending;
class LogRequest {public function handle(RequestSending $event): void { // $event->request ... }}
</code></pre></details><details><summary>Response</summary><p>Response - это HTTP-ответ, который возвращается пользователю в виде HTML, JSON, XML, текстового файла, изображения, редиректа и т.д.</p><pre><code>- вернуть ответ в контроллере
return response('Hello World', 200);
return response()->json(['name' => 'John Doe']);    // вернуть JSON-ответ
return response()->json(['name' => 'John Doe'], 200, [], JSON_PRETTY_PRINT);    // вернуть JSONP-ответ
return redirect('/home');   // вернуть редирект
return redirect('/home')->with('status', 'Profile updated!');   // вернуть редирект с сообщением
// добавить заголовки
return response($content)->header('Content-Type', $type)->header('X-Header-One', 'Header Value')->header('X-Header-Two', 'Header Value');
return response($content)->withHeaders(['Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value',]);
- вернуть ответ в маршруте
Route::get('/', function () {return 'Hello World';});   // преобразует в НТТР-ответ
Route::get('/', function () {return [1, 2, 3];});   // преобразует в JSON
Route::get('/user/{user}', function (User $user) {return $user;});    // модель преобразует в JSON
Route::get('/home', function () {return response('Hello World', 200)->header('Content-Type', 'text/plain');});  // передать код и заголовок
- установить Cache-Control
Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
  Route::get('/privacy', function () {});
  Route::get('/terms', function () {});
});</code></pre><p>cookies</p><pre><code>- добавить файл куки к ответу
return response('Hello World')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);
- поставить куки в очередь для добавления к ответу когда он будет создан
use Illuminate\Support\Facades\Cookie;
Cookie::queue('name', 'value', $minutes);
либо
$cookie = cookie('name', 'value', $minutes);
return response('Hello World')->cookie($cookie);
- удалить куки, обнулив срок действия
return response('Hello World')->withoutCookie('name');
либо Cookie::expire('name');
- отключить шифрование и подпись куки в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
  $middleware->encryptCookies(except: ['cookie_name']);
})</code></pre><p>потоковые ответы</p><pre><code>function streamedContent(): Generator {
    yield 'Hello, ';
    yield 'World!';
}
Route::get('/stream', function () {
  return response()->stream(function (): void {
    foreach (streamedContent() as $chunk) {
      echo $chunk;
      ob_flush();
      flush();  // для отправки буферизованного содержимого
      sleep(2); // Simulate delay between chunks...
    }
  }, 200, ['X-Accel-Buffering' => 'no']);
});
- отправить JSON из маршрута
use App\Models\User;
Route::get('/users.json', function () {
  return response()->streamJson(['users' => User::cursor()]);
});
- отправить в ответ результат функции без записи на диск
use App\Services\GitHub;
return response()->streamDownload(function () {
  echo GitHub::api('repo')->contents()->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');</code></pre><p>создать свой ответ</p><pre><code>namespace App\Providers;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {Response::macro('caps', function (string $value) {
    return Response::make(strtoupper($value));
  });}
}
- применить в контроллере
return response()->caps('foo');
</code></pre></details><details> <summary>Notifications</summary><p>каждое уведомление представлено единым классом в app/Notifications</p><pre><code>php artisan make:notification InvoicePaid   // сгенерировать новое уведомление
- отправка уведомлений через трейт Notifiable
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {use Notifiable;}
// получить экземпляр уведомления
use App\Notifications\InvoicePaid;
$user->notify(new InvoicePaid($invoice));
- отправка уведомлений через фасад Notification полезно при отправке уведомления нескольким объектам
use Illuminate\Support\Facades\Notification;
Notification::send($users, new InvoicePaid($invoice));
// отправить немедленно без постановки в очередь
Notification::sendNow($developers, new DeploymentCompleted($deployment));
// метод via определяет по каким каналам будет доставлено уведомление
  каналы: mail, database, broadcast, vonage, slack и http://laravel-notification-channels.com/
public function via(object $notifiable): array {return $notifiable->prefers_sms ? ['vonage'] : ['mail', 'database'];}
- поместить уведомление в очередь
// для каждой комбинации получателя и каналов будет создана задача в очереди
// если у уведомления три получателя и два канала, то в очередь будет отправлено шесть задач
namespace App\Notifications;
use App\Models\User;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  $user->notify(new InvoicePaid($invoice));}
- отложить доставку уведомления
$delay = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($delay));
либо указать величину задержки
$user->notify((new InvoicePaid($invoice))->delay(['mail' => now()->addMinutes(5), 'sms' => now()->addMinutes(10)]));
либо в классе уведомления
public function withDelay(object $notifiable): array {
return ['mail' => now()->addMinutes(5), 'sms' => now()->addMinutes(10)];}
- указать соединение вручную
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onConnection('redis');}}
// указать соединение для каждого канала
public function viaConnections(): array {return ['mail' => 'redis', 'database' => 'sync'];}
// указать очередь для каждого канала
public function viaQueues(): array {return ['mail' => 'mail-queue', 'slack' => 'slack-queue'];}
- посредник для уведомлений в очереди в классе уведомления
use Illuminate\Queue\Middleware\RateLimited;
public function middleware(object $notifiable, string $channel) {
  return match ($channel) {
    'email' => [new RateLimited('postmark')],
    'slack' => [new RateLimited('slack')],
    default => []};}
- уведомления в очереди и транзакции в БД
use App\Notifications\InvoicePaid;
$user->notify((new InvoicePaid($invoice))->afterCommit());
либо
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->afterCommit();}}
- следует ли отправлять уведомление в очереди после его обработки обработчиком очереди
public function shouldSend(object $notifiable, string $channel): bool {return $this->invoice->isPaid();}
- уведомления по запросу
// отправить уведомление тому, чьи данные не сохранены в БД
use Illuminate\Broadcasting\Channel;
use Illuminate\Support\Facades\Notification;
Notification::route('mail', 'taylor@example.com')
  ->route('vonage', '5555555555')
  ->route('slack', '#slack-channel')
  ->route('broadcast', [new Channel('channel-name')])
  ->notify(new InvoicePaid($invoice));
// указать имя получателя при отправке уведомления по запросу
Notification::route('mail', ['barrett@example.com' => 'Barrett Blair'])->notify(new InvoicePaid($invoice));
// несколько маршрутов для нескольких каналов уведомлений
Notification::routes([
  'mail' => ['barrett@example.com' => 'Barrett Blair'],
  'vonage' => '5555555555',
])->notify(new InvoicePaid($invoice));</code></pre><p>почтовые уведомления</p><pre><code>- сформировать почтовое уведомление
параметр name в config/app.php используется в верхнем и нижнем колонтитулах почтовых уведомлений
public function toMail(object $notifiable): MailMessage {
  $url = url('/invoice/'.$this->invoice->id);
  return (new MailMessage)->greeting('Hello!')->line('One of your invoices has been paid!')
    ->lineIf($this->amount > 0, "Amount paid: {$this->amount}")->action('View Invoice', $url)
    ->line('Thank you for using our application!');}
// указать, что почтовое сообщение относится к ошибке: кнопка действия будет красной
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->error()->subject('Invoice Payment Failed')->line('...');}
// указать собственный шаблон почтового уведомления
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->view('mail.invoice.paid', ['invoice' => $this->invoice]);}
либо с текстовым содержимым
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->view(
    ['mail.invoice.paid', 'mail.invoice.paid-text'],
    ['invoice' => $this->invoice]);}
// в сообщении только текст
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->text('mail.invoice.paid-text', ['invoice' => $this->invoice]);}
// адрес отправителя в config/mail.php, указать вручную для отдельного уведомления
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->from('barrett@example.com', 'Barrett Blair')->line('...');}
// указать адрес электронной почты получателя (по умолчанию свойство email объекта получателя) 
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForMail(Notification $notification): array|string {
    return $this->email_address;    // вернуть только адрес электронной почты
    return [$this->email_address => $this->name];   // вернуть адрес электронной почты и имя
  }}
// по умолчанию для класса InvoicePaid тема сообщения будет Invoice Paid, указать тему вручную
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->subject('Notification Subject')->line('...');}
// почтовый драйвер по умолчанию в config/mail.php, указать вручную
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->mailer('postmark')->line('...');}
// опубликовать шаблоны почтовых уведомлений в resources/views/vendor/notifications для изменения
php artisan vendor:publish --tag=laravel-notifications
- глубокая настройка сообщения перед его доставкой
use Symfony\Component\Mime\Email;
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->withSymfonyMessage(function (Email $message) {
    $message->getHeaders()->addTextHeader('Custom-Header', 'Header Value');});}
- указать получателя сообщения с помощью метода to объекта почтового отправления
use App\Mail\InvoicePaid as InvoicePaidMailable;
use Illuminate\Mail\Mailable;
public function toMail(object $notifiable): Mailable {return (new InvoicePaidMailable($this->invoice))->to($notifiable->email);}
- отправка уведомления по запросу
use App\Mail\InvoicePaid as InvoicePaidMailable;
use Illuminate\Notifications\AnonymousNotifiable;
use Illuminate\Mail\Mailable;
public function toMail(object $notifiable): Mailable {
  $address = $notifiable instanceof AnonymousNotifiable ? $notifiable->routeNotificationFor('mail') : $notifiable->email;
  return (new InvoicePaidMailable($this->invoice)) ->to($address);}
- предварительный просмотр почтовых уведомлений
use App\Models\Invoice;
use App\Notifications\InvoicePaid;
Route::get('/notification', function () {$invoice = Invoice::find(1);
  return (new InvoicePaid($invoice))->toMail($invoice->user);});</code></pre><p>почтовые вложения</p><pre><code>- метод attach принимает абсолютный путь к файлу
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attach('/path/to/file');}
либо
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attach('/path/to/file', [
    'as' => 'name.pdf', 'mime' => 'application/pdf']);}
либо
use App\Mail\InvoicePaid as InvoicePaidMailable;
public function toMail(object $notifiable): Mailable {
  return (new InvoicePaidMailable($this->invoice))->to($notifiable->email)->attachFromStorage('/path/to/file');}
// прикрепить несколько файлов
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attachMany([
    '/path/to/forge.svg', '/path/to/vapor.svg' => ['as' => 'Logo.svg', 'mime' => 'image/svg+xml']]);}
// присоединения необработанной строки в качестве вложения, указать имя файла вложения
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attachData($this->pdf, 'name.pdf', ['mime' => 'application/pdf']);}
// добавить теги и метаданные к сообщению
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Comment Upvoted!')->tag('upvote')->metadata('comment_id', $this->comment->id);}</code></pre><a href="https://documentation.mailgun.com/en/latest/user_manual.html#tagging-1">Mailgun теги<br></a><a href="https://documentation.mailgun.com/en/latest/user_manual.html#attaching-data-to-messages">Mailgun метаданные<br></a><a href="https://postmarkapp.com/blog/tags-support-for-smtp">Postmark теги<br></a><a href="https://postmarkapp.com/support/article/1125-custom-metadata-faq">Postmark метаданные<br></a><a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_MessageTag.html">Amazon SES<br></a><p>почтовые уведомления с разметкой Markdown</p><pre><code>- сгенерировать уведомление с шаблоном Markdown
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid
// уведомление с шаблоном Markdown
public function toMail(object $notifiable): MailMessage {
  $url = url('/invoice/'.$this->invoice->id);
  return (new MailMessage)->subject('Invoice Paid')->markdown('mail.invoice.paid', ['url' => $url]);}
- написать сообщение
<x-mail::message>
  # Invoice Paid
  Your invoice has been paid!
  <x-mail::button :url="$url">View Invoice</x-mail::button>
  Thanks, {{ config('app.name') }}
</x-mail::message>
// создать кнопку
<x-mail::button :url="$url" color="green">View Invoice</x-mail::button>
// указанный блок текста на панели
<x-mail::panel>This is the panel content.</x-mail::panel>
// создать таблицу
<x-mail::table>
  | Laravel       | Table         | Example       |
  | ------------- | :-----------: | ------------: |
  | Col 2 is      | Centered      | $10           |
  | Col 3 is      | Right-Aligned | $20           |
</x-mail::table>
- опубликовать все почтовые компоненты Markdown для настройки в resources/views/vendor/mail
php artisan vendor:publish --tag=laravel-mail
// отредактировать CSS в resources/views/vendor/mail/html/themes/default.css
- создать новую тему для компонентов Laravel Markdown
// поместить файл CSS в каталог html/themes и указать его имя в парметре theme в config/mail.php
// указать тему для отдельного уведомления
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->theme('invoice')->subject('Invoice Paid')->markdown('mail.invoice.paid', ['url' => $url]);}</code></pre><p>канал database</p><pre><code>- database хранит информацию уведомления в таблице БД
// для первичных ключей UUID или ULID заменить метод morphs на uuidMorphs или ulidMorphs в миграции таблицы уведомлений
php artisan make:notifications-table    // создать таблицу базы данных для хранения уведомлений
php artisan migrate
- сохранить уведомление в таблице БД
// если использовать метод toArray, то можно создать один массив данных для каналов database и broadcast
public function toDatabase(object $notifiable): array {
  return ['invoice_id' => $this->invoice->id, 'amount' => $this->invoice->amount];}
// указать тип уведомления для сохранения в таблице БД, по умолчанию в столбец type будет записано имя класса уведомления
public function databaseType(object $notifiable): string {return 'invoice-paid';}
- доступ к сохранённым в БД уведомлениям
$user = App\Models\User::find(1);
foreach ($user->notifications as $notification) {echo $notification->type;}
// получение только непрочитанных уведомлений
$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {echo $notification->type;}
// отметить уведомление в БД как прочитанное
$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {$notification->markAsRead();}
либо для коллекции
$user->unreadNotifications->markAsRead();
// пометить все уведомления как прочитанные
$user = App\Models\User::find(1);
$user->unreadNotifications()->update(['read_at' => now()]);
// полностью удалить уведомления из таблицы
$user->notifications()->delete();</code></pre><p>трансляция уведомлений</p><pre><code>- метод toBroadcast в классе уведомления либо метод toArray переведёт уведомление в JSON и отправит в JS
use Illuminate\Notifications\Messages\BroadcastMessage;
public function toBroadcast(object $notifiable): BroadcastMessage {
  return new BroadcastMessage(['invoice_id' => $this->invoice->id, 'amount' => $this->invoice->amount]);}
- все транслируемые уведомления ставятся в очередь для трансляции
// изменить соединение очереди и имя очереди
return (new BroadcastMessage($data))->onConnection('sqs')->onQueue('broadcasts');
// поле type содержит полное имя класса уведомления, изменить type уведомления
public function broadcastType(): string {return 'broadcast.message';}
- прослушивание транслируемых уведомлений
// уведомления транслируются по частному каналу в формате {notifiable}.{id}
// уведомление App\Models\User с идентификатором 1 транслируется по частному каналу App.Models.User.1
// прослушивать уведомления канала
Echo.private('App.Models.User.' + userId).notification((notification) => {console.log(notification.type);});
- изменить канал транслирования
namespace App\Models;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {
  use Notifiable;
  public function receivesBroadcastNotificationsOn(): string {return 'users.'.$this->id;}}</code></pre><p>уведомления через SMS</p><pre><code>composer require laravel/vonage-notification-channel guzzlehttp/guzzle    // установить пакеты
переменные окружения VONAGE_KEY и VONAGE_SECRET    // публичный и секретный ключи Vonage
переменную окружения VONAGE_SMS_FROM     // номер телефона для отправки
- создать уведомление через SMS
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)->content('Your SMS message content');}
// SMS-сообщение содержит символы Unicode
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)->content('Your unicode message')->unicode();}
// указать номера отправителя вручную
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)->content('Your SMS message content')->from('15554443333');}
// ссылка на клиента позволяет создавать отчеты об использовании SMS конкретным клиентом
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)->clientReference((string) $notifiable->id)->content('Your SMS message content');}
// номер телефона получателя
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForVonage(Notification $notification): string {return $this->phone_number;}}</code></pre><p>уведомления через Slack</p><a href="https://api.slack.com/apps?new_app=1">создать Slack-приложение<br></a><a href="https://laravel.su/docs/12.x/socialite">пакет Socialite для OAuth</a><pre><code>composer require laravel/slack-notification-channel   // установить канал уведомлений Slack
// разрешения chat:write, chat:write.public и chat:write.customize для отправки уведомления только в рабочее пространство Slack-приложения
// область действия chat:write:bot в Slack-приложении
// Bot User OAuth Token в массив конфигурации slack в config/services.php
'slack' => ['notifications' => [
  'bot_user_oauth_token' => env('SLACK_BOT_USER_OAUTH_TOKEN'),
  'channel' => env('SLACK_BOT_USER_DEFAULT_CHANNEL')]]
// распространить приложение через Slack отправлять уведомления во внешние рабочие пространства Slack пользователям вашего приложения
- создать уведомление через Slack
use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\BlockKit\Composites\ConfirmObject;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')->headerBlock('Invoice Paid')
    ->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
    ->sectionBlock(function (SectionBlock $block) {
      $block->text('An invoice has been paid.');
      $block->field("*Invoice No:*\n1000")->markdown();
      $block->field("*Invoice Recipient:*\ntaylor@laravel.com")->markdown();})
    ->dividerBlock()
    ->sectionBlock(function (SectionBlock $block) {
      $block->text('Congratulations!');});}</code></pre><p>использование шаблона Block Kit Builder Slack</p><a href="https://api.slack.com/block-kit">создать уведомление через Slack</a><pre><code>use Illuminate\Notifications\Slack\SlackMessage;
use Illuminate\Support\Str;
public function toSlack(object $notifiable): SlackMessage {
  $template = <<<JSON {
    "blocks": [
      {
        "type": "header",
        "text": {
          "type": "plain_text",
          "text": "Team Announcement"
        }
      },
      {
        "type": "section",
        "text": {
          "type": "plain_text",
          "text": "We are hiring!"
        }
      }]}
  JSON;
  return (new SlackMessage)->usingBlockKitTemplate($template);}</code></pre><p>взаимодействие в Slack</p><a href="https://api.slack.com/interactivity/handling">обработка взаимодействия пользователя</a><pre><code>- включить функцию “Interactivity” и настроить “Request URL”
// отправить POST запрос с полезной нагрузкой на “Request URL”
// пользователь Slack, который нажал на кнопку, идентификатор нажатой кнопки и дополнительная информация
use Illuminate\Notifications\Slack\BlockKit\Blocks\ActionsBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')
    ->headerBlock('Invoice Paid')->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
      ->sectionBlock(function (SectionBlock $block) {$block->text('An invoice has been paid.');})
        ->actionsBlock(function (ActionsBlock $block) {
          $block->button('Acknowledge Invoice')->primary();
          $block->button('Deny')->danger()->id('deny_invoice');
        });}
- модальное окно подтверждения
use Illuminate\Notifications\Slack\BlockKit\Blocks\ActionsBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\BlockKit\Composites\ConfirmObject;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')->headerBlock('Invoice Paid')
    ->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
    ->sectionBlock(function (SectionBlock $block) {$block->text('An invoice has been paid.');})
    ->actionsBlock(function (ActionsBlock $block) {$block->button('Acknowledge Invoice')->primary()->confirm(
      'Acknowledge the payment and send a thank you email?',
      function (ConfirmObject $dialog) {
        $dialog->confirm('Yes');
        $dialog->deny('No');});});}
- просмотр cтруктуры блоков Slack не отправляя их
return (new SlackMessage)->text('Один из ваших счетов оплачен!')->headerBlock('Счет Оплачен')->dd();
либо
->dd(true); // вывести сырую полезную нагрузку
- направить уведомления Slack в соответствующую команду Slack и канал
// метод routeNotificationForSlack в модели уведомляющей событиями вернёт:
// null – использовать маршрут настроенный в уведомлении
// канал, куда отправить уведомление, например, #support-channel
// экземпляр SlackRoute позволяет указать OAuth токен и имя канала, например, SlackRoute::make($this->slack_channel, $this->slack_token)
    для отправки уведомлений во внешние рабочие пространства
// отправить уведомление в канал #support-channel рабочего пространства с OAuth токеном Bot User из config/services.php
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForSlack(Notification $notification): mixed {return '#support-channel';}}
- отправлять уведомления в рабочие пространства Slack пользователей
// Laravel Socialite включает драйвер Slack для аутентификации пользователя в Slack и получения токена бота
// получить токен бота, сохранить его в БД и метод SlackRoute::make для направления уведомления в рабочее пространство пользователя
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable, Illuminate\Notifications\Notification, Illuminate\Notifications\Slack\SlackRoute;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForSlack(Notification $notification): mixed {
    return SlackRoute::make($this->slack_channel, $this->slack_token);}}</code></pre><p>локализация уведомлений</p><pre><code>- метод locale для установки желаемого языка
use Illuminate\Notifications\Notification
$user->notify((new InvoicePaid($invoice))->locale('es'));
Notification::locale('es')->send($users, new InvoicePaid($invoice));    // локализация нескольких уведомлений
- хранить предпочитаемый язык каждого пользователя в модели
use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference {
  public function preferredLocale(): string {return $this->locale;}}
если язык выбран в модели, то применять без locale()
$user->notify(new InvoicePaid($invoice));</code><p>тестирование</p><pre><code>- метод fake фасада Notification, чтобы предотвратить отправку уведомлений
use App\Notifications\OrderShipped;
use Illuminate\Support\Facades\Notification;
test('orders can be shipped', function () {
  Notification::fake();
  Notification::assertNothingSent();    // утверждаем, что уведомления не были отправлены
  // утверждаем, что уведомление  отправлено указанным пользователям
  Notification::assertSentTo([$user], OrderShipped::class);
  Notification::assertNotSentTo([$user], AnotherNotification::class);    // утверждаем, что уведомление не было отправлено
  Notification::assertCount(3);   // утверждаем, что отправлено заданное количество уведомлений});
  // уведомление отправлено по условию
  Notification::assertSentTo($user, function (OrderShipped $notification, array $channels) use ($order) {
    return $notification->order->id === $order->id;});
  // уведомление отправлено по требованию
  Notification::assertSentOnDemand(OrderShipped::class);
  // отправлено ли уведомление по требованию на правильный маршрут
  Notification::assertSentOnDemand(
    OrderShipped::class,
    function (OrderShipped $notification, array $channels, object $notifiable) use ($user) {
      return $notifiable->routes['mail'] === $user->email;});</code></pre><p>события уведомления</p><pre><code>- прослушивать событие, при отправке уведомления
// создать прослушиватели событий для этого события
use Illuminate\Notifications\Events\NotificationSending;
class CheckNotificationStatus {public function handle(NotificationSending $event): void { }}
либо 
public function handle(NotificationSending $event): bool {return false;}    // уведомление не отправлено
// узнать больше о получателе уведомления или самом уведомлении
public function handle(NotificationSending $event): void {
  // $event->channel
  // $event->notifiable
  // $event->notification}
- прослушивать событие, что уведомление отправлено
use Illuminate\Notifications\Events\NotificationSent;
class LogNotification {public function handle(NotificationSent $event): void { }}
// узнать больше о получателе уведомления или самом уведомлении
public function handle(NotificationSent $event): void {
  // $event->channel
  // $event->notifiable
  // $event->notification
  // $event->response}</code></pre><p>написать свои драйверы для доставки уведомлений по другим каналам</p><pre><code>namespace App\Notifications;
use Illuminate\Notifications\Notification;
class VoiceChannel
public function send(object $notifiable, Notification $notification): void {
  $message = $notification->toVoice($notifiable);
  // Отправка уведомления экземпляру `$notifiable`...
}}
// применить
namespace App\Notifications;
use App\Notifications\Messages\VoiceMessage;
use App\Notifications\VoiceChannel;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification {
  use Queueable;
  public function via(object $notifiable): string {return VoiceChannel::class;}   // получить канал
  public function toVoice(object $notifiable): VoiceMessage { }}   // получить содержимое голосового сообщения
</code></pre></pre></details><details> <summary>Mail</summary><p>Каждая почтовая программа, настроенная в config/mail.php, может иметь свою собственную уникальную конфигурацию.</p><pre><code>- драйвер Mailgun
composer require symfony/mailgun-mailer symfony/http-client   // установить пакет
// в config/mail.php параметр default присвоить mailgun
// в массив mailers добавить
'mailgun' => [
  'transport' => 'mailgun',
  // 'client' => ['timeout' => 5]]
// добавить в config/services.php
'mailgun' => [
  'domain' => env('MAILGUN_DOMAIN'),
  'secret' => env('MAILGUN_SECRET'),
  'endpoint' => env('MAILGUN_ENDPOINT', 'api.mailgun.net'),   // регион США
  'scheme' => 'https']
либо
'endpoint' => env('MAILGUN_ENDPOINT', 'api.eu.mailgun.net'),    // регион Европа
- драйвер Postmark
composer require symfony/postmark-mailer symfony/http-client    // установить пакет
// в config/mail.php параметр default присвоить postmark
// в массив mailers добавить
'postmark' => [
  'transport' => 'postmark',
  'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),   // необязательно указать поток сообщений Postmark
  // 'client' => ['timeout' => 5]]
// добавить в config/services.php
'postmark' => ['token' => env('POSTMARK_TOKEN')]
- драйвер Resend
composer require resend/resend-php    // установить пакет
// в config/mail.php параметр default присвоить resend
// добавить в config/services.php
'resend' => ['key' => env('RESEND_KEY')]
- драйвер SES
composer require aws/aws-sdk-php    // установить пакет
// в config/mail.php параметр default присвоить ses
// добавить в config/services.php
'ses' => [
  'key' => env('AWS_ACCESS_KEY_ID'),
  'secret' => env('AWS_SECRET_ACCESS_KEY'),
  'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
  'token' => env('AWS_SESSION_TOKEN')]    // необязательно AWS временные учетные данные через токен сеанса
//  дополнительные параметры для метода SendEmail AWS SDK при отправке электронной почты
'ses' => [
  'key' => env('AWS_ACCESS_KEY_ID'),
  'secret' => env('AWS_SECRET_ACCESS_KEY'),
  'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
  'options' => ['ConfigurationSetName' => 'MyConfigurationSet', 'EmailTags' => [['Name' => 'foo', 'Value' => 'bar']]]]
// заголовок в массиве из метода headers почтового сообщения для взаимодействия с функциями управления подпиской SES
public function headers(): Headers {
  return new Headers(text: [
    'X-Ses-List-Management-Options' => 'contactListName=MyContactList;topicName=MyTopic']);}
- драйвер MailerSend: сервис для отправки транзакционных электронных писем и SMS-сообщений, поддерживает драйвер для Laravel
composer require mailersend/laravel-driver    // установить пакет
// в .env
MAIL_MAILER=mailersend
MAIL_FROM_ADDRESS=app@yourdomain.com
MAIL_FROM_NAME="Имя приложения"
MAILERSEND_API_KEY=ваш-ключ-api
// в массив mailers в config/mail.php
'mailersend' => ['transport' => 'mailersend']
- резервная конфигурация доставки почты
// массив failover содержит массив mailers, который определяет очередность выбора почтовой программы
'mailers' => ['failover' => ['transport' => 'failover', 'mailers' => ['postmark', 'mailgun', 'sendmail']]]
// в config/mail.php
'default' => env('MAIL_MAILER', 'failover')
- транспорт roundrobin позволяет распределить почтовую нагрузку между несколькими почтовыми клиентами
'mailers' => ['roundrobin' => ['transport' => 'roundrobin', 'mailers' => ['ses', 'postmark']]]
// в config/mail.php
'default' => env('MAIL_MAILER', 'roundrobin')
- транспорт failover обеспечивает доступность, транспорт roundrobin обеспечивает балансировку нагрузки</code></pre><p>письмо электронной почты</p><pre><code>php artisan make:mail OrderShipped    // создать почтовый класс в app/Mail
- метод envelope
// отправитель и тема электронной почты
use Illuminate\Mail\Mailables\Address;
use Illuminate\Mail\Mailables\Envelope;
public function envelope(): Envelope {
  return new Envelope(
    from: new Address('jeffrey@example.com', 'Jeffrey Way'),
    subject: 'Order Shipped');}
// указать адрес ответа
return new Envelope(
  from: new Address('jeffrey@example.com', 'Jeffrey Way'),
  replyTo: [new Address('taylor@example.com', 'Taylor Otwell')],
  subject: 'Заказ отправлен');
// указать глобальный адрес отправителя и reply_to в config/mail.php
'from' => [
  'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
  'name' => env('MAIL_FROM_NAME', 'Example')],
'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name']
- метод content
// указать какой шаблон Blade используется для электронного письма
public function content(): Content {
  return new Content(view: 'mail.orders.shipped');}
// определить версию письма в HTML и обычный текст
public function content(): Content {
  return new Content(view: 'mail.orders.shipped', text: 'mail.orders.shipped-text');}
либо
return new Content(html: 'mail.orders.shipped', text: 'mail.orders.shipped-text');
// передать данные шаблону
namespace App\Mail;
use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Mail\Mailables\Content;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable {
  use Queueable, SerializesModels;
  public function __construct(public Order $order) {}   // автоматический доступ к свойствам $order
  public function content(): Content {return new Content(view: 'mail.orders.shipped');}}
// доступ в шаблоне Blade
&lt;div&gt;Price: {{ $order->price }}&lt;/div&gt;
либо
class OrderShipped extends Mailable {
  use Queueable, SerializesModels;
  public function __construct(protected Order $order) {}   // нет автоматического доступа к свойствам $order
  public function content(): Content {
    return new Content(
      view: 'mail.orders.shipped',
      with: ['orderName' => $this->order->name, 'orderPrice' => $this->order->price]);}}  // даёт доступ
// доступ в шаблоне Blade
&lt;div&gt;Price: {{ $orderPrice }}&lt;/div&gt;
- метод attachments
use Illuminate\Mail\Mailables\Attachment;
public function attachments(): array {return [Attachment::fromPath('/path/to/file')];}
либо
public function attachments(): array {
  return [Attachment::fromPath('/path/to/file')->as('name.pdf')->withMime('application/pdf')];}
// прикрепить файл с диска
public function attachments(): array {return [Attachment::fromStorage('/path/to/file')];}
либо
public function attachments(): array {return [Attachment::fromStorage('/path/to/file')
  ->as('name.pdf')->withMime('application/pdf')];}
// указать диск не по умолчанию
public function attachments(): array {return [Attachment::fromStorageDisk('s3', '/path/to/file')
  ->as('name.pdf')->withMime('application/pdf')];}
// присоединить сырую строку байтов (сгенерированный в памяти PDF-файл без записи на диск)
public function attachments(): array {return [Attachment::fromData(fn () => $this->pdf, 'Report.pdf')
  ->withMime('application/pdf')];}
// вставить изображение в шаблон
&lt;body&gt;Here is an image: &lt;img src="{{ $message->embed($pathToImage) }}"&gt;&lt;/body&gt;
// переменная $message автоматически доступна для всех шаблонов с встроенными вложениями
// вставить строку необработанных данных изображения
&lt;body&gt;Here is an image from raw data: &lt;img src="{{ $message->embedData($data, 'example-image.jpg') }}"&gt;&lt;/body&gt;
// прикрепить объект
// в модели прикрепляемого объекта
namespace App\Models;
use Illuminate\Contracts\Mail\Attachable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Mail\Attachment;
class Photo extends Model implements Attachable {
  public function toMailAttachment(): Attachment {return Attachment::fromPath('/path/to/file');}}
// в классе письма
public function attachments(): array {return [$this->photo];}
либо                
return Attachment::fromStorage($this->path);    // создать вложение из файла на основном диске
return Attachment::fromStorageDisk('backblaze', $this->path);   // создать вложение из файла на указанном диске
return Attachment::fromData(fn () => $this->content, 'Имя фотографии');   // создать вложение из данных, хранящихся в памяти
// задать имя файла и MIME-тип
return Attachment::fromPath('/путь/к/файлу')->as('Имя фотографии')->withMime('image/jpeg');
- прикрепить дополнительные заголовки в классе письма
use Illuminate\Mail\Mailables\Headers;
public function headers(): Headers {
  return new Headers(
    messageId: 'custom-message-id@example.com',
    references: ['previous-message@example.com'],
    text: ['X-Custom-Header' => 'Custom Value']);}
- добавить теги и метаданные к письму
use Illuminate\Mail\Mailables\Envelope;
public function envelope(): Envelope {
  return new Envelope(
    subject: 'Заказ отправлен',
    tags: ['shipment'],
    metadata: ['order_id' => $this->order->id]);}
- глубокая настройка письма через Symfony Message
use Illuminate\Mail\Mailables\Envelope;
use Symfony\Component\Mime\Email;
public function envelope(): Envelope {
  return new Envelope(
    subject: 'Заказ отправлен',
    using: [function (Email $message) { }]);}</code></pre><p>письма с разметкой Markdown</p><pre> <code>php artisan make:mail OrderShipped --markdown=mail.orders.shipped   // сгенерировать почтовый класс с шаблоном Markdown
- в методе content
use Illuminate\Mail\Mailables\Content;
public function content(): Content {
  return new Content(
    markdown: 'mail.orders.shipped',
    with: ['url' => $this->orderUrl]);}
// письма с Markdown используют комбинацию компонентов Blade и синтаксиса Markdown
&lt;x-mail::message&gt;
  # Order Shipped
  Your order has been shipped!
  &lt;x-mail::button :url="$url"&gt;View Order&lt;/x-mail::button&gt;
  Thanks, {{ config('app.name') }}
&lt;/x-mail::message&gt;
// компонент кнопки
&lt;x-mail::button :url="$url" color="success"&gt;View Order&lt;/x-mail::button&gt;
// компонент панели
&lt;x-mail::panel&gt;This is the panel content.&lt;/x-mail::panel&gt;
// компонент таблицы
&lt;x-mail::table&gt;
| Laravel       | Table         | Example       |
| ------------- | :-----------: | ------------: |
| Col 2 is      | Centered      | $10           |
| Col 3 is      | Right-Aligned | $20           |
&lt;/x-mail::table&gt;
- опубликует почтовые компоненты Markdown в каталоге resources/views/vendor/mail для внесения изменений
php artisan vendor:publish --tag=laravel-mail
// редактировать CSS в resources/views/vendor/mail/html/themes/default.css
// создать файл CSS в html/themes, чтобы создать новую тему для компонентов Markdown
// имя файла темы указать в параметре theme из config/mail.php
// установить тему для отдельного письма: указать имя файла темы в свойстве $theme почтового класса</code></pre><p>отправка почты</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Mail\OrderShipped;
use App\Models\Order;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
class OrderShipmentController extends Controller {
  public function store(Request $request): RedirectResponse {
    $order = Order::findOrFail($request->order_id);
    Mail::to($request->user())->send(new OrderShipped($order));
    return redirect('/orders');}}
либо
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->send(new OrderShipped($order));
// отправить почтовое сообщение списку получателей
foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {
  Mail::to($recipient)->send(new OrderShipped($order));}
// указать драйвер при отправке почты вручную
Mail::mailer('postmark')->to($request->user())->send(new OrderShipped($order));
// поставить почтовое сообщение в очередь
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->queue(new OrderShipped($order));
// отложить доставку электронного письма в очереди
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->later(now()->addMinutes(10), new OrderShipped($order));
// указать соединение и имя очереди для письма
$message = (new OrderShipped($order))->onConnection('sqs')->onQueue('emails');
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->queue($message);
// письмо при отправке всегда будет ставиться в очередь
use Illuminate\Contracts\Queue\ShouldQueue;
class OrderShipped extends Mailable implements ShouldQueue { }
- письма в очереди и транзакции в БД
// указать, что это письмо в очереди будет отправлено после фиксации всех открытых транзакций БД
Mail::to($request->user())->send((new OrderShipped($order))->afterCommit());
либо из конструктора письма
namespace App\Mail;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable implements ShouldQueue {
  use Queueable, SerializesModels;
  public function __construct() {$this->afterCommit();}}
- получить HTML-содержимое письма, не отправляя его
use App\Mail\InvoicePaid;
use App\Models\Invoice;
$invoice = Invoice::find(1);
return (new InvoicePaid($invoice))->render();
- предварительный просмотр письма в браузере
Route::get('/mailable', function () {
  $invoice = App\Models\Invoice::find(1);
  return new App\Mail\InvoicePaid($invoice);});
- локализация письма
Mail::to($request->user())->locale('es')->send(new OrderShipped($order));
// использовать сохраненный предпочитаемый язык каждого пользователя при отправке почты
use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference {
  public function preferredLocale(): string {return $this->locale;}}
тогда без locale()
Mail::to($request->user())->send(new OrderShipped($order));</code></pre><p>тестирование</p><pre><code>- проверка наличия ожидаемого содержимого в почтовом классе
use App\Mail\InvoicePaid;
use App\Models\User;
test('mailable content', function () {
  $user = User::factory()->create();
  $mailable = new InvoicePaid($user);
  $mailable->assertFrom('jeffrey@example.com');
  $mailable->assertTo('taylor@example.com');
  $mailable->assertHasCc('abigail@example.com');
  $mailable->assertHasBcc('victoria@example.com');
  $mailable->assertHasReplyTo('tyler@example.com');
  $mailable->assertHasSubject('Invoice Paid');
  $mailable->assertHasTag('example-tag');
  $mailable->assertHasMetadata('key', 'value');
  $mailable->assertSeeInHtml($user->email);
  $mailable->assertSeeInHtml('Invoice Paid');
  $mailable->assertSeeInOrderInHtml(['Invoice Paid', 'Thanks']);
  $mailable->assertSeeInText($user->email);
  $mailable->assertSeeInOrderInText(['Invoice Paid', 'Thanks']);
  $mailable->assertHasAttachment('/path/to/file');
  $mailable->assertHasAttachment(Attachment::fromPath('/path/to/file'));
  $mailable->assertHasAttachedData($pdfData, 'name.pdf', ['mime' => 'application/pdf']);
  $mailable->assertHasAttachmentFromStorage('/path/to/file', 'name.pdf', ['mime' => 'application/pdf']);
  $mailable->assertHasAttachmentFromStorageDisk('s3', '/path/to/file', 'name.pdf', ['mime' => 'application/pdf']);});
- тестировать отправку письма
use App\Mail\OrderShipped;
use Illuminate\Support\Facades\Mail;
test('orders can be shipped', function () {
  Mail::fake();
  Mail::assertNothingSent();    // ни одно письмо не было отправлено
  Mail::assertSent(OrderShipped::class);    // было отправлено одно письмо
  Mail::assertSent(OrderShipped::class, 2);   // было отправлено два письма
  Mail::assertSent(OrderShipped::class, 'example@laravel.com');   // письмо было отправлено на указанный адрес
  Mail::assertSent(OrderShipped::class, ['example@laravel.com', '...']);    // письмо было отправлено на несколько адресов
  Mail::assertNotSent(AnotherMailable::class);    // указанное письмо не было отправлено
  Mail::assertSentCount(3);});    // всего было отправлено 3 письма
либо если письмо отправлено в очередь
  Mail::assertQueued(OrderShipped::class);
  Mail::assertNotQueued(OrderShipped::class);
  Mail::assertNothingQueued();
  Mail::assertQueuedCount(3);
// письмо не было отправлено или поставлено в очередь
  Mail::assertNothingOutgoing();
  Mail::assertNotOutgoing(function (OrderShipped $mail) use ($order) {return $mail->order->id === $order->id;});
// письмо отправлено по условию
Mail::assertSent(function (OrderShipped $mail) use ($order) {return $mail->order->id === $order->id;});
// методы для анализа класса отправки электронной почты
Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($user) {
  return $mail->hasTo($user->email) &&
    $mail->hasCc('...') &&
    $mail->hasBcc('...') &&
    $mail->hasReplyTo('...') &&
    $mail->hasFrom('...') &&
    $mail->hasSubject('...');});
// методы анализа вложений в классе отправки электронной почты
use Illuminate\Mail\Mailables\Attachment;
Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {
  return $mail->hasAttachment(Attachment::fromPath('/путь/к/файлу')->as('name.pdf')->withMime('application/pdf'));});
Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {
  return $mail->hasAttachment(Attachment::fromStorageDisk('s3', '/путь/к/файлу'));});
Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($pdfData) {
  return $mail->hasAttachment(Attachment::fromData(fn () => $pdfData, 'name.pdf'));});</code></pre><p>отправка почты при локальной разработке</p><pre><code>// почтовый драйвер log будет записывать все письма в файлы журналов для проверки
// когда Sail запущен можно получить доступ к интерфейсу Mailpit по адресу: http://localhost:8025
// HELO или Mailtrap и драйвер smtp отправять письма в фиктивный почтовый ящик
// указать глобальный адрес кому в App\Providers\AppServiceProvider
use Illuminate\Support\Facades\Mail;
public function boot(): void {if ($this->app->environment('local')) {Mail::alwaysTo('taylor@example.com');}}</code></pre><p>события</p><pre><code>// событие MessageSending отправляется до отправки сообщения
// событие MessageSent отправляется после отправки сообщения
// события отправляются при отправке почты, а не при ее постановке в очередь
// создать слушателя
use Illuminate\Mail\Events\MessageSending;
// use Illuminate\Mail\Events\MessageSent;
class LogMessage {public function handle(MessageSending $event): void { }}</code></pre><p>написать свои транспорты для доставки электронной почты</p><pre><code>use MailchimpTransactional\ApiClient;
use Symfony\Component\Mailer\SentMessage;
use Symfony\Component\Mailer\Transport\AbstractTransport;
use Symfony\Component\Mime\Address;
use Symfony\Component\Mime\MessageConverter;
class MailchimpTransport extends AbstractTransport {
  public function __construct(protected ApiClient $client) {parent::__construct();}
  protected function doSend(SentMessage $message): void {
    $email = MessageConverter::toEmail($message->getOriginalMessage());
    $this->client->messages->send(['message' => [
      'from_email' => $email->getFrom(),
      'to' => collect($email->getTo())->map(function (Address $email) {
        return ['email' => $email->getAddress(), 'type' => 'to'];})->all(),
      'subject' => $email->getSubject(),
      'text' => $email->getTextBody()]]);}
  public function __toString(): string {return 'mailchimp';}}   // строковое представление транспорта
// зарегистрировать транспорт в App\Providers\AppServiceProvider
use App\Mail\MailchimpTransport;
use Illuminate\Support\Facades\Mail;
public function boot(): void {
  Mail::extend('mailchimp', function (array $config = []) {return new MailchimpTransport(/* ... */);});}
// в config/mail.php
'mailchimp' => ['transport' => 'mailchimp']
// использовать другие транспорты Symfony
composer require symfony/brevo-mailer symfony/http-client   // установить Symfony mailer “Brevo”
// добавить запись с учетными данными API Brevo в config/services.php
'brevo' => ['key' => 'ваш-ключ-api']
// зарегистрировать Symfony mailer “Brevo” в App\Providers\AppServiceProvider
use Illuminate\Support\Facades\Mail;
use Symfony\Component\Mailer\Bridge\Brevo\Transport\BrevoTransportFactory;
use Symfony\Component\Mailer\Transport\Dsn;
public function boot(): void {
  Mail::extend('brevo', function () {
    return (new BrevoTransportFactory)->create(new Dsn('brevo+api', 'default', config('services.brevo.key')));});}
// в config/mail.php
'brevo' => ['transport' => 'brevo']
</code></pre></details></details><details><summary>Views</summary><details> <summary>Templates</summary><details> <summary>Blade</summary><p>- шаблоны Blade - это HTML и директивы Blade в файле с расширением .blade.php, компилируются в обычные PHP-файлы и кэшируются<br>
- могут содержать: обычный PHP-код, другие шаблоны Blade, директивы Blade, секции, компоновщики и компоненты<br></p><pre><code>- создать Blade-шаблон
php artisan make:view greeting
- для шаблонов blade вызов глобального помошника view
Route::get('/', function () {return view('greeting', ['name' => 'James']);});
либо вызов фасада View
use Illuminate\Support\Facades\View;
return View::make('greeting', ['name' => 'James']);
greeting - имя файла шаблона
name - вывести в шаблоне значение, либо в шаблон массив данных
return View::first(['custom.admin', 'admin'], $data);   // вызвать первый шаблон из массива
if (View::exists('admin.profile')) { }    // существует ли шаблон
return view('greeting')->with('name', 'Victoria')->with('occupation', 'Astronaut');   // передать в шаблон отдельные данные
return view('admin.profile', $data);    // вызвать resources/views/admin/profile.blade.php
- в App\Providers\AppServiceProvider
public function boot(): void {View::share('key', 'value');}   // сделать данные доступными для всех шаблонов</code></pre><p>Templates composers - это классы или анонимные функции для создания многоразовых шаблонов, чтобы привязывать к шаблону данные перед его отрисовкой.<br>
Привязываемые данные:<br>
- не зависят от контроллеров<br>
- зависят от других данных<br>
- зависят от других шаблонов<br>
- зависят от других компонентов<br>
- данные к шаблону, которые вызываются при его каждой отрисовке<br></p><pre><code>в App\Providers\AppServiceProvider
public function boot(): void
{
  Facades\View::composer('profile', ProfileComposer::class);    // компоновщик на основе класса
  Facades\View::composer('welcome', function (View $view) { });   // компоновщик на основе анонимной функции
}
- создать нового компоновщика профиля
namespace App\View\Composers;
use App\Repositories\UserRepository;
use Illuminate\View\View;
class ProfileComposer
{
  public function __construct(protected UserRepository $users) { }
  public function compose(View $view): void
  {$view->with('count', $this->users->count());}    // привязать данные к шаблону
}
- прикрепить компоновщик к нескольким шаблонам
use App\Views\Composers\MultiComposer;
use Illuminate\Support\Facades\View;
View::composer(['profile', 'dashboard'], MultiComposer::class);
- прикрепить компоновщик ко всем шаблонам
use Illuminate\Support\Facades;
use Illuminate\View\View;
Facades\View::composer('*', function (View $view) { });
- создатели шаблонов выполняются сразу после создания экземпляра, не дожидаясь отрисовки шаблона
use App\View\Creators\ProfileCreator;
use Illuminate\Support\Facades\View;
View::creator('profile', ProfileCreator::class);</code></pre><p>оптимизация шаблонов</p><pre><code>php artisan view:cache    // предварительная компиляция всех шаблонов при развёртывании
php artisan view:clear    // очистка кеша шаблонов
php artisan view:clear   // удалить кешированные шаблоны
{{ }}    // поместить РНР код в шаблон Blade
{{ time() }}    //текущее UNIX-время
Привет, {!! $name !!}   // отключить экранирование данных (экранирование нужно для предотвращения XSS-атак)
Привет, @{{ name }} либо @@if()   // передать в HTML без обработки
- передать в HTML без обработки несколько строк
@verbatim
  &lt;div class="container"&gt;
    Hello, {{ name }}.
  &lt;/div&gt;
@endverbatim
&lt;script&gt; var app = {{ Js::from($array) }}; &lt;/script&gt;    // передать массив шаблону в виде JSON
</code></pre></details><details><summary>Blade directives</summary><p>директивы Blade - это команды для выполнения действий в шаблонах Blade, начинаются с символа @, могут быть вложенными друг в друга и содержать параметры, другие директивы Blade, код (PHP, HTML, JavaScript, CSS)</p><pre><code>- условие
@if (count($records) === 1)<span>у меня есть одна запись!</span>
@elseif (count($records) > 1)<span>у меня есть несколько записей!</span>
@else<span>у меня нет записей!</span>
@endif
@unless (Auth::check())<span>вы не вошли в систему</span>@endunless
@isset($records)<span>переменная $records определена и не равна null</span>@endisset
@empty($records)<span>переменная $records считается «пустой»</span>@endempty
- аутентификация
@auth<span>пользователь аутентифицирован</span>@endauth
@guest<span>пользователь не аутентифицирован</span>@endguest
- аутентификация с правилом guard
@auth('admin')<span>пользователь аутентифицирован</span>@endauth
@guest('admin')<span>пользователь не аутентифицирован</span>@endguest
- ошибки валидации
&lt;input id="title" type="text" class="@error('title') is-invalid @enderror"/&gt;
@error('title')&lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;@enderror
либо
&lt;input id="email" type="email" class="@error('email') is-invalid @else is-valid @enderror"/&gt;
- стэки
@push('scripts')&lt;script src="/example.js"&gt;&lt;/script&gt;@endpush   // для отображения в других шаблонах
@pushIf($shouldPush, 'scripts')&lt;script src="/example.js"&gt;&lt;/script&gt;@endPushIf    // добавить при условии
@prepend('scripts')<span>это будет первое</span>@endprepend   // добавить в начало стэка
&lt;head&gt;@stack('scripts')&lt;/head&gt;    // отобразить весь стэк
- среда окружения
@production<span>содержимое, отображаемое только в эксплуатационном окружении</span>@endproduction
@env('staging')<span>приложение запущено в «переходном» окружении</span>@endenv
@env(['staging', 'production'])<span>приложение запущено в «переходном» или «рабочем» окружении</span>@endenv
- секции
// есть ли в секции наследуемого шаблона содержимое
@hasSection('navigation')
  &lt;div class="pull-right"&gt;
    @yield('navigation')
  &lt;/div&gt;
  &lt;div class="clearfix"&gt;&lt;/div&gt;
@endif
// нет ли в секции содержимого
@sectionMissing('navigation')
  &lt;div class="pull-right"&gt;
    @include('default-navigation')
  &lt;/div&gt;
@endif
- сессия
// есть ли сессия
@session('status')
  &lt;div class="p-4"&gt;{{ $value }}&lt;/div&gt;
@endsession
- передать данные от родителя к ребенку @aware
// родитель
@props(['color' => 'gray'])
&lt;ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}&gt;{{ $slot }}&lt;/ul&gt;
// ребенок
@aware(['color' => 'gray'])
&lt;li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}&gt;{{ $slot }}&lt;/li&gt;
- подключить службу
@inject('metrics', 'App\Services\MetricsService')
&lt;div&gt;<span>Ежемесячный доход:</span> {{ $metrics->monthlyRevenue() }}&lt;/div&gt;
- отдать в исходящий HTTP-ответ фрагмент шаблона
// в шаблоне
@fragment('user-list')
  &lt;ul&gt;
    @foreach ($users as $user)
      &lt;li&gt;{{ $user->name }}&lt;/li&gt;
    @endforeach
  &lt;/ul&gt;
@endfragment
// в роуте или контроллере
return view('dashboard', ['users' => $users])->fragment('user-list');
- отдать в исходящий HTTP-ответ фрагмент шаблона при условии (true - фрагмент, false - всё)
return view('dashboard', ['users' => $users])->fragmentIf($request->hasHeader('HX-Request'), 'user-list');
- отдать в исходящий HTTP-ответ фрагмент шаблона несколько фрагментов
view('dashboard', ['users' => $users])->fragments(['user-list', 'comment-list']);
view('dashboard', ['users' => $users])->fragmentsIf($request->hasHeader('HX-Request'),['user-list', 'comment-list']);
- свитч
@switch($i)
  @case(1)
    первый case...
    @break
  @case(2)
    второй case...
    @break
  @default
    case по умолчанию...
@endswitch
- циклы
@for ($i = 0; $i < 10; $i++) <span>Текущее значение</span> {{ $i }} @endfor
@foreach ($users as $user) &lt;p&gt;<span>Это пользователь</span> {{ $user->id }}&lt;/p&gt; @endforeach
@forelse ($users as $user) &lt;li&gt;{{ $user->name }}&lt;/li&gt;
@empty &lt;p&gt;<span>Нет пользователей</span>&lt;/p&gt;
@endforelse
@while (true) &lt;p&gt;<span>Я зацикливаюсь навсегда.</span>&lt;/p&gt; @endwhile
- пропуск текущей итерации @continue или завершение @break
@foreach ($users as $user)
  @if ($user->type == 1)
    @continue
  @endif
  &lt;li&gt;{{ $user->name }}&lt;/li&gt;
  @if ($user->number == 5)
    @break
  @endif
@endforeach
- пропуск и завершение при условии
@foreach ($users as $user)
  @continue($user->type == 1)
  &lt;li&gt;{{ $user->name }}&lt;/li&gt;
  @break($user->number == 5)
@endforeach
- информация о цикле в переменной $loop
@foreach ($users as $user)
  @if ($loop->first)<span>это первая итерация</span>@endif
  @if ($loop->last)<span>это последняя итерация</span>@endif
  &lt;p&gt;<span>это пользователь</span> {{ $user->id }}&lt;/p&gt;
@endforeach
- $loop родительского цикла
@foreach ($users as $user)
  @foreach ($user->posts as $post)
    @if ($loop->parent->first)<span>это первая итерация родительского цикла</span>@endif
  @endforeach
@endforeach
<span>
$loop->index - Индекс текущей итерации цикла (начинается с 0).<br>
$loop->iteration - Текущая итерация цикла (начинается с 1).<br>
$loop->remaining - Итерации, оставшиеся в цикле.<br>
$loop->count - Общее количество элементов в итерируемом массиве.<br>
$loop->first - Первая ли это итерация цикла.<br>
$loop->last - Последняя ли это итерация цикла.<br>
$loop->even - Четная ли это итерация цикла.<br>
$loop->odd - Нечетная ли это итерация цикла.<br>
$loop->depth - Уровень вложенности текущего цикла.<br>
$loop->parent - Переменная родительского цикла во вложенном цикле.<br>
</span>
- создать свою директиву datetime форматирует переданный $var (экземпляр DateTime)
App\Providers\AppServiceProvider
public function boot(): void
{
  Blade::directive('datetime', function (string $expression) {
    return "&lt;?php echo ($expression)->format('m/d/Y H:i'); ?&gt;";
  });
}
// вызвать
@datetime($var)</code></pre><p>классы и стили по условию</p><pre><code>- класс
@php
  $isActive = false;
  $hasError = true;
@endphp
&lt;span @class([
  'p-4',        // числовой ключ отрисовывается всегда
  'font-bold' => $isActive,
  'text-gray-500' => ! $isActive,
  'bg-red' => $hasError,
])&gt;&lt;/span&gt;
&lt;span class="p-4 text-gray-500 bg-red"&gt;&lt;/span&gt;
- стиль
@php
    $isActive = true;
@endphp
&lt;span @style([
  'background-color: red',
  'font-weight: bold' => $isActive,
])&gt;&lt;/span&gt;
&lt;span style="background-color: red; font-weight: bold;"&gt;&lt;/span&gt;</code></pre><p>атрибуты</p><pre><code>@checked
&lt;input
  type="checkbox"
  name="active"
  value="active"
  @checked(old('active', $user->active))
/&gt;

@selected
&lt;select name="version"&gt;
  @foreach ($product->versions as $version)
    &lt;option value="{{ $version }}" @selected(old('version') == $version)&gt;{{ $version }}&lt;/option&gt;
  @endforeach
&lt;/select&gt;

@disabled
&lt;button type="submit" @disabled($errors->isNotEmpty())&gt;Отправить&lt;/button&gt;

@readonly
&lt;input
  type="email"
  name="email"
  value="email@laravel.com"
  @readonly($user->isNotAdmin())
/&gt;

@required
&lt;input
  type="text"
  name="title"
  value="title"
  @required($user->isAdmin())
/&gt;</code></pre><p>@include подключение дочерних шаблонов (компоненты лучше)</p><pre><code>@include('shared.errors')   // включить шаблон
@include('view.name', ['status' => 'complete'])   // включенный шаблон имеет доступ к родительским данным, добавить данные массивом
@includeIf('view.name', ['status' => 'complete'])   // включить шаблон, который может отсутствовать
- включить шаблон по логическому условию
@includeWhen($boolean, 'view.name', ['status' => 'complete'])
@includeUnless($boolean, 'view.name', ['status' => 'complete'])
@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])    // включить первый шаблон из массива
__DIR__ и __FILE__ ссылаются на расположение кешированного, скомпилированного шаблона.</code></pre><p>@each отрисовка шаблона с коллекцией</p><pre><code>шаблон отрисовывается для каждого элемента в массиве
@each('view.name', $jobs, 'job' 'view.empty')
view.name - шаблон, $jobs - массив, job - текущий элемент массива, view.empty - шаблон если массив пустой</code></pre><p>@once сработает только раз</p><pre><code>@once
  @push('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endpush
@endonce
либо
@pushOnce('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endPushOnce
либо
@prependOnce('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endPrependOnce</code></pre><p>@php код РНР в шаблоне</p><pre><code>@php$counter = 1;@endphp</code></pre><p>@use импорт класса</p><pre><code>@use('App\Models\Flight')   // без псевдонима
@use('App\Models\Flight', 'FlightModel')    // с псевдонимом</code></pre><p>отобразить часть страницы только, если пользователь авторизован</p><pre><code>@can('update', $post)
  текущий пользователь может обновить пост
@elsecan('create', App\Models\Post::class)
  текущий пользователь может создавать новые посты
@else
  показать чать страницы по умолчанию
@endcan

@cannot('update', $post)
  текущий пользователь не может обновить пост
@elsecannot('create', App\Models\Post::class)
  текущий пользователь не может создавать новые посты
@endcannot

@canany(['update', 'view', 'delete'], $post)
  текущий пользователь может обновить, просмотреть или удалить пост
@elsecanany(['create'], \App\Models\Post::class)
  текущий пользователь может создать пост
@endcanany

тоже самое 
@if (Auth::user()->can('update', $post))<span>текущий пользователь может обновить пост</span>@endif
@unless (Auth::user()->can('update', $post))<span>текущий пользователь не может обновить пост</span>@endunless

- если для действия не требуется экземпляр модели, то можно указать политику авторизации через класс
@can('create', App\Models\Post::class)<span>текущий пользователь может создавать посты</span>@endcan
@cannot('create', App\Models\Post::class)<span>текущий пользователь не может создавать посты</span>@endcannot
{{-- --}}    // комментарии Blade не включаются в итоговый HTML
</code></pre></details><details><summary>Components</summary><p>компоненты - это многоразовые элементы интерфейса, созданые с помощью команды artisan или вручную на основе классов или анонимных функций<br>
и могут содержать:<br>
- другие компоненты, шаблоны и директивы Blade<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- атрибуты, которые могут быть переданы в шаблон<br>
- свойства, которые могут быть доступны из шаблона<br>
- слоты, которые могут быть заполнены другими компонентами или шаблонами<br>
- компоненты автоматически обнаруживаются в каталогах app/View/Components и resources/views/components<br></p><pre><code>- создать компонент
php artisan make:component Alert    // на основе класса
php artisan make:component Alert --inline   // на основе встроенного шаблона
php artisan make:component forms.input --view   // анонимный компонент
- отобразить компонент
&lt;x-forms.input /&gt;
// отобразить компонент на основе полученного значения или переменной ($componentName = "secondary-button";)   
&lt;x-dynamic-component :component="$componentName" class="mt-4" /&gt;
// если shouldRender() вернёт true - компонент отражается, false - нет
use Illuminate\Support\Str;
public function shouldRender(): bool
{return Str::length($this->message) > 0;}
- выражения и переменные PHP передавать компоненту через атрибуты c символом : впереди
&lt;x-alert type="error" :message="$message"/&gt;
- общедоступные данные в конструкторе класса компонента доступны в шаблоне компонента
namespace App\View\Components;
use Illuminate\View\Component;
use Illuminate\View\View;
class Alert extends Component
{
  public function __construct(public string $type, public string $message) { }
  public function render(): View {return view('components.alert');}
}
&lt;div class="alert alert-{{ $type }}"&gt;{{ $message }}&lt;/div&gt;
// аргументы конструктора в camelCase, а аргументы в атрибутах HTML в kebab-case
public function __construct(public string $alertType) { }
&lt;x-alert alert-type="danger"/&gt;
// при одинаковых именах атрибута и переменной можно сократить
&lt;x-profile :$userId :$name /&gt;   // сокращенный синтаксис атрибутов
&lt;x-profile :user-id="$userId" :name="$name" /&gt;    // эквивалентно
- так как Alpine.js тоже использует префикс :, то добавить ещё : для РНР
&lt;x-button ::class="{ danger: isDeleting }"&gt;<span>отправить</span>&lt;/x-button&gt;    // шаблон Blade
&lt;button :class="{ danger: isDeleting }"&gt;<span>отправить</span>&lt;/button&gt;   // HTML
- в классе компонента можно задать метод
public function isSelected(string $option): bool {return $option === $this->selected;}    // в классе
&lt;option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}"&gt;{{ $label }}&lt;/option&gt;    // в шаблоне
- все атрибуты не из конструктора компонента автоматически добавляются в $attributes
&lt;div {{ $attributes }}&gt;<span>содержание компонента</span>&lt;/div&gt;   // HTML
- слияние атрибутов
&lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;{{ $message }}&lt;/div&gt;   // компонент
&lt;x-alert type="error" :message="$message" class="mb-4"/&gt;    // шаблон
&lt;div class="alert alert-error mb-4"&gt;<span>содержимое переменной $message</span>&lt;/div&gt;   // HTML
либо
&lt;button {{ $attributes->merge(['type' => 'button']) }}&gt;{{ $slot }}&lt;/button&gt;
- фильтрация атрибутов
{{ $attributes->filter(fn (string $value, string $key) => $key == 'foo') }}   // оставит атрибут если true, остальные удалит
{{ $attributes->whereStartsWith('wire:model') }}    // начинается с
{{ $attributes->whereDoesntStartWith('wire:model') }}   // не начинается с
- проверить есть ли атрибут
@if ($attributes->has('class'))&lt;div&gt;<span>атрибут class присутствует</span>&lt;/div&gt;@endif
@if ($attributes->has(['name', 'class']))&lt;div&gt;<span>все указанные атрибуты присутствуют</span>&lt;/div&gt;@endif
@if ($attributes->hasAny(['href', ':href', 'v-bind:href']))&lt;div&gt;<span>один из указанных атрибутов присутствует</span>&lt;/div&gt;@endif
- получить атрибут
{{ $attributes->get('class') }}   // получить значение атрибута
{{ $attributes->only(['class']) }}    // только по ключу
{{ $attributes->except(['class']) }}    // кроме тех кто с ключом
- вынести классы в одну переменную
  @php
    $classes = 'className1 className2';
  @endphp
  &lt;div {{ $attributes(['class' => $classes]) }}&gt;{{ $slot }}&lt;/div&gt;
- менять вид компонента, изменяя свойства компонента в вёрстке
@props(['size' => 'base'])
@php
  $classes = "className1 className2";
  if ($size === 'base') {$classes .= " className3";}
  if ($size === 'small') {$classes .= " className4";}
@endphp
&lt;a href="#" class="{{ $classes }}"&gt;{{ $slot }}&lt;/a&gt;</code></pre><p>Anonymous Components - компоненты, которые не имеют класса и создаются с помощью встроенного шаблона в resources/views/components</p><pre><code>resources/views/components/alert.blade.php
&lt;x-alert/&gt;    // в шаблоне
либо
resources/views/components/inputs/button.blade.php
&lt;x-inputs.button/&gt;    // в шаблоне
- компонент из нескольких компонентов
/resources/views/components/accordion/accordion.blade.php
/resources/views/components/accordion/item.blade.php
&lt;x-accordion&gt;
  &lt;x-accordion.item&gt;
    ...
  &lt;/x-accordion.item&gt;
&lt;/x-accordion&gt;
- переменные и атрибуты
// в компоненте
@props(['type' => 'info', 'message'])   // info - значение по умолчанию
&lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;{{ $message }}&lt;/div&gt;
// в шаблоне
&lt;x-alert type="error" :message="$message" class="mb-4"/&gt;
- задать свой путь к анонимному компоненту
// для panel.blade.php
App\Providers\AppServiceProvider
public function boot(): void {Blade::anonymousComponentPath(__DIR__.'/../components');}
&lt;x-panel /&gt;   // в шаблоне
либо с пространством имен
Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');
&lt;x-dashboard::panel /&gt;   // в шаблоне</code></pre><p>Slots - это области в шаблоне компонента для заполнения другими компонентами или шаблонами<br>
могут быть именованными или анонимными и содержать:<br>
- другие слоты<br>
- атрибуты и данные, которые могут быть переданы в шаблон<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- свойства, которые могут быть доступны из шаблона<br></p><pre><code>// компонент
&lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;
&lt;div class="alert alert-danger"&gt;{{ $slot }}&lt;/div&gt;
// шаблон
&lt;x-alert&gt;
  &lt;x-slot:title&gt;
    Ошибка сервера
  &lt;/x-slot&gt;
  &lt;strong&gt;Упс!&lt;/strong&gt; Что-то пошло не так!
&lt;/x-alert&gt;
- существует ли контент
// комментарий считается контентом
&lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;
&lt;div class="alert alert-danger"&gt;
  @if ($slot->isEmpty()) <span>Это содержимое по умолчанию, если слот пуст.</span>
  @else{{ $slot }}
  @endif
&lt;/div&gt;
// без комментария
@if ($slot->hasActualContent())<span>В области нет комментариев.</span>@endif
- доступ к данным и методам класса компонента из слота
&lt;x-alert&gt;
  &lt;x-slot:title&gt;{{ $component->formatAlert('Ошибка сервера') }}&lt;/x-slot&gt;
  &lt;strong>Упс!&lt;/strong> Что-то пошло не так!
&lt;/x-alert&gt;
- доступ к атрибутам слота из компонента
@props(['heading','footer'])
&lt;div {{ $attributes->class(['border']) }}&gt;
  &lt;h1 {{ $heading->attributes->class(['text-lg']) }}&gt;{{ $heading }}&lt;/h1&gt;
  {{ $slot }}
  &lt;footer {{ $footer->attributes->class(['text-gray-700']) }}&gt;{{ $footer }}&lt;/footer&gt;
&lt;/div&gt;
- разметка в классе компонента
public function render(): string
{
  return &lt;&lt;&lt;blade
    &lt;div class="alert alert-danger"&gt;{{ $slot }}&lt;/div&gt;
  blade;
}</code></pre><p>- Layouts - шаблоны, которые могут содержать:<br>
- другие макеты, шаблоны и компоненты<br>
- атрибуты, которые могут быть переданы в шаблон<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- свойства, которые могут быть доступны из шаблона<br>
- слоты, которые могут быть заполнены другими компонентами или шаблонами<br></p><pre><code>// resources/views/components/layout.blade.php
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{ $title ?? 'Менеджер задач' }}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1>Задачи&lt;/h1&gt;
    &lt;hr/&gt;
    {{ $slot }}
  &lt;/body&gt;
&lt;/html&gt;
// resources/views/tasks.blade.php
&lt;x-layout&gt;
  &lt;x-slot:title&gt;<span>пользовательский заголовок</span>&lt;/x-slot&gt;
  @foreach ($tasks as $task)
    &lt;div&gt;{{ $task }}&lt;/div&gt;
  @endforeach
&lt;/x-layout&gt;
// app/routes/web.php
use App\Models\Task;
Route::get('/tasks', function () {return view('tasks', ['tasks' => Task::all()]);});
- наследование
// resources/views/layouts/app.blade.php
&lt;html&gt;
  &lt;head&gt;&lt;title><span>Имя приложения - @yield('title')</span>&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    @section('sidebar')<span>Это главная боковая панель.</span>@show   // определяет и дополняет секцию
    &lt;div class="container"&gt;@yield('content')&lt;/div&gt;// @yield('content', 'Содержимое по умолчанию')
  &lt;/body&gt;
&lt;/html&gt;
// resources/views/child.blade.php
@extends('layouts.app')
@section('title', 'Название страницы')
@section('sidebar')
  @@parent    // для добавления (а не перезаписи) содержимого к боковой панели макета
  &lt;p&gt;<span>Это добавляется к главной боковой панели.</span>&lt;/p&gt;
@endsection
@section('content')&lt;p&gt;<span>Это содержимое моей страницы.</span>&lt;/p&gt;@endsection
</code></pre></details></details><details><summary>URL creation</summary><p>url используется для генерации URL-адресов приложения</p><pre><code>url("/posts/{$post->id}");  // http://example.com/posts/1
- URL-адрес с запросом
echo url()->query('/posts', ['search' => 'Laravel']);   // https://example.com/posts?search=Laravel
echo url()->query('/posts?sort=latest', ['search' => 'Laravel']);   // http://example.com/posts?sort=latest&search=Laravel
echo url()->query('/posts?sort=latest', ['sort' => 'oldest']);  // http://example.com/posts?sort=oldest
echo $url = url()->query('/posts', ['columns' => ['title', 'body']]);   // http://example.com/posts?columns%5B0%5D=title&columns%5B1%5D=body
echo urldecode($url);   // http://example.com/posts?columns[0]=title&columns[1]=body
- получить URL
echo url()->current();    // получить текущий URL без строки запроса
echo url()->full();   // получить текущий URL, включая строку запроса
echo url()->previous();   // получить полный URL-адрес предыдущего запроса
либо через фасад
use Illuminate\Support\Facades\URL;
echo URL::current();
- route помощник генерации URL-адресов для именованных маршрутов
Route::get('/post/{post}', function (Post $post) {})->name('post.show');
echo route('post.show', ['post' => 1]); // http://example.com/post/1
либо
Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);  // http://example.com/post/1/comment/3
// что не является параметром машрута, то является запросом
echo route('post.show', ['post' => 1, 'search' => 'rocket']);   // http://example.com/post/1?search=rocket
route('post.show', ['post' => $post]);    // автоматически извлечь ключ маршрута из модели
- подписанные URL: URL-адрес с хешом «подписи», добавленный к строке запроса, чтобы защитить URL
// отказаться от подписки
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);
// исключить домен из хеша подписанного URL
return URL::signedRoute('unsubscribe', ['user' => 1], absolute: false);
// временный подписанный URL-адрес
return URL::temporarySignedRoute('unsubscribe', now()->addMinutes(30), ['user' => 1]);
// проверка подлиности подписанного URL
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
  if (! $request->hasValidSignature()) {abort(401);}
})->name('unsubscribe');
// игнорировать page и order при проверке подлиности подписанного URL
if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {abort(401);}
- signed из Illuminate\Routing\Middleware\ValidateSignature - это middleware для проверки подлиности подписанного URL
Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed');
// без включения домена в хеш подписи
Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed:relative');
- настроить в bootstrap/app.php свой ответ на недействительную подпись URL
use Illuminate\Routing\Exceptions\InvalidSignatureException;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (InvalidSignatureException $e) {
    return response()->view('errors.link-expired', status: 403);
  });
})
- URL для методов контроллера
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);
$url = action([UserController::class, 'profile'], ['id' => 1]);   // с параметрами для метода контроллера
- URL::defaults определяет значение по умолчанию для параметра запроса
// создать middleware
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\URL;
use Symfony\Component\HttpFoundation\Response;
class SetDefaultLocaleForUrls {
  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response {
    URL::defaults(['locale' => $request->user()->locale]);
    return $next($request);
}}
// дать в bootstrap/app.php приоритет выполнения middleware
->withMiddleware(function (Middleware $middleware) {$middleware->prependToPriorityList(
  before: \Illuminate\Routing\Middleware\SubstituteBindings::class,
  prepend: \App\Http\Middleware\SetDefaultLocaleForUrls::class,
);})
Route::get('/{locale}/posts', function () { })->name('post.index');
</code></pre></details><details> <summary>Form</summary><pre><code>&lt;form action="/example" method="POST"&gt;
  @method('PUT')
  @csrf
&lt;/form&gt;
либо
&lt;form action="/example" method="POST"&gt;
  &lt;input type="hidden" name="_method" value="PUT"&gt;
  &lt;input type="hidden" name="_token" value="{{ csrf_token() }}"&gt;
&lt;/form&gt;
</code></pre></details><details> <summary>Vite</summary><p>- Vite - это инструмент сборки на JavaScript и CSS, использует ES-модули и поддерживает:<br>
- HMR (горячая перезагрузка модулей) для быстрой разработки<br>
- TypeScript, JSX, CSS и другие языки<br>
- плагины для расширения функциональности<br>
- SSR (серверный рендеринг) для создания приложений с серверным рендерингом<br>
- предварительную выборку, предзагрузку и кеширование ресурсов для оптимизации загрузки<br>
p.
  vite компелирует, кеширует и отслеживает изменения в папке resources<br>
  resources/views/components/layout.blade.php создаю компонент layout<br>
  вставляю компонент на страницу
code &lt;x-layout&gt;&lt;/x-layout&gt;
p.
  в файле .env указать место хранения загружаемых файлов<br>
  варианты значений в файле config/filesystems.php
code FILESYSTEM_DISK=public
p.
  при загрузке изображения оно будет сохранено в storage/app/public<br>
  чтобы оно отображалось сделать ссылку:
code php artisan storage:link
p Встроенные шаблоны для писем
code ./sail artisan vendor:publish --tag=laravel-mail</p><pre><code>- Blade: vite.config.js
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
  plugins: [
    laravel({
      input: ['resources/css/app.css', 'resources/js/app.js'],
      refresh: true,
    }),
  ],
});
&lt;head&gt;@vite(['resources/css/app.css', 'resources/js/app.js'])&lt;/head&gt;    // в корневом шаблоне
- SPA: vite.config.ts
resources/js/app.tsx    // точка входа в SPA-приложение
laravel({
  input: 'resources/js/app.tsx',  // точка входа vite в приложение
  ssr: 'resources/js/ssr.tsx',    // точка входа ssr в приложение
  refresh: true,  // обновит браузер при сохранении файла
}),
import '../css/app.css';    // импорт CSS в resources/js/app.tsx
// в корневом шаблоне
&lt;head&gt;
  @viteReactRefresh
  @vite(['resources/js/app.jsx'])
&lt;/head&gt;
- подключить ресурсы в resources/js/app.js для обработки 
import.meta.glob([
  '../images/**',
  '../fonts/**',
]);
&lt;img src="{{ Vite::asset('resources/images/logo.png') }}"&gt;    // в шаблоне
- в App\Providers\AppServiceProvider
public function boot(): void
{Vite::macro('image', fn (string $asset) => $this->asset("resources/images/{$asset}"));}    // создать макрос
&lt;img src="{{ Vite::image('logo.png') }}" alt="Laravel Logo"&gt;    // в шаблоне
// предварительная выборка рессурсов при загрузке приложения
public function boot(): void
{Vite::prefetch(concurrency: 3);}   // максимум три параллельные загрузки вместе с загрузкой страницы
{Vite::prefetch();}  // загрузить всё параллельно с загрузкой страницы
{Vite::prefetch(event: 'vite:prefetch');}   // предзагрузка в ручную по событию
// в шаблоне отправить событие для загрузки русурсов через три секунды после загрузки страницы
&lt;script&gt;
  addEventListener('load', () => setTimeout(() => {dispatchEvent(new Event('vite:prefetch'))}, 3000))
&lt;/script&gt;
- отключить vite для всех тестов
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
  protected function setUp(): void {parent::setUp();}
}
test('without vite example', function () {$this->withoutVite();});    // отключить vite в одном тесте
</code></pre></details><details><summary class="menu__submenu_lv1">Alpinejs</summary><a href="https://alpinejs.dev/">alpinejs<br></a><p>К событию JS нужно добавить @. Например @click. </p><a href="https://developer.mozilla.org/ru/docs/Web/Events">Events</a><table><caption>Directives</caption><thead><tr> <th>Directive</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/directives/data">x-data</a></td><td>определяет часть HTML как компонент Alpinejs и предоставляет ему данные </td></tr><tr><td> <a href="https://alpinejs.dev/directives/init">x-init</a></td><td>позволяет выполнить действие в момент когда Alpinejs инициализирует элемент </td></tr><tr><td> <a href="https://alpinejs.dev/directives/show">x-show</a></td><td>показывает или прячет DOM элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/bind">x-bind</a></td><td>устанавливает атрибуты HTML элемента на основании вычислений</td></tr><tr><td> <a href="https://alpinejs.dev/directives/on">x-on</a></td><td>выполняет код при получении события</td></tr><tr><td> <a href="https://alpinejs.dev/directives/text">x-text</a></td><td>вставляет текст в элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/html">x-html</a></td><td>вставляет html разметку в элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/model">x-model</a></td><td>связавыет значение с данными</td></tr><tr><td> <a href="https://alpinejs.dev/directives/modelable">x-modelable</a></td><td>указывает значение, которое нужно связать со значением x-model</td></tr><tr><td> <a href="https://alpinejs.dev/directives/for">x-for</a></td><td>создаёт DOM элементы перебирая массивы и объекты</td></tr><tr><td> <a href="https://alpinejs.dev/directives/transition">x-transition</a></td><td>плавное появление и исчезновение элемента</td></tr><tr><td> <a href="https://alpinejs.dev/directives/effect">x-effect</a></td><td>меняет элемент когда меняются его зависимости</td></tr><tr><td> <a href="https://alpinejs.dev/directives/ignore">x-ignore</a></td><td>Alpine пропускает этот элемент во время инициализации</td></tr><tr><td> <a href="https://alpinejs.dev/directives/ref">x-ref</a></td><td>обозначает элемент для $refs</td></tr><tr><td> <a href="https://alpinejs.dev/directives/cloak">x-cloak</a></td><td>скрывает элемент пока не загрузится Alpine<br>
add to CSS [x-cloak] { display: none !important; }</td></tr><tr><td> <a href="https://alpinejs.dev/directives/teleport">x-teleport</a></td><td>переносит часть шаблона < template > в другую часть страницы</td></tr><tr><td> <a href="https://alpinejs.dev/directives/if">x-if</a></td><td>добавляет и удаляет элементы по словию</td></tr><tr><td> <a href="https://alpinejs.dev/directives/id">x-id</a></td><td>собирает в массив id сгенерированные с помощью $id<br>
создаёт им scope и добавляет к ним суффикс
</td></tr></tbody></table><table><caption>Magics</caption><thead><tr><th>Magic</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/magics/el">$el</a></td><td>выбирает текущий элемент</td></tr><tr><td><a href="https://alpinejs.dev/magics/refs">$refs</a></td><td>выбирает элемент c x-ref</td></tr><tr><td><a href="https://alpinejs.dev/magics/store">$store</a></td><td>доступ к глобальному хранилищу, созданного через Alpine.store()</td></tr><tr><td><a href="https://alpinejs.dev/magics/watch">$watch</a></td><td>наблюдает за указанным элементом</td></tr><tr><td><a href="https://alpinejs.dev/magics/dispatch">$dispatch</a></td><td>создает события браузера</td></tr><tr><td><a href="https://alpinejs.dev/magics/nextTick">$nextTick</a></td><td>выполняет действие после после выполнения первого</td></tr><tr><td><a href="https://alpinejs.dev/magics/root">$root</a></td><td>выбирает ближайший родительский элемент с x-data</td></tr><tr><td><a href="https://alpinejs.dev/magics/data">$data</a></td><td>содежит значения всех x-data, через которых всплывает событие</td></tr><tr><td><a href="https://alpinejs.dev/magics/id">$id</a></td><td>создаёт id для элементов избегая конфликтов одинаковых имён</td></tr></tbody></table><table><caption>Globals</caption><thead><tr><th>Global</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/globals/alpine-data">Alpine.data()</a></td><td>вынести контекст x-data в отдельную функцию и переиспользовать</td></tr><tr><td> <a href="https://alpinejs.dev/globals/alpine-bind">Alpine.bind()</a></td><td>вынести контекст x-data в отдельную функцию и переиспользовать</td></tr><tr><td> <a href="https://alpinejs.dev/globals/alpine-store">Alpine.store()</a></td><td>управление глобальным хранилищем</td></tr></tbody></table></details><details><summary class="menu__submenu_lv1">React</summary><p><b>npx create-react-app название папки (проекта)</b><br>
  - создаст папку с названием проекта и стартовым шаблоном внутри.<br>
<em>JSX</em>:<br>
  - это синтаксический сахар для React.createElement.<br>
  - это расширение JS, чтобы объяснить React как выглядит UI.<br>
  - напоминает язык шаблонов, наделённый силой JavaScript.<br>
  - производит элементы React.<br>
  - преобразуется в JS функцию, которая возвращает JS объект.<br>
  После компиляции каждое JSX-выражение становится обычным вызовом JS-функции, результат которого  - объект JS.<br>
<br>
&lt;div&gt;&lt;/div&gt; = &lt;div/&gt; - если тэг пустой, то самозакрывающийся тэг.<br>
Если разделить выражение на строки, то его нужно обернуть в ().<br>
Запись атрибутов в camelCase.<br>
Кавычки (для строковых литералов), фигурные скобки (для JS-выражений), но не то и другое вместе.<br>
<br>
&lt;div tabIndex=”0”&gt;&lt;/div&gt; - литералы в строке<br>
&lt;img src={user.avatarUrl}&gt; - JS выражения в { }<br>
<br></p><pre><code>const name = ‘Иван-Царевич’; <span> - создали переменную</span>
<span>создали элемент с переменной внутри.</span>
const element = &lt;h1&gt;Здравствуй, {name}!&lt;/h1&gt;;
</code></pre><br><p>Элемент описывает то, что будет на экране.<br>
команда ReactDOM-у отрисовать созданный элемент</p><pre><code>ReactDOM.render(
  element,
  document.getElementById('root'))</code></pre><p>внутри элемента страницы с выбранным id<br>
<br>
<em>&lt;div/&gt</em>; - DOM-тэг с маленькой буквы<br>
<em>&lt;Welcome/&gt</em>; - компонент с большой.<br>
<br>
Первоначальный рендеринг компонента в DOM называется “монтированием” - (mounting).<br>
Каждый раз когда DOM-узел, созданный компанентом, удаляется, происходит “размонтирование” - (unmounting).<br>
<br>
<em>Методы жизненного цикла</em>:<br>
<em>componentDidMount() {...}</em> - запускается после того, как компонент отрендерился в DOM<br>
<em>componentWillUnmount() {...}</em> - запускается перед размонтированием<br>
<br>
Поля <em>this.props</em> и <em>this.state</em> в классах особенные, и их устанавливает сам React.<br>
Присвоить значение this.state можно только в конструкторе,
в остальных случаях только через изменение: <b>this.state({comment: ‘Привет’})</b>.<br>
Родитель-компонент передаёт своё состояние дочерним компонентам в виде пропса.<br>
Это однонаправленный поток данных.<br>
<br>
<em>this.props</em> и <em>this.state</em> могут обновляться асинхронно поэтому операции с ними нужно проводить внутри функции,
получая текущие значения в качестве параметров:<br></p><code>this.setState((state.props) => ({
  counter: state.counter + props.increment
}))</code><br><p><em>Обработка событий</em>:<br>
HTML: &lt;button onclick="activateLasers()"&gt; Активировать лазеры &lt;/button&gt;<br>
React: &lt;button onClick={activateLasers}&gt; Активировать лазеры &lt;/button&gt;<br>
activateLasers - это функция-обработчик события<br>
<br>
В React есть соглашение об именах:<br>
<em>on[имя события]</em> - для пропсов, отвечающих за события,<br>
<em>handle[имя события]</em> - для методов, обрабатывающих события.<br>
События в React в camelCase.<br>
<br>
Чтобы предотвратить обработчик события по умолчанию, нужно вызвать <b>preventDefault()</b>.<br></p><pre><code>function ActionLink() {
  function handleClick(e) {
    e.preventDefault()
    console.log(‘По ссылке кликнули’)
  }
  return (
    &lt;a href=”#”
    onClick={handleClick}&gt;
    Нажми на меня &lt;/a&gt;
  )
}</code></pre><br><p>Если ссылаться на метод как на ссылку - без вызова, т.е. без () поcле него, например, <b>onClick={this.handleClick}</b>,
этот метод нужно привязать к контексту:<br>
в конструкторе <b>this.handleClick = this.handleClick.bind(this)</b>;<br>
в render() &lt;button onClick={this.handleClick}&gt;<br>
или так:<br></p><pre><code>handleClick = () => {
  console.log('значение this: ', this)
}
&lt;button
  onClick={this.handleClick}&gt;
  Нажми на меня
&lt;/button&gt;</code></pre><p>или так:</p><pre><code>handleClick() {console.log('значение this: ', this)}
&lt;button onClick={this.handleClick()}&gt;
  Нажми на меня
&lt;/button&gt;</code><br></pre><p>Чтобы передать свой аргумент (например id строки) в обработчик события:<br>
<em>е</em> - событие React передаётся явно в стрелочных функциях и автоматически в bind.<br></p><pre><code>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;
  Удалить строку
&lt;/button&gt; <span>- Function.prototype.bind</span>

&lt;button onClick={(e) => this.deleteRow(id, e)}&gt;
  Удалить строку
&lt;/button&gt;</code></pre><p>- стрелочная функция - при каждом рендере создаётся новый коллбэк.<br>
Если этот коллбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.<br>
Снижение производительности.<br>
<br>
<em>Структура проекта</em>:<br>
<em>index.html</em> - точка входа в сайт<br>
<em>index.js</em> - подключает необходимое окружение (react, react-dom, index.css, App.js, serviceWorker.js)<br>
<em>index.css</em> - задаёт стили<br>
<em>serviceWorker.js</em><br>
<em>setupTests.js</em><br>
<em>context.js</em><br>
<em>App.js</em> - подключает (объединяет) все компоненты<br>
Файл .css можно не импортировать, т.к. React ищет его сам в своей папке, либо в папках выше.<br>
<br>
<em>Компонент</em>:<br>
Это функция или класс (работают одинаково).<br>
Один компонент - одна ответственность.<br>
Компонент содержит логику и разметку в JSX.<br>
Компоненты можно вкладывать в друг друга.<br>
<br>
Чтобы создать компонент нужно в файле с расширением js написать:<br>
<em>import React from 'react'</em>; - в начале<br>
и<br>
<em>export default App</em>; - в конце.<br>
<br>
Сначала создаём самый маленький компонент, потом вверх по иерархии.<br>
<br>
<em>Компонент в виде класса</em>:</p><pre><code>class Example extends React.Component {
  <span>конструктор объектов</span>
  constractor (props) {
  <span>обязательная ссылка на родителя</span>
  super (props)
  <span>задаём начальное состояние</span>
  this.state = { … }
}
  <span>говорит React что нужно отобразиь на экране</span>
  render() {
    <span>возвращает JSX объект</span>
    return…
  }
}</code></pre><p>В JS - классах всегда нужно вызывать <em>super</em> при объявлении конструктора подкласса.
Все классовые React - компоненты, у которых есть constractor 
должны начинаться с вызова <b>super (props)</b>.
<br>
<em>Компонент в виде функции (функциональный компонент)</em>:</p><pre><code><span>подключение</span>
import React from 'react';
…
const styles = { }

<span>принимает пропсы</span>
function Example (props) { 
  <span>либо так:</span>
  const Example = (props) => {{
    логика на JS
    разметка JSX
    <span>возвращает JSX объект</span>
    return …
    
  }
  export default Example
}

<span>компонент объявлен как класс</span>
class Clock extends React.Component {
  constructor (props) {
    super (props);
    <span>задаём начальное состояние
    при создании объекта</span>
    this.state = {date: new Date()};
  }

  componentDidMount() {
    <span>метод жизненного цикла,
    который React вызывает когда коипонент &lt;Clock/&gt;
    примонтируется в DOM</span>

    <span>вызываем метод tick() каждую секунду</span>
    this.timerID = setInterval ( 
    () => this.tick(), 1000
    );
  }

  componentWillUnmount() {
    <span>метод жизненного цикла,
    который Ract вызывает когда компонент &lt;Clock/&gt;
    удалится из DOM</span>
  }

  tick() {
    this.setState({
      <span>обновляем состояние компонента,
      присваивая новое значение свойства date</span>
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          Привет мир!
        &lt;/h1&gt;

        &lt;h2&gt;
          Сейчас {this.state.date.toLocaleTimeString()}
        &lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock/&gt;,
  document.getElementById('root')
);</code></pre><br><p><em>Пропс</em>:<br>
<em>JSON</em> - объявляем объект в переменную:</p><pre><code>const user = {
  firstName = ‘Марья’,
  lastName = ‘Маревна’
}</code></pre><p>и обращаемся к пропсам:</p><pre><code>user.firstName
user.lastName</code></pre><br><p><em>this.props</em> - объект, кототрый содержит свойства, которые были определены тем, кто вызывает этот компонент.<br>
Вложенный контент может быть доступен через <b>props.children</b></p><pre><code><span>в props получаем значения value и onClick
из класса Board ниже</span>
function Square (props) { 
  return(
    &lt;button onClick={props.onClick}&gt;
      {props.value}
    &lt;/button&gt;
  )}

<span>возвращаем кнопку для подстановки
в качестве объекта this
в блок render в классе Board</span>
                                                                                              
class Board extends React.Component{
  <span>props i из блока render() ниже</span>
  renderSquare(i){
    <span>в компанент Square втуливаем значения value и onClick</span>
    return(
      &lt;Square
        <span>собираем получаемые пропсы в массив</span>
        value = {this.props.square[i]}
        <span>создаём обработчик на событие onClick для каждого пропса i</span>
        onClick = {() = this.props.onClick(i)}
      /&gt;
    )
  }
  render() {
    return(
      <span>передаем в функцию renderSquaer
      (props.value) - 0 или 1 или 2</span>
      &lt;div&gt;
        {this.renderSquare(0)}
        {this.renderSquare(1)}
        {this.renderSquare(2)}
      &lt;/div&gt;
    )
  }
}

<span>компонент объявлен как функция</span>
function Welcome(props) {
  return (
    &lt;h1&gt;
      Привет, {props.name}!
    &lt;/h1&gt;
  );
}
<span>или так:</span>
<span>компонент объявлен как класс</span>
class Welcome extends React.Component { 
  render () {
    return (
      &lt;h1&gt;
        Привет, {this.props.name}!
      &lt;/h1&gt;
    );
  }
}

const element = &lt;Welcome name="Алиса"/&gt;;
ReactDOM.render(
  element,
  document.getElementById('root')
);</code></pre><p>name=”Алиса” - передаётся в функцию Welcome в виде объекта <b>{name: 'Алиса'}</b> - это props.<br>
Функция Welcome возвращает элемент &lt;h1&gt;Привет, Алиса!&lt;/h1&gt; в ReactDOM.<br>
<br>
Пропсы нужно только читать.<br>
React-компоненты не меняют свои входные данные.<br>
Компонент никогда не должен что-то записывать в свои пропсы:</p><pre><code>function sum(a, b) {
  return a + b;
}
<span>а вот так нельзя:</span>
function withdraw(account, amount) {
  account.total -= amount;
}</code></pre><p>Передать пропс можно от родителя к потомку пропустив несколько промежуточных потомков
напрямую с помощью <b>React.createContext()</b>.<br>
Для этого создаём отдельный файл context.js и используем &lt;Context.Provider&gt;.<br>
<br>
<em>Файл context.js</em>:</p><pre><code>import React from 'react'
const Context = React.createContext()
export default Context
<span>с помощью Context.Provider
передаю любое JS сквозь всех потомков</span>
&lt;Context.Provider value={{ … }}&gt;
&lt;div className=”...”&gt;
&lt;h1&gt; Hello world! &lt;/h1&gt;
&lt;Example/&gt;
&lt;/div&gt;
&lt;/Context.Provider&gt;</code></pre><p><em>Состояние</em>:<br>
Сохранять и изменять можно только состояния <em>(state)</em>.<br>
Конкретный state контролируется и доступен только конкретному компоненту.<br>
Состояние содержит данные, специфичные для этого компонента. Они могут изменятся со временем.<br>
Состояние определяется пользователем и должно быть простым объектом JS.<br>
Состояние можно изменять только через <b>setState()</b>, присвоить состоянию значение напрямую можно только в конструкторе.<br>
Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.<br>
Этот процесс называется “нисходящим” (“top-down”) или “однонаправленным” (“unidirectional”) потоком данных.<br>
<br>
Если несколько компонентов должны отражать одни и теже изменяющиеся данные, 
то нужно поднимать общее состояние до ближайшего общего предка.<br>
Чтобы собрать данные из нескольких дочерних элементов, или чтобы дать возможность двум компонентам общаться,
вам нужно объявить общее состояние внутри родительского компонента.<br>
Родительский компонент может передать состояние обратно дочерним элементам с помощью пропсов.<br>
Это поддерживает синхронизацию дочерних компонентов друг с другом и с родительким компонентом.<br>
<br>
<em>Хуки</em>:</p><code>const [todos, setTodos] = React.useState([ ])</code><p>Это функции, с которыми можно “подцепиться” к состоянию
и к методам жизненного цикла React из функциональных компонентов.<br>
Хуки не работают в классах, а используются вместо них.<br>
Хуки вызывают только на верхнем уровне (не в циклах, условиях и т.д.)<br>
Хуки вызывают только из функциональных компонентов React, не из обычных JS-функций.<br>
Если имя функции начинается с use (useSamething) и использует другие хуки,
то такая функция это пользовательский хук.<br>
<br>
<em>useState(i)</em> - возвращает массив из двух элементов:<br>
  состояние (это state - состояние) и функцию, которая изменяет это состояние.<br>
  Имена даём возвращаемому состоянию и функции произвольно.<br>
<br>
<em>useEffect(i)</em> - React запускает эффекты useEffect(() => {...}) после каждого рендера, включая первый рендер.</p><pre><code>useEffect(() => {
fetch('http://…')
  .then(responce=>responce.json())
  .then(todos=>{
    setTodos(todos)
  })
}, [])</code></pre><br><p>вызвать хук можно либо</p><pre><code>import React, { useEffect } from 'react'
useEffect(i) {...}
<span>либо</span>
React.useEffect(i) {...}</code></pre><br><p>Сравнение хука и класса:<br>
<em>Хук</em>:</p><pre><code><span>подключение хука</span>
import React, {useState} from 'react'
function Example() {
  <span>0 это начальное состояние,
  это может быть не объект</span>
  const [count, setCount] = useState(0)
  return (
    &lt;div&gt;
      &lt;p&gt;Вы нажали {count} раз &lt;/p&gt;
      &lt;button
        onClick={() => setCount(count + 1)}
      &gt;
        Нажми на меня
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre><br><p><em>Класс</em>:</p><pre><code>class Example extends React.Component {
  constractor (props) {
    super (props)
    this.state = {
      count: 0
    }
  }
  render () {
    return (
      &lt;div&gt;
        &lt;p&gt;
          Вы нажали {this.state.count} раз
        &lt;/p&gt;
        &lt;button 
          onClick={() => this.setState({
            count.this.state.count + 1
          })}
        &gt;
            Нажми на меня
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre><p>Чтобы наделить функциональный компонент состоянием нужно либо преобразовать его в класс, либо добавить в него хук.<br>
React запоминает значение переменной состояния между вызовами функции.<br>
<em>Итого</em>:</p><pre><code><span>подключаем хук</span>
import React, {useState} from 'react'
<span>добавляем переменную в функцию</span>
const [count, setCount] = useState(0)
<span>вызываем функцию изменения</span>
&lt;button onClick={() => setCount(count + 1)}&gt;</code></pre><br><p><em>Хук еффекта выполняет побочные действия</em>:<br>
- загрузка данных<br>
- оформление подписки и изменение DOM вручную<br>
- представляет собой совокупность методов componentDidMount, componentDidUpdate и componentWillUnmount.<br>
<br>
Эффекты позволяют выполнить дополнительный код после того, как React обновил DOM, т.е. после каждого рендера.<br>
Любой эффект может возвратить функцию, которая сбросит его.<br>
React будет сбрасывать эффект перед тем, как компонент размонтируется. Например оформление и отмена подписки:</p><pre><code>import React , {useState, useEffect} from 'react'
function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null)
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline)
    }
    ChatAPI.subscribeToFriendStatus(
      props.friend.id,
      handleStatusChange
    )
    <span>сброс эффекта</span>
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(
        props.friend.id,
        handleStatusChange
      )
    }
  })
  if (isOnline === null) {
    return ‘Загрузка…’
  }
  return isOnline ? ‘В сети’ : ‘Не в сети’
}</code></pre><p>Чтобы React выполнял эффект только в случае изменения нужен второй аргумент в виде массива,
с которым будет сравниваться значение первого аргумента.<br>
При каждом рендере react сравнивает новое значение переменной в первом аргументе со старым значением переменной,
указанным во втором аргументе (в массиве).</p><pre><code><span>стрелочная функция это первый аргумент эффекта</span>
useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline)
  }
  ChatAPI.subscribeToFriendStatus(
    props.friend.id,
    handleStatusChange
  )
  return() => {
    ChatAPI.unsubscribeFromFriendStatus(
      props.friend.id,
      handleStatusChange
    )
  }
}
<span>это второй аргумент эффекта
со старым значением переменной,
по которому будет сравнение первого аргумента:
повторно подписаться только если
props.friend.id изменился.</span>
[props.friend.id])</code></pre><br><p><em>Обычный эффект без сброса</em>:</p><pre><code>import React, {useState, useEffect} from 'react'
function Example() {
  const [count, setCount] = useState(0)
  useEffect(() => {
    document.title = `Вы нажали ${count} раз`
<span>перезапускать эффект только если count поменялся</span>
  }, [count])
  return (
    &lt;div&gt;
      &lt;p&gt;
        Вы нажали {count} раз
      &lt;/p&gt;
      &lt;button
        onClick={() => setCount(count + 1)}
      &gt;
        Нажми на меня
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre><br><p>Для корректной работы с хуками нужно установить плагин для ESLint:<br>
<b>npm i eslint-plugin-react-hooks --save -dev</b></p><pre><code>useContext:
import React, {useContext} from 'react'
const themes = {
  light: {
    foreground: “#000000”,
    background: “#eeeeee”
  }
  dark: {
    foreground: “#ffffff”,
    background: “#222222”
  }
}
<span>создаём объект контекста со свойством light</span>
const ThemeContext = React.createContext(themes.light)
function App() {
  return(
    <span>значение value определяет текущее значение</span>
    &lt;ThemeContext.Provider
      value={themes.dark}
    &gt;
    <span>передаваемого в Toolbar контекста.
    При обновлении значения - новый рендер.</span>
    &lt;Toolbar/&gt;
    <span>Меняем контекст на тёмную тему.</span>
    &lt;/ThemeContext.Provider&gt;
  )								
}
<span>передаём контекст потомку</span>
function Toolbar (props) {
  return(
    &lt;div&gt;
      &lt;ThemedButton/&gt;
    &lt;/div&gt;
  )
}
function ThemedButton() {
<span>используем контекст с тёмной темой</span>
  const theme = useContext(ThemeContext)
  return (
    &lt;button style={{background: theme.background, color: theme.foreground}}&gt; Я стилизован темой из контекста! &lt;/button&gt;
  )
}</code></pre><br><p><em>Управляемый компонент</em>:<br>
Если форму обрбатывать с помощью JS-функции, у которой есть доступ к введённым данным,
то такая форма называется “управляемым компонентом”.<br>
Библиотека Formik.<br>
Или, другими словами, <em>управляемый компонент</em> - это элемент формы рендер,
поведение при пользовательском вводе и значение которого контролирует React.<br></p><pre><code>class NameForm extends React.Component{
  constructor(props){
    super(props)
    this.state={value:' '}
    this.handleChange=this.handleChange.bind(this)
    this.handleSubmit=this.handleSubmit.bind(this)
  }
  handleChange(event) {
    this.setState({value: event.target.value})
  }
  handleSubmit(event){
    alert('Отправленное имя: ' + this.state.value)
    <span>отменяем действие по умолчанию</span>
    event.preventDefault()
  }
  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Имя:
          &lt;input
            type=”text”
            value={this.state.value}
            onChange={this.handleChange}
          /&gt;
        &lt;/label&gt;
        &lt;input
          type=”Submit”
          value=”Отправить”
        /&gt;
      &lt;/form&gt;
    )
  }
}</code></pre><br><p>в атрибуте value всегда будет отражаться React состояние <b>this.state.value</b>,
а каждое нажатие клавиш через <b>handleChange</b> будет это состояние изменять и React будет обновлять поле ввода по мере печатанья.</p><pre><code>&lt;textarea&gt;
  также как
&lt;input/&gt;
&lt;textarea
  value={this.state.value}
  onChange={this.handleChange}
&gt;</code></pre><p>Чтобы использовать несколько тегов input нужно каждому дать свой атрибут name.</p><pre><code>&lt;select&gt;
  &lt;option value=”grapefruit”&gt;
    Грейпфрут
  &lt;/option&gt;
  &lt;option value=”lime”&gt;
    Лайм
  &lt;/option&gt;
  &lt;option selected value=”coconut”&gt;
    Кокос
  &lt;/option&gt;
  &lt;option value=”mango”&gt;
    Манго
  &lt;/option&gt;
&lt;/select&gt;</code></pre><p>если в value передать массив, то можно выбрать несколько опций:</p><code>&lt;select multiple={true} value={[‘Б’, ‘В’]}&gt;</code><p>в React выбранный элемент присваивается в конструкторе по умолчанию:<br>
<b>this.state={value='cocnut'}</b>,<br>
а потом изменяется через setState:<br>
<b> &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;/select&gt</b>;<br>
Если установить значение value, то пользователь изменить его не сможет:<br></p><code>ReactDOM.render(&lt;input value=”Привет”/&gt;)</code><p>Для любых изменяемых данных в React -приложении должен быть один “источник истины” (state).<br>
Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.<br>
Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка.<br>
Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами,
вы должны полагаться на однонаправленный поток данных
  - это водопад пропсов от родителя к потомку,
в который каждый компонент добавляет свой state в виде пропса (props).<br>
<br>
<em>Композиция</em>:<br>
Вместо наследования:</p><pre><code>function FancyBorder(props) {
  return (
      <span>поместить в div всё,
      что выделено тэгом
      &lt;FancyBorder&gt;</span>
    &lt;div
      className={'FancyBorder FancyBorder-' + props.color}
    &gt;
      {props.children}
    &lt;/div&gt;
  )
}
function Dialog(props) {
  return (
      <span>определяю тэг &lt;FancyBorder&gt;
      и его содержимое для подстановки</span>
    &lt;FancyBorder color="blue"&gt;
      &lt;h1 className="Dialog-title"&gt;
        {props.title}
      &lt;/h1&gt;
      &lt;p className="Dialog-message"&gt;
        {props.message}
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  )
}
function WelcomDialog() {
  return (
    <span>определяю компонент для рендера
    и задаю значение пропсов</span>
    &lt;Dialog
      title="Welcom"
      message="Thank you for visiting our spacecraft!"
    /&gt;
  )
}
ReactDOM.render(
  &lt;WelcomDialog/&gt;,
  document.getElementById('root')
)</code></pre><br><p><em>Ключи</em>:<br>
Ключи помогают React определить, какие элементы были изменены, добавлены или удалены.</p><pre><code>const todoItems = todos.map((todo) => 
  &lt;li key={todo.id}&gt;
    {todo.text}
  &lt;/li&gt;
)
function NumberList(props) {
  const numbers = props.numbers
  <span>функция map() преобразует массив numbers в список</span>
  const listItems = numbers.map((number) =>
    &lt;ListItem
      <span>ключ нужно определить внутри массива, ключ это строка</span>
      key={number.toString()}
      value={number}
    /&gt;
  )
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  )
}
<span>или так:</span>
function NumberList(props) {
  const numbers = props.numbers
  return (
    &lt;ul&gt;
      {numbers.map((number) => 
        &lt;ListItem
          key={number.toString()}
          value={number}
        /&gt;
      )}
    &lt;/ul&gt;
  )
}</code></pre><br><p><em>Валидирование типов</em>:<br>
Библиотека prop-types нужна для задания типов переменных:<br>
<b>npm i prop-types</b>.</p><pre><code>import PropTypes from 'prop-types'

function Example ({prop1, prop2, prop3}) {...}
Example.propTypes={
  prop1: PropTypes.object.isRequired,
  prop2: PropTypes.number,
  prop3: PropTypes.func.isRequired,
}
export default Example</code></pre><br><p><em>Условный рендеринг</em>:</p><pre><code>if (isLoggedIn) {
  return &lt;UserGreeting/&gt;;
}
return &lt;GuestGreeting/&gt;;

{
  unreadMessages.length > 0 && 
  &lt;h2&gt;
    у вас {unreadMessages.length} непрочитанных сообщений.
  &lt;/h2&gt;
}
Пользователь 
  &lt;b&gt;{
    isLoggedIn ? 'сейчас' : 'не'
  }&lt;/b&gt;
на сайте.</code></pre><br><img src="../img/js/react/react.png" alt=""><img src="../img/js/react/react0.png" alt=""><img src="../img/js/react/React1.png" alt=""><img src="../img/js/react/React2.png" alt=""><img src="../img/js/react/React3.png" alt=""><img src="../img/js/react/React4.png" alt=""><img src="../img/js/react/React5.png" alt=""><img src="../img/js/react/React6.png" alt=""><img src="../img/js/react/React7.png" alt=""><img src="../img/js/react/React8.png" alt=""><img src="../img/js/react/React9.png" alt=""><img src="../img/js/react/React10.png" alt=""><img src="../img/js/react/React11.png" alt=""><img src="../img/js/react/React12.png" alt=""><img src="../img/js/react/React13.png" alt=""><img src="../img/js/react/React14.png" alt=""><img src="../img/js/react/React15.png" alt=""><img src="../img/js/react/React16.png" alt=""><img src="../img/js/react/React17.png" alt=""><img src="../img/js/react/React18.png" alt=""><img src="../img/js/react/React19.png" alt=""><img src="../img/js/react/React20.png" alt=""><img src="../img/js/react/React21.png" alt=""><img src="../img/js/react/React22.png" alt=""><img src="../img/js/react/React23.png" alt=""><img src="../img/js/react/React24.png" alt=""><img src="../img/js/react/React25.png" alt=""><img src="../img/js/react/React26.png" alt=""><img src="../img/js/react/React27.png" alt=""><img src="../img/js/react/React28.png" alt=""><img src="../img/js/react/React29.png" alt=""><img src="../img/js/react/React30.png" alt=""><img src="../img/js/react/React31.png" alt=""><img src="../img/js/react/React32.png" alt=""><img src="../img/js/react/React33.png" alt=""><img src="../img/js/react/React34.png" alt=""></details><details><summary class="menu__submenu_lv1">Redux</summary><a href="https://redux.js.org/introduction/getting-started">Redux</a><p>Весь базовый функционал redux умещается в малюсенький файлик</p><pre><code>function createStore(reducer, initialState) {
  let state = initialState
  return {
    dispatch: action => { state = reducer(state, action) },
    getState: () => state
  }
}</code></pre><br><p><dfn>createStore</dfn> - возвращает объект с полем “dispatch”.<br>
<dfn>dispatch</dfn> - это функция, которая всего лишь применяет редюсер к нашему текущему состоянию
<b>(newState = reducer(state, action))</b>.<br>
<br>
С этими 7 строками уже можно писать TodoApp.<br>
Инициализация хранилища:</p><pre><code>function todosReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: action.id,
          text: action.text,
          completed: false
        }
      ]
    case 'TOGGLE_TODO':
      return state.map(todo => {
        if (todo.id === action.id) {
          return { ...todo, completed: !todo.completed }
        }
        return todo
      })
      default: return state
  }
}

const initialTodos = []

const store = createStore(todoReducer, initialTodos)</code></pre><br><p>Использование:</p><pre><code>store.dispatch({
  type: 'ADD_TODO',
  id: 1,
  text: 'Понять на сколько redux прост'
})

store.getState() -  [{ 
                      id: 1,
                      text: ‘Понять насколько redux прост’,
                      completed: false
                    }]
store.dispatch({
  type: 'TOGGLE_TODO',
  id: 1
})

store.getState() -  [{
                      id: 1,
                      text: ‘Понять насколько redux прост’,
                      completed: true
                    }]</code></pre><br><p>Метод combineReducers позволяет вместо того, чтобы создавать один огромный reducer для всего состояния приложения сразу, разбивать его на отдельные модули.</p><pre><code>function counterReducer(state, action) {
  if (action.type === 'ADD') {
    return state + 1
  } else {
    return state
  }
}

const reducer = combineReducers({
  todoState: todoReducer, 
  counterState: counterReducer
})

const initialState = {
  todoState: [],
  counterState: 0,
}

const store = createStore(reducer, initialState)</code></pre><br><p>Если упростить, то:</p><pre><code>function reducer(state, action) {
  return {
    todoState: todoReducer(state, action),
    counterState: counterReducer(state, action),
  }
}</code></pre><br><p>Но этот код плохо масштабируется.<br>
Если у нас 2 “под-состояния”, нам нужно дважды написать (state, action),
а хорошие программисты так не делают.<br>
Если редюсоров и стэйтов много, то через обработку коллекции редюсеров:</p><pre><code>function combineReducers(reducersMap) {
  return function combinationReducer(state, action) {
    const nextState = {}
    Object.entries(reducersMap).forEach(([key, reducer]) => {
      nextState[key] =  reducer(state[key], action)
    })
    return nextState
  }
}</code></pre><br><p><dfn>middleware в разрезе redux</dfn> - это какая-то штука, которая слушает все dispatch и при определенных условиях делает что-то.</p><pre><code>const createStoreWithMiddleware = applyMiddleware(somdfniddleware)(createStore)
const store = createStoreWithMiddleware(reducer, initialState)</code></pre><br><p><dfn>applyMiddleware</dfn> переопределяет метод dispatch, добавляя перед (или после) обновлением состояния какую-то пользовательскую логику.<br>
самый популярный middleware от создателей redux - <dfn>redux-thunk</dfn>, чаще всего используют при асинхронных операциях.<br>
Его смысл сводится к тому, что можно передавать в store.dispatch сложные функции<br></p><pre><code>const thunk = store => dispatch => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState)
  }
  return dispatch(action)
}</code></pre><br><p>метод createStore принимал атрибуты (reducer, initialState) и возвращал объект с ключами { dispatch, getSate }.<br>
метод applyMiddleware берёт уже реализованный метод createStore и переопределяет его возвращаемое значение:</p><pre><code>function applyMiddleware(middleware) {
  return function createStoreWithMiddleware(createStore) {
    return (reducer, state) => {
      const store = createStore(reducer, state)
      return {
        dispatch: action => middleware(store)(store.dispatch)(action),
        getState: store.getState,
      }
    }
  }
}</code></pre><br><p><dfn>form</dfn>:</p><pre><code>import { useDispatch } from 'react-redux'
import { createPost } from 'actions/posts'

const [postData, setPostData] = useState({
  creator: ' ',
  title: ' ',
  message: ' '
})

const dispatch = useDispatch()

const handleSubmit = (e) => {
  e.preventDefault()
  dispatch(createPost(postData))
}</code></pre><br><p><dfn>action</dfn>:</p><pre><code>export const createPost = (post) => async (dispatch) => {
try {
  const { data } = await api.createPost(post)
  dispatch ({ type: 'CREATE', payload: data })
  } catch (error) {
    console.log(error)
  }
}</code></pre><br><p><dfn>api</dfn>:</p><code>export const createPost = (newPost) => axios.post(url, newPost)</code><br><p><dfn>server/controllers</dfn>:</p><pre><code>export const createPost = async (req, res) => {
  const post = req.body;
  const newPostMessage = new PostMessage({
    …post,
    creator: req.userId,
    createdAt: new Date().toISOString()
  })

  try {
    await newPostMessage.save();
    res.status(201).json(newPostMessage);
  } catch (error) {
    res.status(409).json({ message: error.message });
  }
}</code></pre><br><p><dfn>server/models</dfn>:</p><pre><code>import mongoose from 'mongoose'

const postSchdfna = mongoose.Schdfna({
  title: String,
  message: String,
  name: String,
  creator: String,
  tags: [String],
  selectedFile: String,
  likes: { type: [String], default: [] },
  createdAt: {
    type: Date,
    default: new Date(),
  },
})

export default mongoose.model('PostMessage', postSchdfna);</code></pre><br><p><dfn>reducers</dfn>:</p><pre><code>export default (post = [ ], action) => {
  switch (action.type) {
    case 'FATCH_ALL':
      return action.payload;
    case 'CREATE':
      return [ …posts, action.payload ];
    default: return posts;
  }
}</code></pre><br><img src="../img/js/react/redux.jpg" alt=""></details><details> <summary>Livewire<details><summary>Create component Livewire</summary><p>В livewire можно указывать роут на класс компонента</p><pre><code>Route::get('/posts', ShowPosts::class);
Route::get('/posts/create', CreatePost::class);</code></pre><p>для этого необходимо создать шаблон для всех компонентов<br>
(components.layouts.app.blade.php)</p><code>./sail artisan livewire:layout<p>Компонент имеет доступ к публичным свойствам и методам своего класса</p><pre><code>php artisan make:livewire ComponentName
<span>or</span>
php artisan make:livewire component-name
</code></pre><p>Создать компонент в папке</p><pre><code>php artisan make:livewire FolderName\\ComponentName
<span>or</span>
php artisan make:livewire folder-name.component-name
</code></pre><p>Создать компонент с тестом</p><code>code ./sail artisan make:livewire create-post --pest</code><p>Создать шаблон для компонентов livewire</p><code>./sail artisan livewire:layout</code><p>Выбирать разные шаблоны на весь класс</p><pre><code><Layout layouts.app></Layout> 
class CreatePost extends Component { }</code></pre><p>Выбирать разные шаблоны на методе</p><pre><code><Layout layouts.app></Layout> 
public function render()
{
  return view('livewire.create-post');
}</code></pre><p>Выбирать разные шаблоны динамически</p><pre><code>public function render()
{
  return view('livewire.create-post')
    ->layout('layouts.app'); 
}</code></pre><p>Через @yield('content') указываю файл шаблона</p><pre><code>&lt;body&gt;
  @yield('content')
&lt;/body&gt;</code></pre><p>Метод render() можно не указывать<br>
Livewire будет автоматически выводить view с названием как у класса
</p><p>В класс User.php добавить подстановку title в шаблон</p><code>use Livewire\Attributes\Title;
<Title title></Title></code><p>Подстановка title динамически</p><pre><code>public function render()
{
  return view('livewire.create-post')
    ->title('Create Post'); 
}
</code></pre><p>задаю свойства livewire компонента в классе</p><code>public $title = 'Post title...';</code><p>задаю свойства livewire компонента в виде</p><code><h1>Title: "{{ $title }}"</h1></code><p>Дополнительные свойства при рендере в классе</p><code>return view('livewire.create-post')->with([
  'author' => Auth::user()->name,
]);
</code><p>Дополнительные свойства при рендере в виде</p><code>Author: {{ $author }}</code><p>При выводе в любом цикле всегда указывать ключ</p><pre><code>@foreach ($posts as $post)
  &lt;livewire:post-item :$post :key="$post->id"&gt;
  @livewire(PostItem::class, ['post' => $post], key($post->id))
@endforeach
</code></pre><p>Привязка ввода к свойству класса</p><code>&lt;input type="text" id="title" wire:model="title"&gt;</code><p>Привязка ввода к методу класса</p><pre><code>&lt;form wire:submit="save"&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;
</code></pre><p>Получить значения и очистить поля ввода</p><pre><code>class ManageTodos extends Component
{
  public $todos = [];
  public $todo = '';
  public function addTodo()
  {
    $this->todos[] = $this->todo;
    $this->reset('todo'); 
  }
}</code></pre><p>Получить значения и очистить поля ввода</p><pre><code>class ManageTodos extends Component
{
  public $todos = [];

  public $todo = '';

  public function addTodo()
  {
    $this->todos[] = $this->pull('todo');
  }
}
// The same as $this->all() and $this->reset();
$this->pull();

// The same as $this->only(...) and $this->reset(...);
$this->pull(['title', 'content']);
</code></pre><p>Только авторизированный пользователь может изменить данные</p><pre><code>public function update()
{
  $post = Post::findOrFail($this->id);
  $this->authorize('update', $post); 
  $post->update(...);
}</code></pre><p>Изменение свойства возможно только внутри класса</p><pre><code>class UpdatePost extends Component
{
  <Locked></Locked> 
  public $id;
}</code></pre><p>Свойства Eloquent моделей по умолчанию изменять возможно только внутри класса</p><pre><code>class UpdatePost extends Component
{
  public Post $post; 
  public $title;
  public $content;
  
  public function update()
  {
    $this->post->update([
      'title' => $this->title,
      'content' => $this->content,
    ]);
    session()->flash('message', 'Post updated successfully!');
  }
}
</code></pre><p>Свойство <Computed></Computed> кеширует запрошенные данные,<br>
чтобы отправлять каждый раз новый запрос.<br>
Обращаться к свойству через объект $this->todos</p><pre><code>use Livewire\Attributes\Computed;

<Computed></Computed>
public function todos()
{
  return Auth::user()
    ->todos()
    ->select(['title', 'content'])
    ->get();
}

public function markAllComplete() 
{
  $this->todos->each->complete();
}
</code></pre><p>Вывод компонента в Blade view</p><code>&lt;livewire:create-post /&gt;</code><p>Вывод компонента в Blade view со значением</p><code>&lt;livewire:create-post title="Initial Title" /&gt;</code><p>Вывод компонента в Blade view с динамическим значением переменной</p><code>&lt;livewire:create-post :title="$initialTitle" /&gt;</code><p>Инициализация переменной в классе при подключении компонента</p><pre><code>class CreatePost extends Component
{
  public $title;
  public function mount($title = null)
  {
    $this->title = $title;
  }
}
</code></pre><p>livewire инициализирует переменную автоматически</p><pre><code>class CreatePost extends Component
{
  public $title;
}
</code></pre><p>Инлайн компонент - это один файл где разметка внутри метода render()</p><code>./sail artisan make:livewire CreatePost --inline</code><p>В routes/web.php добавить</p><pre><code>use App\Livewire\User\User;
Route::get('user', User::class);</code></pre><p>В классе UserCreate.php добавить переход на страницу uri без перезагрузки страницы с сервера</p><code>$this->redirect('/user', navigate: true);</code><p>Свойства и методы формы вынесены в отдельный класс UserForm<br>
В компоненте User объект класса UserForm определён как form<br>
Обращения к свойствам класса UserForm через form<br></p><p>Подключить assets в layout/app.blade.php</p><pre><code>@assets
  &lt;script src="https://cdn.jsdelivr.net/npm/pikaday/pikaday.js" defer&gt;&lt;/script&gt;
  &lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css"&gt;
@endassets

@vite(['resources/css/app.css', 'resources/js/app.js'])
</code></pre><!-- Actions--><p>$refresh - проверяет БД и отображает на странице</p><code>&lt;button type="button" wire:click="$refresh"&gt;...&lt;/button&gt;</code><p>$commit - отслеживает изменения компонета на сервере</p><code>&lt;button type="button" wire:click="$commit"&gt;...&lt;/button&gt;</code><!-- Event listeners--><p>wire:click<br>
wire:submit<br>
wire:keydown<br>
wire:keyup<br>
wire:mouseenter<br>
wire:* - любой текст после wire: может быть названием события<br>
Livewire поддерживает любые событыя браузера, например wire:transitionend<br></p><a href="https://livewire.laravel.com/docs/actions">слушатели событий<br></a><br><p>wire:loading - загрузчик<br>
wire:click="delete({{ $post->id }})" - передать в класс параметр<br>
wire:click="$parent.removePost({{ $post->id }})" - обращаюсь к методу родительского компонента<br>
wire:click="$set('query', '')" - заменил значение свойства query на пустую строку<br>
wire:click="$toggle('sortAsc')" - при каждом нажатии меняет true/false</p><pre><code>&lt;button wire:click="$toggle('sortAsc')"&gt;
  Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}
&lt;/button&gt;</code></pre><p>wire:click="$dispatch('post-deleted')" - срабатывает событие<br>
$event - даёт доступ к событиям JS, например при нажатии enter<br>
передать значение ввода в search() - метод класса компонента</p><code>&lt;input type="text" wire:keydown.enter="search($event.target.value)"&gt;</code><p>При выполнении метода с <Renderless></Renderless> метод render() этого же класса не выполняется,<br>
либо skipRender() внутри метода<br></p><pre><code><Renderless></Renderless> 
public function incrementViewCount()
{
  $this->post->incrementViewCount();
}

public function incrementViewCount()
{
  $this->post->incrementViewCount();
  $this->skipRender(); 
}</code></pre><p>wire:dirty.class="border-yellow" - позволяет менять класс<br>
если значение поля отличается от значения этого поля в БД</p><code>&lt;input type="text" wire:model.blur="title" wire:dirty.class="border-yellow"&gt;</code><p>Пока поле ввода title будет в фокусе, будет Unsaved...<br>
когда фокус уйдёт, значение будет записано в БД и Unsaved... исчезнет</p><pre><code>&lt;input type="text" wire:model.blur="title"&gt;
&lt;div wire:dirty wire:target="title"&gt;Unsaved...&lt;/div&gt;</code></pre><p>Можно выносить части Livewire компонентов в Blade компоненты</p><pre><code>&lt;form wire:submit="save"&gt;
  &lt;x-input-text name="title" wire:model="title" /&gt;
  &lt;x-input-text name="content" wire:model="content" /&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre><p>Blade компонент</p><pre><code>@props(['name'])
&lt;input type="text" name="{{ $name }}" {{ $attributes }}&gt;
&lt;div&gt;
    @error($name) &lt;span class="error"&gt;{{ $message }}&lt;/span&gt; @enderror
&lt;/div&gt;
</code></pre><p>породить событие post-created</p><code>$this->dispatch('post-created', title: $post->title);</code><p>по событию выполнить метод</p><pre><code><On post-created></On> 
public function updatePostList($title) { }</code></pre><p>породить событие post-created с динамическим аттрибутом</p><pre><code>$this->dispatch("post-updated.{$post->id}");

<On post-updated.{post.id}></On></code></pre><p>презагрузить родительский компонент,<br>
если в дочернем компоненте будет событие saved</p><code>&lt;livewire:edit-post @saved="$refresh"&gt;</code><p>вызвать метод close() родительского компонента<br>
если в дочернем компоненте будет saved конткретного postId</p><code>&lt;livewire:edit-post @saved="close($event.detail.postId)"&gt;</code></code></details><details><summary>Validation</summary><p>В основном такая же как в ларавел, но метод validate() применяется на объекте компонента<br>
Метод validate() возвращает массив отвалидированных данных либо массив ошибок</p><pre><code>public function save()
{
  $validated = $this->validate([ 
    'title' => 'required|min:3',
    'content' => 'required|min:3',
  ]);
  Post::create($validated);
  return redirect()->to('/posts');
}</code></pre><p>В форме ввода не фронте отобразить ошибку валидации с помощью<br>
директивы @error(), по ключу title выводиться значение $message</p><pre><code>&lt;input type="text" wire:model="title"&gt;
&lt;div&gt;@error('title') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Задать правила валидации можно разными способами</p><pre><code><span>методом validate()</span>
$validated = $this->validate([
  <span>массивом</span>
  'name' => ['required', 'min:2', 'max:30'],
  <span>строкой через разделитель</span>
  'email' => 'required|email|max:30',
  'password' => 'required|min:6',
]);
<span>параметром <Validate></Validate></span>
<span>отслеживает изменение значений</span>
<span>использует стандартные валидаторы ларавел</span>
<span>свой текст сообщения</span>
<Validate required message: Имя обязательно></Validate>
<span>своё имя поля в сообщении</span>
<Validate min:2 as: Name></Validate>
<Validate max:30></Validate>
public string $name;
<span>написать свои правила валидации</span>
protected function rules(): array
{
  return [
    'name' => ['required', 'min:2', 'max:30'],
    'email' => 'required|email|max:30',
    'password' => 'required|min:6',
  ];
}
<span>написать свои тексты сообщений об ошибке</span>
protected function messages(): array
{
  return [
    <span>название поля.валидатор => текст ошибки</span>
    'name.required' => 'Имя обязательно!',
    'name.min' => 'Имя должно быть длиннее!',
    'email.required' => 'Введите почту!',
    'password.required' => 'Пароль обязателен!',
  ];
}</code></pre><p>Если правила валидации заданы параметром <Validate></Validate><br>
или методом rules(),<br>
то метод validate() вызываем без параметров</p><code>$validated = $this->validate();</code><p>Создаю пользователя в БД</p><code>User::create($validated);</code><p>wire:model.blur="name" - real-time validation<br>
срабатывает по событию либо <dfn>.live</dfn> либо <dfn>.blur</dfn><br>
работает при использовании параметра валидирования <Validate></Validate><br>
wire:model.live="name" - отправляет на сервер введенный знак сразу<br>
wire:model.live.debounce="name" - отправляет на сервер введенное значение через 200мс после последнего нажатия<br>
wire:model.live.debounce.5ms="name" - отправляет на сервер введенное значение через 5мс после нажатия<br>
</p></details><details><summary>Form</summary><p>B компоненте создаю форму и меняю действие по умолчанию на вызов метода save из класса<br>
Форма вызывает метод обработки при надатии на enter или на кнопку Save<br>
B полях ввода данных привязываю данные к свойствам компонента<br>
Свойство компонента wire:model привязывает к полю ввода свойство класса wire:model="name"<br></p><pre><code>&lt;form wire:submit.prevent="save"&gt;
  &lt;input type="text" wire:model="name"&gt;
  &lt;input type="email" wire:model="email"&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre><p>B методе сохранения данных вызываю метод валидации данных<br>
Если данные валидны, то сохраняю данные в БД<br>
Если данные не валидны, то вывожу ошибку</p><pre><code>public function save()
{
  $validated = $this->validate([
    'name' => 'required|min:3',
    'email' => 'required|email',
  ]);
  User::create($validated);
}</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;
&lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;
&lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;</code></pre><p>Получить все данные формы</p><code>$this->all();</code><p>Получить данные выборочных полей</p><code>$this->only(['name', 'email'])</code><p>Метод pull() - это метод only() + reset()<br>
Заберёт из формы данные полей name и email<br>
и очистит поля формы name и email</p><code>$this->pull(['name', 'email'])</code><p>заберёт из формы все данные и очистит форму</p><code>$this->pull();</code><p>Создать класс формы в app/Livewire/Forms/FormName.php</p><code>php artisan livewire:form FormName</code><p>При создании компонентов CreatePost, UpdatePost и т.д.
в классах компонентов будут вызываться методы и свойства класса FormName.php.
T.e. все свойства и методы формы в одном классе и исспользуются разными компонентами.
Для доступа к свойствам и методам калсса формы в классе компонента создаётся её объект form
и обращение к свойствам и методам через объект.
B классе компонента:</p><pre><code>public UserForm $form;
public function save()
{$this->form->saveUser();}</code></pre><p>B шаблоне компонента:</p><code>wire:model="form.name"</code></details><details><summary>Events</summary><p>События позволяю прослушивать события в другом компоненте.
Сгенерировать событие: метод dispatch()</p><code>$this->dispatch('eventname');
<span>or</span>
$this->dispatch('eventname', title: $post->title);</code><p>В другом (других) компоненте добавить слушателя события</p><code>use Livewire\Attributes\On;
<On eventname></On>
public function updatePost($title) {}
</code></details></summary></details></details><details><summary>Data</summary><details><summary>Encryption</summary><p>- шифрование - это процесс преобразования данных в неразборчивый вид с помощью алгоритма шифрования<br>
- дешифрование - это процесс преобразования зашифрованных данных в исходный вид с помощью алгоритма дешифрования<br>
- Laravel использует библиотеку OpenSSL и Sodium для шифрования и дешифрования данных<br>
- ключ шифрования хранится в переменной окружения APP_KEY в .env файле<br>
- параметр key в config/app.php устанавливается через APP_KEY в .env<br>
- ключ шифрования должен быть уникальным для каждого приложения случайным набором символов длинной 32 байта или 256 бит и защищёным от доступа посторонних лиц<br>
- драйверы шифрования: bcrypt, argon, argon2id, scrypt, md5, sha1, sha256, sha512, whirlpool, ripemd160, tiger1600, haval1600, gost, gost-crypto<br> 
- при изменении ключа все сеансы аутентификации пользователей будут завершены.</p><pre><code>php artisan key:generate    // сгенерировать ключ
- для плавной смены ключа предыдущие ключи шифрования указать в переменной окружения APP_PREVIOUS_KEYS
APP_KEY="base64:J63qRTDLub5NuZvP+kb8YIorGS6qFYHKVo6u7179stY="
APP_PREVIOUS_KEYS="base64:2nLsGFGzyoae2ax3EF2Lyq/hH6QghBGLIq5uL+Gp8/w="
- зашифровать значение
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
class DigitalOceanTokenController extends Controller {
  public function store(Request $request): RedirectResponse {
    $request->user()->fill(['token' => Crypt::encryptString($request->token)])->save();
    return redirect('/secrets');
}}
- расшифровать значения
use Illuminate\Contracts\Encryption\DecryptException;
use Illuminate\Support\Facades\Crypt;
try {$decrypted = Crypt::decryptString($encryptedValue);}
catch (DecryptException $e) { }
</code></pre></details><details><summary>Hashing</summary><p>хеширование - это необратимый процесс преобразования данных в неразборчивый вид с помощью алгоритма хеширования,<br>
используется для хранения паролей и проверки целостности, подлинности, идентичности, уникальности, безопасности, доступности, конфиденциальности данных<br>
- Laravel использует библиотеку Hash, Argon2, Bcrypt, Argon2id для хеширования данных<br>
- драйвер хеширования bcrypt, argon и argon2id указан в переменной HASH_DRIVER в .env<br>
- HASH_VERIFY в .env: true - сверять алгоритм хеширования пароля с установленным, false - любой алгоритм хеширования</p><pre><code>php artisan config:publish hashing    // опубликовать файл конфигурации хеширования для настройки параметров драйвера хеширования
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
class PasswordController extends Controller {
  // Обновить пароль пользователя
  public function update(Request $request): RedirectResponse
  {
    $request->user()->fill(['password' => Hash::make($request->newPassword)])->save();
    return redirect('/profile');
}}
$hashed = Hash::make('password', ['rounds' => 12]);   // коэффициент работы Bcrypt
$hashed = Hash::make('password', ['memory' => 1024, 'time' => 2, 'threads' => 2]);    // коэффициент работы Argon2
if (Hash::check('plain-text', $hashedPassword)) { }   // сверить хеш
if (Hash::needsRehash($hashed)) {$hashed = Hash::make('plain-text');}   // нужно ли повторно хешировать
</code></pre></details><details> <summary>Password Reset</summary><p>для сброса пароля нужно:<br>
- в App\Models\User<br>
Illuminate\Notifications\Notifiable<br>
Illuminate\Contracts\Auth\CanResetPassword<br>
- в 0001_01_01_000000_create_users_table.php токен сброса пароля<br>
- в bootstrap/app.php указать trustHosts - отвечать только на запросы указанных хостов<br>
- форма запроса ссылки сброса пароля с полем для email<br></p><pre><code>Route::get('/forgot-password', function () {return view('auth.forgot-password');
})->middleware('guest')->name('password.request');
- сверить почту и отправить на неё ссылку
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
Route::post('/forgot-password', function (Request $request) {
  $request->validate(['email' => 'required|email']);
  $status = Password::sendResetLink($request->only('email'));
  return $status === Password::ResetLinkSent
    ? back()->with(['status' => __($status)])
    : back()->withErrors(['email' => __($status)]);
})->middleware('guest')->name('password.email');
- форма ввода нового пароля, после перехода по ссылке сброса пароля
Route::get('/reset-password/{token}', function (string $token) {
  return view('auth.reset-password', ['token' => $token]);
})->middleware('guest')->name('password.reset');
- проверка входящего запроса и обновление пароля пользователя в базе данных
use App\Models\User;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
Route::post('/reset-password', function (Request $request) {
  $request->validate([
    'token' => 'required',
    'email' => 'required|email',
    'password' => 'required|min:8|confirmed',
  ]);
  $status = Password::reset(
    $request->only('email', 'password', 'password_confirmation', 'token'),
    function (User $user, string $password) {$user->forceFill(['password' => Hash::make($password)
      ])->setRememberToken(Str::random(60));
      $user->save();
      event(new PasswordReset($user));
  });
  return $status === Password::PasswordReset
    ? redirect()->route('login')->with('status', __($status))
    : back()->withErrors(['email' => [__($status)]]);
})->middleware('guest')->name('password.update');
php artisan auth:clear-resets   // удалить просроченные токены
- для автоматизации добавить в планировщик
use Illuminate\Support\Facades\Schedule;
Schedule::command('auth:clear-resets')->everyFifteenMinutes();
- в App\Providers\AppServiceProvider изменить URL-адрес ссылки для сброса пароля
use App\Models\User;
use Illuminate\Auth\Notifications\ResetPassword;
public function boot(): void
{
  ResetPassword::createUrlUsing(function (User $user, string $token) {
    return 'https://example.com/reset-password?token='.$token;
  });
}
- свой вариант уведомления для отправки пользователю ссылки для сброса пароля
use App\Notifications\ResetPasswordNotification;
public function sendPasswordResetNotification($token): void
{
  $url = 'https://example.com/reset-password?token='.$token;
  $this->notify(new ResetPasswordNotification($url));
}
</code></pre></details><details><summary>Request creation</summary><p>- Конфигурация баз данных в config/database.php
- Параметры конфигурации определяются значениями переменных окружения в .env
- Фасад DB содержит методы для каждого типа запроса: select, update, insert, delete, и statement.</p><pre><code>- команды artisan
php artisan db    // подключиться к базе данных
php artisan db mysql    // подключиться к базе данных и указать имя соединения
php artisan db:show   // просмотр БД
php artisan db:show --database=pgsql    // просмотр БД с именем соединения
php artisan db:show --counts --views   // количество строк и представления для просмотра
php artisan db:table users   // обзор отдельной таблицы
php artisan db:monitor --databases=mysql,pgsql --max=100    // мониторить соединения mysql и pgsql каждую минуту и отправить событие Illuminate\Database\Events\DatabaseBusy при количестве открытых соединений больше 100</code></pre><p>в App\Providers\AppServiceProvider</p><pre><code>- слушатель SQL-запроса
namespace App\Providers;
use Illuminate\Database\Events\QueryExecuted;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void
  {
    DB::listen(function (QueryExecuted $query) {
      // $query->sql;
      // $query->bindings;
      // $query->time;
      // $query->toRawSql();
    });
}}
- вызвать функцию когда время выполнения запроса дольше указанного
namespace App\Providers;
use Illuminate\Database\Connection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
use Illuminate\Database\Events\QueryExecuted;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void
  {DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) { });}
}
- слушать событие Illuminate\Database\Events\DatabaseBusy 
use App\Notifications\DatabaseApproachingMaxConnections;
use Illuminate\Database\Events\DatabaseBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;
public function boot(): void {
  Event::listen(function (DatabaseBusy $event) {
    Notification::route('mail', 'dev@example.com')->notify(new DatabaseApproachingMaxConnections(
      $event->connectionName,
      $event->connections
    ));
});}</code></pre><p>Illuminate\Support\Facades\Schema;</p><pre><code>- проверка БД
use Illuminate\Support\Facades\Schema;
$tables = Schema::getTables();
$views = Schema::getViews();
$columns = Schema::getColumns('users');
$indexes = Schema::getIndexes('users');
$foreignKeys = Schema::getForeignKeys('users');
$columns = Schema::connection('sqlite')->getColumns('users');   // проверить соединение с БД</code></pre><p>Illuminate\Support\Facades\DB</p><pre><code>- показать список всех пользователей приложения
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;
class UserController extends Controller {
  public function index(): View {
    $users = DB::select('select * from users where active = ?', [1]);
    return view('user.index', ['users' => $users]);
}}
- select всегда возвращает массив
$users = DB::select('select * from users');
foreach ($users as $user) {echo $user->name;}
- чтобы получить значение в виде числа
$burgers = DB::scalar("select count(case when food = 'burger' then 1 end) as burgers from menu");
- получить все наборы результатов, возвращенных хранимой процедурой
[$options, $notifications] = DB::selectResultSets(
  "CALL get_user_options_and_notifications(?)", $request->user()->id
);
- связывания параметров, используя именованные привязки
$results = DB::select('select * from users where id = :id', ['id' => 1]);
- insert
DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);
- update
$affected = DB::update('update users set votes = 100 where name = ?',['Anita']);
- delete 
$deleted = DB::delete('delete from users');
- запрос общего типа
DB::statement('drop table users');
- запрос SQL без привязки каких-либо значений
DB::unprepared('update users set votes = 100 where name = "Dries"');
- Если в config/database.php несколько соединений, то получить доступ к соединению с помощью метода connection
$users = DB::connection('sqlite')->select(/* ... */);
- получить доступ к базовому экземпляру PDO текущего соединения
$pdo = DB::connection()->getPdo();
- выполнение набора операций в транзакции
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
});
либо с количеством попыток при взаимоблокировке
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
}, 5);
- транзакция вручную
DB::beginTransaction();   // начать транзакцию
DB::rollBack();   // откатить транзакцию
DB::commit();   // зафиксировать транзакцию
- получить все строки таблицы
$users = DB::table('users')->get();
- получить доступ к значению каждого столбца
$users = DB::table('users')->get();
foreach ($users as $user) {echo $user->name;}
- получить одну строку или один столбец
$user = DB::table('users')->where('name', 'John')->first();
return $user->email;
либо если строки может не быть
$user = DB::table('users')->where('name', 'John')->firstOrFail();
- получить одно значение из строки
$email = DB::table('users')->where('name', 'John')->value('email');
- получить одну строку по значению столбца id
$user = DB::table('users')->find(3);
- получить значения одного столбца в виде коллекции
use Illuminate\Support\Facades\DB;
$titles = DB::table('users')->pluck('title');
foreach ($titles as $title) {echo $title;}
- получить значения одного столбца в виде коллекции с ключами из столбца name
$titles = DB::table('users')->pluck('title', 'name');
foreach ($titles as $name => $title) {echo $title;}
- извлекать данные частями
DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
  foreach ($users as $user) { }
});
- остановить обработку после получения части данных
DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    return false;
});
- при изменении данных одновременно с получением по частям
DB::table('users')->where('active', false)->chunkById(100, function (Collection $users) {
  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['active' => true]);}
});
- сгруппировать логически условия запроса
DB::table('users')->where(function ($query) {$query->where('credits', 1)->orWhere('credits', 2);
})->chunkById(100, function (Collection $users) {
  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['credits' => 3]);}
});
- метод lazy() возвращает данные по частям в виде экземпляра LazyCollection
DB::table('users')->orderBy('id')->lazy()->each(function (object $user) { });
- при изменении данных одновременно с получением по частям использовать методы lazyById или lazyByIdDesc
DB::table('users')->where('active', false)->lazyById()->each(function (object $user) {
  DB::table('users')->where('id', $user->id)->update(['active' => true]);
});
- построитель запросов также содержит методы count, max, min, avg, и sum
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');
либо
$price = DB::table('orders')->where('finalized', 1)->avg('price');
- проверить существование записей
if (DB::table('orders')->where('finalized', 1)->exists()) { }
if (DB::table('orders')->where('finalized', 1)->doesntExist()) { }
- указать собственное выражение SELECT для запроса
$users = DB::table('users')->select('name', 'email as user_email')->get();
- вернуть уникальные результаты
$users = DB::table('users')->distinct()->get();
- добавить столбец к существующему выражению SELECT
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();
- cырые sql-выражения
$users = DB::table('users')->select(DB::raw('count(*) as user_count, status'))
  ->where('status', '<>', 1)->groupBy('status')->get();
$orders = DB::table('orders')->selectRaw('price * ? as price_with_tax', [1.0825])->get();
$orders = DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 100)', [200])->get();
$orders = DB::table('orders')->select('department', DB::raw('SUM(price) as total_sales'))
  ->groupBy('department')->havingRaw('SUM(price) > ?', [2500])->get();
$orders = DB::table('orders')->orderByRaw('updated_at - created_at DESC')->get();
$orders = DB::table('orders')->select('city', 'state')->groupByRaw('city, state')->get();
$users = DB::table('users')->join('contacts', 'users.id', '=', 'contacts.user_id')
  ->join('orders', 'users.id', '=', 'orders.user_id')
  ->select('users.*', 'contacts.phone', 'orders.price')->get();
$users = DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')->get();
$users = DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')->get();
$sizes = DB::table('sizes')->crossJoin('colors')->get();
DB::table('users')->join('contacts', function (JoinClause $join) {
  $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
})->get();
DB::table('users')->join('contacts', function (JoinClause $join) {
  $join->on('users.id', '=', 'contacts.user_id')->where('contacts.user_id', '>', 5);
})->get();
- присоединить запрос к подзапросу
$latestPosts = DB::table('posts')->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)->groupBy('user_id');
$users = DB::table('users')->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {
  $join->on('users.id', '=', 'latest_posts.user_id');
})->get();
- боковые соединения с подзапросом
// получить коллекцию пользователей, а также три последних блог-поста пользователя
$latestPosts = DB::table('posts')
  ->select('id as post_id', 'title as post_title', 'created_at as post_created_at')
  ->whereColumn('user_id', 'users.id')->orderBy('created_at', 'desc')->limit(3);
$users = DB::table('users')->joinLateral($latestPosts, 'latest_posts')->get();
- объединение двух или более запросов Unions
$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first)->get();
// запросы, объединенные с использованием метода unionAll, не будут удалять повторяющиеся результаты
$users = DB::table('users')->where('votes', '=', 100)->where('age', '>', 35)->get();
либо
$users = DB::table('users')->where('votes', 100)->get();
либо
$users = DB::table('users')->where('votes', '>=', 100)->get();
$users = DB::table('users')->where('votes', '<>', 100)->get();
$users = DB::table('users')->where('name', 'like', 'T%')->get();
либо
$users = DB::table('users')->where([
  ['status', '=', '1'],
  ['subscribed', '<>', '1'],
])->get();
- метод orWhere для добавления к запросу с помощью оператора OR
$users = DB::table('users')->where('votes', '>', 100)->orWhere('name', 'John')->get();
либо
$users = DB::table('users')->where('votes', '>', 100)->orWhere(function (Builder $query) {
  $query->where('name', 'Abigail')->where('votes', '>', 50);})->get();
// сформирует запрос: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)
- методы whereNot и orWhereNot могут использоваться для отрицания заданной группы ограничений запроса
$products = DB::table('products')->whereNot(function (Builder $query) {
  $query->where('clearance', true)->orWhere('price', '<', 10);})->get();
- выбрать все записи, где хотя бы один столбец из списка соответствует определенному значению
$users = DB::table('users')->where('active', true)
  ->whereAny(['name', 'email', 'phone'],'like', 'Example%')->get();
// сформирует запрос: 
SELECT * FROM users
WHERE active = true AND (name LIKE 'Example%' OR email LIKE 'Example%' OR phone LIKE 'Example%')
- извлечение записей, где все указанные столбцы соответствуют заданному условию
$posts = DB::table('posts')->where('published', true)
  ->whereAll(['title', 'content'], 'like', '%Laravel%')->get();
// сформирует запрос:
SELECT * FROM posts
WHERE published = true AND (title LIKE '%Laravel%' AND content LIKE '%Laravel%')
- извлечения записей, в которых ни один из заданных столбцов не соответствует заданному ограничению
$posts = DB::table('albums')->where('published', true)
  ->whereNone(['title', 'lyrics', 'tags'], 'like', '%explicit%')->get();
// сформирует запрос:
SELECT * FROM albums
WHERE published = true
AND NOT ( title LIKE '%explicit%' OR lyrics LIKE '%explicit%' OR tags LIKE '%explicit%')
- запрос к столбцу типа JSON
$users = DB::table('users')->where('preferences->dining->meal', 'salad')->get();
- запрос массивов JSON
$users = DB::table('users')->whereJsonContains('options->languages', 'en')->get();
либо
$users = DB::table('users')->whereJsonContains('options->languages', ['en', 'de'])->get();
- длина массива JSON
$users = DB::table('users')->whereJsonLength('options->languages', 0)->get();
$users = DB::table('users')->whereJsonLength('options->languages', '>', 1)->get();
- сопоставления с образцом
$users = DB::table('users')->whereLike('name', '%John%')->get();
- включить поиск с учетом регистра
$users = DB::table('users')->whereLike('name', '%John%', caseSensitive: true)->get();
- or с условием LIKE
$users = DB::table('users')->where('votes', '>', 100)->orWhereLike('name', '%John%')->get();
- не такой как образец
$users = DB::table('users')->whereNotLike('name', '%John%')->get();
- or с условием NOT LIKE
$users = DB::table('users')->where('votes', '>', 100)->orWhereNotLike('name', '%John%')->get();
- значение переданного столбца содержится в указанном массиве
$users = DB::table('users')->whereIn('id', [1, 2, 3])->get();
- значение переданного столбца не содержится в указанном массиве
$users = DB::table('users')->whereNotIn('id', [1, 2, 3])->get();
- объект запроса как аргумент
$activeUsers = DB::table('users')->select('id')->where('is_active', 1);
$users = DB::table('comments')->whereIn('user_id', $activeUsers)->get();
// сформирует запрос
select * from comments where user_id in (select id from users where is_active = 1)
- проверяет, что значение столбца находится между двумя значениями
$users = DB::table('users')->whereBetween('votes', [1, 100])->get();
- проверяет, что значение столбца находится за пределами двух значений
$users = DB::table('users')->whereNotBetween('votes', [1, 100])->get();
- проверяет, что значение столбца находится между двумя значениями двух столбцов в одной строке таблицы
$patients = DB::table('patients')
  ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();
- проверяет, что значение столбца находится за пределами двух значений двух столбцов в одной строке таблицы
$patients = DB::table('patients')
  ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();
- проверяет, что значение переданного столбца равно NULL
$users = DB::table('users')->whereNull('updated_at')->get();
- проверяет, что значение переданного столбца не равно NULL
$users = DB::table('users')->whereNotNull('updated_at')->get();
- сравнение значения столбца с датой
$users = DB::table('users')->whereDate('created_at', '2016-12-31')->get();
- сравнение значения столбца с конкретным месяцем
$users = DB::table('users')->whereMonth('created_at', '12')->get();
- сравнение значения столбца с определенным днем месяца
$users = DB::table('users')->whereDay('created_at', '31')->get();
- сравнение значения столбца с конкретным годом
$users = DB::table('users')->whereYear('created_at', '2016')->get();
- сравнение значения столбца с определенным временем
$users = DB::table('users')->whereTime('created_at', '=', '11:20:45')->get();
- проверка равенства двух столбцов
$users = DB::table('users')->whereColumn('first_name', 'last_name')->get();
либо
$users = DB::table('users')->whereColumn('updated_at', '>', 'created_at')->get();
либо
$users = DB::table('users')->whereColumn([
  ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at']])->get();
- всегда группировать вызовы метода orWhere в круглых скобках
$users = DB::table('users')->where('name', '=', 'John')->where(function (Builder $query) {
  $query->where('votes', '>', 100)->orWhere('title', '=', 'Admin');})->get();
// сформирует запрос
select * from users where name = 'John' and (votes > 100 or title = 'Admin')
- WHERE EXISTS
$users = DB::table('users')->whereExists(function (Builder $query) {
  $query->select(DB::raw(1))->from('orders')->whereColumn('orders.user_id', 'users.id');
})->get();
либо
$orders = DB::table('orders')->select(DB::raw(1))->whereColumn('orders.user_id', 'users.id');
$users = DB::table('users')->whereExists($orders)->get();
// в обоих случаях получим
select * from users where exists (select 1 from orders where orders.user_id = users.id)
- сравнивает результаты подзапроса с переданным значением
$users = User::where(function (Builder $query) {
  $query->select('type')->from('membership')->whereColumn('membership.user_id', 'users.id')
    ->orderByDesc('membership.start_date')->limit(1);}, 'Pro')->get();
- сравнивает столбец с результатами подзапроса
$incomes = Income::where('amount', '<', function (Builder $query) {
  $query->selectRaw('avg(i.amount)')->from('incomes as i');})->get();
- whereFullText и orWhereFullText добавят полнотекстовые “условия” в запрос для столбцов, имеющих полнотекстовые индексы
$users = DB::table('users')->whereFullText('bio', 'web developer')->get();
- сортировать результаты запроса по конкретному столбцу
$users = DB::table('users')->orderBy('name', 'desc')->get();
либо
$users = DB::table('users')->orderBy('name', 'desc')->orderBy('email', 'asc')->get();
- latest и oldest: упорядочить результаты по дате, по умолчанию по столбцу created_at, либо указать столбец сортировки
$user = DB::table('users')->latest()->first();
- сортировка результатов запроса в случайном порядке
$randomUser = DB::table('users')->inRandomOrder()->first();
- Метод reorder удаляет все примененые выражения ORDER BY
$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();
- удалить все существующие выражения ORDER BY и применить к запросу совершенно новый порядок
$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();
- группировка результатов запроса
$users = DB::table('users')->groupBy('account_id')->having('account_id', '>', 100)->get();
- фильтрация результатов в заданном диапазоне
$report = DB::table('orders')->selectRaw('count(id) as number_of_orders, customer_id')
  ->groupBy('customer_id')->havingBetween('number_of_orders', [5, 15])->get();
- группировка по нескольким столбцам
$users = DB::table('users')->groupBy('first_name', 'status')->having('account_id', '>', 100)->get();
- take: ограничить количество результатов, возвращаемых запросом
- skip: пропустить указанное количество результатов из запроса
$users = DB::table('users')->skip(10)->take(5)->get();
либо limit и offset
$users = DB::table('users')->offset(10)->limit(5)->get();
- применить выражение при условии: when выполняет переданную функцию если первый аргумент равен true
$role = $request->input('role');
$users = DB::table('users')->when($role, function (Builder $query, string $role) {
  $query->where('role_id', $role);})->get();
- второя переданная when функция будет выполнена если первый аргумент равен false
$sortByVotes = $request->boolean('sort_by_votes');
$users = DB::table('users')->when($sortByVotes, function (Builder $query, bool $sortByVotes) {
  $query->orderBy('votes');}, function (Builder $query) {$query->orderBy('name');})->get();
- вставка записей в таблицу БД
DB::table('users')->insert(['email' => 'kayla@example.com', 'votes' => 0]);
- каждый из массивов это запись, которую нужно вставить в таблицу
DB::table('users')->insert([
  ['email' => 'picard@example.com', 'votes' => 0],
  ['email' => 'janeway@example.com', 'votes' => 0],
]);
- игнорировать ошибки при вставке записей в базу данных
DB::table('users')->insertOrIgnore([
  ['id' => 1, 'email' => 'sisko@example.com'],
  ['id' => 2, 'email' => 'archer@example.com'],
]);
- вставляет новые записи в таблицу, используя подзапрос
DB::table('pruned_users')->insertUsing(['id', 'name', 'email', 'email_verified_at'],
DB::table('users')->select('id', 'name', 'email', 'email_verified_at')
->where('updated_at', '<=', now()->subMonth()));
- вставить запись и затем получить идентификатор этой записи
$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);
- вставляет записи, которые не существуют, и обновляет записи, которые уже существуют, новыми значениями<br>
- попытается вставить две записи. Если запись уже существует с такими же значениями столбцов departure и destination, то обновит столбец price этой записи<br>
DB::table('flights')->upsert([
  ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
  ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
], ['departure', 'destination'], ['price']);
- обновить существующие записи
$affected = DB::table('users')->where('id', 1)->update(['votes' => 1]);
- Если запись существует, она будет обновлена значениями второго аргумента.<br>
- Если запись не может быть найдена, будет вставлена новая запись с объединенными атрибутами обоих аргументов<br>
DB::table('users')->updateOrInsert(['email' => 'john@example.com', 'name' => 'John'], ['votes' => '2']);
либо через условие
DB::table('users')->updateOrInsert(['user_id' => $user_id],fn ($exists) => $exists 
  ? ['name' => $data['name'],'email' => $data['email']]
  : ['name' => $data['name'], 'email' => $data['email'], 'marketable' => true]);
- обновление столбца JSON
$affected = DB::table('users')->where('id', 1)->update(['options->enabled' => true]);
- методы увеличения или уменьшения значения конкретного столбца
DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes', 5);
либо
DB::table('users')->increment('votes', 1, ['name' => 'John']);
- увеличивать или уменьшать значения нескольких столбцов с помощью методов incrementEach и decrementEach
DB::table('users')->incrementEach(['votes' => 5, 'balance' => 100]);
- удалить записи из таблицы
$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();
- удаление всех записей из таблицы и сброс автоинкрементного идентификатора на ноль
DB::table('users')->truncate();
- предотвратить изменение выбранных строк до тех пор, пока транзакция не будет зафиксирована
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
- предотвращает изменение выбранных записей
DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();
- отобразить связанные параметры запроса и сам SQL-запрос
DB::table('users')->where('votes', '>', 100)->dd();
DB::table('users')->where('votes', '>', 100)->dump();
либо
DB::table('users')->where('votes', '>', 100)->dumpRawSql();
DB::table('users')->where('votes', '>', 100)->ddRawSql();
</code></pre></details><details> <summary>Collections</summary><a href="http://github.com/Mezuno/laravel-collections-doc">Collections</a><p>коллекции - это итераторы, которые можно перебирать как массив</p><pre><code>use App\Models\User;
$users = User::where('active', 1)->get();
foreach ($users as $user) {echo $user->name;}
- коллекции поддерживают map и reduce
$names = User::all()->reject(function (User $user) {return $user->active === false;})
  ->map(function (User $user) {return $user->name;});</code></pre><p>- все коллекции Eloquent расширяют базовый класс коллекций Laravel<br>
- методы collapse, flatten, flip, keys, pluck, и zip возвращают экземпляр базовой коллекции<br>
- коллекции Eloquent наследуют все методы класса базовой коллекции и содержит расширенный набор методов<br></p><pre><code>$users->append('team');   // указать, что атрибут должен быть добавлен к каждой записи в коллекции
либо
$users->append(['team', 'is_admin']);
$users->contains(1);    // содержится ли запись в коллекции
либо
$users->contains(User::find(1));
$users = $users->diff(User::whereIn('id', [1, 2, 3])->get());   // возвращает все записи, которых нет в переданной коллекции
$users = $users->except([1, 2, 3]);   // озвращает все записи, у которых нет указанных первичных ключей
$users = User::all();   // возвращает запись по указанному ключу
$user = $users->find(1);
$users = User::all();   // возвращает запись по указанному ключу или исключение
$user = $users->findOrFail(1);
$users = $users->fresh();   // возвращает обновлённые записи
$users = $users->fresh('comments');   // возвращает обновлённые записи с отношением
$users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());  // возвращает записи, которые присутствуют в указанной коллекции
$users->load(['comments', 'posts']);    // загружает указанные отношения для всех записей в коллекции
$users->load('comments.author');
$users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
$users->loadMissing(['comments', 'posts']);   // загружает ещё незагруженные отношения для всех записей в коллекции
$users->loadMissing('comments.author');
$users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
$users->modelKeys();    // возвращает первичные ключи для всех записей в коллекции [1, 2, 3, 4, 5]
$users = $users->makeVisible(['address', 'phone_number']);    // делает видимыми скрытые атрибуты записей из коллекции
$users = $users->makeHidden(['address', 'phone_number']);   // делает скрытыми атрибуты записей из коллекции
$users = $users->only([1, 2, 3]);   // возвращает все записи с указанными первичными ключами
$users = $users->setVisible(['id', 'name']);    // временно переопределяет видимые атрибуты для каждой записи в коллекции
// временно переопределяет скрытые атрибуты для каждой записи в коллекции
$users = $users->setHidden(['email', 'password', 'remember_token']);
// возвращает экземпляр построителя запросов
use App\Models\User;
$users = User::where('status', 'VIP')->get();
$users->toQuery()->update(['status' => 'Administrator']);
// возвращает уникальные записи в коллекции
$users = $users->unique();
- удаления записей из полученной коллекции
$flights = Flight::where('destination', 'Paris')->get();
$flights = $flights->reject(function (Flight $flight) {return $flight->cancelled;});
- перебирать коллекции
foreach ($flights as $flight) {echo $flight->name;}
- получать коллекцию записей частями
use App\Models\Flight;
use Illuminate\Database\Eloquent\Collection;
// 200 - количество записей за «порцию» к каждой порции применяется function (Collection $flights) {}
Flight::chunk(200, function (Collection $flights) {foreach ($flights as $flight) { }});
// извлекать записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
Flight::where('departed', true)->chunkById(200, function (Collection $flights) {
  $flights->each->update(['departed' => false]);}, column: 'id');
// логическая группировка в запросе
Flight::where(function ($query) {$query->where('delayed', true)->orWhere('cancelled', true);})
  ->chunkById(200, function (Collection $flights) {
  $flights->each->update(['departed' => false, 'cancelled' => true]);}, column: 'id');
- lazy() возвращает каждую порцию записей как отдельную коллекцию
foreach (Flight::lazy() as $flight) { }
// lazyById извлекает записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
Flight::where('departed', true)->lazyById(200, column: 'id')->each->update(['departed' => false]);
// lazyByIdDesc - отфильтровать результаты по убыванию id
- при использовании cursor будет только один запрос к БД и только одна модель хранится в памяти в любой момент времени при итерации
foreach (Flight::where('destination', 'Zurich')->cursor() as $flight) { }
либо
$users = User::cursor()->filter(function (User $user) {return $user->id > 500;});
foreach ($users as $user) {echo $user->id;}
- извлечь информацию из связанных таблиц в одном запросе
// выбрал все пункты назначения и рейсы, которые прибыли последними в этот пункт назначения
use App\Models\Destination;
use App\Models\Flight;
return Destination::addSelect(['last_flight' => Flight::select('name')->whereColumn('destination_id', 'destinations.id')
  ->orderByDesc('arrived_at')->limit(1)])->get();
// отсортировал пункты назначения по последнему рейсу
return Destination::orderByDesc(Flight::select('arrived_at')->whereColumn('destination_id', 'destinations.id')
  ->orderByDesc('arrived_at')->limit(1))->get();
- использовать собственный объект Collection
namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Attributes\CollectedBy;
use Illuminate\Database\Eloquent\Model;
<CollectedBy UserCollection::class></CollectedBy>
class User extends Model { }
// либо
namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
class User extends Model {
  public function newCollection(array $models = []): Collection
  {return new UserCollection($models);}}</code></pre><p>в App\Providers\AppServiceProvider</p><pre><code>- определить макрос
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
public function boot(): void {
  Collection::macro('toUpper', function () {
    return $this->map(function (string $value) {return Str::upper($value);});});
// вызвать макрос в любом месте приложения
$collection = collect(['first', 'second']);
$upper = $collection->toUpper();
либо с дополнительными аргументами
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Lang;
Collection::macro('toLocale', function (string $locale) {
  return $this->map(function (string $value) use ($locale) {
    return Lang::get($value, [], $locale);});});
// вызвать макрос в любом месте приложения
$collection = collect(['first', 'second']);
$translated = $collection->toLocale('es');</code></pre><p>Класс Illuminate\Support\Collection обеспечивает гибкую и удобную обертку для работы с массивами данных</p><pre><code>- создать новый экземпляр коллекции из массива
$collection = collect(['taylor', 'abigail', null])->map(function (?string $name) {
  return strtoupper($name);})->reject(function (string $name) {return empty($name);});
- создать коллекцию
$collection = collect([1, 2, 3]);</code></pre><p>Сообщения высшего порядка - сокращения для выполнения действий с коллекциями<br>
average, avg, contains, each, every, filter, first, flatMap, groupBy, keyBy, map, max, min, partition,
reject, skipUntil, skipWhile, some, sortBy, sortByDesc, sum, takeUntil, takeWhile, unique</p><pre><code>- вызывать метод для каждого объекта коллекции
use App\Models\User;
$users = User::where('votes', '>', 500)->get();
$users->each->markAsVip();
- собрать общее количество «голосов» для коллекции пользователей
$users = User::where('group', 'Development')->get();
return $users->sum->votes;</code></pre><p>Отложенные коллекции использует генераторы PHP, чтобы работать с очень большим набором данных при низком потреблении памяти</p><pre> <code>- отложенные коллекции сохраняют в памяти только небольшую часть файла в текущий момент
use App\Models\LogEntry;
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {yield $line;}
})->chunk(4)->map(function (array $lines) {return LogEntry::fromLines($lines);
})->each(function (LogEntry $logEntry) { // Обработка записи журнала...});
- cursor возвращает LazyCollection: в течении одиного запроса к БД, модели Eloquent загружать в память и обрабатывать по одной
use App\Models\User;
$users = User::cursor()->filter(function (User $user) {return $user->id > 500;});
foreach ($users as $user) {echo $user->id;}
- создать экземпляр отложенной коллекции
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {yield $line;}});</code></pre><p>Класс Collection и класс LazyCollection реализуют контракт Illuminate\Support\Enumerable, который определяет методы:</p><a href="https://laravel.su/docs/12.x/collections#kontrakt-enumerable">методы доступные в классе Collection и LazyCollection</a><pre><code>- дополнительно класс LazyCollection содержит методы:
- takeUntilTimeout - коллекция перечисляет значения до указанного времени
$lazyCollection = LazyCollection::times(INF)->takeUntilTimeout(now()->addMinute());
$lazyCollection->each(function (int $number) {
  dump($number);
  sleep(1);});
либо запланировать отправку счетов из БД, которая запускается каждые 15 минут и обрабатывает счета максимум 14 минут
use App\Models\Invoice;
use Illuminate\Support\Carbon;
Invoice::pending()->cursor()->takeUntilTimeout(
  Carbon::createFromTimestamp(LARAVEL_START)->add(14, 'minutes'))->each(fn (Invoice $invoice) => $invoice->submit());
- tapEach вызывает переданное замыкание только тогда, когда элементы извлекаются из списка один за другим
$lazyCollection = LazyCollection::times(INF)->tapEach(function (int $value) {dump($value);});   // ничего не выведено
$array = $lazyCollection->take(3)->all();   // три элемента выведено
- throttle: каждое значение возвращается через указанное количество секунд
use App\Models\User;
User::where('vip', true)->cursor()->throttle(seconds: 1)->each(function (User $user) { // Вызов внешнего API... });
- remember запоминает любые значения, которые уже были перечислены, и не будет извлекать их снова
$users = User::cursor()->remember();    // запрос еще не выполнен
$users->take(5)->all();   // первые 5 пользователей из БД включены в результирующую коллекцию
$users->take(20)->all();    // первые 5 пользователей из кеша коллекции, а стальные из БД включены в результирующую коллекцию
</code></pre></details><details> <summary>Eloquent ORM</summary><p>Eloquent ORM - это реализация Active Record для работы с БД с помощью PHP-кода, SQL-запросов, миграций, сидов, фабрик и отношений<br></p><details><summary>Модели</summary><p>models - классы моделей Eloquent для взаимодействия с таблицами БД методами построителя запросов<br>
Eloquent будет предполагать, что модель Flight хранит записи в таблице flights<br>
а модель AirTrafficController – в таблице air_traffic_controllers</p><pre><code>- создать модель
php artisan make:model Flight
// + миграцию
php artisan make:model Flight --migration
php artisan make:model Flight -m
// + фабрику FlightFactory...
php artisan make:model Flight --factory
php artisan make:model Flight -f
// + наполнитель FlightSeeder...
php artisan make:model Flight --seed
php artisan make:model Flight -s
// + контроллер FlightController...
php artisan make:model Flight --controller
php artisan make:model Flight -c
// + контроллер, ресурс и запрос
php artisan make:model Flight --controller --resource --requests
php artisan make:model Flight -crR
// + политика FlightPolicy
php artisan make:model Flight --policy
// + миграция, фабрика, наполнитель и контроллер
php artisan make:model Flight -mfsc
// в полном комплекте (Model, Migration, Factory, Seeder, Request, Controller, Policy)
php artisan make:model Flight --all
php artisan make:model Flight -a
// без миграции
php artisan make:model Flight -cfs --policy
// при типе связи $this->belongsToMany() создать сводную модель
php artisan make:model Flight --pivot
php artisan make:model Flight -p
// помощь по созданию модели
php artisan help make:model
// обзор всех атрибутов и отношений модели
php artisan model:show Flight
// содажимое БД
php artisan db:show
php artisan db:table users
// содажимое таблицы БД
php artisan tinker
User::all();
php artisan make:scope AncientScope    // сгенерировать новый глобальный диапазон в app/Models/Scopes</code></pre><p>в файле routes/console.php</p><pre><code>php artisan model:prune   // удаления записей
code php artisan model:prune --pretend    // сколько записей будет удалено при выполнении чистки</code></pre><p>в App\Providers\AppServiceProvider.php</p><pre><code>public function boot(): void {Model::unguard();}    // не указывать fillable в моделях, модели без защиты
// генерировать исключение при попытке заполнения значением неподлежащего заполнению атрибута
Model::preventSilentlyDiscardingAttributes($this->app->isLocal());
// генерировать исключение при попытке назначить значение неподлежащего назначению атрибута
Model::preventSilentlyDiscardingAttributes(! $this->app->isProduction());
// запретить отложенную загрузку
Model::preventLazyLoading(! $this->app->isProduction());</code></pre><p>в App\Http\Controllers</p><pre><code>- вставить новую запись
class FlightController extends Controller
{
  // Сохранить новый рейс в базе данных
  public function store(Request $request): RedirectResponse {
    // тут провести валидацию запроса
    $flight = new Flight;   // создать экземпляр модели
    $flight->name = $request->name;   // установить атрибуты модели
    $flight->save();    // сохранить запись (экземпляр модели)
    return redirect('/flights');
  }}
либо
// при свойстве fillable или guarded в классе модели
$flight = Flight::create(['name' => 'London to Paris']);
- выполнять операцию с моделью, не изменяя ее метку времени в updated_at
Model::withoutTimestamps(fn () => $post->increment('reads'));
- получить все записи из связанной с моделью таблицы БД
foreach (Flight::all() as $flight) {echo $flight->name;}
- построить запрос с дополнительными условиями
$flights = Flight::where('active', 1)->orderBy('name')->take(10)->get();
- повторно извлечь модель из БД
$flight = Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh();
- повторно обновить существующую модель
$flight = Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"
- получить запись
$flight = Flight::find(1);    // по ее первичному ключу
$flight = Flight::where('active', 1)->first();    // первую соответствующую условиям запроса
либо
$flight = Flight::firstWhere('active', 1);
- если запись не найдена, то вернуть функцию
$flight = Flight::findOr(1, function () {});
$flight = Flight::where('legs', '>', 3)->firstOr(function () {});
- если запись не найдена, то вернуть исключение
$flight = Flight::findOrFail(1);
$flight = Flight::where('legs', '>', 3)->firstOrFail();
либо
Route::get('/api/flights/{id}', function (string $id) {return Flight::findOrFail($id);});
- если запись не найдена, то создать новую
$flight = Flight::firstOrCreate(['name' => 'London to Paris']);   // получить запись по `name` или создать
либо
$flight = Flight::firstOrNew(['name' => 'London to Paris']);
// получить запись по `name` или создать с атрибутами `name`,` delayed` и `arrival_time`
$flight = Flight::firstOrCreate(['name' => 'London to Paris'], ['delayed' => 1, 'arrival_time' => '11:30']);
либо
$flight = Flight::firstOrNew(['name' => 'Tokyo to Sydney'], ['delayed' => 1, 'arrival_time' => '11:30']);
$flight->save()   // сохраненить вручную
- возвращают соответствующее скалярное значение вместо экземпляра модели
$count = Flight::where('active', 1)->count();
$max = Flight::where('active', 1)->max('price');
- обновить запись
$flight = Flight::find(1);
$flight->name = 'Paris to London';
$flight->save();
- обновить или создать новую запись
$flight = Flight::updateOrCreate(['departure' => 'Oakland', 'destination' => 'San Diego'], ['price' => 99, 'discounted' => 1]);
- все рейсы с пунктом назначения в Сан-Диего, будут помечены как задержанные
Flight::where('active', 1)->where('destination', 'San Diego')->update(['delayed' => 1]);  // update возвращает количество затронутых строк
- обновление или создание записей за одну операцию
Flight::upsert([    // столбцы второго аргумента должны иметь “primary” или “unique” индекс
    ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
    ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
], uniqueBy: ['departure', 'destination'], update: ['price']);
- изменения атрибутов
$user = User::create(['first_name' => 'Taylor', 'last_name' => 'Otwell', 'title' => 'Developer']);
$user->title = 'Painter';
$user->save();
// было ли изменение с момента получения модели
$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false
$user->isDirty(['first_name', 'title']); // true
// остался ли атрибут неизменным с момента получения модели
$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true
$user->isClean(['first_name', 'title']); // false
$user->isDirty(); // false
$user->isClean(); // true
// были ли изменены какие-либо атрибуты при последнем сохранении модели в текущем цикле запроса
$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged(['title', 'slug']); // true
$user->wasChanged('first_name'); // false
$user->wasChanged(['first_name', 'title']); // true
// возвращает массив, содержащий исходные атрибуты модели
$user = User::find(1);
$user->name; // John
$user->email; // john@example.com
$user->name = "Jack";
$user->name; // Jack
$user->getOriginal('name'); // John
$user->getOriginal(); // массив исходных атрибутов
- удалить запись
$flight = Flight::find(1);
$flight->delete();
- удалить все записи таблицы
Flight::truncate();
- удаление записи по ключу
Flight::destroy(1);
Flight::destroy(1, 2, 3);
Flight::destroy([1, 2, 3]);
Flight::destroy(collect([1, 2, 3]));
- удаление записи через запрос с условием
$deleted = Flight::where('active', 0)->delete();
- была ли данная запись программно удалена
if ($flight->trashed()) { }
- восстановить программно удаленную запись
$flight->restore();
либо
Flight::withTrashed()->where('airline_id', 1)->restore();
либо
$flight->history()->restore();  
- окончательно удалить запись
Flight::forceDestroy(1);
либо
$flight->forceDelete();
либо
$flight->history()->forceDelete();
- отобразить программно удаленные записи в результате запроса
$flights = Flight::withTrashed()->where('account_id', 1)->get();
либо
$flight->history()->withTrashed()->get();
- отобразить только программно удаленные записи
$flights = Flight::onlyTrashed()->where('airline_id', 1)->get();</code></pre><p>в App\Models</p><pre><code>- указать имя таблицы модели вручную
class Flight extends Model {protected $table = 'my_flights';}
- все атрибуты массово-заполняемые, модель без защиты
protected $guarded = [];
- определить массово-заполняемые атрибуты модели
protected $fillable = ['name'];
- для JSON-столбцов необходимо указать массово назначаемый ключ для каждого столбца
protected $fillable = ['options->enabled'];
// вернёт новую запись
$flight = Flight::create(['name' => 'London to Paris']);
// заполнить запись атрибутами
$flight->fill(['name' => 'Amsterdam to Frankfurt']);
- указать связи
class Employer extends Model
{
  use HasFactory;
  public function user(): BelongsTo {return $this->belongsTo(User::class);}
  public function jobs(): HasMany {return $this->hasMany(Job::class);}
}
- указать первичным ключом не id столбец
protected $primaryKey = 'flight_id';
- первичный ключ неинкрементный
public $incrementing = false;
- первичный ключ не целочисленный
protected $keyType = 'string';
<span>
- «Составные» первичные ключи не поддерживаются, можно добавить дополнительные многоколоночные уникальные индексы вместе с первичным ключем таблицы<br>
- UUID – уникальные буквенно-цифровые идентификаторы длиной 36 символов<br>
- использовать ключ UUID вместо автоинкрементного целочисленного ключа<br>
(у таблицы должен быть столбец UUID,т.е. $table->uuid('id'); в миграции)<br>
</span>
use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Model;
class Article extends Model {use HasUuids;}
// применить в контроллере
$article = Article::create(['title' => 'Traveling to Europe']);
$article->id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"
- переопределить процесс генерации UUID
use Ramsey\Uuid\Uuid;
public function newUniqueId(): string {return (string) Uuid::uuid4();}
public function uniqueIds(): array {return ['id', 'discount_code'];}
- ULID имеют длину 26 символов (у таблицы должен быть столбец ULID,т.е. $table->ulid('id'); в миграции)
use Illuminate\Database\Eloquent\Concerns\HasUlids;
use Illuminate\Database\Eloquent\Model;
class Article extends Model {use HasUlids;}
// применить в контроллере
$article = Article::create(['title' => 'Traveling to Asia']);
$article->id; // "01gd4d3tgrrfqeda94gdbtdk5c"
- устанавливать значения столбцов created_at и updated_at вручную
public $timestamps = false;
- задать формат хранения даты в БД и сериализации модели в массив или JSON
protected $dateFormat = 'U';
- указать имена столбцов хранения временных меток
class Flight extends Model
{
  const CREATED_AT = 'creation_date';
  const UPDATED_AT = 'updated_date';
}
- указать соединение с БД не по умолчанию для отдельной модели
protected $connection = 'mysql';
- указать значения атрибутов по умолчанию
protected $attributes = [
  'options' => '[]',    // для JSON столбца
  'delayed' => false,
  'status' => 'draft',
  'view_count' => 0,
];
- программное удаление: фактически не удаляются из БД, а устанавливается атрибут deleted_at
use Illuminate\Database\Eloquent\SoftDeletes;
class Flight extends Model {use SoftDeletes;}
- добавить столбец deleted_at в таблицу БД
Schema::table('flights', function (Blueprint $table) {$table->softDeletes();});
Schema::table('flights', function (Blueprint $table) {$table->dropSoftDeletes();});
- удалять данные, которые больше не нужны
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Prunable;
class Flight extends Model
{
  use Prunable;
  // получите запрос для удаления устаревших записей модели
  public function prunable(): Builder
  {return static::where('created_at', '<=', now()->subMonth());}
}
- метод pruning для удаления любых дополнительных ресурсов, связанных с записью
protected function pruning(): void { }
Schedule::command('model:prune')->daily();    // автоматически проверять и чистить модели от старых записей в app/Models
Schedule::command('model:prune', ['--model' => [Address::class, Flight::class]])->daily();    // если не в app/Models
Schedule::command('model:prune', ['--except' => [Address::class, Flight::class],])->daily();    // чистить модели кроме указанных
- удаление записей с помощью запросов массового удаления
{
  use MassPrunable;
  public function prunable(): Builder
  {return static::where('created_at', '<=', now()->subMonth());}
}
- создать копию записи
$shipping = Address::create([
  'type' => 'shipping',
  'line_1' => '123 Example Street',
  'city' => 'Victorville',
  'state' => 'CA',
  'postcode' => '90001',
]);
$billing = $shipping->replicate()->fill(['type' => 'billing']);
$billing->save();
- создать копию записи без указанных атрибутов
$flight = Flight::create([
  'destination' => 'LAX',
  'origin' => 'LHR',
  'last_flown' => '2020-03-04 11:00:00',
  'last_pilot_id' => 747,
]);
$flight = $flight->replicate(['last_flown', 'last_pilot_id']);
- глобальные диапазоны позволяют добавлять ограничения ко всем запросам для конкретной модели
namespace App\Models\Scopes;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;
class AncientScope implements Scope
{
  // Применить диапазон к переданному построителю запросов
  public function apply(Builder $builder, Model $model): void
  {$builder->where('created_at', '<', now()->subYears(2000));}
}
// применить глобальный диапазон к модели
namespace App\Models;
use App\Models\Scopes\AncientScope;
use Illuminate\Database\Eloquent\Attributes\ScopedBy;
<ScopedBy [AncientScope::class]></ScopedBy>
class User extends Model { }
либо
namespace App\Models;
use App\Models\Scopes\AncientScope;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
  // Метод «booted» модели
  protected static function booted(): void
  {static::addGlobalScope(new AncientScope);}
}
// User::all() вернёт
select * from `users` where `created_at` < 0021-02-18 00:00:00
// создать глобальный диапозон без класса через функцию
class User extends Model {
  protected static function booted(): void {
    static::addGlobalScope('ancient', function (Builder $builder) {
      $builder->where('created_at', '<', now()->subYears(2000));
    });
  }}
// исключения глобального диапазона в текущем запросе
User::withoutGlobalScope(AncientScope::class)->get();
либо
User::withoutGlobalScope('ancient')->get();
либо
User::withoutGlobalScopes()->get();   // игнорировать все глобальные диапазоны
User::withoutGlobalScopes([FirstScope::class, SecondScope::class])->get();    // игнорировать некоторые глобальные диапазоны
- чтобы определить локальный диапазон - добавить к методу префикс scope
class User extends Model {
  // диапазон запроса, включающий только популярных пользователей
  public function scopePopular(Builder $query): void {$query->where('votes', '>', 100);}
  // диапазон запроса, включающий только активных пользователей
  public function scopeActive(Builder $query): void {$query->where('active', 1);}
  // диапазон запроса, включающий пользователей только определенного типа
  public function scopeOfType(Builder $query, string $type): void {$query->where('type', $type);}
}
// вызвать метод при выполнении запроса
use App\Models\User;
$users = User::popular()->active()->orderBy('created_at')->get();
либо
$users = User::popular()->orWhere(function (Builder $query) {$query->active();})->get();
либо
$users = User::popular()->orWhere->active()->get();
либо
$users = User::ofType('admin')->get();
- сравнение моделей
if ($post->is($anotherPost)) {}
if ($post->isNot($anotherPost)) {}
if ($post->author()->is($user)) {}    // сравнить связанную модель без запроса на получение этой модели
</code></pre></details><details> <summary>Accessors</summary><p>Аксессор преобразует значение столбца таблицы (атрибута модели) при обращении к нему.<br></p><pre><code>- аксессор для атрибута first_name
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
class User extends Model {
  protected function firstName(): Attribute {
    // конструктор класса Attribute
    return Attribute::make(get: fn (string $value) => ucfirst($value));   // способ доступа к атрибуту
  }}
// получить доступ к значению аксессора
use App\Models\User;
$user = User::find(1);
$firstName = $user->first_name;
- преобразовать несколько атрибутов модели в один “объект-значение” (value object)
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;
protected function address(): Attribute {
  return Attribute::make(
    get: fn (mixed $value, array $attributes) => new Address($attributes['address_line_one'], $attributes['address_line_two']),
  );}
// При возвращении объектов-значений из аксессоров любые изменения, внесенные в объект-значение, автоматически синхронизируются с моделью перед ее сохранением.
use App\Models\User;
$user = User::find(1);
$user->address->lineOne = 'Updated Address Line 1 Value';
$user->address->lineTwo = 'Updated Address Line 2 Value';
$user->save();
- включить кэширование для примитивных значений
protected function hash(): Attribute
{return Attribute::make(get: fn (string $value) => bcrypt(gzuncompress($value)))->shouldCache();}
// отключить кэширование для атрибутов
protected function address(): Attribute
{return Attribute::make(get: fn (mixed $value, array $attributes) => new Address(
  $attributes['address_line_one'], $attributes['address_line_two']))->withoutObjectCaching();
}
</code></pre></details><details> <summary>Mutators</summary><p>Мутатор преобразует значение атрибута в момент его присвоения экземпляру Eloquent.</p><pre><code>- мутатор для атрибута first_name
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
class User extends Model {
  {return Attribute::make(get: fn (string $value) => ucfirst($value), set: fn (string $value) => strtolower($value));}}
// использовать мутатор
use App\Models\User;
$user = User::find(1);
// мутатор применит к 'Sally' функцию strtolower и установит полученное значение во внутреннем массиве $attributes
$user->first_name = 'Sally';
- установить несколько атрибутов в модели
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;
protected function address(): Attribute
{return Attribute::make(
  get: fn (mixed $value, array $attributes) => new Address($attributes['address_line_one'], $attributes['address_line_two']),
  set: fn (Address $value) => ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo]);}
</code></pre></details><details> <summary>Typing</summary><a href="http://laravel.su/docs/12.x/eloquent-mutators#privedenie-atributov-k-tipam">Поддерживаемые типы преобразования</a><p>- Приведение атрибутов к типам обеспечивает функциональность, аналогичную аксессорам и мутаторам, но без необходимости определения каких-либо дополнительных методов модели.<br>
- Метод casts должен возвращать массив, где ключом является имя приводимого атрибута, а значением — тип, к которому нужно привести столбец.<br></p><pre><code>- привести атрибут is_admin из значения 0 или 1 к логическому типу
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model {protected function casts(): array {return ['is_admin' => 'boolean'];}}
// применение атрибута (базовое значение хранится в базе данных как целое число)
$user = App\Models\User::find(1);
if ($user->is_admin) { }
// добавить новое временное приведение во время выполнения
$user->mergeCasts(['is_admin' => 'integer', 'options' => 'object']);
- преобразование в строку
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\AsStringable;
class User extends Model {protected function casts(): array {return ['directory' => AsStringable::class];}}
- столбцы типа JSON или TEXT (содержащее сериализованный JSON) при типизации к array,
  автоматически десериализует атрибут модели Eloquent в массив PHP
class User extends Model {protected function casts(): array {return ['options' => 'array'];}}
// при назначении атрибута options, массив будет автоматически сериализован обратно в JSON для сохранения
use App\Models\User;
$user = User::find(1);
$options = $user->options;
$options['key'] = 'value';
$user->options = $options;
$user->save();
// обновить одно поле JSON-атрибута (разрешить массовое назначение)
$user = User::find(1);
$user->update(['options->key' => 'value']);
// преобразовать атрибут JSON в класс ArrayObject
use Illuminate\Database\Eloquent\Casts\AsArrayObject;
protected function casts(): array {return ['options' => AsArrayObject::class];}
// преобразовать атрибут JSON в экземпляр Laravel Collection
use Illuminate\Database\Eloquent\Casts\AsCollection;
protected function casts(): array {return ['options' => AsCollection::class];}
- создать экземпляр пользовательского класса коллекции вместо базового
use App\Collections\OptionCollection;
use Illuminate\Database\Eloquent\Casts\AsCollection;
protected function casts(): array
{return ['options' => AsCollection::using(OptionCollection::class)];}
- типизация даты
protected function casts(): array {return ['created_at' => 'datetime:Y-m-d'];}
// настроить формат сериализации по умолчанию
protected function serializeDate(DateTimeInterface $date): string
{return $date->format('Y-m-d');}
// столбцы created_at и updated_at всегда форматируются в формате UTC, независимо от настроек часового пояса приложения
// указать формат сохранения дат модели в базе данных
protected $dateFormat = 'U';
- Типизация "Enum"
- преобразовать значение атрибута в перечисление PHP
use App\Enums\ServerStatus;
protected function casts(): array {return ['status' => ServerStatus::class];}
// атрибут будет автоматически преобразован в перечисление и обратно
if ($server->status == ServerStatus::Provisioned) {
  $server->status = ServerStatus::Ready;
  $server->save();
}
- массив значений перечисления в одном столбце
use App\Enums\ServerStatus;
use Illuminate\Database\Eloquent\Casts\AsEnumCollection;
protected function casts(): array
{return ['statuses' => AsEnumCollection::of(ServerStatus::class)];}
- приведение encrypted зашифрует значение атрибута модели
// при изменении ключа в переменной окружения APP_KEY придется вручную повторно зашифровать зашифрованные атрибуты
- типизация во время запроса
use App\Models\Post;
use App\Models\User;
$users = User::select(['users.*', 'last_posted_at' => Post::selectRaw('MAX(created_at)')
  ->whereColumn('user_id', 'users.id')])->get();
// применить типизацию datetime к last_posted_at при выполнении запроса
$users = User::select(['users.*', 'last_posted_at' => Post::selectRaw('MAX(created_at)')
  ->whereColumn('user_id', 'users.id')])->withCasts(['last_posted_at' => 'datetime'])->get();</code></pre><p>создать свой преобразователь типов</p><pre><code>php artisan make:cast Json
// get - преобразует “сырое” значения из БД к типизированному значению
// set – преобразует типизированное значение в “сырое” значение, которое можно сохранить в базе данных
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
use Illuminate\Database\Eloquent\Model;
class Json implements CastsAttributes {
  public function get(Model $model, string $key, mixed $value, array $attributes): array
  {return json_decode($value, true);}
  public function set(Model $model, string $key, mixed $value, array $attributes): string
  {return json_encode($value);}}
// применение
namespace App\Models;
use App\Casts\Json;
use Illuminate\Database\Eloquent\Model;
class User extends Model {protected function casts(): array {return ['options' => Json::class];}}
// преобразовать значения к объектам - set возвращает массив пар ключ / значение
namespace App\Casts;
use App\ValueObjects\Address as AddressValueObject;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
use Illuminate\Database\Eloquent\Model;
use InvalidArgumentException;
class Address implements CastsAttributes {
  public function get(Model $model, string $key, mixed $value, array $attributes): AddressValueObject
  {return new AddressValueObject($attributes['address_line_one'], $attributes['address_line_two']);}
  public function set(Model $model, string $key, mixed $value, array $attributes): array
    {if (! $value instanceof AddressValueObject) {
      throw new InvalidArgumentException('The given value is not an Address instance.');}
    return ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo];}}
// применение
use App\Models\User;
$user = User::find(1);
$user->address->lineOne = 'Updated Address Value';
$user->save();
// атрибуты приведеные к объектам значений кэшируются автоматически
// отключить кэширование объектов в пользовательском классе приведения
class Address implements CastsAttributes {public bool $withoutObjectCaching = true;}
// при преобразовании таблицы в массив или JSON с использованием методов toArray и toJson,
// объекты-значения будут сериализованы автоматически, если типизаторы реализуют интерфейсы Illuminate\Contracts\Support\Arrayable и JsonSerializable
// сериализовать вручную в пользовательском типизаторе
public function serialize(Model $model, string $key, mixed $value, array $attributes): string
{return (string) $value;}
- сгенерировать класс приведения только для входящих значений (только преобразует указанные значения атрибутов модели)
php artisan make:cast Hash --inbound
// типизатор хеширует входящие значения с использованием указанного алгоритма
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsInboundAttributes;
use Illuminate\Database\Eloquent\Model;
class Hash implements CastsInboundAttributes {
  public function __construct(protected string|null $algorithm = null) {}
  public function set(Model $model, string $key, mixed $value, array $attributes): string
    {return is_null($this->algorithm) ? bcrypt($value) : hash($this->algorithm, $value);}}
// параметры типизатора задаются с помощью символа : через запятую
protected function casts(): array
{return ['secret' => Hash::class.':sha256'];}
- определить класс типизатора в объекте-значения
// возвращает имя пользовательского класса типизатора
namespace App\ValueObjects;
use Illuminate\Contracts\Database\Eloquent\Castable;
use App\Casts\Address as AddressCast;
class Address implements Castable {
  public static function castUsing(array $arguments): string{return AddressCast::class;}}
// применение
use App\ValueObjects\Address;
protected function casts(): array {return ['address' => Address::class.':argument'];}
// либо
namespace App\ValueObjects;
use Illuminate\Contracts\Database\Eloquent\Castable;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
class Address implements Castable {
  public static function castUsing(array $arguments): CastsAttributes {
    return new class implements CastsAttributes{
      public function get(Model $model, string $key, mixed $value, array $attributes): Address
      {return new Address($attributes['address_line_one'], $attributes['address_line_two']);}
      public function set(Model $model, string $key, mixed $value, array $attributes): array
      {return ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo];}
    };}}
</code></pre></details><details> <summary>Api resources</summary><details> <summary>Resource classes</summary><p>классы ресурсов Eloquent преобразуют модель в массив</p><pre><code>- сгенерировать новый ресурс модели
php artisan make:resource UserResource
- класс ресурса
namespace App\Http\Resources;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
class UserResource extends JsonResource
{public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}}
// вернуть ресурс из маршрута или контроллера (массив ресурса будет преобразован в JSON)
use App\Http\Resources\UserResource;
use App\Models\User;
Route::get('/user/{id}', function (string $id) {return new UserResource(User::findOrFail($id));});
// для возврата коллекции ресурса или ответа с постраничной разбивкой
  экземпляр пагинатора можно передать методу collection ресурса или коллекции ресурса
Route::get('/users', function () {return UserResource::collection(User::all());});
- включить связанные ресурсы в ответ: добавить посты пользователя в ответ ресурса
use App\Http\Resources\PostResource;
use Illuminate\Http\Request;
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'posts' => PostResource::collection($this->posts),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}</code></pre><p>ответ ресурса после возврата из маршрута или контроллера (преобразован в JSON)</p><pre><code>- верхний ресурс обёрнут в ключ data
{
  "data": [
    {
      "id": 1,
      "name": "Eladio Schroeder Sr.",
      "email": "therese28@example.com"
    },
    {
      "id": 2,
      "name": "Liliana Mayert",
      "email": "evandervort@example.com"
    }
  ]
}
- отключить обертывание верхнего ресурса
namespace App\Providers;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
  public function register(): void { }
  public function boot(): void {JsonResource::withoutWrapping();}
}
- разбитые на страницы ответы всегда содержат ключи meta и links с информацией о состоянии постраничной разбивки,
  поэтому Laravel обернет данные ресурса в ключ data, даже если был вызван метод withoutWrapping
{
  "data": [
      {
        "id": 1,
        "name": "Eladio Schroeder Sr.",
        "email": "therese28@example.com"
      },
      {
        "id": 2,
        "name": "Liliana Mayert",
        "email": "evandervort@example.com"
      }
  ],
  "links":{
    "first": "http://example.com/users?page=1",
    "last": "http://example.com/users?page=1",
    "prev": null,
    "next": null
  },
  "meta":{
    "current_page": 1,
    "from": 1,
    "last_page": 1,
    "path": "http://example.com/users",
    "per_page": 15,
    "to": 10,
    "total": 10
  }
}
// настроить информацию, включаемую в ключи links или meta ответа пагинации
public function paginationInformation($request, $paginated, $default)
{
  $default['links']['custom'] = 'https://example.com';
  return $default;
}
- включить атрибут в ответ ресурса, по условию
// включить в ответ значение 'secret-value', только если текущий пользователь администратор
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'secret' => $this->when($request->user()->isAdmin(), 'secret-value'),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}
либо вычислить результирующее значение, только если переданное условие истинно
'secret' => $this->when($request->user()->isAdmin(), function () {return 'secret-value';}),
// включение атрибута, если он присутствует в модели
'name' => $this->whenHas('name')
// включение атрибута в ответ ресурса, если атрибут не равен null
'name' => $this->whenNotNull($this->name)
// несколько атрибутов при одном и том же условии
  (ключи должны быть одного типа (string, int),цифровые ключи должны быть упорядочены)
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    $this->mergeWhen($request->user()->isAdmin(), ['first-secret' => 'value', 'second-secret' => 'value']),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}
// включать отношения в ответ ресурса если отношение уже загружено в модель
  (позволяет избежать проблем «N+1» с запросами в ресурсах)
// ключ posts будет удален из ответа ресурса, если отношение не было загружено
use App\Http\Resources\PostResource;
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'posts' => PostResource::collection($this->whenLoaded('posts')),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}
// включить счетчик отношений в ответ ресурса, если счетчик отношений был загружен в модели
new UserResource($user->loadCount('posts'));
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'posts_count' => $this->whenCounted('posts'),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];}
// условная загрузка агрегатов avg, sum, min и max
'words_avg' => $this->whenAggregated('posts', 'words', 'avg'),
'words_sum' => $this->whenAggregated('posts', 'words', 'sum'),
'words_min' => $this->whenAggregated('posts', 'words', 'min'),
'words_max' => $this->whenAggregated('posts', 'words', 'max'),
// включать данные из сводных таблиц отношений «многие ко многим» по условию
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    // 'role_user' - имя сводной таблицы
    'expires_at' => $this->whenPivotLoaded('role_user', function () {
      return $this->pivot->expires_at;
    }),
  ];}
либо экземпляр модели сводной таблицы в качестве первого аргумента
'expires_at' => $this->whenPivotLoaded(new Membership, function () {
  return $this->pivot->expires_at;
}),
// если сводная таблица использует аксессор
public function toArray(Request $request): array {
  return [
    'id' => $this->id,
    'name' => $this->name,
    'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {
      return $this->subscription->expires_at;
    }),
  ];}
- включить в ответ самого верхнего русурса массив метаданных
namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;
class UserCollection extends ResourceCollection
{
  public function toArray(Request $request): array {return parent::toArray($request);}
  public function with(Request $request): array {return ['meta' => ['key' => 'value']];}
}
// добавить данные верхнего уровня при создании экземпляров ресурсов в маршруте или контроллере
return (new UserCollection(User::all()->load('roles')))->additional(['meta' => ['key' => 'value',]]);
- метод response связанный с ресурсом, вернет экземпляр Illuminate\Http\JsonResponse, 
  что даст полный контроль над заголовками HTTP-ответа
use App\Http\Resources\UserResource;
use App\Models\User;
Route::get('/user', function () {
  return (new UserResource(User::find(1)))->response()->header('X-Value', 'True');});
либо определить метод withResponse внутри самого ресурса, если ресурс самый верхний в ответе
namespace App\Http\Resources;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
class UserResource extends JsonResource {
  public function toArray(Request $request): array {return ['id' => $this->id];}
  public function withResponse(Request $request, JsonResponse $response): void
  {$response->header('X-Value', 'True');}}
</code></pre></details><details> <summary>Resource collections</summary><p>- коллекции ресурса, позволяет определить любые метаданные, которые должны быть включены в ответ<br>
- коллекции ресурса преобразуют коллекцию моделей в массив<br>
- каждый элемент коллекции сопостовляется с его единственным классом ресурсов<br>
- единственным классом ресурса является коллекции UserCollection может быть либо класс User либо класс UserResource<br></p><pre><code>php artisan make:resource User --collection   // сгенерировать новую коллекцию ресурса
либо
php artisan make:resource UserCollection
- класс коллекции ресурса
namespace App\Http\Resources;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\ResourceCollection;
class UserCollection extends ResourceCollection {
  public function toArray(Request $request): array
    {return ['data' => $this->collection, 'links' => ['self' => 'link-value']];}}
// вернуть из маршрута или контроллера (массив коллекции будет преобразован в JSON)
use App\Http\Resources\UserCollection;
use App\Models\User;
Route::get('/users', function () {return new UserCollection(User::all());});
- сохранять исходные ключи коллекции при возврате из маршрута (по умолчанию меняет на числовые)
namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\JsonResource;
class UserResource extends JsonResource {public $preserveKeys = true;}
// вернуть коллекцию ресурса
use App\Http\Resources\UserResource;
use App\Models\User;
Route::get('/users', function () {return UserResource::collection(User::all()->keyBy->id);});
- изменить класс ресурса для коллекции
namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;
class UserCollection extends ResourceCollection {public $collects = Member::class;}</code></pre><p>- чтобы обернуть все коллекции ресурсов ключом data, независимо от их вложенности<br>
нужно определить класс коллекции для каждого ресурса и вернуть коллекцию с ключом data<br></p><pre><code>namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;
class CommentsCollection extends ResourceCollection {
  public function toArray(Request $request): array {return ['data' => $this->collection];}}
</code></pre></details><details> <summary>Serialization</summary><p>сериализация в массив</p><pre><code>- преобразовать модель и ее загруженные отношения в массив
use App\Models\User;
$user = User::with('roles')->first();
return $user->toArray();
- преобразованиe атрибутов модели в массив
$user = User::first();
return $user->attributesToArray();
- преобразовать коллекции моделей в массивы
$users = User::all();
return $users->toArray();</code></pre><p>сериализация в JSON</p><pre><code>- преобразовать модель и ее загруженные отношения в JSON
use App\Models\User;
$user = User::find(1);
return $user->toJson();
return $user->toJson(JSON_PRETTY_PRINT);
- преобразование модели или коллекции в строку, автоматически вызовет метод toJson
return (string) User::find(1);
- Laravel автоматически сериализует модели и коллекции Eloquent в JSON, когда они возвращаются из маршрутов или контроллеров
Route::get('/users', function () {return User::all();});
- cкрытие атрибутов из JSON
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model {protected $hidden = ['password'];}
либо только те, которые видны
protected $visible = ['first_name', 'last_name'];
// сделать некоторые обычно скрытые атрибуты видимыми на конкретном экземпляре модели
return $user->makeVisible('attribute')->toArray();
// скрыть некоторые атрибуты, которые обычно видны
return $user->makeHidden('attribute')->toArray();
// временно переопределить все видимые или скрытые атрибуты
return $user->setVisible(['id', 'name'])->toArray();
return $user->setHidden(['email', 'password', 'remember_token'])->toArray();</code></pre><p>добавить атрибуты, которым нет соответствующего столбца в базе данных, при преобразовании моделей в массивы или JSON</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{protected function isAdmin(): Attribute {return new Attribute(get: fn () => 'yes');}}
- автоматическое добавление аксессора к массиву и JSON-представлению модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model {protected $appends = ['is_admin'];}
- добавить дополнительные атрибуты во время выполнения скрипта
return $user->append('is_admin')->toArray();
- переопределить весь массив добавленных свойств для конкретного экземпляра модели
return $user->setAppends(['is_admin'])->toArray();</code></pre><p>сериализация даты</p><pre><code>- формат сериализации массива/JSON для всех дат модели по умолчанию
protected function serializeDate(DateTimeInterface $date): string
{return $date->format('Y-m-d');}
- настроить формат сериализации отдельных атрибутов даты
protected function casts(): array
{return ['birthday' => 'date:Y-m-d', 'joined_at' => 'datetime:Y-m-d H:00'];}
</code></pre></details></details><details><summary>Migrations</summary><a href="http://laravel.su/docs/12.x/migrations#dostupnye-psevdonimy-komand">псевдонимы команд</a><a href="http://laravel.su/docs/12.x/migrations#sobytiia">каждая операция миграции отправляет событие</a><p>- миграции позволяют создавать и изменять таблицы БД<br>
- сначала выполняются SQL-операторы дампа, потом все оставшиеся миграции, которые не были включены в дамп БД</p><pre><code>php artisan make:migration create_flights_table  // создать миграцию в database/migrations
php artisan schema:dump   // «сжать» миграции в один файл SQL
php artisan schema:dump --prune  // выгрузить текущий дамп БД в database/schema и удалить все существующие миграции
php artisan schema:dump --database=testing --prune    // создать дамп БД с поключением тестов
php artisan migrate    // запустить все незавершенные миграции
php artisan migrate:status   // узнать какие миграции выполнены
php artisan migrate --pretend    // посмотреть SQL-запросы, которые будут выполнены миграциями без запуска миграций
php artisan migrate --isolated   // блокировать попытки выполнить команду migrate, пока выполняется текущая
php artisan migrate --force    // запуск команды без подтверждения
php artisan migrate:rollback   // откатить последнюю миграцию
php artisan migrate:rollback --step=5    // откатить ограниченное количество миграций
php artisan migrate:rollback --batch=3   // откатить все миграции в третьей партии (партии в таблице migrations)
php artisan migrate:reset    // откатить все миграции
php artisan migrate:refresh   // откат и миграция одной командой
php artisan migrate:refresh --seed    // откатить базу данных и запустить все наполнители БД
php artisan migrate:refresh --step=5    // откатить и повторно запустить последние пять миграций
php artisan migrate:fresh   // удалить все таблицы из БД и выполнить миграцию
php artisan migrate:fresh --seed    // удалить все таблицы из БД и выполнить миграцию с наполнением
php artisan migrate:fresh --database=admin    // указать имя соединения с БД, которое следует использовать (имя соединения из конфига)</code></pre><p>Класс миграции содержит два метода: up для добавления новых таблиц, столбцов или индексов и down для отмены действий up</p><pre><code>- создать таблицу flights
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration {
  public function up(): void {Schema::create('flights', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('airline');
    $table->timestamps();
  });}
  public function down(): void {Schema::drop('flights');}};
либо
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
Schema::create('flights', function (Blueprint $table) {
  $table->id();
  $table->string('name');
  $table->string('email');
  $table->timestamps();});
Schema::table('users', function (Blueprint $table) {$table->integer('votes');});    // обновление существующих таблиц
Schema::rename($from, $to);   // переименовать существующую таблицу БД
Schema::connection('sqlite')->create('users', function (Blueprint $table) {$table->id();});   // подключение к БД не по умолчанию
protected $connection = 'pgsql';    // подключение к БД не по умолчанию
if (Schema::hasTable('users')) { }   // таблица `users` существует
if (Schema::hasColumn('users', 'email')) { }   // таблица `users` существует и содержит столбец `email`
if (Schema::hasIndex('users', ['email'], 'unique')) { }   // таблица `users` существует и имеет уникальный индекс в столбце `email`
Schema::create('users', function (Blueprint $table) {$table->engine('InnoDB');});   // механизм хранения таблицы в MariaDB или MySQL
// набор символов и кодировка для создаваемой таблицы в MariaDB или MySQL
Schema::create('users', function (Blueprint $table) {
  $table->charset('utf8mb4');
  $table->collation('utf8mb4_unicode_ci');});
// «временная» таблица видна только текущему соединению и удаляется при закрытии соединения
Schema::create('calculations', function (Blueprint $table) {$table->temporary();});
// комментарий к таблице БД, только в MariaDB, MySQL и PostgreSQL
Schema::create('calculations', function (Blueprint $table) {$table->comment('Business calculations');});
Schema::drop('users');    // удалить существующую таблицу (внешний ключ в таблице должен иметь явное имя в файлах миграции)
либо
Schema::dropIfExists('users');</code></pre><p>столбцы</p><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-stolbcov">типы столбцов</a><a href="http://laravel.su/docs/12.x/migrations#modifikatory-stolbca">модификаторы столбцов</a><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-indeksov">типы индексов</a><a href="http://laravel.su/docs/12.x/migrations#udalenie-indeksov">удалить индекс</a><pre><code>Schema::table('users', function (Blueprint $table) {$table->string('email')->nullable();});   // может быть NULL
$table->json('movies')->default(new Expression('(JSON_ARRAY())'));    // значение столбца по умолчанию
// добавить набор столбцов после существующего в MariaDB или MySQL
$table->after('password', function (Blueprint $table) {
  $table->string('address_line1');
  $table->string('address_line2');
  $table->string('city');});
Schema::table('users', function (Blueprint $table) {$table->string('name', 50)->change();}); // изменить тип и атрибуты столбца
// добавить атрибуты unsigned, default и comment
Schema::table('users', function (Blueprint $table) {
  $table->integer('votes')->unsigned()->default(1)->comment('мой комментарий')->change();});
Schema::table('users', function (Blueprint $table) {$table->renameColumn('from', 'to');});    // переименование столбца
Schema::table('users', function (Blueprint $table) {$table->dropColumn('votes');});   // удалениe столбца
либо
Schema::table('users', function (Blueprint $table) {$table->dropColumn(['votes', 'avatar', 'location']);});
$table->bigIncrements('id')->primary()->change();   // добавить индекс
$table->char('postal_code', 10)->unique(false)->change();   // удалить индекс
Schema::table('users', function (Blueprint $table) {$table->string('email')->unique();});   // создать индекс при создании столбца
$table->unique('email');    // создать индекс на существующем столбце
$table->index(['account_id', 'created_at']);   // созданиe составного индекса
$table->unique('email', 'unique_email');   // указать имя индекса вручную (второй аргумент)
$table->renameIndex('from', 'to')    // переименовать индекс
Schema::table('geo', function (Blueprint $table) {$table->dropIndex(['state']);});    // удалить простой индекс `geo_state_index`
- создание внешнего ключа (SQLite по умолчанию отключает внешние ключи)
Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');});
либо
Schema::table('posts', function (Blueprint $table) {$table->foreignId('user_id')->constrained();});
// указать имя таблицы и созданного индекса
Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained(table: 'users', indexName: 'posts_user_id');});
$table->foreignId('user_id')->constrained()->onUpdate('cascade')->onDelete('cascade');    // действие при удалении и при обновлении
$table->foreignId('user_id')->nullable()->constrained();    // любые модификаторы перед constrained 
// удалить внешний ключ
$table->dropForeign('posts_user_id_foreign');   // имя внешнего ключа это имя таблицы, столбца и суффикса _foreign
либо
$table->dropForeign(['user_id']);
// включить или отключить внешний ключ в миграциях
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();
Schema::withoutForeignKeyConstraints(function () { });    // ограничения отключены внутри функции
</code></pre></details><details><summary>Seeders</summary><p>классы наполнителей хранятся в database/seeders<br></p><pre><code>php artisan make:seeder UserSeeder    // сгенерировать новый наполнитель
php artisan db:seed   // наполнить БД
php artisan db:seed --class=UserSeeder    // указать конкретный класс наполнителя
php artisan migrate:fresh --seed    // полная перестройка БД с наполнением
php artisan migrate:fresh --seed --seeder=UserSeeder    // указать конкретный класс наполнителя
php artisan db:seed --force    // запустить наполнители без подтверждений
- вставлять данные в базу данных
namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
class DatabaseSeeder extends Seeder {
  public function run(): void {
    DB::table('users')->insert([
      'name' => Str::random(10),
      'email' => Str::random(10).'@example.com',
      'password' => Hash::make('password'),
    ]);
  }}
- метод call для запуска других наполнителей
public function run(): void {
  $this->call([
    UserSeeder::class,
    PostSeeder::class,
    CommentSeeder::class,
  ]);}
- отправка событий модели во время выполнения сидов
namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
class DatabaseSeeder extends Seeder {
  use WithoutModelEvents;
  public function run(): void {$this->call([UserSeeder::class]);}}
- Sequence меняет значения полей для каждой итерации цикла создания данных
public function run(): void {
  $tags = Tag::factory(3)->create();
  Job::factory(20)->hasAttached($tags)
  ->create(new Sequence(['featured' => false, 'schedule' => 'Full Time'],
    ['featured' => true, 'schedule' => 'Part Time']));}
</code></pre></details><details> <summary>Factories</summary><p>- фабрики моделей для удобного создания большого количества записей в БД
- языковой стандарт Faker - параметр faker_locale в config/app.php</p><pre><code>- сгенерировать фабрику для модели User в database/factories с именем UserFactory
php artisan make:factory UserFactory
// в модели User
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
class User extends Authenticatable {use HasFactory;}
- создать фабрику вручную
// в модели
use Database\Factories\Administration\FlightFactory;
protected static function newFactory() {return FlightFactory::new();}
// в фабрике
use App\Administration\Flight;
use Illuminate\Database\Eloquent\Factories\Factory;
class FlightFactory extends Factory {protected $model = Flight::class;}
- состояние фабрик
// изменить значение атрибута в фабрике \Database\Factories\UserFactory
use Illuminate\Database\Eloquent\Factories\Factory;
public function suspended(): Factory {
  return $this->state(function (array $attributes) {
    return ['account_status' => 'suspended'];   // аккаунт пользователя временно приостановлен
  });}
- создать модель без сохранения в базе данных
use App\Models\User;
$user = User::factory()->make();
- создать коллекцию из множества моделей
$users = User::factory()->count(3)->make();
- применить состояние к модели
$users = User::factory()->count(5)->suspended()->make();
- переопределить значения по умолчанию для моделей
$user = User::factory()->make(['name' => 'Abigail Otwell']);
либо
$user = User::factory()->state(['name' => 'Abigail Otwell'])->make();
- создать модель
use App\Models\User;
// Создаем один экземпляр `App\Models\User`
$user = User::factory()->create();
// Создаем три экземпляра `App\Models\User`
$users = User::factory()->count(3)->create();
// переопределить атрибуты модели по умолчанию
$user = User::factory()->create(['name' => 'Abigail']);
// чередовать значение атрибута для каждой создаваемой модели
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Sequence;
$users = User::factory()->count(10)->state(new Sequence(['admin' => 'Y'], ['admin' => 'N']))->create();
либо
use Illuminate\Database\Eloquent\Factories\Sequence;
$users = User::factory()->count(10)->state(new Sequence(
  fn (Sequence $sequence) => ['role' => UserRoles::all()->random()]))->create();
либо
$users = User::factory()->count(10)
  ->sequence(fn (Sequence $sequence) => ['name' => 'Name '.$sequence->index])->create();
либо
$users = User::factory()->count(2)->sequence(['name' => 'First User'], ['name' => 'Second User'])->create();
- отношения фабрик
// создать пользователя с тремя постами, модель User должна иметь метод posts, который определяет отношения
use App\Models\Post;
use App\Models\User;
$user = User::factory()->has(Post::factory()->count(3))->create();
// либо указать метод отношений модели User вручную
$user = User::factory()->has(Post::factory()->count(3), 'posts')->create();
// манипуляции с состоянием связанных моделей
$user = User::factory()->has(Post::factory()->count(3)
  ->state(function (array $attributes, User $user) {return ['user_type' => $user->type];}))->create();
либо при наличии метода отношений posts модели User использовать магический метод отношений фабрики hasPosts()
$user = User::factory()->hasPosts(3)->create();
// создать 50 пользователей, по одному посту у каждого
use App\Models\User;
public function run(): void{User::factory()->count(50)->hasPosts(1)->create();}
// переопределение атрибутов в связанных моделях
$user = User::factory()->hasPosts(3, ['published' => false])->create();
либо
$user = User::factory()->hasPosts(3, function (array $attributes, User $user)
{return ['user_type' => $user->type]})->create();
// обратное отношение for, для определения родительской модели
use App\Models\Post;
use App\Models\User;
$posts = Post::factory()->count(3)->for(User::factory()->state(['name' => 'Jessica Archer']))->create();
либо
$user = User::factory()->create();
$posts = Post::factory()->count(3)->for($user)->create();
// магический метод отношений фабрики при наличии отношения user в модели Post
$posts = Post::factory()->count(3)->forUser(['name' => 'Jessica Archer'])->create();
// отношения Many To Many
use App\Models\Role;
use App\Models\User;
$user = User::factory()->has(Role::factory()->count(3))->create();
// установить атрибуты в связующей таблице
use App\Models\Role;
use App\Models\User;
$user = User::factory()->hasAttached(Role::factory()->count(3), ['active' => true])->create();
// преобразовать состояние связанной модели через доступ к родительской модели
$user = User::factory()->hasAttached(
  Role::factory()->count(3)->state(function (array $attributes, User $user) {
    return ['name' => $user->name.' Role'];}), ['active' => true])->create();
// прикрепить существующие записи к создаваемым моделям
// трем пользователям будут назначены одни и те же три роли
$roles = Role::factory()->count(3)->create();
$user = User::factory()->count(3)->hasAttached($roles, ['active' => true])->create();
// магический метод отношений фабрики при наличии метода отношений roles модели User
$user = User::factory()->hasRoles(1, ['name' => 'Editor'])->create();
// полиморфные отношения Morph Many создаются так же, как типичные отношения Has Many
// модель App\Models\Post имеет отношение morphMany с моделью App\Models\Comment
use App\Models\Post;
$post = Post::factory()->hasComments(3)->create();
// создать три комментария, относящиеся к одному посту, используя напрямую метод for
$comments = Comment::factory()->count(3)->for(Post::factory(), 'commentable')->create();
// полиморфные отношения Many To Many 
use App\Models\Tag;
use App\Models\Video;
$videos = Video::factory()->hasAttached(Tag::factory()->count(3), ['public' => true])->create();
либо
$videos = Video::factory()->hasTags(3, ['public' => true])->create();
// определить отношение в рамках фабрики
// создать нового пользователя при создании публикации
use App\Models\User;
public function definition(): array {
  return [
    'user_id' => User::factory(),
    'title' => fake()->title(),
    'content' => fake()->paragraph(),
  ];}
public function definition(): array {
  return [
    'user_id' => User::factory(),
    'user_type' => function (array $attributes) {return User::find($attributes['user_id'])->type;},
    'title' => fake()->title(),
    'content' => fake()->paragraph(),
  ];}
// использовать одну и ту же авиакомпанию как для билета, так и для рейса
Ticket::factory()->recycle(Airline::factory()->create())->create();
// recycle принимает коллекцию существующих моделей - будет выбрана случайная модель из коллекции
Ticket::factory()->recycle($airlines)->create();
</code></pre></details><details> <summary>Relations</summary><p>Отношения реализованы поверх построителей запросов.<br>
Внешний ключ в дочерней модели: родительская модель User, дочерняя модель Phone должна иметь столбец user_id<br></p><pre><code>$user->posts()->where('active', 1)->get();    // отношения определяются как методы ->posts() в классах модели $user
- один к одному (имеет одного)
// запись модели User связана с одной записью модели Phone
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOne;
class User extends Model {
  public function phone(): HasOne {
    return $this->hasOne(Phone::class);   // получить телефон, связанный с пользователем
    return $this->hasOne(Phone::class, 'foreign_key');    // задать внешний ключ вручную
    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');   // задать искомое значение в user_id вручную
  }}
$phone = User::find(1)->phone;    // получить связанную запись в контроллере
// определить инверсию отношения hasOne
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Phone extends Model {
  public function user(): BelongsTo {
    return $this->belongsTo(User::class);   // получить пользователя, владеющего телефоном
    return $this->belongsTo(User::class, 'foreign_key');    // задать внешний ключ вручную
    return $this->belongsTo(User::class, 'foreign_key', 'owner_key');   // задать вручную искомое в id модели User значение
  }}
- один ко многим (имеет много)
use Illuminate\Database\Eloquent\Relations\HasMany;
class Post extends Model {
  public function comments(): HasMany {
    return $this->hasMany(Comment::class);    // получить коллекцию связанных комментариев
    return $this->hasMany(Comment::class, 'foreign_key');   // задать внешний ключ вручную
    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');    // задать искомое значение в post_id вручную
  }}
$comments = Post::find(1)->comments;    // получить комментарии
foreach ($comments as $comment) { }   // перебор комментариев
$comment = Post::find(1)->comments()->where('title', 'foo')->first();   // дополнительные ограничения
// определить инверсию отношения hasMany
class Comment extends Model {
  public function post(): BelongsTo {
    return $this->belongsTo(Post::class);   // модель Comment имеет внешний ключ post_id
    return $this->belongsTo(Post::class, 'foreign_key');    // задать внешний ключ вручную
    return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');   // задать вручную искомое в id модели Post значение
  }}
$comment = Comment::find(1);    // получить родительский пост комментария
return $comment->post->title;   // вернуть заголовок родительского пост комментария
public function latestOrder(): HasOne {return $this->hasOne(Order::class)->latestOfMany();} // получить последний заказ пользователя
public function oldestOrder(): HasOne {return $this->hasOne(Order::class)->oldestOfMany();} // получить первый заказ пользователя
// первый аргумент ofMany - столбец по которому ищем
public function largestOrder(): HasOne
{return $this->hasOne(Order::class)->ofMany('price', 'max');}  // получить самый дорогой заказ пользователя
либо через HasMany
public function orders(): HasMany {return $this->hasMany(Order::class);}    // получить заказы пользователя
public function largestOrder(): HasOne {return $this->orders()->one()->ofMany('price', 'max');}
public function currentPricing(): HasOne {
  return $this->hasOne(Price::class)->ofMany(['published_at' => 'max', 'id' => 'max'],    // получить актуальную цену на продукт
    function (Builder $query) {$query->where('published_at', '<', now());});}   // подзапрос
- один через отношение
// сопоставить модель с экземпляром другой модели, связавшись через третью модель
// механик связан с машиной, а машина связана с владельцем
mechanics
  id - integer
  name - string
cars
  id - integer
  model - string
  mechanic_id - integer
owners
  id - integer
  name - string
  car_id - integer
// механик получит доступ к владельцу через машину
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOneThrough;
class Mechanic extends Model {
  public function carOwner(): HasOneThrough {return $this->hasOneThrough(Owner::class, Car::class);}}    // получить владельца машины
либо через ключи
class Mechanic extends Model {
  public function carOwner(): HasOneThrough {
    return $this->hasOneThrough(
      Owner::class,
      Car::class,
      'mechanic_id', // Внешний ключ в таблице `cars`
      'car_id', // Внешний ключ в таблице `owners`
      'id', // Локальный ключ в таблице `mechanics`
      'id' // Локальный ключ в таблице `cars`
    );}}
// получить владельца
return $this->through('cars')->has('owner');    // String based syntax
return $this->throughCars()->hasOwner();    // Dynamic syntax
- многие через отношение
projects
  id - integer
  name - string
environments
  id - integer
  project_id - integer
  name - string
deployments
  id - integer
  environment_id - integer
  commit_hash - string
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;
class Project extends Model {
  public function deployments(): HasManyThrough {
    return $this->hasManyThrough(Deployment::class, Environment::class);}}  // получит все развёртывания через среду окружения
// через ключи
class Project extends Model {
  public function deployments(): HasManyThrough {
    return $this->hasManyThrough(
      Deployment::class,
      Environment::class,
      'project_id', // Внешний ключ в таблице `environments`
      'environment_id', // Внешний ключ в таблице `deployments`
      'id', // Локальный ключ в таблице `projects`
      'id' // Локальный ключ в таблице `environments`
    );}}
// получить развёртывания
return $this->through('environments')->has('deployments');    // String based syntax
return $this->throughEnvironments()->hasDeployments();    // Dynamic syntax
- получение доступа к родительской модели из дочерней при циклическом переборе записей дочерней модели может вызвать проблему «N + 1»
$posts = Post::with('comments')->get();
foreach ($posts as $post) {foreach ($post->comments as $comment) {echo $comment->post->title;}}   // проблема «N + 1»
// автоматически прикрепить запись из родительской модели к её дочерним записям из дочерней модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
class Post extends Model {public function comments(): HasMany {return $this->hasMany(Comment::class)->chaperone();}}
либо
$posts = Post::with(['comments' => fn ($comments) => $comments->chaperone()])->get();
- oтношения belongsTo, hasOne, hasOneThrough и morphOne позволяют определить модель по умолчанию при получении null
public function user(): BelongsTo {return $this->belongsTo(User::class)->withDefault();}    // вернёт пустую модель
либо получить автора поста
public function user(): BelongsTo {return $this->belongsTo(User::class)->withDefault(['name' => 'Guest Author']);}
либо
public function user(): BelongsTo
{return $this->belongsTo(User::class)->withDefault(function ($user, $post) {$user->name = 'Guest Author';});}
- определить в запросе к кому принадлежит
$posts = Post::where('user_id', $user->id)->get();
либо
$posts = Post::whereBelongsTo($user)->get();
либо
$users = User::where('vip', true)->get();
$posts = Post::whereBelongsTo($users)->get();
либо
$posts = Post::whereBelongsTo($user, 'author')->get();
- многие ко многим
// таблицы пользователей и ролей
users
  id - integer
  name - string
roles
  id - integer
  name - string
role_user
  user_id - integer
  role_id - integer
// роли, принадлежащие пользователю
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
class User extends Model {
  public function roles(): BelongsToMany {return $this->belongsToMany(Role::class);}}
$user = User::find(1);    // получить доступ к ролям пользователя
foreach ($user->roles as $role) { }   // перебрать роли пользователя
$roles = User::find(1)->roles()->orderBy('name')->get();    // с ограничениями и условиями
// обратное отношение многие-ко-многим
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
class Role extends Model {
  // пользователи, принадлежащие к роли
  public function users(): BelongsToMany {return $this->belongsToMany(User::class);}}
// Eloquent автоматически соединит имена таблиц User и Role в алфавитном порядке role_user для поиска связующей таблицы
return $this->belongsToMany(Role::class, 'role_user');    // задать имя связующей таблицы вручную
return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');    // изменить имена столбцов ключей
// доступ к связующей таблице
$user = User::find(1);
foreach ($user->roles as $role) {echo $role->pivot->created_at;}
// дополнительные столбцы связующей таблицы
return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');
// чтобы связующая таблица имела временные метки created_at и updated_at, нужно вызвать withTimestamps
return $this->belongsToMany(Role::class)->withTimestamps();
// дугое имя для связующей таблицы
return $this->belongsToMany(Podcast::class)->as('subscription')->withTimestamps();
// получить столбец связующей таблицы
$users = User::with('podcasts')->get();
foreach ($users->flatMap->podcasts as $podcast) {echo $podcast->subscription->created_at;}
// фильтрация запросов по столбцам связующей таблицы
return $this->belongsToMany(Role::class)->wherePivot('approved', 1);
return $this->belongsToMany(Role::class)->wherePivotIn('priority', [1, 2]);
return $this->belongsToMany(Role::class)->wherePivotNotIn('priority', [1, 2]);
return $this->belongsToMany(Podcast::class)->as('subscriptions')
  ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);
return $this->belongsToMany(Podcast::class)->as('subscriptions')
  ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);
return $this->belongsToMany(Podcast::class)->as('subscriptions')->wherePivotNull('expired_at');
return $this->belongsToMany(Podcast::class)->as('subscriptions')->wherePivotNotNull('expired_at');
return $this->belongsToMany(Badge::class)->where('rank', 'gold')->orderByPivot('created_at', 'desc');
- определить свою модель связующей таблицы RoleUser
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
class Role extends Model {
  public function users(): BelongsToMany {
    return $this->belongsToMany(User::class)->using(RoleUser::class);}}    // пользователи, принадлежащие к роли
// модель связующей модели RoleUser
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;
class RoleUser extends Pivot { }
// автоинкремент для связующей таблицы
public $incrementing = true;    // идентификаторы модели автоинкрементные</code></pre><p>полиморфные отношения</p><pre><code>- один к одному полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации
// таблицы
posts
  id - integer
  name - string
users
  id - integer
  name - string
images
  id - integer
  url - string
  imageable_id - integer
  imageable_type - string
// модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;
class Image extends Model {
  // получить родительскую модель (пользователя или поста), к которой относится изображение
  public function imageable(): MorphTo{return $this->morphTo();}}
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphOne;
class Post extends Model {
  // получить изображение поста
  public function image(): MorphOne {return $this->morphOne(Image::class, 'imageable');}}
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphOne;
class User extends Model {
  // получить изображение пользователя
  public function image(): MorphOne {return $this->morphOne(Image::class, 'imageable');}}
// получить доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
$image = $post->image;
// получить родительский объект полиморфной модели, вернёт Post или User
use App\Models\Image;
$image = Image::find(1);
$imageable = $image->imageable;
// получить родительскую модель, к которой относится изображение
public function imageable(): MorphTo {return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');}
- один ко многим полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации
// таблицы
posts
  id - integer
  title - string
  body - text
videos
  id - integer
  title - string
  url - string
comments
  id - integer
  body - text
  commentable_id - integer
  commentable_type - string
// модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;
class Comment extends Model {
  // получить родительскую модель (поста или видео), к которой относится комментарий
  public function commentable(): MorphTo {return $this->morphTo();}}
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphMany;
class Post extends Model {
  // получить все комментарии поста
  public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable');}}
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphMany;
class Video extends Model {
  // получить все комментарии видео
  public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable');}}
// доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
foreach ($post->comments as $comment) { }
// доступ к родительской модели, вернет либо экземпляр Post, либо Video
use App\Models\Comment;
$comment = Comment::find(1);
$commentable = $comment->commentable;
// проблема «N + 1»
$posts = Post::with('comments')->get();
foreach ($posts as $post) {foreach ($post->comments as $comment) {echo $comment->commentable->title;}}
// автоматически связывать записи родительской модели с дочерними
class Post extends Model {
  public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable')->chaperone();}}
// либо
use App\Models\Post;
$posts = Post::with(['comments' => fn ($comments) => $comments->chaperone()])->get();
- один из многих полиморф
// Get the user's most recent image.
public function latestImage(): MorphOne {return $this->morphOne(Image::class, 'imageable')->latestOfMany();}
// либо
// Get the user's oldest image.public function oldestImage(): MorphOne {
  return $this->morphOne(Image::class, 'imageable')->oldestOfMany();}
ofMany('likes', 'max')    // задать столбец сортировки и способ сортировки вручную
// Получить изображение, у которого больше всего лайков.
public function bestImage() {return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');}
- многие ко многим полиморф
// таблицы
posts
  id - integer
  name - string
videos
  id - integer
  name - string
tags
  id - integer
  name - string
taggables
  tag_id - integer
  taggable_id - integer
  taggable_type - string
// модель
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;
class Post extends Model {
  // Получить все теги поста, taggable - связующая таблица
  public function tags(): MorphToMany {return $this->morphToMany(Tag::class, 'taggable');}}
// получить записи родительской модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;
class Tag extends Model {
  // Получить все посты, которым присвоен этот тег.
  public function posts(): MorphToMany {return $this->morphedByMany(Post::class, 'taggable');}
  // Получить все видео, которым присвоен этот тег.
  public function videos(): MorphToMany {return $this->morphedByMany(Video::class, 'taggable');}}
// получить доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
foreach ($post->tags as $tag) { }
// получить доступ к родительской модели
use App\Models\Tag;
$tag = Tag::find(1);
foreach ($tag->posts as $post) { }
foreach ($tag->videos as $video) { }
// задать псевдоним полиморфного типа модели вручную
use Illuminate\Database\Eloquent\Relations\Relation;
Relation::enforceMorphMap(['post' => 'App\Models\Post', 'video' => 'App\Models\Video']);
либо
$alias = $post->getMorphClass();    // определить псевдоним полиморфного типа конкретной модели
$class = Relation::getMorphedModel($alias); // определить полное имя класса, связанное с псевдонимом
- динамические отношения
// настроить динамические отношения в App\Providers\AppServiceProvider метод boot
use App\Models\Order;
use App\Models\Customer;
Order::resolveRelationUsing('customer', function (Order $orderModel) {
  return $orderModel->belongsTo(Customer::class, 'customer_id');});</code></pre><p>- запросы отношений
// получить экземпляр отношения, не выполняя запроса загрузки связанных моделей
  namespace App\Models;
  use Illuminate\Database\Eloquent\Model;
  use Illuminate\Database\Eloquent\Relations\HasMany;
  class User extends Model {
    // получить все посты пользователя
    public function posts(): HasMany {return $this->hasMany(Post::class);}}
  // запросить отношение posts
  use App\Models\User;
  $user = User::find(1);
  $user->posts()->where('active', 1)->get();
  либо
  $user->posts()->where('active', 1)->orWhere('votes', '>=', 100)->get();
  // вернёт
  select * from posts where user_id = ? and active = 1 or votes >= 100
  либо
  use Illuminate\Database\Eloquent\Builder;
  $user->posts()->where(function (Builder $query) {return $query->where('active', 1)
    ->orWhere('votes', '>=', 100);})->get();
  // вернёт
  select * from posts where user_id = ? and (active = 1 or votes >= 100)
  // получить доступ к отношению, как к свойству
  use App\Models\User;
  $user = User::find(1);
  foreach ($user->posts as $post) { }
  - получить записи таблицы, у которых есть отношения с другими таблицами
  use App\Models\Post;
  // Получить все посты, в которых есть хотя бы один комментарий
  $posts = Post::has('comments')->get();
  // Получить посты, в которых есть 3 или более комментариев
  $posts = Post::has('comments', '>=', 3)->get();
  // Получить посты, в которых есть хотя бы один комментарий с изображениями
  $posts = Post::has('comments.images')->get();
  либо
  use Illuminate\Database\Eloquent\Builder;
  // Получить посты с хотя бы одним комментарием, содержащим `code%`
  $posts = Post::whereHas('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');})->get();
  // Получить посты с как минимум десятью комментариями, содержащими `code%`
  $posts = Post::whereHas('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');}, '>=', 10)->get();
  // запросить все посты с не одобренными комментариями
  use App\Models\Post;
  $posts = Post::whereRelation('comments', 'is_approved', false)->get();
  // запросить посты в зависимости от момента создания комментария
  $posts = Post::whereRelation('comments', 'created_at', '>=', now()->subHour())->get();
  - получить записи таблицы, у которых нет отношения с другими таблицами
  // получить все посты блога, которые не имеют комментариев
  use App\Models\Post;
  $posts = Post::doesntHave('comments')->get();
  // проверить содержимое комментария
  use Illuminate\Database\Eloquent\Builder;
  $posts = Post::whereDoesntHave('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');})->get();
  // получить посты без комментариев и с комментариями от незабаненных авторов
  use Illuminate\Database\Eloquent\Builder;
  $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
    $query->where('banned', 0);})->get();
  - узнать о существовании полиморфных «один-к» отношений
  use App\Models\Comment;
  use App\Models\Post;
  use App\Models\Video;
  use Illuminate\Database\Eloquent\Builder;
  // Получить комментарии, связанные с постами или видео с заголовком, содержащими `code%`
  $comments = Comment::whereHasMorph('commentable', [Post::class, Video::class],
    function (Builder $query) {$query->where('title', 'like', 'code%');})->get();
  // Получить комментарии, связанные с постами с заголовком, не содержащим `code%`
  $comments = Comment::whereDoesntHaveMorph('commentable', Post::class,
    function (Builder $query) {$query->where('title', 'like', 'code%');})->get();
  // с указанием типа
  use Illuminate\Database\Eloquent\Builder;
  $comments = Comment::whereHasMorph('commentable', [Post::class, Video::class],
    function (Builder $query, string $type) {
      $column = $type === Post::class ? 'content' : 'title';
      $query->where($column, 'like', 'code%');})->get();
  // запросить дочерние элементы
  $comments = Comment::whereMorphedTo('commentable', $post)->orWhereMorphedTo('commentable', $video)->get();
  - извлечь все возможные полиморфные типы из БД
  use Illuminate\Database\Eloquent\Builder;
  $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
    $query->where('title', 'like', 'foo%');})->get();
  - агрегирование связанных моделей
  // подсчитать количество связанных моделей для отношения, не загружая модели
  use App\Models\Post;
  $posts = Post::withCount('comments')->get();
  foreach ($posts as $post) {echo $post->comments_count;}
  // добавить «счетчики» для нескольких отношений, а также добавить дополнительные ограничения к запросам
  use Illuminate\Database\Eloquent\Builder;
  $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
    $query->where('content', 'like', 'code%');}])->get();
  echo $posts[0]->votes_count;
  echo $posts[0]->comments_count;
  // использовать псевдоним результата подсчета отношений
  use Illuminate\Database\Eloquent\Builder;
  $posts = Post::withCount(['comments',
    'comments as pending_comments_count' => function (Builder $query) {
      $query->where('approved', false);},])->get();
  echo $posts[0]->comments_count;
  echo $posts[0]->pending_comments_count;
  // загрузить счетчик отношений после того, как родительская модель уже была получена
  $book = Book::first();
  $book->loadCount('genres');
  // установить дополнительные ограничения запроса
  $book->loadCount(['reviews' => function (Builder $query) {$query->where('rating', 5);}])
  // withCount вызывать после метода select
  $posts = Post::select(['title', 'body'])->withCount('comments')->get();
  // сумма комментариев
  use App\Models\Post;
  $posts = Post::withSum('comments', 'votes')->get();
  foreach ($posts as $post) {echo $post->comments_sum_votes;}
  // с псевдонимом
  $posts = Post::withSum('comments as total_comments', 'votes')->get();
  foreach ($posts as $post) {echo $post->total_comments;}
  // отложенное выполнение на уже полученных моделях
  $post = Post::first();
  $post->loadSum('comments', 'votes');
  // все методы вызывать после select
  $posts = Post::select(['title', 'body'])->withExists('comments')->get();
  // посчитать количество отношений у родителей
    Photo родитель Tag, Post родитель Comment, Photo и Post полиморфные родители ActivityFeed
  use Illuminate\Database\Eloquent\Relations\MorphTo;
  // отложенное выполнение на уже загруженный записях ActivityFeed
  $activities = ActivityFeed::with(['parentable' => function (MorphTo $morphTo) {
    $morphTo->morphWithCount([Photo::class => ['tags'], Post::class => ['comments'],]);}])->get();</p><p>проблема «N+1»</p><pre><code>// модель Book «принадлежит» модели Author
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Book extends Model {
  // Получить автора книги.
  public function author(): BelongsTo {return $this->belongsTo(Author::class);}}
// получим все книги и их авторов
// если в таблице 25 книг, то будет 26 запросов:
// один для получения всех книг
// 25 дополнительных запросов для получения автора каждой книги
use App\Models\Book;
$books = Book::all();
foreach ($books as $book) {echo $book->author->name;}
// при жадной загрузке будут выполнены только два запроса:
// один запрос для получения всех книг
// второй запрос – для получения всех авторов для всех книг
$books = Book::with('author')->get();
foreach ($books as $book) {echo $book->author->name;}
// вернёт
select * from books
select * from authors where id in (1, 2, 3, 4, 5, ...)</code></pre><p>- жадная (eager) загрузка<br>
- При доступе к отношениям как к свойствам, связанные модели загружаются «отложенно», т.е. не загружаются, пока вы впервые не затребуете доступ к свойству.<br>
- Можно «жадно» загрузить отношения во время запроса родительской модели.<br>
- Жадная загрузка позволяет избежать проблем «N+1» с запросами. <br>
- Жадная загрузка обеспечивает значительное сокращение количества SQL-запросов, которые необходимо выполнить для загрузки отношений модели.<br>
- всегда предотвращать ленивую загрузку<br></p><pre><code>// в App\Providers\AppServiceProvider в boot
use Illuminate\Database\Eloquent\Model;
public function boot(): void {Model::preventLazyLoading(! $this->app->isProduction());}
// когда приложение попытается лениво загрузить отношение, будет исключение<br>
// регистрировать, а не выбрасывать исключение<br>
Model::handleLazyLoadingViolationUsing(function (Model $model, string $relation) {
  $class = $model::class;
  info("Attempted to lazy load [{$relation}] on model [{$class}].");});
// загрузить несколько разных отношений
$books = Book::with(['author', 'publisher'])->get();
// вложенная жадная загрузка контактов всех авторов книг
$books = Book::with('author.contacts')->get();
// одновременная загрузка нескольких вложенных отношений
$books = Book::with(['author' => ['contacts', 'publisher']])->get();
// загрузить полиморфное отношение «один-к»
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;
class ActivityFeed extends Model {
  // Получить родительский элемент записи ленты активности.
  public function parentable(): MorphTo {return $this->morphTo();}}
// Event, Photo и Post могут создавать модели ActivityFeed
// Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
// получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
use Illuminate\Database\Eloquent\Relations\MorphTo;
$activities = ActivityFeed::query()->with(['parentable' => function (MorphTo $morphTo) {
  $morphTo->morphWith([
    Event::class => ['calendar'],
    Photo::class => ['tags'],
    Post::class => ['author']]);}])->get();
$books = Book::with('author:id,name,book_id')->get();   // жадная загрузка указанных столбцов
// постоянная загрузка отношений при извлечении модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Book extends Model {
  protected $with = ['author'];
  public function author(): BelongsTo {return $this->belongsTo(Author::class);}   // получить автора книги
  public function genre(): BelongsTo {return $this->belongsTo(Genre::class);}}   // получить жанр книги
// удалить элемент из свойства $with для одного запроса
$books = Book::without('author')->get();
// для одного запроса
$books = Book::withOnly('genre')->get();
// ключ массива – имя отношения
// значение массива – ограничение к запросу жадной загрузки
// загружать только те посты, столбец title которых содержит слово code
use App\Models\User;
use Illuminate\Contracts\Database\Eloquent\Builder;
$users = User::with(['posts' => function (Builder $query) {
  $query->where('title', 'like', '%code%');}])->get();
// сортировка по времени создания
$users = User::with(['posts' => function (Builder $query) {
  $query->orderBy('created_at', 'desc');}])->get();
// ограничения к жадной загрузке полиморфного отношения «один-к»
// загружать только скрытые посты, а видео только с типом как образовательное
use Illuminate\Database\Eloquent\Relations\MorphTo;
$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
  $morphTo->constrain([
    Post::class => function ($query) {$query->whereNull('hidden_at');},
    Video::class => function ($query) {$query->where('type', 'educational');}
  ]);}])->get();
// проверить наличие отношения при жадной загрузке
use App\Models\User;
$users = User::withWhereHas('posts', function ($query) {$query->where('featured', true);})->get();
// жадно загрузить отношение только после получения родительской модели
use App\Models\Book;
$books = Book::all();
if ($someCondition) {$books->load('author', 'publisher');}
// с ограничением
$author->load(['books' => function (Builder $query) {$query->orderBy('published_date', 'asc');}]);
$book->loadMissing('author');   // загрузить если еще не было загружено
// вложенная жадная пост-загрузка с полиморфными отношениями «один-к»
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;
class ActivityFeed extends Model {
  // получить родительский элемент записи ленты активности
  public function parentable(): MorphTo {return $this->morphTo();}}
// Event, Photo и Post могут создавать модели ActivityFeed
// Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
// получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
$activities = ActivityFeed::with('parentable')->get()->loadMorph('parentable', [
  Event::class => ['calendar'],
  Photo::class => ['tags'],
  Post::class => ['author']]);</code></pre><p>вставка и обновление связанных моделей</p><pre><code>// добавить новый комментарий к посту
use App\Models\Comment;
use App\Models\Post;
$comment = new Comment(['message' => 'A new comment.']);
$post = Post::find(1);
$post->comments()->save($comment);
// сохранить несколько связанных записей
$post = Post::find(1);
$post->comments()->saveMany([
  new Comment(['message' => 'A new comment.']),
  new Comment(['message' => 'Another new comment.'])]);
// получить доступ к отношениям после использования методов save или saveMany
$post->comments()->save($comment);
$post->refresh();
// все комментарии, включая только что сохраненный комментарий
$post->comments;
// сохранить пост, его комментарии и авторы этих комментариев
$post = Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();
// сохранения поста и его связанных отношений без вызова каких-либо событий
$post->pushQuietly();
// метод save принимает экземпляр модели Eloquent, а create принимает простой массив PHP
use App\Models\Post;
$post = Post::find(1);
$comment = $post->comments()->create(['message' => 'A new comment.']);
// создание нескольких связанных записей
$post = Post::find(1);
$post->comments()->createMany([['message' => 'A new comment.'], ['message' => 'Another new comment.']]);
// создания постов без отправки каких-либо событий
$user = User::find(1);
$user->posts()->createQuietly(['title' => 'Post title.']);
$user->posts()->createManyQuietly([['title' => 'First post.'], ['title' => 'Second post.']]);
// создание и обновление записей методы findOrNew, firstOrNew, firstOrCreate, и updateOrCreate
// назначить дочернюю модель новой родительской модели
use App\Models\Account;
$account = Account::find(10);
$user->account()->associate($account);
$user->save();
удалить родительскую модель из дочерней модели
$user->account()->dissociate();
$user->save();
// присоединить «многие-ко-многим», вставив запись в связующую таблицу
use App\Models\User;
$user = User::find(1);
$user->roles()->attach($roleId);
// передать массив дополнительных данных для вставки в связующую таблицу
$user->roles()->attach($roleId, ['expires' => $expires]);
// удалить запись отношения «многие-ко-многим» - удалит запись из связующей таблицы
// Отсоединить одну роль от пользователя
$user->roles()->detach($roleId);
// Отсоединить от пользователя все роли
$user->roles()->detach();
либо
$user = User::find(1);
$user->roles()->detach([1, 2, 3]);
$user->roles()->attach([1 => ['expires' => $expires], 2 => ['expires' => $expires]]);
// создать ассоциации «многие-ко-многим», добавив массив идентификаторов в связующую таблицу
$user->roles()->sync([1, 2, 3]);
либо
$user->roles()->sync([1 => ['expires' => true], 2, 3]);
// вставить одинаковые значения в связующую таблицу для каждого ID
$user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);
// не удалять существующие связи, идентификаторы которых отсутствуют в переданном массиве
$user->roles()->syncWithoutDetaching([1, 2, 3]);
// если переданный идентификатор в настоящее время присоединен, он будет отсоединен и наоборот
$user->roles()->toggle([1, 2, 3]);
// передать дополнительные значения для связующей таблицы вместе с идентификаторами
$user->roles()->toggle([1 => ['expires' => true], 2 => ['expires' => true]]);
// обновить существующую строку в связующей таблице
$user = User::find(1);
$user->roles()->updateExistingPivot($roleId, ['active' => false]);</code></pre><p>временные метки родителя</p><pre><code>// обновить временную метку родителя при обновлении дочерней модели
// свойство $touches дочерней модели, содержит имена отношений, которые должны обновляться с дочерней моделью
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Comment extends Model {
  protected $touches = ['post'];    // все отношения, временные метки которых должны быть затронуты
  // получить пост, к которому принадлежит комментарий
  public function post(): BelongsTo {return $this->belongsTo(Post::class);}}
</code></pre></details></details><details> <summary>Pagination</summary><p>paginate автоматически устанавливает «предел» и «смещение» в запросе на основе текущей страницы</p><pre><code>- в tailwind.config.js
content: [
  './resources/**/*.blade.php',
  './resources/**/*.js',
  './resources/**/*.vue',
  './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php']
- отобразить 15 элементов на странице
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;
class UserController extends Controller {
  public function index(): View
  {return view('user.index', ['users' => DB::table('users')->paginate(15)]);}}
- отображать только простые ссылки «Далее» и «Назад» без общего количества страниц
$users = DB::table('users')->simplePaginate(15);
- разбить запросы Eloquent на страницы
use App\Models\User;
$users = User::paginate(15);
либо
$users = User::where('votes', '>', 100)->paginate(15);
либо
$users = User::where('votes', '>', 100)->simplePaginate(15);
либо
$users = User::where('votes', '>', 100)->cursorPaginate(15);
- отобразить два отдельных модуля пагинации на одном экране:
  в третьем параметре указать имя страницы отдельно для каждого модуля пагинации
use App\Models\User;
$users = User::where('votes', '>', 100)->paginate($perPage = 15, $columns = ['*'], $pageName = 'users');</code></pre><p>- paginate и simplePaginate создают запросы с использованием SQL-оператора “offset”<br>
- Cursor-пагинация работает путем создания конструкции “where”<br>
- пагинация на основе смещения включает номер страницы в строке запроса URL-адресов<br>
- Курсор представляет собой закодированную строку, содержащую место, с которого следующий запрос с пагинацией должен начать постраничную навигацию, и направление, в котором он должен разбиваться на страницы<br></p><pre><code>$users = DB::table('users')->orderBy('id')->cursorPaginate(15);
- отобразить “вторую страницу” результатов для таблицы users, упорядоченных по id
select * from users order by id asc limit 15 offset 15;   // offset пагинация
select * from users where id > 15 order by id asc limit 15;   // cursor пагинация</code></pre><p>Преимущества Cursor-пагинация перед Offset-пагинацией:<br>
- Для больших наборов данных Cursor-пагинация обеспечивать лучшую производительность, если столбцы “order by” проиндексированы. Это связано с тем, что предложение “offset” сканирует все ранее сопоставленные данные.<br>
- Для наборов данных с частыми записями Offset-пагинация может пропускать записи или отображать дубликаты, если результаты были недавно добавлены или удалены со страницы, которую пользователь просматривает в данный момент.<br>
<br>
Ограничения Cursor-пагинации:<br>
- Как и simplePaginate, Cursor-пагинация может использоваться только для отображения ссылок “Далее” и “Назад” и не поддерживает создание ссылок с номерами страниц.<br>
- Требуется, чтобы порядок был основан как минимум на одном уникальном столбце или на комбинации уникальных столбцов. - Столбцы с null – значениями не поддерживаются.<br>
- Выражения запросов c “order by” поддерживаются только в том случае, если они имеют псевдоним и также добавлены в “select”.<br>
- Выражения запросов с параметрами не поддерживаются.<br>
- чтобы пагинатор генерировал ссылки типа http://example.com/admin/users?page=N</p><pre><code>use App\Models\User;
Route::get('/users', function () {
  $users = User::paginate(15);
  $users->withPath('/admin/users');});
- добавить sort=votes к каждой ссылке пагинации
use App\Models\User;
Route::get('/users', function () {
  $users = User::paginate(15);
  $users->appends(['sort' => 'votes']);});
- добавить все значения строки текущего запроса к ссылкам постраничной навигации
$users = User::paginate(15)->withQueryString();
- добавить «хеш-фрагмент» к URL-адресам
$users = User::paginate(15)->fragment('users');</code></pre><p>- вызов метода paginate возвращает экземпляр Illuminate\Pagination\LengthAwarePaginator<br>
- вызов метода simplePaginate возвращает экземпляр Illuminate\Pagination\Paginator<br>
- вызов метода cursorPaginate возвращает экземпляр Illuminate\Pagination\CursorPaginator<br>
- экземпляры являются итераторами и могут быть перебраны как массив<br></p><a href="http://laravel.su/docs/12.x/pagination#metody-ekzempliara-paginator-i-lengthawarepaginator">экземпляры содержат методы, описывающие результирующий набор</a><pre><code>&lt;div class="container"&gt;@foreach ($users as $user){{ $user->name }}@endforeach&lt;/div&gt;
// links отрисует ссылки с переменной запроса page на остальные страницы
{{ $users->links() }}</code></pre><p>- HTML, сгенерированный методом links, совместим с фреймворком Tailwind CSS<br>
- пагинатор отображает навигационные ссылки, включающие номер текущей страницы, а также ссылки для трех страниц до и после текущей<br>
- контролировать, сколько дополнительных ссылок отображается с каждой стороны от текущей страницы<br></p><pre><code>{{ $users->onEachSide(5)->links() }}
- преобразовать экземпляр пагинатора в JSON, вернув его из маршрута или действия контроллера
use App\Models\User;
Route::get('/users', function () {return User::paginate();});</code></pre><p>передать свой шаблон отображения навигационных ссылок пагинации</p><pre><code>{{ $paginator->links('view.name') }}
{{ $paginator->links('view.name', ['foo' => 'bar']) }}    // передача дополнительных данных в шаблон</code></pre><p>- отредактировать встроенные шаблоны постраничной навигации
- файл tailwind.blade.php в resources/views/vendor/pagination - шаблон постраничной навигации по умолчанию<br></p><pre><code>php artisan vendor:publish --tag=laravel-pagination
- назначить другой файл шаблоном постраничной навигации по умолчанию<br>
namespace App\Providers;
use Illuminate\Pagination\Paginator;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void {
    Paginator::defaultView('view-name');
    Paginator::defaultSimpleView('view-name');}}
</code></pre></details><details><summary>Redis</summary><a href="http://laravel.su/docs/12.x/redis">redis</a><p>- Redis используется в качестве кэша и драйвера очереди<br>
- драйвер Redis по умолчанию использует расширение phpredis<br>
- расширение predis не поддерживается<br>
- расширение phpredis поддерживает Redis 3.0 и выше<br>
- кеширование данных в Redis<br>
- кеширование представлений в Redis<br>
- кеширование маршрутов в Redis<br>
- кеширование конфигурации в Redis<br></p><pre><code>php artisan config:cache
php artisan route:cache
php artisan view:cache

use Illuminate\Support\Facades\Redis;
Redis::set('key', 'value');
Redis::get('key');
Redis::del('key');
Redis::exists('key');
Redis::expire('key', 60);
Redis::ttl('key');
Redis::keys('*');
Redis::flushAll();
</code></pre></details><details><summary>Cache</summary><p></p><pre><code></code></pre></details><details><summary>Rate Limiting</summary><p>ограничить любое действие в течение указанного периода времени, использует кеш приложения по умолчанию в config/cache.php</p><pre><code>- указать драйвер кеша для ограничителя скорости
'default' => env('CACHE_STORE', 'database'),
'limiter' => 'redis'
- attempt возвращает false если не осталось доступных попыток либо вернет результат функции или true
use Illuminate\Support\Facades\RateLimiter;
$executed = RateLimiter::attempt(
  'send-message:'.$user->id,
  $perMinute = 5,
  function() { // Отправляю сообщение...});
if (! $executed) {return 'Отправлено слишком много сообщений!';}
либо разрешить пять попыток каждые две минуты
$executed = RateLimiter::attempt(
  'send-message:'.$user->id,
  $perTwoMinutes = 5,
  function() { // Отправляем сообщение...},
  $decayRate = 120);
- определить не превышено ли максимальное количество разрешенных попыток в минуту
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {return 'Слишком много попыток!';}
RateLimiter::increment('send-message:'.$user->id);
- получение оставшегося количества попыток
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::remaining('send-message:'.$user->id, $perMinute = 5)) {
  RateLimiter::increment('send-message:'.$user->id);}
- увеличить количество попыток для указанного ключа более чем на единицу
RateLimiter::increment('send-message:'.$user->id, amount: 5);
- availableIn возвращает количество секунд появления новых попыток
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {
  $seconds = RateLimiter::availableIn('send-message:'.$user->id);
  return 'Вы можете повторить попытку через '.$seconds.' секунд.';}
  RateLimiter::increment('send-message:'.$user->id);
- сбросить количество попыток
use App\Models\Message;
use Illuminate\Support\Facades\RateLimiter;
public function read(Message $message): Message {
  $message->markAsRead();
  RateLimiter::clear('send-message:'.$message->user_id);
  return $message;}
</code></pre></details><details><summary>MongoDB</summary><a href="http://laravel.su/docs/12.x/mongodb">mongodb</a><p>- MongoDB используется в качестве драйвера кэша, очереди, сессий, БД<br>
- драйвер MongoDB по умолчанию использует расширение mongodb<br>
- расширение mongodb поддерживает MongoDB 2.6 и выше<br></p><code>php artisan vendor:publish --provider="Jenssegers\Mongodb\MongodbServiceProvider"</code></details></details><details><summary>How to</summary><details> <summary>Api</summary><p>Установить пакет Sanctum, создать роут, миграцию personal_access_tokens_table и токен аутентификацию для api</p><code>./sail artisan install:api</code><p>Создать модель с миграцией</p><code>./sail artisan make:model Category -m</code><p>Обновить таблицы</p><code>./sail artisan migrate</code><p>создать контроллер в отдельной структуре папок (v1 - версия)
--model=Category - привязка к модели
--api - методы апи контроллера
--requests - вынос валидации в отдельные классы</p><code>./sail artisan make:controller Api/V1/CategoryController --model=Category --api --requests</code><p>сгруппировать роуты по версиям и создать рессурсный роут</p><code>use App\Http\Controllers\Api\V1\CategoryController;
Route::prefix('v1')->group(function()
{
    Route::apiResource('categories', CategoryController::class);
});</code><p>просмотреть список роутов</p><code>./sail artisan route:list --except-vendor</code><p>В файле bootstrap/app.php можно добавить свой обработчик ошибок</p><code>use Illuminate\Foundation\Configuration\Exceptions;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (NotFoundHttpException $e, Request $request) {
    if ($request->is('api/*')) {
      return response()->json([
        'message' => 'Record not found.'
      ], 404);
    }
  });
})</code><p>Чтобы задать формат api ответа создать Resources</p><code>./sail artisan make:resource Api/V1/CategoryResource</code><p>в контроллере возврат данных таблицы через рессурс-коллекцию для массива данных</p><code>return CategoryResource::collection(Category::all());</code><p>для возврата одной записи из таблицы данных</p><code>new CategoryResource(Category::findOrFail($id));</code><p>либо</p><code>public function show(Category $category)
{
  return new CategoryResource($category);
}</code><p>в Api/V1/PostResource задаю условие: поле "content" показывать если роут posts.show</p><code>"content"=> $this->when(Route::currentRouteName() == 'posts.show', $this->content),</code><p>в Api/V1/PostResource по связи метода category из модели получаю свойство категории</p><code>"categoryName" => $this->category->title,</code><p>в Models/Post задаю связь с таблицей category методом category</p><code>public function category()
{
  return $this->belongsTo(Category::class);
}</code><p>в Models/Post задаю список полей, которые не участвуют в работе методов</p><code>protected $hidden = [
  "created_at",
];</code><p>в PostController по связи метода category из модели Models/Post получаю всё одним запросом
и вывожу частями по 5 постов</p><code>return PostResource::collection(Post::with('category')->paginate(5));</code><p>для ограничения количества запросов в App\Providers\AppServiceProvider добавить в метод boot()</p><code>use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
RateLimiter::for('api', function (Request $request) {
  return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});</code><p>ключить ограничение middleware(['throttle:api', 'auth:sanctum']) в роуты</p><code>Route::prefix('v1')->middleware(['throttle:api'])->group(function()</code><p>для доступа к данным апи через токен добавить в модель User</p><code>use Laravel\Sanctum\HasApiTokens;
use HasApiTokens</code><p>установить срок жизни токена в минутах в config/sanctum.php          </p><code>'expiration' = 10,</code><p>просроченные токены удалять командой sanctum:prune-expired</p><code>use Illuminate\Support\Facades\Schedule;
Schedule::command('sanctum:prune-expired --hours=24')->daily();
</code></details><details><summary>CRUD</summary><p>Create model</p><code>php artisan make:model Post -mfcr</code><p>Add columns in migration<br>
Define fillable columns and relation in Post model and relation in User model<br>
Fill database/factories/PostFactory.php and database/seeders/DatabaseSeeder.php<br>
Fill database fake data<br></p><code>php artisan migrate:fresh --seed</code><p>In resources/js/types/index.d.ts create interface Post<br>
Create link for images</p><code>php artisan storage:link</code><p>Add navItem in resources/js/components/app-sidebar.tsx to posts.index<br>
Copy resources/js/pages/dashboard.tsx to resources/js/pages/posts/index.tsx<br>
In resources/js/pages/posts/index.tsx import table from shadcn and create inertia link for post creating<br>
Copy resources/js/pages/auth/login.tsx to resources/js/pages/posts/create.tsx<br>
In resources/js/types/index.d.ts create type PostForm<br>
Import and past textarea from shadcn into resources/js/pages/posts/create.tsx<br>
Copy resources/js/pages/posts/create.tsx to resources/js/pages/posts/edit.tsx<br>
Create resource for posts<br></p><code>php artisan make:resource PostResource</code><p>Add to boot function AppServiceProvider</p><code>JsonResource::withoutWrapping();</code><p>Register route for posts/ in routes/web.php<br>
Fill methods in PostController<br>
Clear and optimazing data<br></p><pre><code>php artisan optimize
php artisan optimize:clear</code></pre><p>Add flash messages to app/Http/Middleware/HandleInertia/Requests<br>
In resources/js/types/index.d.ts create interface Flash<br>
Import sonner toaster from shadcn component into resources/js/layouts/app-layout.tsx<br>
Display toaster into resources/js/pages/posts/index.tsx<br>
</p><p>Access by SSH to VPS by password<br>
Authenticated like user for installed Laravel on VPS<br></p><code>su - user</code><p>To see domain folder with installed project</p><code>cd htdocs </code><p>Come into Laravel files</p><code>cd domainfolder</code><p>In domainfolder generate ssh key for VPS</p><code>ssh-keygen -t ed25519 -C "my@email.com"   // leave passphrase empty</code><p>Read VPS ssh public key</p><code>cat ~/.ssh/id_ed25519.pub   // copy the key</code><p>In github repository open settings>Deploy keys>Add deploy key, paste VPS ssh public key (Allow write server)<br>
Move installed Laravel files into tmp folder<br></p><code> mv domainfolder/ tmp</code><p>Clone Laravel files from private repository github by ssh into domainfolder<br></p><code>git clone githubUrl domainfolder</code><p>In domainfolder copy .env file</p><code>cp .env.exemple .env</code><p>In domainfolder</p><code>composer install</code><p>Create sqlite database</p><code>php artisan migrate</code><p>Create mysql database on VPS server panel and change database setting into .env for mysql<br>
Apply data into mysql database</p><code>php artisan migrate</code><p>Generate app key</p><code>php artisan key:generate --ansi</code><p>Install as root nodejs on VPS</p><a href="https://nodejs.org/en/download">Nodejs</a><p>In htdocs/domainfolder run as user</p><pre><code>npm install
npm run build</code></pre><p>Fill database fake data</p><code>php artisan migrate:fresh --seed</code><p>Test app in browser</p><a href="http://laravel.com/docs/12.x/queues#supervisor-configuration">automaticaly ssr on VPS install as root</a><a href="https://youtu.be/lqKbDEBa2B0">youtube tutorial at 5:20:00</a><p>In conf file change command to </p><code>artisan inertia:start-ssr</code><p>In .env file</p><pre><code>APP-NAME=Appname
APP_ENV=prod
APP_DEBUG=false
APP_URL=Appurl</code></pre><p>change mail settings</p><p>Create localy .github/workflows/deploy.yml with action for github<br>
Github repository>settings>Secrets and variables>Actions
Create new secret - see youtube tutorial 5:41:30
</p></details><details><summary>Rename table</summary><p>в файле config/queue.php меняю название таблиц по умолчанию<br>
к названию таблицы добавляю слово queue</p><pre><code>'database' => [
  'driver' => 'database',
  'connection' => env('DB_QUEUE_CONNECTION'),
  'table' => env('DB_QUEUE_TABLE', 'queued_jobs'),
  'queue' => env('DB_QUEUE', 'default'),
  'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
  'after_commit' => false,
],

'batching' => [
  'database' => env('DB_CONNECTION', 'sqlite'),
  'table' => 'queued_job_batches',
],
'failed' => [
    'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
    'database' => env('DB_CONNECTION', 'sqlite'),
    'table' => 'queued_failed_jobs',
], </code></pre><p>в папке database/migrations/<br>
к названию файла по умолчанию добавляю слово queue</p><code>0001_01_01_000002_create_queued_jobs_table.php</code><p>в нутри файлa к названиям таблиц добавляю слово queue</p><pre><code>Schema::create('queued_jobs', function (Blueprint $table) {
  ...
Schema::create('queued_job_batches', function (Blueprint $table) {
  ...
Schema::create('queued_failed_jobs', function (Blueprint $table) {</code></pre><p>удаляю старые файлы и создаю новые c учётом изменений</p><code>php artisan migrate:fresh</code><p>чтобы внести изменения в базу данных:</p><code>php artisan migrate</code></details></details></details></details></div></nav></main><footer> </footer></div></body></html>