<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="robots" content="noindex, nofollow"><meta name="robots" content="none"><meta name="robots" content="noimageindex, nofollow"><link rel="stylesheet" type="text/css" href="./style.min.css"><title>Skills</title></head><body><div class="wrapper"><header> <a class="logo" href="https://kwebhub.github.io/skills/">MAY THE FORCE BE WITH YOU</a></header><main><nav class="menu"><div class="menu__inner"><details><summary>Platform</summary><p>Design: react - tailwind | pug - scss - alpinejs</p><a href="https://github.com">Github</a><a href="http://www.figma.com">Figma</a><a href="https://dbdiagram.io">DB Diagram</a><a href="https://nodejs.org/en/download/">Node.js</a><a href="https://code.visualstudio.com">VSCode (Theme: Catppuccin Mocha, Font: Cascadia Code)</a><a href="http://www.contentful.com/blog/react-app-tailwind-css">React App Tailwind CSS</a><a href="http://www.github.com/gitname/react-gh-pages/">React GitHub Pages</a><br><p>Development:</p><a href="https://refactoring.guru/ru">Паттерны, рефакторинг, SOLID</a><a href="http://docs.docker.com/engine">Docker</a><a href="https://aws.amazon.com/ru/?nc2=h_lg">AWS</a><a href="https://laravel.com">laravel</a><a href="https://laravel.su/">laravel(ru)<br></a><br><p>Security: bash, linux, rust, net, crypto</p></details><details><summary>Symbols</summary><p>Symbols<br>
<b>0b11111111</b> - бинарная (двоичная) форма записи числа 255<br>
<b>0о377</b> - восьмиричная форма записи числа 255<br>
<b>0xff</b> - шестнадцатиричная форма записи числа 255<br>
<br>
Регулярные выражения<br>
<b>^</b> - циркумфлекс, значение начинается с указанной подстроки<br>
<b>$</b> - доллар, значение заканчивается указанной подстрокой<br>
<b>~</b> - тильда, значение содержит указанное слово<br>
<b>*</b> - звезда, значение содержит указанную подстроку<br>
<b>!</b> - восклецательный знак, значение без указанной подстроки<br>
<b>|</b> - вертикальная черта, значение содержит указанное слово или после этого слова знак дефиса<br>
</p></details><details><summary>API</summary><p><dfn>API</dfn> (Application programming interface) - это контракт, который предоставляется программою “Ко мне можно обращаться так и так, я обязуюсь делать то и это”.<br>
<dfn>API</dfn> -  это набор функций. <br>
Наборы группируются разработчиком по функционалу, по заказчику, по смыслу операций и т.д.<br>
<br>
<em>HTML, XML - языки:</em> <br>
  HTML - закрепленные теги, прощает некоторые синтаксические ошибки. <br>
  XML - теги создает пользователь, проверка синтаксиса и валидация документа по WDSL. <br>
<br>
<em>RPC, REST - архитектура API:</em> <br>
  RPC - запрос на выполнение функции на сервере по имени функции с входными параметрами. <br>
  REST - запрос с помощью установленных методов к ресурсу (сущности) на сервере. <br>
<br>
<em>XML, JSON - формат передачи данных:</em> <br>
  XML - наличие тегов, корневого элемента и пространства имен. Не может содержать массивы. <br>
  JSON - более компактный, не имеет тегов, может содержать в значениях массивы. <br>
<br>
<em>HTTP, SOAP - протоколы передачи данных:</em> <br>
  HTTP - протокол прикладного уровня передачи данных. <br>
  SOAP - формальный корпоративный подход, работает поверх любого протокола связи, даже асинхронно. <br>
<br>
<em>Наиболее распространенные связки:</em> <br>
  JSON + REST + HTTP <br>
  XML + RPC + SOAP <br>
<br>
<dfn>Интерфейс программирования приложений</dfn> (API) - это интерфейс или правила связи между клиентом и сервером, предназначенный для упрощения создания программного обеспечения на стороне клиента. <br>
API является важной абстракцией, описывающей функциональность «в чистом виде», безотносительно того, как реализована эта функциональность.<br>
<br>
<dfn>RPC</dfn> (Remote Procedure Call) <br>
<dfn>Удаленный вызов процедур</dfn> — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). <br></p><img src="./img/web/rpc.png" alt=""><img src="./img/web/rpc1.png" alt=""><br><p><dfn>REST</dfn> (Representational State Transfer) <br>
<dfn>Передача состояния представления</dfn> — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.<br>
REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой системы по модели клиент-сервер.<br>
Особенности архитектурного стиля:<br>
- Каждая сущность должна иметь уникальный идентификатор – URI<br>
- Сущности должны быть связаны между собой<br>
- Для чтения и изменения данных должны использоваться стандартные методы<br>
- Должна быть поддержка нескольких типов ресурсов<br>
- Взаимодействие должно осуществляться без состояния<br>
<br>
Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.<br>
Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35 страница в этой книге — /book/3/page/35.<br>
CRUD в REST:<br>
- GET /book/ — получить список всех книг<br>
- GET /book/3/ — получить книгу номер 3<br>
- POST /book/ — добавить книгу (данные в теле запроса)<br>
- PUT /book/3 – изменить книгу (данные в теле запроса)<br>
- DELETE /book/3 – удалить книгу<br>
<br>
Или:<br>
- GET /book/ — получить список всех книг<br>
- GET /book/3/ — получить книгу номер 3<br>
- POST /book/ — добавить книгу (данные в теле запроса)<br>
- POST /book/3 — изменить книгу (данные в теле запроса)<br>
- POST /book/3 — удалить книгу (тело запроса пустое)<br>
<br></p><img src="./img/web/MicroService.png" alt=""><p>RPC: Мы отправляем сообщение, и это может привести к тому, что что-то сохранится в базе данных для сохранения истории, что может быть другим вызовом RPC, возможно, с теми же именами полей. <br>
REST: Мы создаем ресурс сообщений в коллекции сообщений пользователя.<br>
Мы можем легко увидеть историю этого, выполнив GET для того же URL.<br></p><img src="./img/web/rpcrest.png" alt=""><img src="./img/web/rpcrest1.png" alt=""><p>API основанные на RPC прекрасно работают для действий (выполнения процедур или команд).<br>
API основанные на REST хороши для моделирования сущностей и применения CRUD (create, read, update, delete) для данных.<br>
<br>
<dfn>JSON</dfn> - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером.<br>
Он основан на подмножестве языка программирования JavaScript.<br>
Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. <br>
<br>
Ключи в JSON находятся с левой стороны от двоеточия.<br>
Их нужно оборачивать в двойные кавычки (например, "key ") и это может быть любая строка.<br>
В каждом объекте, ключи должны быть уникальными.<br>
Пробелы допускаются, но лучше их заменять знаком подчеркивания.<br>
Значения находятся с правой стороны от двоеточия.<br>
Значения могут быть одним из шести типов данных:<br>
Строкой<br>
Числом<br>
Объектом<br>
Массивом<br>
Булевым значением<br>
null<br></p><img src="./img/web/json1.png" alt=""><img src="./img/web/json2.png" alt=""><p>JSON более компактный и не требует тегов закрытия как в XML.<br>
Более того, XML не может использовать массивы, как в примере с JSON.
</p></details><details><summary>Markdown</summary><pre><code><span>Heading:</span>
# H1
## H2
### H3
#### H4
##### H5
###### H6

<span>Bold:</span>
**bold text**

<span>Italic:</span>
*italicized text*

<span>Strikethrough:</span>
~~The world is flat.~~

<span>Blockquote:</span>
> blockquote

<span>Ordered List:</span>
1. First item
2. Second item
3. Third item

<span>Unordered List:</span>
- First item
- Second item
- Third item

<span>Code:</span>
`code`

<span>Link:</span>
[title](https://www.example.com)

<span>Image:</span>
![alt text](image.jpg)

<span>Table:</span>
| Item         | Price | # In stock |
|--------------|:-----:|-----------:|
| Juicy Apples |  1.99 |        739 |
| Bananas      |  1.89 |          6 |

<span>Fenced Code Block:</span>
  {
    "firstName": "John",
    "lastName": "Smith",
    "age": 25
  }

<span>Footnote:</span>
Here's a sentence with a footnote. [^1]
[^1]: This is the footnote. 

<span>Heading ID:</span>
My Great Heading {#custom-id}

<span>Definition List:</span>
term
: definition

<span>Task List:</span>
- [x] Write the press release
- [ ] Update the website
- [ ] Contact the media 

<span>Emoji:</span>
That is so funny! :joy:

<span>Highlight:</span>
I need to highlight these ==very important words==. 

<span>Subscript:</span>
H~2~O

<span>Superscript:</span>
X^2^
</code></pre></details><details><summary>XML</summary><p><dfn>XML</dfn> - это язык разметки подобный HTML. <br>
Расшифровывается как (англ. <i>Extensible Markup Language</i> - Расширяемый Язык Разметки). <br>
В отличии от остальных языков разметки, XML сам по себе не определён (это означает, что вы должны сами определять используемые теги). <br>
Основной целью XML является передача данных между разными системами (даже концептуально разными), такими как интернет.<br>
Cвое название получил по той причине, что в нем нет фиксированного формата, как в HTML. <br>В то время как язык HTML ограничивается набором твердо закрепленных тегов, пользователи XML могут создавать свои собственные тэги, которые бы отвечали тематике документа. <br>Таким образом, XML - это метаязык. <br>Этот язык используется в качестве средства для описания грамматики других языков и контроля за правильностью составления документов.<br>
Для корректного XML документа должны исполняться следующие условия: <br>
Правильное оформление документа. <br>
Соблюдаться все синтаксические правила XML. <br>
Документ должен соответствовать семантическим правилам языка (которые обычно заданны в схеме XML или DTD (англ. Document Type Definition (en-US))).<br>
<br>
Сходство с HTML:<br>
- В XML существуют открывающие, закрывающие и пустые тэги.<br>
- Теги в документе могут быть вложены друг в друга.<br>
- Теги начала и конца элемента являются основными используемыми в XML разметками.<br>
- Тэги могут иметь атрибуты, причем количество атрибутов зависит от фантазии автора.<br>
- Документы XML могут содержать ссылки на другие объекты.<br>
<br>
Основные отличия от HTML: <br>
Большое внимание уделяется контролю документа. <br>
Проверка действительности документа предполагает выполнение следующих действий: <br>
- Синтаксическая проверка, <br>
- Проверка валидности документа.<br>
<br>
XML обычно используют для описания чего-то. <br>
Существуют методы отображения XML данных, но если вы не определили способ визуализации XML документа, то в браузере он отобразится построчно, как обычный текстовый файл. <br>
Один из методов отображения XML - указать CSS (чтобы использовать в документе нужно прописать инструкцию xml-stylesheet). <br></p><code>xml-stylesheet type="text/css" href="stylesheet.css"</code><br><p>Есть также много других мощных методов отображения XML, например, <dfn>XSLT</dfn>(англ. <i>Extensible Stylesheet Language Transformations</i>), который может использоваться для преобразование XML в другие языки такие, как HTML. <br>
Это делает XML очень универсальным. <br></p><code>xml-stylesheet type="text/xsl" href="transform.xsl"</code><br><img src="./img/web/XML_.png" alt=""><img src="./img/web/XMLDTD.png" alt=""><img src="./img/web/XMLEntities.png" alt=""></details><details><summary>HTML</summary><pre><code>&lt;div&gt;
  &lt;p&gt;Привет, мир!&lt;/p&gt;
&lt;/div&gt;</code></pre><p><dfn>Структура</dfn><br>
<b>!DOCTYPE</b> - Тип документа<br>
<b>html</b> - Корень HTML-документа<br>
<b>head</b> - Содержит метаданные/информацию для документа, блочный<br>
<b>title</b> - Название сайта, которое отображается во вкладке<br>
<b>body</b> - Тело документа, блочный<br>
<b>header</b> - Заголовок документа или раздела, блочный, семантика<br>
<b>nav</b> - Навигационные ссылки, блочный, семантика<br>
<b>main</b> - Основное содержимое документа, блочный, семантика<br>
<b>section</b> - Раздел в документе, семантика<br>
<b>aside</b> - Боковая панель сайта, второстепенный контент, семантика<br>
<b>div</b> - Контейнер, блочный<br>
<b>footer</b> - Нижний колонтитул документа или раздела, блочный, семантика<br>
<br>
<dfn>Вставка</dfn><br>
<b>script</b> - JS вставка<br>
<b>style</b> - CSS вставка<br>
<b>embed</b> - Контейнер для внешнего приложения, блочный<br>
<b>object</b> - Контейнер для внешнего приложения, блочный<br>
<b>template</b> - Контейнер для контента, который должен быть скрыт при загрузке страницы<br>
<b>iframe</b> - Встроенный фрейм (страница в странице)<br>
<b>noscript</b> - Альтернативный контент при не поддержании JS<br>
<br>
<dfn>Списки</dfn><br>
<b>details</b> - Спойлер, блочный<br>
<b>summary</b> - название спойлера<br>
<b>dl</b> - Список определений, блочный<br>
<b>dt</b> - Термин<br>
<b>dd</b> - Значение термина<br>
<b>ol</b> - Упорядоченный список, блочный<br>
<b>ul</b> - Неупорядоченный список, блочный<br>
<b>menu</b> - Неупорядоченный список, блочный<br>
<b>li</b> - Элемент списка, блочный<br>
<b>optgroup</b> label="" - Группу связанных параметров в раскрывающемся списке<br>
<b>option</b> value="" - параметр в раскрывающемся списке<br>
<b>label</b> for="cars" - Имя раскрывающегося списка<br>
<b>select</b> name="cars" id="cars"- Раскрывающийся список<br>
<b>option</b> value="" - Значение раскрывающегося списка<br>
<br>
<dfn>Текст</dfn><br>
<b>article</b> - Группировка связанных элементов в независимый объект, семантика<br>
<b>hgroup</b> - Заголовок и связанный контент, блочный<br>
<b>abbr</b> title="Расшифровка" - Аббревиатура или акроним, строчный<br>
<b>address</b> - Вывод контактной информации, строчный<br>
<b>b</b> - Жирный текст, строчный<br>
<b>small</b> - Меньший текст, строчный<br>
<b>span</b> - Часть текста в строке, строчный<br>
<b>strong</b> - Текст большой важности, строчный, семантика<br>
<b>u</b> - Подчеркнутый текст, строчный<br>
<b>sub</b> - Подстрочный текст<br>
<b>sup</b> - Надстрочный текст<br>
<b>bdi</b> - Изолирует часть текста, строчный<br>
<b>bdo</b> dir="rtl" - Переопределяет направление текста, строчный<br>
<b>blockquote</b> cite="ссылка на источник" - Раздел, цитируемый из другого источника, блочный, семантика<br>
<b>q</b> - Короткая цитата, семантика<br>
<b>time</b> - Вывод даты и времени, семантика<br>
<b>br</b> - Разрыв строки, строчный<br>
<b>cite</b> - Название произведения, вывод автора цитаты, строчный, семантика<br>
<b>code</b> - Часть компьютерного кода, строчный<br>
<b>data</b> value="номер продукта" - Ассоциирует название продукта с номером продукта, строчный<br>
<b>del</b> - Перечеркнутый текст, строчный<br>
<b>dfn</b> - Термин, который будет определен, строчный<br>
<b>em</b> - Выделенный текст, текст с ударением (более громко), отдельная мысль или перефразировка, строчный, семантика<br>
<b>h1</b> - h1 - h6, Заголовок, блочный, семантика<br>
<b>i</b> - Текст курсивом. Текст, который отличается (иностранное слово, мысли и т.д.), строчный<br>
<b>ins</b> - Текст, который был вставлен, строчный<br>
<b>kbd</b> - Текст, как ввод с клавиатуры, строчный<br>
<b>mark</b> - Отмеченный/выделенный текст особого внимания, строчный<br>
<b>s</b> - Неправильныйт текст<br>
<b>samp</b> - Текст как вывод компьютерной программы<br>
<b>var</b> - Текст как переменная<br>
<b>wbr</b> - Возможный разрыв строки<br>
<b>p</b> - Параграф, блочный<br>
<b>pre</b> - Предварительно отформатированный текст, блочный<br>
<b>ruby</b> - Аннотация Ruby (для восточноазиатской типографики)<br>
<b>hr</b> - Тематическое изменение содержания (линия), блочный<br>
<br>
<dfn>Ссылки</dfn><br>
<b>link</b> - Связывает с документом другой документ, блочный<br>
<b>a</b> href="ссылка" - Гиперссылка<br>
<b>a</b> href="#" target="_blank" title="Подсказка" class="" id="" style=""<br>
<b>a</b> href="tel: phone"<br>
<b>a</b> href="email: address"<br>
<b>base</b> href="..." - Базовый URL-адрес для всех относительных URL-адресов в документе, строчный<br>
<br>
<dfn>Формы</dfn><br>
<b>dialog</b> - Диалоговое окно, блочный<br>
<b>textarea</b> rows="" cols="" - Поле многострочного ввода (текстовая область)<br>
<b>button</b> - Кликабельная кнопка, блочный<br>
<br>
<b>table</b> - Таблица, блочный<br>
<b>caption</b> - Название таблицы, блочный<br>
<b>thead</b> - Шапка таблицы, блочный<br>
<b>tbody</b> - Тело таблицы, блочный<br>
<b>tr</b> - Строка таблицы, блочный<br>
<b>th</b> - Ячейка шапки таблицы, блочный<br>
<b>td</b> - Ячейка тела таблицы, блочный<br>
<b>tfoot</b> - Подвал таблицы, блочный<br>
<b>colgroup</b> - Группа столбцов в таблице<br>
<b>colspan</b> ="2" - Объединение столбцов в таблице<br>
<b>rowspan</b> ="2" - Объединение строк в таблице<br></p><pre><code>form action="" method=""
  label for="" /label
  input type="" id="" name="" value="" tabindex=""
  textarea name="" placeholder="" /textarea
  select
    option /option
  /select
  input type="submit" id="" name="" value="Надпись на кнопке"
  button /button
/form</code></pre><p><b>form</b> action="/action_page.php" - HTML-форма для ввода пользователя. Отвечает за отправку введенных данных, адрес передачи - атрибут action, метод передачи - атрибут method<br>
<b>fieldset</b> - Групперует элементы формы<br>
<b>legend</b> - Заголовок формы<br>
<b>label</b> for="fname" - Заголовок поля<br>
<b>input</b> type="text" id="fname" name="fname" - Поле ввода<br>
<b>input</b> type="submit" value="Submit" - Кнопка отправить<br>
<br>
<b>form</b> action="/action_page.php" method="get" - Форма с предопределённым списком вариантов для поля ввода<br>
<b>label</b> for="browser" - Заголовок поля<br>
<b>input</b> list="browsers" name="browser" id="browser" - Поле ввода<br>
<b>datalist</b> id="browsers" - Список вариантов<br>
<b>option</b> value="Edge" - Вариант ввода<br>
<b>input</b> type="submit" - Кнопка отправить<br>
<br>
<b>search</b> - Раздел поиска<br>
<b>form</b> - Форма поиска<br>
<b>input</b> name="" id="" placeholder="" - Поле ввода поиска<br>
<br>
<b>form</b> oninput="x.value=parseInt(a.value)+parseInt(b.value)" - Результат расчета<br>
<b>input</b> type="range" id="a" value="50" - ввод первого слагаемого<br>
+ <b>input</b> type="number" id="b" value="25" - ввод второго слагаемого<br>
= <b>output</b> name="x" for="a b" - вывод суммы<br>
<br>
<b>label</b> for="idname" - Заголовок манометра<br>
<b>meter</b> id="idname" value="" - Скалярное измерение в известном диапазоне (манометр)<br>
<br>          
<b>label</b> for="file" - Заголовок прогресса<br>
<b>progress</b> id="file" value="32" max="100" - Представляет ход выполнения задачи, блочный<br>
<br>
<dfn>Медиа</dfn><br>
<b>canvas</b> id="myCanvas" - Рисование графики на лету, блочный<br>
<b>svg</b> width="" height="" - Контейнер для графики SVG, блочный<br>
<b>img</b> src="" alt="" - Изображение, строчный<br>
<br>
<b>img</b> src="" alt="" usemap="#workmap" - Карта-изображения<br>
<b>map</b> name="workmap" - Карта-изображения<br>
<b>area</b> shape="" coords="" alt="" href="" - Карта-изображения<br>
<br>
<b>picture</b> - контейнер для нескольких вариантов ресурсов изображений, блочный<br>
  source media="(min-width: 650px)" srcset="img_food.jpg" - Адаптив без css, ускоряет загрузку верстки.<br>
  source media="(min-width: 465px)" srcset="img_car.jpg" <br>
  img src="img_girl.jpg" - Если браузер не поддерживает picture, то выведет img.<br>
/picture<br>
<br>
<b>figure</b> - Групировка медиа-элементов, блочный, изображение с доп.тегами<br>
  img src="" - медиа-элемент<br>
  figcaption  - Заголовок медиа-элемента<br>
<b>audio</b> controls - Встроенный аудио контент<br>
<b>source</b> src="horse.ogg" type="audio/ogg" - аудио контент<br>
<b>source</b> src="horse.mp3" type="audio/mpeg" - аудио контент<br>
<b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
<br>          
<b>video</b> width="" height="" controls - Встроенный видио контент, блочный<br>
<b>source</b> src="" type="" - видио контент<br>
<b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
<br>
<dfn>Мета</dfn>
<b>meta charset="UTF-8"</b> - Кодировка<br>
<b>meta name="viewport" content="width=1170"</b> - фиксированная ширина вся помещается в экран<br>
<b>meta name="viewport" content="width=device-width"</b> - адаптивный<br>
<b>meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</b> - параметры адаптивности<br>
<b>meta name="format-detection" content="telephone=no"</b> - отключает ссылку у номера телефона на iOS<br>
<b>meta name="description" content="<i>описание до 140 символов</i>"</b> - для SEO<br>
<b>meta name="keywords" content="<i>ключевые слова через запятую до 20</i>"</b> - ключевые слова для SEO<br>
<b>meta name="robots" content="noindex, nofollow"</b> - недопуск поисковых роботов к страице<br>
<b>meta name="robots" content="none"</b>
<b>meta name="robots" content="noimageindex, nofollow"</b> - запрет индексации картинок и ссылок<br>
<b>meta name="Author" content="<i>Дарт Вейдер</i>"</b> - Автор страницы<br>
<b>meta name="Copyright" content="<i>Люк Скайвокер</i>"</b> - Авторские права<br>
<b>meta name="Address" content="<i>Татуин, кратер № 97</i>"</b> - Адрес автора<br>
<b>meta http-equiv="refresh" content="0"; url=""</b> - обновляет страницу либо перенаправляет пользователя, указать количество секунд до перенаправления и адрес страницы<br>
<b>meta property="og:locale" content="<i>ru_RU</i>"</b> - локализация для русcкоязычного сайта<br>
<b>meta property="og:type" content="<i>article</i>"</b> - тип контента статья<br>
<b>meta property="og:title" content="<i>META теги</i>"</b> - заголовок записи в социальной сети<br>
<b>meta property="og:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
<b>meta property="og:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
<b>meta property="og:url" content="http://fls.guru/meta/ "</b> - ссылка на текущую страницу<br>
<b>meta property="og:site_name" content="<i>Название сайта</i>"</b> - Название сайта<br>
<b>meta name="twitter:card" content="<i>summary</i>"</b> - тип карты твитер<br>
<b>meta name="twitter:site" content="<i>Автор</i>"</b> - имя/логин автора<br>
<b>meta name="twitter:title" content="<i>META теги</i>"</b> - название страницы<br>
<b>meta name="twitter:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
<b>meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
<br>
p Валидаторы HTML:<br></p><a href="https://caninclude.glitch.me/">glitch<br></a><a href="https://validator.w3.org/">w3<br></a><a href="https://developers.facebook.com/tools/debug/sharing/"> Facebook<br></a><a href="https://ruogp.me/">ogp<br></a><a href="https://cards-dev.twitter.com/validator">twitter<br></a><a href="https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started">twitter<br></a><a href="https://www.w3schools.com/html/default.asp">W3schools<br></a></details><details><summary>Pug</summary><a href="https://pugjs.org/language/attributes.html">Официальная документация по Pug</a><p>Pug - это препроцессор HTML и шаблонизатор, который был написан на JavaScript для Node.js.<br>
<br>
В терминале:<br></p><code>pug -w . -o ./ -P -E php</code><p><b>pug</b> - компилировать файлы с расширением .pug<br>
<b>-w</b> - watcher - следить за изменениями в файлах<br>
<b>.</b> - текущий каталог (каталог слежения)<br>
<b>-o</b> - output - вывод скомпилированных файлов<br>
<b>./</b> - каталог вывода<br>
<b>-P</b> - pretty - удобочитаемый вид<br>
<b>-E php</b> - компилировать с расширением php<br>
<br>
В Pug нет закрывающих тегов, вместо этого он использует строгую табуляцию (отступы) для определения вложености тегов.<br>
Для закрытия тегов в конце необходимо добавить символ `/`: `foo(bar='baz')/`<br></p><pre><code>ul            
  li Item A
  li Item B
  li Item C</code></pre><p>Теги внутри строки<br></p><code>This is plain old <em>text</em> content.</code><br><p><dfn>Комментарии</dfn>
Существуют различные комментариев: те, которые будут отображаться после компиляции, и те, которые пропадут.</p><pre><code>//-
  Comments for your template writers.
  Use as much text as you want.
//
  Comments for your HTML readers.
  Use as much text as you want.</code></pre><p>Перенос текста на несколько строк</p><pre><code>| The
| mulyiline
| text</code></pre><p>или так</p><pre><code>The
mulyiline
text</code></pre><br><p>Синтаксис</p><pre><code>a(class='button' href='google.com') Google

input(type='checkbox' name='agreement' checked)

- var url = 'pug-test.html';
a(href='/' + url) Link

- url = 'https://example.com/'
a(href=url) Another link

- var classes = ['foo', 'bar', 'baz']
a(class=classes)

//- the class attribute may also be repeated to merge arrays
a.bang(class=classes class=['bing'])</code></pre><br><p>Многострочный ассоциативный массив</p><pre><code>-
  var priceItem = [
    {include: filterInc, parameter : "Розовый фильтр"},
    {include: smileInc, parameter : "Смайлики"},
    {include: commentInc, parameter : "Комментарии"}
  ]</code></pre><br><p><dfn>Условия</dfn></p><pre><code>- var user = { description: 'foo bar baz' }
- var authorised = false

// user
if user.description
  h2.green Description
  p.description= user.description
else if authorised
  h2.blue Description
  p.description.
    User has no description,
    why not add one...
else
  h2.red Description
  p.description User has no description

- var authenticated = true
body(class=authenticated ? 'authed' : 'anon')</code></pre><br><p><dfn>Конструкция Switch Case</dfn><br>
Pug поддерживает switch case, которая представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.</p><pre><code>- var friends = 10
case friends
  when 0
    p you have no friends
  when 1
    p you have a friend
  default
    p you have  friends</code></pre><br><p><dfn>Циклы</dfn></p><pre><code>ul                                            
  each val, index in ['zero', 'one', 'two']
    li= index + ': ' + val

- var values = [];
ul
  each val in values
    li= val
  else
    li There are no values

- var n = 0;
ul
  while n < 4
    li= n++</code></pre><br><p><dfn>Вставка JavaScript кода</dfn><br>
Pug поддерживает вставку частей JavaScript кода в шаблоны.<br>
Не буфферизированный код начинается с символа `-`  </p><pre><code>- for (var x = 0; x < 3; x++)                 
  li item</code></pre><br><p>Буфферизированный код начинается с символа `=`</p><pre><code>- let firstName = "Bob"
p= firstName
- let lastName = "Joe"
.full-name= firstName + " " + lastName
.full-name= `First name: ${firstName} Last name: ${lastName}`

- const names = ['Bob Joe', 'John Doe', 'Billy Bob', 'John Week']
ol
  each name in names
    li= name

-
  const friendsList = [
    {
      "firstName":"Bob",
      "lastName":"Joe",
      "mobile":"123456789"
    },
    {
      "firstName":"John",
      "lastName":"Doe",
      "mobile":"123456789"
    },
    {
      "firstName":"Billy",
      "lastName":"Bob",
      "mobile":"123456789"
    }
  ]

// friendsList
  each friend in friendsList
    .friend
      .first-name= friend.firstName
      .last-name= friend.lastName
      .mobile= friend.mobile

-
  const friendsList2 = []

// friendsList2
  each friend in friendsList
    .friend
      .first-name # {friend.firstName}
      .last-name # {friend.lastName}
      .mobile # {friend.mobile}
  else
    .oh-no You have no friends!

mixin friendCard(friend)
  .friend
    .first-name # {friend.firstName}
    .last-name # {friend.lastName}
    .mobile # {friend.mobile}

// friends
  each friend in friendsList
    +friendCard(friend)</code></pre><br><p><dfn>PHP</dfn><br>
вывод данных полученных из формы, код вместе с html в php файле.</p><pre><code>.friend.
  <?php
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
  ?></code></pre><p><b>.friend.</b> - точка вначале обозначает класс (friend), точка в конце означает, что далее многостраничный текст<br></p><br><p><dfn>Интерполяция переменных</dfn>
Pug предоставляет различные способы вывода переменных.</p><pre><code>- var title = "On Dogs: Man's Best Friend";
- var author = "enlore";
- var theGreat = "<span>escape!</span>";
h1= title
p Written with love by # {author}
p This will be safe: ! {theGreat}</code></pre><br><p>doctype html - Тип документа<br>
<br>
<dfn>Инклюды</dfn> (Includes)<br>
Pug имеет возможность вставки содержимого одного файла в другой файл Pug.</p><pre><code>doctype html
html
  head
    style
    include style.css
  body
    h1 My Site
    p Welcome to my super lame site.
    script
      include script.js</code></pre><p><dfn>Наследование шаблонов</dfn><br>
Pug поддерживает наследование шаблонов.<br>
Наследование шаблонов работает через ключевые слова <b>block</b> и <b>extend</b>.<br>
В шаблоне block - обычный блок Pug, который может заменить дочерний шаблон.<br>
Этот процесс является рекурсивным.</p><pre><code>// layout.pug
html
  head
    title My Site
    block scripts
      script(src='/jquery.js')
  body
    block content
    block foot
      #footer
        p some footer content

// home.pug
extends templates/layout
- var title = 'Animals'
- var pets = ['cat', 'dog']
block content
  h1= title // or h1 # {title}
  each petName in pets
    p= petName // or p # {petName}</code></pre><p><dfn>Миксины</dfn><br>
Поддержка миксинов позволяет создавать переиспользуемые блоки.</p><pre><code>// Declaration
mixin pet(name)
  li.pet= name
// use
ul                                              
  +pet('cat')
  +pet('dog')
  +pet('pig') 

mixin article(title)
  .article
    .article-wrapper
      h1= title
      if block
        block
      else
        p No content provided
+article('Hello world')
+article('Hello world')
  p This is my
  p Amazing article

mixin link(href, name)
// attributes == {class: "btn"}
  a(class!=attributes.class href=href)= name

+link('/foo', 'foo')(class="btn")
</code></pre></details><details><summary>CSS</summary><p><em>Стилем или CSS</em> (<i>Cascading Style Sheets, каскадные таблицы стилей</i>) <br>
  называется набор параметров форматирования,
  который применяется к элементам документа,
  чтобы изменить их внешний вид.<br>
  <em>Достоинства</em>:<br>
  - Разграничение кода и оформления<br>
  - Разное оформление для разных устройств<br>
  - Расширенные по сравнению с HTML способы оформления элементов<br>
  - Ускорение загрузки сайта<br>
  - Единое стилевое оформление множества документов<br>
<br>
<b>h1</b> <em>style</em> ="color: red;" - Внутренние стили. Приоритет максимальный.<br>
<br>
<b>style</b> - Глобальные стили<br>
  h1 {<br>
    color: red;<br>
  }<br>
<b>style</b><br>
<br>
<b>link</b> rel="stylesheet" href="<i>путь/к файлу/CSS</i>" - Связанные стили<br>
<br></p><a href="https://www.w3schools.com/css/default.asp">W3schools</a><details><summary>Селекторы</summary><pre><code>селектор {
  свойство: значение;
}</code></pre><p>- Базовые ( #id,.class, tag)<br>
- Иерархические (+, >, ~)<br>
- Атрибутные ([atribute])<br>
- :псевдоклассы (:hover, :visited и т.д.) - при действии<br>
- ::псевдоэлементы (::after, ::before) - добавляем элемент до или после выбранного<br>
<br>
<b>"tag</b> - имя тэга<br>
<b>".class</b> - CSS-класс<br>
<b>"#id</b> - ID тэга<br>
<b>"name = value</b> - Атрибут тэга<br>
<b>":filter</b> - фильтр<br>
<br>
<b>"*</b> - все элементы на странице<br>
<b>"sel, sel, sel</b> - выбор элементов по множетву селекторов<br>
<b>"sel sel</b> - всех потомков<br>
<b>"sel > sel</b> - только прямых потомков<br>
<b>"sel + sel</b> - следующий сосед этого же уровня<br>
<b>"sel ~ sel</b> - всех следующих соседей этого же уровня<br>
<br>
<b>[title="first"]</b> - атрибут title равен first<br>
<b>[title~="first"]</b> - атрибут title содержит слово first<br>
<b>sel:first-child {}</b> - первый ребенок<br>
<b>sel:last-child {}</b> - последний ребенок<br>
<b>sel:nth-child(2) {}</b> - второй ребенок<br>
<b>sel:nth-child(2n) {}</b> - каждый второй ребенок<br>
<b>sel:nth-child(even) {}</b> - чётные<br>
<b>sel:nth-child(add) {}</b> - нечётные<br>
<b>div.text {}</b>  применяем css-свойство к тегу div с классом text<br>
<b>.block.text {}</b>  применяем к тегам, содержащим оба класса<br>
<b>.block,.text {}</b>  применяем к тегам, содержащим один из классов<br>
<b>.block .text {}</b>  применяем к тегам, содержащим класс text и находящийся внутри элемента с классом block<br>
<b>.text > div {}</b>  применяем к первому div верхнего уровня внутри элемента с классом text<br>
<b>.block + .text</b> sibling<br>
<b>.block : hover</b> <br>
псевдоклассы состояния: hover, active, target, focus<br>
псевдоклассы навигации: first child, last child, first off type, last off type, not<br>
<b>.block :: after</b> псевдоэлементы: before, after<br>
@import "имя файла"; - импорт файлов<br>
<br>
<em>Параметр в качестве селектора</em>:<br>
[class*="__container"] {}  применяем css-свойство ко всем элементам с атрибутом class, значение которого содержит __container<br>
<br>
<em>Псевдокласс</em> - это модификатор селектора<br>
<b>.link:hover{}</b><br>
<b>:hover</b> - срабатывает при наведении<br>
<b>:visited</b> - срабатывает для посещенных ссылок<br>
<b>:active</b> - срабатывает при нажатии на элемент<br>
<b>:focus</b> - срабатывает при получении элементом фокуса<br>
<b>:first-child</b> - обращение к первому элементу в блоке<br>
<b>:last-child</b> - обращение к последнему элементу в блоке<br>
<b>:nth-child(номер элемента по порядку, odd, even)</b> - обращение к конкретному элементу в блоке<br>
<br>
<em>Псевдоэлемент</em><br>
строчный, модификатор содержимого элемента, синтаксис<br>
<b>.text:hover::befor{}</b> либо <b>.text::first-line{}</b><br>
<b>::first-line{}</b> - задает стиль первой строки текста<br>
<b>::first-letter{}</b> - задает стиль первого символа<br>
<b>::before</b> - для отображения контента до содержимого элемента, к которому применяется.<br>
  Обязательное свойство <b>content</b>: '';<br>
<b>::after</b> - для отображения контента после содержимого элемента, к которому применяется.<br>
  Обязательное свойство <b>content</b>: '';<br>
<br>
<em>БЭМ</em><br>
- блок - часть кода, которая повторяется или может повторяться самостоятельно<br>
- элемент - это часть блока. имя класса блока__имя класса элемента<br>
- модификатор - дополняет или уточняет стиль блока или элемента<br>
<br>
класс_модификатор<br>
класс__элемент_модификатор<br>
микс - позволяет использовать блоки и элементы в одном объекте<br>
<br>
<em>Абсолютные единицы измерения</em><br>
<b>px</b> (пиксель)  Все остальные еденицы измерения пересчитываются браузером в пиксели<br>
<br>
<em>Относительные единицы измерения</em><br>
<b>em</b> - равен текущему размеру объекта.<br> Лучше использовать для медиа-запросов и в случае когда нужно привязаться к текущему размеру шрифта.<br>
<b>rem</b> - равен размеру шрифта в теге html, а если там нет, то браузера по умолчанию (16px).<br> Т.е. не зависит от резмаера шрифта родителя.<br> Лучше использовать для размеров шрифтов, отступов, не указывая размер для тега html.<br>
<b>%</b> - разные свойства css вычисляют % от разных оснований.<br> Лучше использовать для отзывчивых резиновых конструкций, для позиционирования объектов и для скрола.<br>
<b>vw, vh, vmin, vmax</b> - работают относительно окна браузера (viewport).<br> Лучше использовать для полноэкранных блоков и scss вычислений.<br>
<b>fr</b> - единица измерения в модуле grid.<br>
<b>ex</b> - единица измерения относительно размера прописной "е".<br>
<b>ch</b> - единица измерения относительно размера 0.<br>
</p></details><details><summary>Свойства</summary><p><em>Текст</em><br>
<b>font-family</b> - семейство шрифта.<br>
<b>font-size</b> - размер шрифта елемента.<br>
<b>font-style</b> - начертание шрифта (курсив, наклон и нормальный)<br>
<b>font-weight</b> - насыщенность (вес) шрифта<br>
<b>color</b> - цвет текста<br>
<b>text-align</b> - горизонтальное выравнивание текста<br>
<b>text-decoration</b> - оформление текста (подчеркивание, перечеркивание и т.д.)<br>
<b>text-shadow</b> - добавляет тень к тексту<br>
<b>text-transform</b> - преобразование заглавных и прописных символов<br>
<b>text-ident</b> - отступ первой строки от края блока<br>
<b>letter-spacing</b> - определяет интервал между символами<br>
<b>word-spacing</b> - определяет интервал между словами<br>
<b>white-space</b> - управляет свойствами пробелов между словами<br>
<b>line-height</b> - устанавливает межстрочный интервал текста<br>
<br>
<em>Геометрия</em><br>
<b>padding</b> - внутренний отступ блочных тегов<br>
<b>margin</b> - внешний отступ блочных тегов<br>
<b>width</b> - ширина блочных тегов<br>
<b>max-width</b> - устанавливает макимальную ширину блочных тегов<br>
<b>min-width</b> - устанавливает минимальную ширину блочных тегов<br>
<b>height</b> - устанавливает высоту блочных тегов<br>
<b>max-height</b> - устанавливает максимальную высоту блочных тегов<br>
<b>min-height</b> - устанавливает минимальную высоту блочных тегов<br>
<br>
<em>Отоброжение</em><br>
<b>overflow</b> - управляет отображением содержания блочного елемента<br>
<b>display</b> - определяет как елемент должен быть показан в документе<br>
<b>border</b> - граница блока<br>
<b>border-radius</b> - устанавливает радиус скругления уголков блока<br>
<b>outline</b> - внешняя граница блока<br>
<b>box-shadow</b> - добавляет тень к блоку<br>
<b>opacity</b> - определяет уровень прозрачности элемента<br>
<b>visibility</b> - отображение или скрытие блока<br>
<b>background</b> - управляет фоном элемента<br>
<b>background-color</b> - цвет фона элемента<br>
<b>background-image</b> - фоновое изображение или градиентная заливка<br>
<b>background-repeat</b> - повторение фонового изображения<br>
<b>background-position</b> - положение фонового изображения<br>
<b>background-attachment</b> - прокручивание фона вместе с содержимым элемента<br>
<b>background-size</b> - размеры фонового изображения<br>
<b>background</b> - позволяет задать несколько фоновых изображений одному блоку<br>
<b>background-origin и background-clip</b> - отвечают за показ фона вместе с границей border.<br>
<br>
<em>Позиционирование</em><br>
<b>position</b> - совйство позиционирования устанавливает тип позиционирования элемента относительно других элементов или окна браузера<br>
<b>position: static</b>; - по умолчанию у всех блоков<br>
<b>position: relative</b>; - положение относительно изначального места в коде, обязательно с:<br>
<b>left, top, right, bottom</b> - управляют позицией элемента<br>
<b>z-index</b> - управляет наложением элементов<br>
Для взаиморасположения относительно друг друга у одного элемента должно быть absolute у другого relative<br>
<b>position: absolute</b>; - утрачивает связь с местом в коде и свойствами тега, обязательно с:<br>
<b>position: fixed</b>; - фиксирует элемент относительно окна браузера не завися от элементов с relative и прокрутки обязательно с: left, top, right, bottom - управляют позицией элемента<br>
<b>position: sticky</b>; - переводит элемент из static в fixed при достижении элементом указаной позиции обязательно с: left, top, right, bottom - управляют позицией элемента<br>
<br>
<em>Трансформ</em><br>
<b>transform</b> - применяется только к блочным объектам<br>
<b>transform: translate(0px, 0px</b>); - translate сдвигает элемент на новое место<br>
<b>transform: scale(1, 1)</b>; - scale масштабирует изображения, т.е. zoom. При отрицательном значении - зеркалит.<br>
<b>transform: rotate(0deg)</b>; - поворачивает элемент. Положительное значение по часовой, отрицетельное - против.<br>
<b>transform: skew(0deg, 0deg)</b>; - деформирует стороны объекта по вертикали и горизонтали.<br>
<b>transform: matrix(a, b, c, d, e)</b>; - позволяет объединить трансформации. Значения без едениц измерения.<br>
<b>transform: translate(0px, 0px) scale(1, 1) rotate(0deg)</b>;
<b>transform-origin: center</b>; - смещает центр трансформации<br>
<b>perspective: 0px</b>; - установка глубины перспективы<br>
<b>perspective-origin: center</b>; - смена точки начала координат<br>
<b>transform: translate3d(0px, 0px, 0px)</b>;<br>
<b>transform: scale3d(1, 1, 1)</b>;<br>
<b>transform: rotate3d(x, y, z, deg)</b>;<br>
<b>transform: matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n)</b>; - 16 значений<br>
<b>transform: translate3d(0px, 0px, 0px) rotate3d(1, 1, 1, 0deg)</b>;
<b>transform-style: flat</b>; - задает стиль трансформации<br>
<b>backface-visibility: visible</b>; - показывает обратную сторону объекта<br>
<br>
<em>Шрифты</em> подключаем любо в html тегом <b>link</b> либо в scss через <b>@import</b><br>
fonts.google.com<br>
nomail.com.ua<br>
font2web.com<br>
<br>
БЭМ: ru.bem.info<br>
</p></details><details><summary>Flex</summary><p><b>display</b>: flex; - включает флекс разметку<br>
<b>display</b>: inline-flex; - строчный флекс-контейнер<br>
<br>
<b>justify-content</b> - определяет выравнивание вдоль основной оси<br>
<b>justify-content</b>: flex-start; - елементы слева<br>
<b>justify-content</b>: flx-end; - елементы справа<br>
<b>justify-content</b>: cnter; - елементы в центре<br>
<b>justify-content</b>: space-between; - пространство между елементами<br>
<b>justify-content</b>: space-around; - пространство вокруг елементов<br>
<br>
<em>для флекс-контейнера:</em>
<b>align-items</b> - определяет поведение вдоль перекрёсной оси<br>
<b>align-items</b>: stretch; - елементы подстраиваются под самый высокий<br>
<b>align-items</b>: flex-start; - высота флекс-елемента от верха на высоту контента<br>
<b>align-items</b>: flex-end; - высота флекс-елемента от низа на высоту контента<br>
<b>align-items</b>: center; - флекс-елементы выстроятся по горизонтальному центру самого высокого елемента<br>
<b>align-items</b>: baseline; - выстраивает флекс-елементы по базовой линии<br>
<b>flex-wrap</b>: nowrap; - флекс-елементы не адаптируются<br>
<b>flex-wrap</b>: wrap; - флекс-елементы адаптируются<br>
<b>flex-wrap</b>: wrap-reverse; - флекс-елементы адаптируются в обратном порядке<br>
<br>
<em>для флекс-елемента:</em>
<b>align-self</b> - переопределяет выравнивание<br>
<b>align-self</b>: stretch;<br>
<b>align-self</b>: center;<br>
<b>align-self</b>: flex-start;<br>
<b>align-self</b>: flex-end;<br>
<br>
<b>order</b> - порядок вывода елементов<br>
<b>order</b>: 1; - выводим первым<br>
<b>flex-basis</b> - базовый размер элемента<br>
<b>flex-basis</b>: auto; - по размеру контента<br>
<br>
<b>flex-grow</b> - возможность увеличиваться в размере<br>
<b>flex-grow</b>: 0; - не больше чем flex-basis<br>
<b>flex-shrink</b> - возможность уменьшаться в размере<br>
<b>flex-shrink</b>: 1; - разрешено становиться меньше<br>
<b>flex</b>: 0 1 auto; - короткая запись flex-grow flex-shrink flex-basis<br>
<br>
<b>flex-direction</b> - устанавливает основную ось<br>
<b>flex-direction</b>: row; - в ряд<br>
<b>flex-direction</b>: row-reverse; - в обратную сторону в обратном порядке<br>
<b>flex-direction</b>: column; - основная ось вертикально<br>
<b>flex-direction</b>: column-revers; - вертикально снизу вверх<br>
</p></details><details><summary>GRID</summary><p><b>display</b>: grid; - определяет блочный грид-контейнер<br>
<b>display</b>: inline-grid; - определяет строчный грид-контейнер<br>
<b>grid-template-columns</b>: ; - управление колонками<br>
<b>grid-template-rows</b>: ; - управление рядами<br>
<b>grid-template-columns</b>: 200px minmax(150px, 1fr) 200px; - первая колонка шириной 200рх, вторая - минимум 150рх и максимум на всю ширину грид-контейнера, третья - шириной 200рх<br>
<b>grid-template-rows</b>: 1fr 1fr; - два ряда делят высоту грид-контейнера поровну<br>
<b>grid-template-columns</b>: fit-content(400px) 1fr auto; - ширина первой колонки по контенту, но не шире 400рх, вторая колонка - вся свободная ширина блока, третья колонка по ширине контента<br>
<b>grid-template-columns</b>: repeat(3, 1fr); - 3 колонки размером 1fr<br>
<b>grid-template-areas</b>: ; - управляет областями<br>
<b>grid-area</b>: ; - применяется к елементам<br>
<b>grid-template</b>: repeat(2, 1fr) / repeat(3, 1fr); - две равные строки и три равные колонки<br>
<b>grid-template</b>:<br>
[start] "header header" 100px [row2]<br>
[row2]  "side content" 1fr [row-end] / 150px 1fr; - управление областями, через свойство grid-area присваиваем имена элементам, в первом ряду header занимает две колонки, второй ряд содержит колонки side и content, высота рядов 1fr, ширина колонок 150px 1fr.<br>
<b>grid-auto-rows</b>: ; - управляет рядом неявной сетки, т.е. ряд, который не обозначен в grid-template-rows<br>
<b>grid-auto-columns</b>: ; - если не задан grid-template-columns<br>
<b>grid-auto-flow</b>: row; - выстраивает грид-элементы поочередно в ряд<br>
<b>grid-auto-flow</b>: column; - выстраивает грид-элементы поочередно в колонку<br>
<b>grid-auto-flow</b>: dense; - выстраивает грид-элементы в произвольном порядке<br>
<br>
<em>Размещение элементов с помощью линий сетки</em>:<br>  
<b>grid-row-start</b>: auto;<br>
<b>grid-row-end</b>: auto;<br>
<b>grid-column-start</b>: auto;<br>
<b>grid-column-end</b>: auto;<br>
<b>grid-row-start</b>: span 2; объект занимает 2 строчки<br>
<b>grid-template-rows</b>: [start] 1fr [row2] 1fr [row-end]; - две строки одинаковой высоты и [имена линий] между строк сверху вниз<br>
<b>grid-template-columns</b>: [start] 1fr [col2] 1fr [col3] 1fr [col-end]; - три столбца одинаковой ширины и [имена линий] меду столбцами слева направо<br>
<b>grid-row</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
<b>grid-column</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
или<br>
<b>grid-row</b>: start / row2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
<b>grid-column</b>: start / col2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
<b>order</b>: 1; - задается каждому елементу сетки и определяет порядок вывода елемента<br>
<b>justify-items</b>: stretch; - растягивает/прижимает елементы в ячейках вправо/влево<br>
<b>align-items</b>: stretch; - растягивает/прижимает елементы в ячейках вверх/вниз<br>
<b>row-gap</b>: 20px; - расстояние между строками<br>
<b>column-gap</b>: 20px; - расстояние между колонками<br>
или<br>
<b>gap</b>: 20px; - и для строк и для колонок одновременно<br>
</p></details><details><summary>Адаптивная верстка</summary><p><em>отзывчивая</em> - всё в <b>%</b>, указываем только максимальную ширину для body, весь контент на своём месте, отзывается на изменение ширины экрана.<br>
<em>адаптивная</em> - <b>брейкпоинты</b>, медиа-запросы, контент перестраивается на брейкпоинтах при изменении ширины экрана.<br>
<em>отзывчиво-адаптивная</em> - делаем отзывчиую пока читается контент при уменьшении ширины экрана. При ширине плохо читабельного контента далем брейкпоинт - адаптив.<br>
<b>meta</b> name="viewport" content="width=device-width"<br>
<em>Брейкпоинт</em>:</p><pre><code>@media (max-width:1200px){
  .container{
    max-width: 970px;
  }
}

@media (max-width:992px){
  .container{
    max-width: 750px;
  }
}

@media (max-width:767px){
  .container{
    max-width: none;
  }
}</code></pre><b>@import</b> url(color.css) screen and (color); - медиа-запрос в css,<br>
<b>link</b> rel="stylesheet" media="screen and (color)" href="example.css" - медиа-запрос в html: файл стилей подключится в только при выполнении условия медиа-запроса<br></details><details><summary>Animation</summary><pre><code><b>@keyframes</b> <i>grow</i> {
  <b>from</b> {
    font-size: 20px;
  }
  <b>to</b> {
    font-size: 100px;
  }
}

<b>h1</b> {
  <b>animation-name</b>: <i>grow</i>;
  <b>animation-direction</b>: 2s;
  <b>animation-fill-mode</b>: forwards;
}

<span>или</span>

<b>@keyframes</b> <i>grow</i> {
  <b>from</b> {
    left: 0%;
  }
  <b>to</b> {
    left: 50%;
  }
}

<b>h1</b> {
  <b>position: relative</b>
  <b>animation-name</b>: <i>grow</i>;
  <b>animation-direction</b>: 2s;
  <b>animation-fill-mode</b>: forwards;
}</code></pre><p><b>animation-name</b>: имя ключевых кадров, имя ключевых кадров № 2; - список применяемых к элементу анимаций (кадров)<br>
<b>animation-duration</b> - продолжительность анимации<br>
<b>animation-timing-function</b> - сценарий анимации<br>
<b>animation-iteration-count</b> - количество повторов ключевых кадров<br>
<b>animation-direction</b> - тип и направление проигрования ключевых кадров<br>
<b>animation-play-state</b> - запускает либо приостанавливает анимацию по событию<br>
<b>animation-name</b>: none; - возвращает анимацию на исходную<br>
<b>animation-delay</b> - задержка перед началом анимации<br>
<b>animation-fill-mode</b> - определяет какие свойства применятся после завершения анимации<br>
<b>animation</b>: name duration function count direction delay mode;<br>
<b>animation</b>: firstname 2s linear infinite alternate 0s forwards, secondname 5s ease infinite alternate 0s forwards;<br>
<br>
Сколько свойств - столько и значений transition-duration через запятую<br>
<b>transition-duration</b> - время перехода<br>
<b>transition-property</b> - содержит css свойства к которым будет применен переход<br>
<b>transition-delay</b> - время задержки перехода<br>
<b>transition-timing-function</b> - сценарий анимации<br>
<b>общая запись</b>: transition: all 1s ease 0s; - transition: property duration function delay;<br>
<b>transition</b>: padding 1s ease 0s, color 2s ease-in 0.5s;<br>
</p></details><details><summary>Графика</summary><p><b>JPEG/JPG</b> - растровый, оптимизируется хорошо, лучше для контента<br>
<b>PNG</b> - растровый, оптимизируется плохо, может быть прозрачным, лучше для фона и элементов дизайна<br>
<b>GIF</b> - растровый, до 256 цветов, видеоролик в формате изображения, оптимизируется хорошо<br>
<b>SVG</b> - векторный, хорошо подходит для иконок и при масштабировании изображения<br>
<b>WebP</b> - замена всех растровых форматов (прозрачность, анимация, хорошо оптимизируется)<br>
<b>ico</b> - растровый, оптимизируется хорошо, может быть прозрачным, 16х16рх, для иконок<br>
<b>link</b> rel="shortcut icon" href="favicon.ico"<br>
<b>object</b> - работа с изображениями в контейнере как background в фоне<br>
<b>object-fit</b>: fill; - управляет изображением внутри контейнера<br>
<b>object-position</b>: center; - позиционирование изображения относительно родителя<br>
</p></details><a href="https://www.youtube.com/@OnlineTutorialsYT">OnlineTutorialsYT</a><a href="https://www.youtube.com/@codeonly">Code Only</a><a href="https://www.youtube.com/playlist?list=PLM6XATa8CAG6IJvQBkrTTNZmpIcyS2Avk">Как сделать</a><a href="https://www.youtube.com/watch?v=kfOe-F64C_A&amp;list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr&amp;index=9">Уроки HTML CSS JS</a><a href="https://www.youtube.com/playlist?list=PLN2KCaMlZNdCBrVcXJXEO1iaTkZIMEA7R">Верстка сайта от 0 до 1</a><a href="https://www.w3.org/TR/cssom-1/">CSSOM</a></details><details><summary>Sass</summary><p><em>Sass</em> - препроцессор, добавляет функционала в css<br>
<em>SCSS</em> - синтаксис Sass похожий на синтаксис css<br>
<em>Вложенность</em> - писать правила css внутрь других правил<br>
<em>&</em> - подставляет вместо себя класс, внутри которого указан. Удобно для указания псевдоклассов и псевдо элементов<br> 
<em>$var:80px;</em> - переменная var со значением 80 пикселей<br>
<br>
<em>Шаблоны</em>:<br>
<b>%tpl</b> {параметры css} - задаём шаблон tpl<br>
<b>@extend</b> %tpl; - вставляем в нужный блок правил css<br>
либо<br>
<b>.tpl</b> {параметры css} - задаём шаблон tpl<br>
<b>@extend</b> .tpl; - вставляем в нужный блок правил css<br></p><pre><code>%message {
  <b>font-family</b>: sans-serif;
  <b>font-size</b>: 18px;
  <b>font-weight</b>: bold;
  <b>border</b>: 1px solid black;
  <b>padding</b>: 20px;
  <b>maigin</b>: 20px;
}

.success {
  <b>@extend %message</b>;
  <b>background-color</b>: green;
}

.warning {
  <b>@extend %message</b>;
  <b>background-color</b>: orange;
}

.error {
  <b>@extend %message</b>;
  <b>background-color</b>: red;
}</code></pre><br><p><em>Миксины</em>:<br>
@<b>mixin</b> exempl($var) {font-size: $var;} - объявляем миксин с переменной<br>
@<b>include</b> exempl(100px); - вставляем в нужный блок правил css со значением поддерживает математические рассчеты<br>
<br>
<em>Комментарии</em>:<br>
<b>/* */</b> - отображается и в файле scss и в css<br>
<b>//</b> - отображается только в файле scss<br></p><br><a href="https://sass-scss.ru/">Manual</a></details><details><summary>jQuery</summary><p>(function( $ ) {alert($.fn.jquery);}) - проверить версию<br>
<br>
Подключить<br></p><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;</code><p><b>compressed</b> - сжатая и минифицированная, поключают к готовому сайту<br>
<b>uncompressed</b> - обычная, удобочитаемая, поключают при разработке<br>
<b>slim</b> - без анимации и без Ajax<br>
<br>
<em>Скрипт</em></p><pre><code><span>запускать скрипт только после загрузки страницы</span>
$(document).ready(function() {
  <span>при нажатии кнопки</span>
  $("button").on("click", function() {
    <span>скрыть заголовок в течении 3-х секунд</span>
    $("h1").hide(3000);
  });
});</code></pre><br><p><em>Селекторы</em> - все как в CSS</p><pre><code>$('a'); = document.querySelectorAll("a");
$('sel').method();

<span>выбрать элементы по атрибуту - target</span>
$('a[target]');

<span>выбрать элементы с атрибутом target равное _blank</span>
$('a[target="_blank"]')</code></pre><br><p>По элементам форм:<br>
:button<br>
:password<br>
:disabled<br>
:file<br>
<br>
CSS</p><code>$("p").css("background-color", "#2ecc71");</code><br><p>Пример:<br>
&lt;a href="https://ya.ru" target="_blank" title="Переход на Яндекс"&gt;Yandex&lt;/a&gt<br>
<br>
Выбрать элементы, у которых значение атрибута:<br>
<b>$('a[href^="https"]')</b> - href начинается с https<br>
<b>$('a[href$=".ru"]')</b> - href заканчивается на .ru<br>
<b>$('a[title~="Яндекс"]')</b> - title содержит слово Яндекс<br>
<b>$('a[title*="epe"]')</b> - title содержит подстроку ере<br>
<b>$('a[href!="https://www.google.com"]')</b> - выберет элементы, у которых либо нет указанного атрибута, либо у атрибута другое значение
<br>
<em>Фильтры</em><br>
<b>$("li:first").css("color", "green")</b>;<br> 
- <b>:first, :last, :even, :odd</b> - первый, последний, чётный, нечётный из выборки<br>
- <b>:eq(), :gt(), :lt()</b> - индексы элемнтов выборки<br>
- <b>:root, :header, :focus, :lang()</b>, :target - HTML-элементы<br>
- <b>:not()</b>, :animated - отрицанние и анимирование<br>
<br>
<b>$("li").filter(":first").css("color", "green")</b>; - :first - не является частью языка css, поэтому через метод filter()</p><br><a href="https://jquery.com">jQuery</a><a href="https://www.w3schools.com/jquery/default.asp">W3schools</a><a href="https://core.trac.wordpress.org/query">Wordpress jQuery</a></details><details><summary>Alpinejs</summary><a href="https://alpinejs.dev/">alpinejs<br></a><p>К событию JS нужно добавить @. Например @click. </p><a href="https://developer.mozilla.org/ru/docs/Web/Events">Events</a><table><caption>Directives</caption><thead><tr> <th>Directive</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/directives/data">x-data</a></td><td>определяет часть HTML как компонент Alpinejs и предоставляет ему данные </td></tr><tr><td> <a href="https://alpinejs.dev/directives/init">x-init</a></td><td>позволяет выполнить действие в момент когда Alpinejs инициализирует элемент </td></tr><tr><td> <a href="https://alpinejs.dev/directives/show">x-show</a></td><td>показывает или прячет DOM элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/bind">x-bind</a></td><td>устанавливает атрибуты HTML элемента на основании вычислений</td></tr><tr><td> <a href="https://alpinejs.dev/directives/on">x-on</a></td><td>выполняет код при получении события</td></tr><tr><td> <a href="https://alpinejs.dev/directives/text">x-text</a></td><td>вставляет текст в элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/html">x-html</a></td><td>вставляет html разметку в элемент</td></tr><tr><td> <a href="https://alpinejs.dev/directives/model">x-model</a></td><td>связавыет значение с данными</td></tr><tr><td> <a href="https://alpinejs.dev/directives/modelable">x-modelable</a></td><td>указывает значение, которое нужно связать со значением x-model</td></tr><tr><td> <a href="https://alpinejs.dev/directives/for">x-for</a></td><td>создаёт DOM элементы перебирая массивы и объекты</td></tr><tr><td> <a href="https://alpinejs.dev/directives/transition">x-transition</a></td><td>плавное появление и исчезновение элемента</td></tr><tr><td> <a href="https://alpinejs.dev/directives/effect">x-effect</a></td><td>меняет элемент когда меняются его зависимости</td></tr><tr><td> <a href="https://alpinejs.dev/directives/ignore">x-ignore</a></td><td>Alpine пропускает этот элемент во время инициализации</td></tr><tr><td> <a href="https://alpinejs.dev/directives/ref">x-ref</a></td><td>обозначает элемент для $refs</td></tr><tr><td> <a href="https://alpinejs.dev/directives/cloak">x-cloak</a></td><td>скрывает элемент пока не загрузится Alpine<br>
add to CSS [x-cloak] { display: none !important; }</td></tr><tr><td> <a href="https://alpinejs.dev/directives/teleport">x-teleport</a></td><td>переносит часть шаблона < template > в другую часть страницы</td></tr><tr><td> <a href="https://alpinejs.dev/directives/if">x-if</a></td><td>добавляет и удаляет элементы по словию</td></tr><tr><td> <a href="https://alpinejs.dev/directives/id">x-id</a></td><td>собирает в массив id сгенерированные с помощью $id<br>
создаёт им scope и добавляет к ним суффикс
</td></tr></tbody></table><table><caption>Magics</caption><thead><tr><th>Magic</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/magics/el">$el</a></td><td>выбирает текущий элемент</td></tr><tr><td><a href="https://alpinejs.dev/magics/refs">$refs</a></td><td>выбирает элемент c x-ref</td></tr><tr><td><a href="https://alpinejs.dev/magics/store">$store</a></td><td>доступ к глобальному хранилищу, созданного через Alpine.store()</td></tr><tr><td><a href="https://alpinejs.dev/magics/watch">$watch</a></td><td>наблюдает за указанным элементом</td></tr><tr><td><a href="https://alpinejs.dev/magics/dispatch">$dispatch</a></td><td>создает события браузера</td></tr><tr><td><a href="https://alpinejs.dev/magics/nextTick">$nextTick</a></td><td>выполняет действие после после выполнения первого</td></tr><tr><td><a href="https://alpinejs.dev/magics/root">$root</a></td><td>выбирает ближайший родительский элемент с x-data</td></tr><tr><td><a href="https://alpinejs.dev/magics/data">$data</a></td><td>содежит значения всех x-data, через которых всплывает событие</td></tr><tr><td><a href="https://alpinejs.dev/magics/id">$id</a></td><td>создаёт id для элементов избегая конфликтов одинаковых имён</td></tr></tbody></table><table><caption>Globals</caption><thead><tr><th>Global</th><th>Description</th></tr></thead><tbody> <tr><td> <a href="https://alpinejs.dev/globals/alpine-data">Alpine.data()</a></td><td>вынести контекст x-data в отдельную функцию и переиспользовать</td></tr><tr><td> <a href="https://alpinejs.dev/globals/alpine-bind">Alpine.bind()</a></td><td>вынести контекст x-data в отдельную функцию и переиспользовать</td></tr><tr><td> <a href="https://alpinejs.dev/globals/alpine-store">Alpine.store()</a></td><td>управление глобальным хранилищем</td></tr></tbody></table></details><details><summary>JS</summary><details><summary>Синтаксис</summary><p>&lt;<b>script</b>&gt;alert('Привет мир!') &lt;/<b>script</b>&gt; - вставить скрипт в html, либо<br>
&lt;<b>script</b> src="/path/to/script.js"&gt; &lt;/<b>script</b>&gt; - подключить в html файл со скриптом.<br>
<b>"use strict"</b> или <b>'use strict'</b> - строгий режим. Отключить невозможно.<br>
Классы и модули строгий режим включают автоматически.<br>
<br>
Имена должны быть легко читаемые, camelCase, описательные и лаконичные.<br>
<b>" "</b> или <b>' '</b> - это строка<br>
<b>`${...} `</b> - вставить выражение в строку<br>
<b>//</b> - однострочный комментарий<br>
<b>/*...*/</b> - многострочный комментарий<br>
<br>
<dfn>Блок инструкций</dfn>:</p><pre><code>{
  console.log('Учим');
  console.log('JS');
}</code></pre><br><p><dfn>Область видимости {}</dfn><br>
<b>const KNOW_VAL = I know the value</b>; - константа с известным заранее значением пишем в верхнем регистре<br>
<b>const donotKnow = I don't know the value</b>; - константа с неизвестным заранее значением<br>
<b>var</b> - ключевое слово переменной, можно использовать до объявления.<br>
область видимости в пределах модуля, <br>
исключение: если объявлена в теле функции, то видна только в теле функции.<br>
<br>
<dfn>Комментируй</dfn>:<br>
  - общую архитектуру<br>
  - использование функций<br>
  - неочевидные решения<br>
  - важные детали<br>
<em>Не комментируй что делает код.</em><br>
<br></p><table><caption><dfn>Значения</dfn>:</caption><thead><th>фиксированные значения</th><th>литералы</th></thead><tbody><tr><td>литерал целого числа</td><td>25</td></tr><tr><td>литерал дробного числа</td><td>23.8</td></tr><tr><td>литерал строки</td><td>'Javascript', "Javascript"</td></tr><tr><td>литерал массива</td><td>[], [15,7,89]</td></tr><tr><td>литерал объекта</td><td>{}, {name: 'Javascript', surname: 'Javascript'}</td></tr><tr><td>литерал регулярного выражения</td><td>(ab|bc)</td></tr><tr><td>значения констант</td><td>const MAX_VALUE = 17;</td></tr><tr><td>значения переменных</td><td>var section = 'JS';</td></tr></tbody></table><code>let arr = ['HTML','CSS','JS'];</code><br><p><dfn>Выражения</dfn> - комбинация значений переменных и операторов<br>
<dfn>Ключевые слова</dfn> - определяет какое действие нужно выполнить<br>
<br>
<dfn>Автоматическое тестирование</dfn> - тесты пишуться отдельно:<br>
по-разному запускают функции и сравнивают результат с ожидаемым.<br>
<br>
<dfn>спецификация состоит из</dfn>:</p><pre><code><span>описываем функцию pow</span>
describe ("pow", function(){
  <span>рабочий блок - описывает что делает</span>
  it ("возводит в степень n", function() {
    <span>функция assert проверяет работу функции pow</span>
    assert.equal(pow(2, 3), 8);
  });
});</code></pre><br><p><dfn>Опциональная цепочка</dfn>:<br>
Если перед <em>?.</em> undefined или null, то останавливает вычисление и возвращает undefined (без ошибки).<br>
<em>?.</em> работает:<br>
  - с существующими переменными<br>
  - с функциями user1.admin?.(...)<br>
  - с квадратными скобками ?.[...]<br>
<b>let user = {}</b>; - пользователь без адреса<br>
<b>alert(user?.adress?.street)</b>; - undefined (без ошибки)<br>
<b>delete user?.name</b> - удалит user.name если user существует<br>
<b>obj?.prop</b> - вернёт obj.prop если obj есть, иначе undefined<br>
<b>obj?.[prop]</b> - вернёт obj[prop] если obj есть, иначе undefined<br>
<b>obj.method?.()</b> - вызовет obj.method если он есть, иначе undefined<br>
      </p></details><details><summary>Types</summary><p><dfn>Тип</dfn>:<br>
- набор характеристик значения,<br>
- не у переменной, а у значения,<br>
- присваиваится переменной вместе со значением.
</p><details><summary>Object</summary><pre><code>Object {
        property1: value1,
        property2: value2
       }

let someObj = new Object();
let someObj = {
  key1: value1,
};
console.log(someObj.key);
либо 
console.log(someObj['key']);</code></pre><p><b>someObj.key2 = value2</b>; - добавил в объект свойство (ключ: значение)<br>
<b>delete someObj.key2</b>; - удалил из объекта свойство (ключ: значение)<br>
<b>let obj = someObj</b>; - скопировал ссылку на объект в другую переменную<br>
<b>let obj = Object.assign({}, someObj)</b>; - сделал дубликат объекта</p><pre><code><span>проверка на наличие свойства</span>
if ("key1" in someObj) {}
<span>перебирает все свойства объекта</span>
for (let key in object) {}
let someObj = {
  key1: value1,
  <span>метод объекта</span>
  someFunc: function () {},
  <span>либо</span>
  someFunc() {},
};</code></pre><p><dfn>Function</dfn> - это Object, но выведен отдельно для простоты определения функций<br>
<dfn>Object.getOwnPropertySymbols(obj)</dfn> - получить все свойства объекта с ключами-символами<br>
<dfn>Reflect.ownKeys(obj)</dfn> - возвращает все ключи объекта включая символьные<br>
</p></details><details><summary>Примитивы</summary><p><dfn>Примитивы</dfn> - это конкретные значения.<br>
С помощью объектов-оберток (Number, String, ...) все примитивы кроме null и undefined
имеют методы работы с ними.<br>
<dfn>undefined</dfn> - неопределен, нет значения<br>
<dfn>null</dfn> - переменная определена, значение - ничего<br>
<dfn>boolean</dfn> - true/false<br>
<dfn>number</dfn> - числа целые и с точкой<br>
<dfn>infinity</dfn> (безконечность)<br>
<dfn>NaN</dfn> (Not a Number)<br>
<br>
<dfn>Обычные числа в JS</dfn> - это числа с плавающей точкой двойной точности 
(double precision floating point numbers), 64-битный формат IEEE-754.<br>
<br>
<dfn>BigInt</dfn> - числа позволяют работать с числами произвольной длины.<br>
123e6 = 123 000 000 (e6 - это 6 нулей) 123e-6 = 0,000123<br>
let someNum = 1000000; лучше так: let someNum = 1e6;<br>
let num = 0.000001; - let num = 1e-6;<br>
<br>
<dfn>string</dfn> - строка ' ', " ", `${}`<br>
"Какое-то \n предложение \n\t тут": \n - перевод строки, \t - табуляция (отступ), \ - экранирование<br>
let someText = "text";<br></p><pre><code><span>длина строки</span>
console.log(someText.length);

<span>получаем символ строки</span>
let firstSymbol = someText[0];

<span>последний символ строки</span>
let lastSymbol = someText[someText.length-1];

<span>перебирает символы строки</span>
for (const char of someText) {
  console.log(char);
}</code></pre><p><dfn>someText.toUpperCase()</dfn> - все буквы большие<br>
<dfn>someText.toLowerCase()</dfn> - все буквы маленькие<br>
<dfn>someText.indexOf(substr, pos)</dfn> - ищет подстроку substr в строке someText,<br>
  pos - необязательный, символ с которого искать<br>
<dfn>includes(substr, pos), startsWith(substr), endsWith(substr)</dfn> - проверяет на наличие, возвращает true или false<br>
<dfn>slice(start, end)</dfn> - возвращает часть строки без end<br>
<br>
<dfn>Symbol</dfn> - идентификатор объекта<br>
Два <b>Symbol("id")</b> с одинаковым "<b>id</b>" - это разные символы.<br>
let id = Symbol.for("id") - читает символ "id" из глобального реестра,
если символа нет, то создаст новый глобальный символ.<br>
В глобальном реестре под одним именем один символ.<br>
Используется как "скрытые" свойства объектов, т.к. символьное свойство не появится в for..in,
например:<br>
- Symbol.iterator - для итераторов,<br>
- Symbol.toPrimitive - для преобразования объектов в примитивы<br></p><pre><code><span>создание символа</span>
let id = Symbol("id");
let user = {
<span>не преобразуются в строку автоматически</span>
  name: "Вася",
<span>просто id:123 не работает,</span>
<span>т.к. нужно значение переменной id,</span>
<span>а не срока id.</span>
  [id]: 123
};
</code></pre></details><details><summary>typeof</summary><p><em>typeof</em> - возвращает тип аргумента<br>
<em>typeof 0</em> - number<br>
<em>typeof true</em> - boolean<br>
<em>typeof 'JS'</em> - string<br>
<em>typeof undefined</em> - undefined<br>
<em>typeof Math</em> - object<br>
<em>typeof Symbol ('JS')</em> - symbol<br>
<em>typeof null</em> - object - баг, это null<br>
<em>typeof function() {}</em> - function - баг, это object<br>
<em>typeof NaN</em> - number - Not a Number возвращает number<br>
</p></details><details><summary>Приведение типов</summary><p>Основные приведения: <dfn>строковое, численное и логическое.</dfn><br>
<em>' ', 0, null, undefined, Nan, false</em> - приводятся Boolean() к false.<br>
<em>Boolean('Hello')</em> - true<br>
<em>Boolean(' ')</em> - true, пробел - это символ<br>
<em>Boolean('0')</em> - true, '0' приводится к строке<br>
<em>Boolean(0)</em> - false<br>
<em>Boolean([])</em> - true<br>
<em>Boolean({})</em> - true<br>
<br>
Операторы приводят значения null к 0, а undefined к NaN:<br>
<em>null > 0</em> - false<br>
<em>null >= 0</em> - true<br>
<em>null == 0</em> - false<br>
<em>undefined > 0</em> - false<br>
<em>undefined == 0</em> - false<br>
<br>
<b>NaN</b> возвращает <b>false</b> при любых сравнениях.<br>
При нестрогом равенстве null/undefined ни к чему не приводятся и равны только друг другу.<br>
<br>
<dfn>Строки и числа</dfn><br>
<em>String(value);</em> - приведение к строке<br>
<em>Number(value);</em> - приведение к числу<br>
<em>Number("123");</em> - 123<br>
<em>Number("123z");</em> - NaN<br>
<em>Number(true);</em> - 1<br>
<em>Number(false);</em> - 0<br>
<em>+true</em> - 1<br>
<em>+''</em> - 0<br>
<em>null + 2</em> - number 2, null приводится к 0<br>
<em>1 + '2'</em> - string 12<br>
<em>'' + 1 + 0</em> - string 10<br>
<em>'' - 1 + 0</em> - number -1, у строки есть только оператор сложения (конкатенация), поэтому -1 это число + 0<br>
<em>'3' + '8'</em> - number 24<br>
<em>4 + 10 + 'px'</em> - string 14px<br>
<em>'px' + 4 + 10</em> - string px410<br>
<em>'42' - 40</em> - number 2<br>
<em>'42px' - 40</em> - NaN, px к числу не приводится<br>
<em>undefined + 2</em> - NaN, undefined приводится к NaN<br>
<em>parseInt()</em> - возвращает целое число, которое смогло получить из параметра<br>
<em>parseFloat()</em>- возвращает число с точкой, которое смогло получить из параметра<br>
<em>parseInt(str, base)</em> - преобразует строку в число,<br>
base - система исчисления 2 =&lt;base =&lt;36, по умолчанию 10<br>
<em>parseInt('0xff', 16)</em> - 255, дополнительное свойство - читает кодировки чисел<br>
<em>parseInt('100px')</em> - 100<br>
<em>parseFloat('12.5dfn')</em> - 12.5<br>
<em>parseInt('a123')</em> - NaN, не смог прочитать ни одной цифры<br>
<em>num.toString(base)</em> - преобразует число num в строку в виде системы исчисления base (от 2 до 32, по умолчанию 10)<br>
Если вызывать метод на числе, то <b>123..toString(36)</b> или <b>(123).toString(36)</b><br>
<em>num.toFixed(n)</em> - округляет до n знаков после запятой и возвращает результат в виде строки<br>
<em>isNaN(value)</em> - преобразует в число и проверяет является ли оно NaN. NaN никогда не будет равно NaN.<br>
<em>NaN === NaN</em> - false<br>
<em>isFinite(value)</em> - преобразует в число и возвращает true если обычное число<br>
<em>Object.is(a, b)</em> - идентично a === b<br>
<em>Object.is(NaN, NaN)</em> === true<br>
<em>Object.is(0, -0)</em> === false, технически 0 и -0 это разные значения<br>
встроенный объект <em>Math</em> - математические операции над числами<br>
<br>
<dfn>Преобразование объектов в примитивы:</dfn><br>
<b>obj[Symbol.toPrimitive](hint)</b> - вызывается метод объекта если он существует<br>
Если <b>hint = string</b>, то вызывается <b>obj.toString()</b>,<br>если такого нет, то <b>obj.valueOf()</b><br>
Если <b>hint = number или default</b>, то вызывается <b>obj.valueOf()</b>,<br>если такого нет, то <b>obj.toString()</b>.</p><img src="../img/js/Прототип.png" alt=""></details></details><details><summary>Регулярные выражения</summary></details><details><summary>Операторы</summary><p><em>операнд</em> - это то, к чему применяется оператор<br>
<em>-х;</em> - унарный оператор - применяется к одному операнду<br>
<em>у - х;</em> - бинарный оператор - применяется к двум операндам<br>
<em>+операнд</em> - приведение к числу<br>
<em>=</em> - оператор присваивания<br>
<br>
<dfn>все операторы возвращают значение</dfn><br>
<em>+</em> сложения, если одно из слагаемых строка, то сумма - строка.<br>
Остальные операторы дают число.<br>
<em>-</em> вычитания<br>
<em>*</em> умножения<br>
<em>/</em> деления<br>
<em>%</em> взятие остатка от деления (5%2 = 1)<br>
<em>**</em> возведения в степень<br>
<br>
<dfn>Инкремент/декремент можно применять только к переменной.</dfn><br>
<em>++</em> инкремент увеличивает на 1<br>
<em>--</em> декремент уменьшает на 1<br>
<em>counter++</em> постфиксная форма возвращает старое значение (до увеличения/уменьшения числа)<br>
<em>++counter</em> префиксная форма возвращает новое значение<br>
<br>
<dfn>операторы == vs === (нестрогое vs строгое)</dfn><br>
<em>==</em> сравнивает с приведением типов<br>
<em>===</em> сравнивает без приведения типов<br></p><pre><code>2 == '2' <span>true</span>
2 === '2' <span>false</span>
undefined == null <span>true</span>
undefined === null <span>false</span>
'0' == false    <span>true</span>
'0' == 0        <span>true</span>
0 == 0          <span>true</span>
false == ''     <span>true</span>
false == []     <span>true</span>
false == {}     <span>false</span>
'' == 0         <span>true</span>
'' == []        <span>true</span>
'' == {}        <span>false</span>
'' == null      <span>false</span>
{} == {}        <span>false</span>
{} === {}       <span>false</span></code></pre><p>== и === для объектов работают одинаково.<br>
Два объекта равны если это один и тот же объект.</p><pre><code>2**2 = 4
4**(1/2) = 2 <span>квадратный корень</span>
8**(1/3) = 2 <span>кубический корень</span></code></pre><br><p><dfn>Приоритет</dfn>:<br>
<em>+</em> унарный плюс<br>
<em>-</em> унарный минус<br>
<em>**</em> возведение в степень<br>
<em>*</em> умножение<br>
<em>/</em> деление<br>
<em>+</em> сложение<br>
<em>-</em> вычитание<br>
<em>=</em> присваивание<br>
<br></p><p><dfn>Операторы сравнения</dfn>:<br></p><pre><code>a&gt; b, a &lt;b    <span>больше/меньше</span>
a&gt;= b, a <= b  <span>больше/меньше или равно</span>
a == b          <span>равно</span>
a === b         <span>строгое равно</span>
a != b          <span>не равно</span>
a !== b         <span>строгое не равно</span></code></pre><p>Все операторы возвращают true или false.<br>
Строки сравниваются посимвольно.<br>
При сравнении разных типов - приведение к числу.<br></p><br><p><dfn>Оператор запятая</dfn> (,):<br>
- позволяет вычислять несколько выражений, разделяя их запятой.<br>
- каждое выражение выполняется, но возвращается результат только последнего.<br></p><pre><code>let a = (1+2, 3+4);   <span>скобки важны, т.к. приоритет ниже чем =</span>
alert(a);   <span>7-результат 3+4.</span></code></pre><br><p><dfn>Побитовые операторы</dfn>:</p><pre><code>&   <em>AND</em>                     <span>и</span>
|   <em>OR</em>                      <span>или</span>
^   <em>XOR</em>                     <span>побитовое исключающие или</span>
~   <em>NOT</em>                     <span>не</span>
<<  <em>LEFT SHIFT</em>              <span>левый сдвиг</span>
>>  <em>RIGHT SHIFT</em>             <span>правый сдвиг</span>
>>> <em>ZERO-FILL RIGHT SHIFT</em>   <span>правый сдвиг с заполнением нулями</span></code></pre><p>Побитовые операторы работают с 32-разрядными целыми числами (приводят к ним), на уровне их внутреннего двоичного представления.<br></p><br><p><dfn>Логические операторы</dfn>:<br>
<em>||</em>  или - если любой из аргументов true, то вернет true, иначе false</p><pre><code>true  || true   <span>true</span>
false || true   <span>true</span>
true  || false  <span>true</span>
false || false  <span>false</span></code></pre><p>- цепочка или || возвращает первое истиное значение или последнее, если такое значение не найдено.<br>
- цепочка вычисляется слева направо.<br></p><code>undefined || null || 0  <span>результат 0</span></code><br><p><em>&&</em>  и - если оба аргумента true, то вернет true, иначе false</p><pre><code>true  && true   <span>true</span>
false && true   <span>false</span>
true  && false  <span>false</span>
false && false  <span>false</span></code></pre><p>- цепочка или && возвращает первое ложное значение или или последнее, если такое значение не найдено.<br>
- приоритет и && больше чем или ||.<br>
<em>Или ||</em> спотыкается на правде, <em>и &&</em> спотыкается на лжи.<br></p><br><p><em>!</em> не  - принимает один аргумент, приводит к логическому типу и возвращает к противоположное значение.<br>
<em>!true</em> - false<br>
<em>!0</em> - true<br>
<em>!"non-empty string"</em> - true<br>
<em>!null</em> - false<br>
<em>!операнд</em> - приведение к boolean<br>
Приоритет <em>!</em> наивысший из всех логических операторов.<br></p><br><p><em>??</em> - оператор объединения с null, возвращает первое определённое значение, если оно отличается от null или undefined.</p><pre><code>let height = 0;
height || 100 <span>вернет 100</span> 
height ?? 100 <span>вернет 0</span>
a ?? b <span>результат a, если а определено, иначе b</span>
let user;
alert(user??"Аноним");  <span>Аноним</span></code></pre><p>Запрещено использовать оператор ?? вместе с && и || без явного указания приоритета скобками.</p><br><p><em>...</em> - троеточие, обозначает оператор "остаточные параметры" если нахидотся в конце списка аргументов функции либо оператор "расширения".<br>
- оператор "остаточные параметры" используется, чтобы создавать функции с неопределённым числом аргументов, собирает оставшиеся параметры в массив:</p><code>let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Repablic"];</code><p>- оператор "расширения" позволяет вставить массив в функцию, расширяя перебираемый объект arr в список аргументов (f...arr);<br>
оператор "расширения" работает только с итерируемыми объектами.
</p></details><details><summary>Инструкции</summary><p><dfn>Условное ветвление</dfn>:</p><pre><code>if (...) {          
  ...             
} else if (...) {    
  ...
}</code></pre><p>- вычисляет условие в скобках<br>
- приводит к логическому типу<br>
- если условие true, то выполняет блок кода<br>
Блоков else и else if может быть сколько угодно, а может и не быть.<br></p><pre><code>if () {}
if () {} else {}
if () {} else if () {} else {}

switch(x) {
  case 'value1':
    ...
    break
  case 'value2':
    ...
    break
  default:
    ...
  break
}</code></pre><p>- switch заменяет несколько if.<br>
- switch имеет один или несколько блоков case.<br>
- проверка равенства всегда строгая.<br>
- если нет break, то выполнение пойдет по следующим case без проверки.<br></p><br><p>? - тернарный оператор (три аргумента)<br>
let result = условие <b>?</b> значение1 <b>:</b> значение2;<br>
если условие true, то значение1, иначе значение2<br>
break/continue использовать нельзя<br>
() <b>?</b> valueIfTrue <b>:</b> valueIfFalse; тоже самое <b>if () {} else {}</b><br></p><br><p><dfn>Циклы</dfn>:</p><pre><code>while (...) {
  <span>тело цикла - выполняется пока условие true</span>
}
while () {} - <span>если процедура не одна, то {}.
Если процедура одна: while () procedure;</span>

do {
  <span>тело цикла</span>
} while (...);</code></pre><p>- выполнить и проверить условие<br>
- если условие true, то выполнить и проверить условие ещё раз<br></p><pre><code>for (начало; условаие; шаг) {
  <span>тело цикла</span>
}</code></pre><p>- выполнить начало<br>
- посторять пока условие true:<br>
если условие true, то выполнить тело<br>
выполнить шаг и проверить условие<br>
Любая часть может быть пропущена.<br></p><pre><code>for (;;) {
  <span>будет выполняться вечно</span>
}

for (key in object) {
  <span>тело цикла выполняется для каждого свойства объекта</span>
}</code></pre><p><em>for..in</em> - для перебора свойств объекта<br>
<em>for..of</em> - для перебора значений массива<br></p><pre><code>let fruits = ["Яблоко", "Апельсин", "Слива"];
for (let fruit of fruits) {
  alert(fruit);
}</code></pre><p>- проходит по значениям каждого элемента массива<br>
- не предоставляет доступа к номеру элемента, только к его значению<br></p><br><p><dfn>Метка</dfn> - точка местоположения в коде:</p><pre><code>outer: for (...) {
  for (...) {
    if (!input) break outer;
  }
}</code></pre><p>outer: - метка-идентификатор с двоеточием<br>
break/continue поддерживает метки
</p></details><details><summary>Функция</summary><img src="../img/js/Синтаксис.png" alt=""><br><p><dfn>Функция</dfn> - это значение, представляющее действие.<br>
Одна функция - одно действие.</p><pre><code>function sayHi(аргументы, через, запятую) {
  <span>тело функции, код</span>
}</code></pre><p><em>sayHi</em> - обращение к переменной, содержащей код функции.<br>
<em>sayHi()</em> - вызываем код функции на выполнение.<br></p><br><p>Можно передать внутрь функции любую информацию через аргументы функции.<br>
Переданные через аргументы значения копируются в локальные переменные (параметры) и используются в теле функции.<br>
Функция всегда получает только копию значения.<br>
Если аргумент не указан, то его значением становится undefined.<br></p><pre><code>function showMessage(from, text = "текст не добавлен") {
  alert(from + ": " + text);  <span>"текст не добавлен" - текст по умолчанию.</span>
} </code></pre><p><dfn>return</dfn> - функция останавливается и возвращает значение.<br>
Результат функции с пустым retutn или без него - undefined.<br>
<br>
Функция внутри другой функции называется <dfn>вложенной</dfn>.<br>
<br>
<dfn>Рекурсия</dfn> - функция вызывает саму себя. Глубина рекурсии - количество вызовов самой себя.<br>
<br>
<dfn>Колбэк функция</dfn> - функция передаваемая параметром в другую функцию и вызываемая внутри другой функции.<br></p><pre><code>function func1(param1, param2) {}
function func2(param3) {}
function func3(param1, param2) {
  func2(func1(param1, param2));
}
func3(param1, param2); <span>- выдаст результат работы func1 и func2</span></code></pre><p>Функция - это объект, его свойства:<br>
- <b>name</b> - имя функции<br>
- <b>length</b> - количество аргументов в объявлении функции, троеточие (остаточные аргументы) не считаються.<br>
<br>
Функция может содержать другие функции в своих свойствах.<br>
<br>
<em>Переменные</em> - это не свойства функции и не наоборот - это два параллельных мира.<br>
<br>
Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.<br>
Arguments не поддерживает методы массивов и всегда содержит все аргументы функции - мы не можем получить их часть.<br>
<br>
<dfn>Function Declaration</dfn> (Объявление функций) считывается интерпритатором когда создаётся лексическое окуржение,
в котором объявлена, hosting работает.<br>
При запуске функций, для неё создаётся лексическое окружение для хранения локальных переменных и параметров вызова.<br></p><pre><code>function sayHi(аргументы, через, запятую) {
  <span>тело, код функции</span>
}</code></pre><br><p><dfn>Function Expression</dfn> (Функциональное выражение) считывается когда выполнение доходит до него, hosting не работает.</p><pre><code>let sayHi = function() {
  alert("Привет");
}</code></pre><p><dfn>Named Function Expression NFE</dfn> (именованное функциональное выражение) - когда у функционального выражения есть имя.<br>
Имя функционального выражения не доступно за пределами функции и позволяет функции ссылаться на себя (рекурсивные вызовы).</p><pre><code>let sayHi = function func(who) {
  alert(`Hello, ${who}`);
}</code></pre><p><dfn>IIFE</dfn> - Immediate Invoked Function Expression<br>
Функциональное выражение моментального выполнения.<br>
Позволяет оборачивать функции для моментального выполнения, передавая необходимые параметры.<br>
Используются для создания локальной области видимости (scope) с замыканием на внешнюю переменную.<br>
Пути создания IIFE:<br></p><pre><code>(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с логического оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();</code></pre><br><p><dfn>=> Arrow functions</dfn> (Стрелочные функции):<br>
- не имееют this. При обращении к this, его значение берётся снаружи.<br>
- не имеют arguments. Arguments внешней функции.<br>
- не могут быть вызваны с new. Не могут быть конструктором.<br>
- нет super.<br>
- предназначены для небольшого кода без контекста, выполняемого в контексте текущего кода.<br>
- func.bind(this) создаёт связанную версию функции, а => ничего не привязывает, т.к. у неё нет this.<br></p><pre><code>let sum = (a, b) => a + b;
<span>или</span>
let sum = (a, b) => {
  let result = a + b;
  return result;
};        </code></pre><p>при фигурных скобках для возврата значения нужно явно вызвать return.</p><br><p><dfn>new Function</dfn><br>
При создании функции через new Function в её [[Environment]] записывается ссылка не на внешнее лексическое окружение,
в котором она была создана, а на глобальное.<br>
Поэтому у неё доступ только к глобальным перменным.<br>
Используют new Function когда код функции заранее не известен, а будет определен только в процессе выполнения.<br></p><pre><code>let func = new Function([arg1, arg2, ...argN], functionBody);
let sum = new Function('a', 'b', return a+b);</code></pre><p>Можно получить код функции с сервера:</p><pre><code>let str = ...код полученный с сервера динамически...
let func = new Function(str);
func();</code></pre><p>Переданные явно глобальные аргументы не вызывают проблем у минификаторов.<br>
<br>
<dfn>Минификатор</dfn> - специальная программа, которая уменьшает размер кода, удаляя комментарии,
лишние пробелы, а локальным переменным даются укороченные имена.<br>
<br>
<dfn>Функции-конструкторы</dfn> (Конструкторы):<br>
- имя с заглавной буквы<br>
- вызывается при помощи оператора new<br>
- используется для повторного создания однотипных объектов<br>
При вызове создаёт пустой this в начале и возвращает заполненный (свойства и их значения) в конце:<br>
<em>this = {};</em> явно добавляет свойства к this<br>
<em>return this;</em> неявно<br></p><pre><code>function User(name) {             
  this.name = name;            
  this.isAdmin = false;
}                                
let user = new User("Вася");</code></pre><p>выполняет роль класса, сама функция ничего не возвращает</p><pre><code>function Cat(color, name) {      
  this.color = color;
  this.name = name;
}
const cat = new Cat('black', 'Кот');
console.log(cat);      <span>Cat {color:'black', name: 'Кот'}</span>
const cat = Cat();     <span>присвоит cat undefined, т.к. Cat() ничего не возвращает</span>
const cat = new Cat(); <span>присвоит cat - Cat{color: undefined, name: undefined}, т.к. нет входных аргументов</span>

function myNew(constractor, ...args) {   <span>создаём своё ключевое слово new</span>
  const obj = {};                      <span>new всегда возвращает новый объект</span>
  Object.setPrototypeOf(obj.constractor.prototype)
  return constractor.apply(obj, args) || obj;
}</code></pre><p>- устанавливаем в поле prototype объекта переданную во входных аргументах constructor-ссылку, теперь constructor прототип obj.<br>
- теперь obj имеет доступ ко всем полям constructor, выполняет функцию-конструктор в контексте obj с входными аргументами args
или в случае ошибки только сам obj.<br>
const cat = myNew(Cat, 'black', 'Кот');
console.log(cat);   <span>Cat {color:'black', name:'Кот'}</span></p><p>выполняем своё ключевое слово myNew c constructor в контексте Cat и входными аргументами 'black' и 'Кот'.</p><pre><code>function SomeFuncCon(name, age) {
  this.name = name;
  this.age = age;
}
<span>создаю конструктором новый объект Вася и вывожу в консоль</span>
console.log(new SomeFuncCon('Vasya', 30));</code></pre><p>Планирование вызова функции:<br>
<em>setTimeout</em>(функция или код, задержка, параметр, параметр) - вызывает функцию один раз через какое-то время<br>
<em>setInterval</em>(функция или код, задержка, параметр, параметр) - вызывает функцию много раз через интервал времени<br>
<br></p><code>let timeId = setTimeout(someFunc, param, param);</code><p><em>setInterval(timeId)</em>; - прерывание setTimeout.<br>
Если setTimeout вызывать из setTimeout (рекурсия), то получим setInterval<br>
clearInterval тоже самое что и setInterval<br>
<br>
<dfn>Контекст</dfn> - объект, который передают при вызове и который указывает с каким объектом работает вызываемая функция.<br>
Ключевое слово function создаёт свой контекст, к которому нужно привязать объект (this), с которым работает функция.<br>
<em>this</em> - обозначает текущий объект<br>
<br>
<dfn>Контекст выполнения</dfn> - специальная внутренняя структура данных, которая содержит информацию о вызове функции:<br>
- место в коде, где находится итерпритатор<br>
- локальные переменные функции<br>
- значение this<br>
- прочая служебная информация.<br>
<br>
<dfn>Привязка контекста: bind</dfn><br></p><code>person.knows.bind(john, 'ничего не', 'Джон');</code><p>в отличии от call и apply, bind не вызывает метод knows на выполнение, 
а возвращает новый объект, который нужно вызвать как функцию (),
чтобы передать вызов в knows и установить this = john.<br>
Для выполнения пишем так:<br></p><code>person.knows.bind(john, 'ничего не', 'Джон')();</code><p>либо так</p><pre><code>const bound = person.knows.bind(john, 'ничего не', 'Джон');
bound();</code></pre><p>При передаче методов объекта в качестве колбэков,
например в setTimeout, метод передаётся отдельно от объекта, происходит потеря this.<br>
Встроенный в функции метод bind позволяет зафиксировать this.<br>
Частичная или частично применённая функция - это функция с привязанными аргументами.<br></p><code>let bound = func.bind(context, [arg1], [arg2], ...);</code><br><p><dfn>Явная привязка контекста</dfn>:</p><pre><code>function logThis() {
  console.log(this)
}
const obj = {num: 42};
logThis.apply(obj); {num: 42}
logThis.call(obj); {num: 42}
logThis.bind(obj)(); {num: 42}</code></pre><br><p><dfn>Неявная привязка контекста</dfn>:</p><pre><code>const animal = {
  legs: 4,
    logThis: function() {
      console.log(this);
  }
}
animal.logThis();  {legs: 4, logThis:[Function: logThis]}</code></pre><p>в контекст привязался тот объект, в котором была вызвана функция.<br>
<br>
<dfn>Методы</dfn> - это функции как свойства объекта.<br>
Методы ссылаются на объект через this для доступа к информации внутри объекта.<br>
Значение this вычисляется во время выполнения кода (когда функция вызвана) и зависит от контекста.<br>
Функция может быть скопирована между объектами (из одного объекта в другой).<br>
Значением this во время вызова синтаксисом "метода" (object.method()) является объект перед точкой.<br>
У стрелочных функций нет this, его значение берётся из внешей функции.<br>
Для работы вызовов типа user.hi(), точка возвращает не саму функцию, 
а специальное значение "ссылочного типа" - Reference Type.<br>
<br>
<dfn>Значение ссылочного типа</dfn> - это "триплет", комбинация из трёх значений:<br>
<em>base</em> - объект<br>
<em>name</em> - имя свойства объекта<br>
<em>strict</em> - режим исполнения (true если <b>'use strict</b>')<br>
Когда скобки () применяются к значению ссылочного типа (вызов функции), 
они получают полную информацию об объекте и его методе, и могут подставить правильный <b>this</b>.<br>
Ссылочный тип - исключительно внутренний, промежуточный, используется чтобы передать информацию от точки до вызывающих скобок().<br>
При любой другой операции, например присваении <b>hi = user.hi</b>;
ссылочный тип заменяется на само значение <b>user.hi</b> (функцию), и дальше работа только с ней - без this.<br>
<br>
<dfn>Замыкание</dfn> - это функция, которая помнит лексическое окружение где она была создана (свои внешние переменные)
и может получить к нему доступ с помощью скрытого свойства [[Environment]].<br>
Все функции, кроме newFunction(), изначально являются замыканиями.<br></p><pre><code>function sayHelloTo(name) {
  const message = 'Helo' + name;
  return function() {   <span>анонимная функция</span>
    console.log(message);
  }
}
<span>helloToElena ссылается на анонимную функцию</span>
const helloToElena = sayHelloTo('Elena');

<span>helloToIgor ссылается на анонимную функцию</span>
const helloToIgor = sayHelloTo('Igor');  

helloToElena();      <span>Hello Elena</span>
helloToIgor();       <span>Hello Igor</span>

const fib = [1, 2, 3, 5, 8, 13];
for (var i=0; i &lt;fib.length; i++) {
  setTimeout(function() {
    console.log(`fib[${j}] = ${fib[j]}`)
  }, 1500)
}</code></pre><p>через 1,5 секунды должен вывести индекс = значение, 
но не работает т.к. цикл for за 1,5 секунды успевает пробежать по всей длине массива и var i уже имеет значение 6.<br>
Только потом срабатывает setTimeout.<br>
<br>
<dfn>Исправление через область видимости</dfn>:<br>
const fib = [1, 2, 3, 5, 8, 13];
for (let i=0; i &lt;fib.length; i++) {
  setTimeout(function() {
    console.log(`fib[${j}] = ${fib[j]}`)
  }, 1500)
}</p><p>поменять var на let, т.к. let действует только в области видимости цикла.<br>
<br>
<dfn>Исправление через замыкание</dfn>:<br></p><pre><code>const fib = [1, 2, 3, 5, 8, 13];
for (var i=0; i &lt;fib.length; i++) {
(function(j) {
  setTimeout(function() {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  })(i)
}</code></pre><p>обернуть setTimeoutв функцию и через ()()(IIFE) замкнуть функцию на var i.</p><pre><code>let someObj = {
  key1: value1,

  someFunc() {
    function anotherFunc() {console.log(`${this.key1}`)}

    anotherFunc();
  }
};</code></pre><p><b>someObj.someFunc();</b> - ошибка, anotherFunc() создает свою область видимости и замыкается (использует)
область видимости someFunc(), this ищет в области видимости someFunc() свойство key1.</p><pre><code>let someObj = {
  key1: value1,

  someFunc() {
    let someVar = () => console.log(`${this.key1}`)

    someVar();
  }
};</code></pre><p><b>someObj.someFunc();</b> - стрелочная функция не создает свою область видимости и пользуется всем что есть у
someFunc(), т.е. области видимости someFunc() и someObj.<br>
<b>this</b> находит свойство key1 в области видимости someObj<br>
<br>
<dfn>Перенапрвление вызова</dfn> (call forwarding) - передача всех аргументов вместе с контекстом другой функции:<br>
<b>call и apply</b> - встроенные методы функции, позволяют вызывать функцию, явно устанавливая this.<br>
Одна разница:<br>
- оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.<br>
- apply принимает только псевдомассив args.<br></p><pre><code>const person = {
  surname: 'Старк',
  knows: function(what, name) {
    console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
  }
}    <span>функция работает в контексте (this) объекта person</span>

const john = {surname: 'Сноу'}
person.knows('всё', 'Бран')      <span>Ты всё знаешь Бран Старк</span></code></pre><p>чтобы перенаправить вызов, функцию knows не вызываем (), а обращаемся к ней как к объекту
и вызываем её метод call(), в который передаём объект (this), в контексте которого она
должна отработать и аргументы самой функции knows:<br></p><pre><code><span>Ты ничего не знаешь, Джон Сноу.</span>
person.knows.call(john, 'ничего не', 'Джон');

<span>аргументы в виде массива.</span>
person.knows.apply(john, ['ничего не', 'Джон']);

<span>ES-6 синтаксис - оператор спред (...) разворачивает массив.</span>
person.knows.call(john, ...['ничего не', 'Джон']);</code></pre><br><p><dfn>Заимствование метода</dfn>:</p><pre><code><span>функция делает ключ-строку из принимаемых аргументов</span>
function hash (args) {
  return args[0] + ',' + args[1];
}
<span>позаимствовали join у массива</span>
function hash (args) {
  alert([].join.call(args));
}
</code></pre></details><details><summary>Event loop</summary><dfn>Event loop</dfn> - событийный цикл (бесконечный цикл):<img src="../img/js/EventLoop.png" alt=""><p>1. Выполнить старейшую задачу из очереди макрозадач.<br>
<b>setTimeout(f)</b> с нулевой задержкой добавляет в очередь новую макрозадачу.<br>
2. Выполнить старейшую задачу из очереди микрозадач.<br>
<b>queuemicrotask(f)</b> - добавляет в очередь новую микрозадачу.<br>
Обработчики промисов в микрозадачах.<br>
3. Отрисовать изменения страницы (если есть).<br>
4. Если очередь макрозадач пуста - подождать, когда появится макрозадача.<br>
Сразу после каждой макрозадачи: все микрозадачи -> события -> рендеринг -> макрозадача<br>
<br>
<dfn>Очередь</dfn> - (queue) добавляем в конец, извлекаем с начала.<br>
<dfn>Стек</dfn> - (stack) новые элементы всегда добавляются или удаляются с конца.<br>
<br>
<dfn>Web workers</dfn>:<br>
- способ исполнить код в параллельном потоке<br>
- обмениваются сообщениями с основным процессом<br>
- имеют свои переменные и свой событийный цикл<br>
- позволяют задействовать несколько ядер процессора сразу<br>
- не имеют доступа к DOM<br>
- используются для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.<br>
</p></details><details><summary>Environment</summary><p><dfn>Переменная</dfn> - это именованное хранилище для данных, которое является свойством Environment Record.<br>
<dfn>Переменные</dfn> - это ссылки на значения, объекты или на другие переменные.<br>
Объекты храняться и копируются по ссылке.<br>
Создание переменной происходит в два этапа:<br>
- <dfn>declaration</dfn> (объявление)<br>
- <dfn>definition</dfn> (определение), <dfn>initalization</dfn> (инициализация)<br>
Имя переменной может содержать буквы, цифры, символы $ и _.<br>
Первый символ в имени не цифра. Регистр имеет значение.<br>
Переменная не объявлена - is not defined.<br>
Переменная не определена - undefined.<br>
<br>
<dfn>hoisting</dfn> (всплытие, поднятие) - это механизм в JS, в котором объявления переменных и функций, 
передвигаются вверх своей области видимости (локальной или глобальной) перед тем как код будет выполнен и мы
можем обратиться к ним ещё до их определения.<br>
hoisting передвигает только объявления функций и переменных, их определения остаются на своих местах.<br>
<br>
<dfn>LexicalEnvironment</dfn> - объект лексического окружения состоит из двух частей:<br>
<dfn>Environment Record</dfn> - (лексическое окружение) объект, в котором как свойства храняться все локальные переменные, 
значение this и т.д.<br>
Это структура, состоящая из лексических областей видимости, 
которая определяет связи между идентификаторами переменных и функций с их определениями 
на основе вложенности лексических областей видимости.<br></p><pre><code>function funcA() {
  let a = 1;
  function funcB() {
    let b = 2;
    function funcC() {
      let c = 3;
      console.log(a, b, c);
    }
  }
}</code></pre><p>Один вызов функции - одно лексическое окружение.<br>
Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.<br>
Для цикла у каждой итерации свой отдельное лексическое окружение.<br>
Из-за того, что у блока есть собственное лексическое окружение, код снаружи не видит переменные этого блока.<br>
При обращении к переменной - сначала ищем во внутреннем лексическом окружении, затем во внешнем, и так до глобального.<br>
Функция получает последнее значение внешних переменных.<br>
Объект лексического окружения существует пока есть хотя бы одна вложенная функция, которая ссылается на него.<br>
<br>
<dfn>Scope</dfn> - (лексическая область видимости) ссылка на внешнее лексическое окружение, 
т.е. это область видимости, которая указывает на доступность переменных:<br>
- глобальная область видимости - window или document в браузере<br>
- локальная область видимости  - в рамках одной функции или блока кода<br>
<br>
Это область видимости, которая определена во время разбора кода на лексемы 
и формируется исходя из того, где переменные, функции и инструкции размещены в коде.<br>
<br>
лексемы:<br>
 <b>var a = 2;</b><br>
<em>var</em> - объявление переменной<br>
<em>a</em> - идентификатор (имя) переменной<br>
<em>=</em> - оператор присваивания<br>
<em>2</em> - число<br>
<em>;</em> - конец инструкции<br>
<dfn>let</dfn> - изменяемая впеременная, область видимости блок, hoisting не работает.<br>
<dfn>const</dfn> - неизеняемая переменная, область видимости блок, hoisting не работает.<br>
Константы с заглавными буквами для заранее известных значений.<br>
Константы маленькими буквами для значений вычисляемых и присваиваемых в процессе выполнения.<br>
<dfn>var</dfn> - изменяемая переменная, область видимости функция или скрипт, hoisting работает.<br></p><pre><code>let a = 'variable a'; <span>- global scope</span>
let b = 'variable b';
{
  a = 'New variable A'; <span>- a from global scope</span>
  let b = 'Local Variable B'; <span>- b from local scope</span>
  console.log('A:', a); <span>- New Variable A</span>
  console.log('B:', b); <span>- Local Variable B</span>
  console.log('C:', c); <span>- ReferenceError</span>
  let c = 'Something';
}
console.log('A:', a); <span>- New Variable A</span>
console.log('B:', b); <span>- Local Variable B</span>
</code></pre></details><details><summary>Коллекции</summary><p>Объекты для хранения именованных коллекций.<br>
<dfn>Массив</dfn> - (Array), подвид объектов для хранения упорядоченых коллекций,
расширяют объекты методами для работы с упорядоченными коллекциями данных и свойством <b>length</b>.<br>
Получить доступ к элементу <b>arr[0]</b> - это синтаксис доступа по ключу (<b>obj[key]</b>),
где в роли obj у нас arr, а key - числовой индекс.<br>
Создание пустого массива: <br></p><pre><code>let arr = new Array();
<span>либо</span>
let arr = [];
let arr = newArray(2); <span>- создать пустой массив на 2 пустых элемента.</span>

let fruins = ["Яблоко", "Апельсин", "Слива"];
fruits[0] <span>- получить элемент</span>
fruins[2] = 'Груша'; <span>- заменить элемент с индеком 2</span>
fruins[3] = 'Лимон'; <span>- добывить новый элемент</span>
fruins.length <span>- общее число элементов массива</span>
alert(fruins); <span>- вывести массив целиком</span></code></pre><p>В массиве могут храниться элементы любого типа.<br>
<br>
<dfn>Массив</dfn> - это объект, который намного быстрее объекта если работать с массивом ни как с объектом, 
а как с упорядоченной коллекцией:<br>
- свойства именовать цифрами (индексы - числа, а не строки)<br>
- не создавать дыр, т.е. не оставлять свойства без значений (0: "Вася", 1: , 2: "Петя")<br>
- не заполнять массив значениями в обратном порядке (сконца)<br></p><pre><code>let arr = new Array();
let arr = [];
let arr = [el1, el2, el3,]; <span>- элементом массива может быть что угодно.</span>
arr[1] <span>- обращение к элементу, индексация с 0</span>
arr.length <span>- длина массива</span>
let arrNew = arr; <span>- скопировал ссылку на массив</span></code></pre><br><p>масcивы могут работать и как очередь и как стек:<br>
<em>push()</em> - добавляет в конец массива - выполняется быстро<br>
<em>pop()</em> - удаляет элемент вконце массива - выполняется быстро<br>
<em>shift()</em> - удаляет элемент вначале массива - выполняется медленно<br>
<em>unshift()</em> - добавляет элемент вначало массива - выполняется медленно<br>
<em>delete arr[1]</em>; - удаление конкретного элемента<br>
<em>arr.splice(pos, count)</em>; - начиная с позиции pos удалить count элементов<br>
(pos - считаем сначала, -pos - считаем сконца)</p><pre><code><span>начиная с позиции pos удалить count элементов и вернуть удаленные элементы в переменную</span>
let rm = arr.splice(pos, count);

<span>начиная с позиции pos заменить count элементов на elem</span>
arr.splice(pos, count, elem);

<span>начиная с позиции pos добавить elem1, elem2</span>
arr.splice(pos, 0, eldfn1, eldfn2); -

<span>копируем весь массив</span>
let arrNew = arr.slice();

<span>копируем массив с позиции 1 до позиции 2, не включая позицию 2</span>
let arrNew = arr.slice(1, 2);

<span>копирует весь массив и добавляет в конец нового массива elem</span>
let arrNew = arr.concat(elem);

<span>ищет elem с индекса from, возвращает индекс найденого item или -1</span>
arr.indexOf(elem, from);

<span>возвращает индекс найденого elem или -1, ищет справа налево</span>
arr.lastIndexOf(elem);

<span>ищет elem с индекса from, возвращает true  или false</span>
arr.includes(elem, from);</code></pre><br><p>Для массивов, элементы которых объекты:<br>
<em>find()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то прерывает поиск и возвращает соответствующее свойство либо undefined</p><pre><code>let res = arr.find(function(elem, index, array) {
  return elem.prop === 18;
});
<span>либо</span>
let res = arr.find(elem => elem.prop === 18);</code></pre><p><em>findIndex()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то прерывает поиск и возвращает соответствующей индекс либо undefined</p><code>let res = arr.findIndex(elem => elem.prop === 18);</code><p><em>filter()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
если условие совпало, то продолжает поиск и возвращает массив совпавших свойств либо undefined</p><code>let res = arr.filter(elem => elem.prop&gt;= 18);</code><p><em>sort(fn)</em> - сортирует массив, меняя в нем порядок элементов по алгоритму функции fn,<br>
если fn не указана, то по возрастанию</p><pre><code>function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  if (a&gt; b) return 1;
  if (a == b) return 0;
  if (a &lt;b) return -1;
}
console.log(arr.sort(compareNum));
<span>либо</span>
function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  return a - b;
}
console.log(arr.sort(compareNum));
<span>либо</span>
console.log(arr.sort((a, b) => a - b));</code></pre><p><em>reverse()</em> - меняет порядок елементов в массиве на обратный <b>arr.reverse()</b>;
<br>
<em>map()</em> - перебирает элементы массива, применяет функцию к каждому элементу и возвращает 
на его место в массиве результат работы функции.<br></p><code>let res = arr.map(function(eldfn, index, array) {});</code><p><em>split()</em> - преобразовывает строку в массив по указанному разделителю</p><pre><code>let str = 'eldfn1,eldfn2,eldfn3';
let arr = str.split(',', limit);</code></pre><p>limit ограничивает количество элементов, которые попадут в массив если не указывать, то все
<br>
<em>join()</em> - преобразовывает массив в строку с указанным разделителем</p><pre><code>let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
let res =  arr.join(',');
<span>либо</span>
let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
let res =  String(arr); - разделитель всегда запятая</code></pre><p><b>Array.isArray(arr)</b> - возвращает true если arr это массив, иначе false
<br>  
Циклы для перебора элементов массива:<br></p><code>for (i=0; i &lt;arr.length; i++) и for (let var of arr) {}</code><p><em>forEach()</em> - метод перебора массива, применяет функцию для каждого элемента массива</p><pre><code>arr.foreach(function(eldfn, index, array) {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
});
<span>либо</span>
arr.forEach((eldfn, index, array) => {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
});
<span>либо</span>
let func = function(eldfn, index, array) {
  console.log(`${eldfn} находится на ${index} позиции в ${array}`);
};
arr.forEach(func);</code></pre><p><em>reduce()</em> - перебирает элементы массива и вычисляет значение на основе всего массива<br></p><pre><code>let value = arr.reduce(
  function(
    previousValue, eldfn, index, array
  ) {},
[initial]);</code></pre><br><p><em>previousValue</em> - результат предыдущего вызова этой функции, равен initial при первом вызове функции (если initial передан),<br>
<em>elem</em> - очередной элемент массива<br>
<em>index</em> - его индекс<br>
<em>array</em> - сам массив<br>
<br>
<dfn>reduceRight()</dfn> - так же как и reduce(), но справа на лево<br></p><br><img src="../img/js/Methods.jpg" alt=""><br><p><dfn>Псевдомассив</dfn> - объекты, у которых есть индексы и свойство length,
могут иметь другие свойства и методы, но у них нет встроенных методов массива.<br>
<b>Array.from(obj[,mapFn, thisArg])</b> - создаёт Array из итерируемого объекта
или псевдомассива obj, и затем к нему можно применить методы массивов.<br>
Необязательные аргументы mapFn и thisArg позволяют применять функцию с 
задаваемым контекстом к каждому элементу.<br>
<br>
<dfn>Итерируемые объекты</dfn> - объекты, которые реализуют метод <b>Symbol.iterator</b>,
и их можно использовать в цикле for..of.<br>
Результат вызова <b>obj[Symbol.iterator]</b> называется итератором. Он управляет итерацией.<br>
Итератор должен иметь метод <b>next()</b>, который возвращает объект<br>
<b>{done: Boolean, value: any}</b>,<br> где done: true - окончание итерации,
иначе value - следующее значение.<br>
Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его
и напрямую. Строковый итератор знает про сурогатные пары.<br>
<br>
Свойство <dfn>length</dfn> - это наибольший цифровой индекс плюс один.
Самый простой способ очистить массив - это <b>arr.length = 0</b>;<br>
Метод <b>toString</b> возвращает список элементов, разделённых запятыми.<br>
<br>
<dfn>Добавление/удаление элементов</dfn>:<br>
<em>push(...itdfns)</em> - добавляет элементы в конец<br>
<em>pop()</em> - извлекает элемент с конца<br>
<em>shift()</em> - извлекает элемент с начала<br>
<em>unshift(...itdfns)</em> - добавляет элемент в начало<br>
<em>splice(pos, deleteCount, ...itdfns)</em> - начиная с индекса pos, удаляет deleteCount элементов и вставляет itdfns.<br>
<em>slice(start, end)</em> - создаёт новый массив, копируя в него элементы с позиции start до end, не включая end.<br>
<em>concat(...itdfns)</em> - возвращает новый массив: копирует все элементы текущего массива и добавляет к нему itdfns.<br>
Если какой-то из itdfns является массивом, то беруться его элементы.<br>
Если объект имеет специальное свойство <b>Symbol.isConcatSpreadable</b>, то он обрабатывается concat как массив,
т.е. вместо объекта добавляются его числовые свойства.<br>
Методы push/pop выполняются быстро, а shift/unshift - медлено.<br>
<br>
<dfn>Поиск среди элементов</dfn>:<br>
<em>indexOf/lastIndexOf(itdfn, pos)</em> - ищет itdfn, начиая с позиции pos, и возвращает его индекс или -1, если ничего не найдено.<br>
<em>includes(value)</em> - возвращает true, если в массиве есть элемент value, иначе false.<br>
<em>find/filter(func)</em> - фильтрует элементы через функцию и отдаёт первое/все значения, 
у которых при прохождении через функцию возвращается true.<br>
<em>findIndex</em> - похож на find, но возвращает индекс вместо значения.<br>
<br>
<dfn>Перебор элементов</dfn>:<br>
<em>forEach(func)</em> - вызывает func для каждого элемента. Ничего не возвращает.<br></p><code>["Bilbo", "Gandalf", "Nazgul"].forEach(alert); - вызов alert для каждого элемента.<br></code><br><p><dfn>Преобразование массива</dfn>:<br>
<em>map(func)</em> - создаёт новый массив из результатов вызова func для каждого элемента.<br>
<em>sort(func)</em> - сортирует массив "на месте", а потом возвращает его.<br>
<em>revers(func, initial)</em> - вычисляет одно значение на основе всего массива,
вызывая func для каждого элемента и передавая промежуточный результат между вызовами.<br>
<br>
<dfn>Деструктуризация</dfn> позволяет разбивать объект или массив на переменные при присвоении.<br>
Для объекта: (неупомянутые свойства копируются в объект rest.)<br></p><code>let {prop: varName = default, ...rest} = object</code><p>Для массива: (первый элемент копируется в itdfn1, второй в itdfn2, остальные в массив rest.)<br></p><code>let [itdfn1 = default, itdfn2, ...rest] = array</code><p>Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и первая.</p><br><p><dfn>Map</dfn> - коллекция пар: ключ-значение.<br>
Отличия от обычного объекта Object:<br>
- что угодно может быть ключом, в том числе и объекты.<br>
- есть дополнительные методы, свойство size.<br>
<br>
<dfn>Методы и свойства</dfn>:<br>
<em>newMap([iterable])</em> - создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ, значение] для инициализации.<br>
<em>map.set(key.value)</em> - записывает по ключу key значение value.<br>
<em>map.get(key)</em> - возвращает значение по ключу или undefined, если ключа нет.<br>
<em>map.has(key)</em> - возвращает true, если ключ key присутствует в коллекции, иначе false.<br>
<em>map.delete(key)</em> - удаляет элемент по ключу key.<br>
<em>map.clear()</em> - очищает коллекцию от всех элементов.<br>
<em>map.size</em> - возвращает текущее количество элементов.<br>
<em>map.keys()</em> - возвращает итерируемый объект по ключам.<br>
<em>map.values()</em> - возвращает итерируемый объект по значениям.<br>
<em>map.entries()</em> - возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.<br>
<em>Object.entries(obj)</em> - создаёт Map из обычного объекта.<br>
<em>let obj = Object.fromEntries(map)</em>; - создаёт объект из Map.<br>
<br>
<dfn>Set</dfn> - коллекция значений без ключей, где каждое значение может появляться только один раз.<br>
<br>
<dfn>Методы и свойства</dfn>:<br>
<em>newSet([iterable])</em> - создаёт Set, можно указать перебираемый объект со значениями без инициализации.<br>
<em>set.add(value)</em> - добавляет значение если такого нет, возвращает тот же объект.<br>
<em>set.delete(value)</em> - удаляет значение, возвращает true если value было, иначе false.<br>
<em>set.has(value)</em> - возвращает true, если значение есть, иначе false.<br>
<em>set.clear()</em> - удаляет все значения.<br>
<em>set.size</em> - возвращает количество элементов в множестве.<br>
<em>set.values()</em> - возвращает перебираемый объект для значений.<br>
<em>set.keys()</em> - то же самое, что и <b>set.values()</b>, нужен для обратной совместимости с Map.<br>
<br>
Перебор Map и Set всегда осуществляется в порядке добавления элементов,
поменять порядок элементов или получить элемент напрямую по номеру нельзя.<br>
<br>
<dfn>WeakMap & WeakSet</dfn>:<br>
<em>WeakMap</em> - Map-подобная коллекция, где ключи только объекты, автоматически удаляемые вместе со значениями
как только они становяться недостижимыми.<br>
<em>WeakSet</em> - Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми.<br>
<dfn>Methods</dfn>:<br></p><pre><code>weakMap.get(key)          weakSet.get(key)
weakMap.set(key, value)   weakSet.set(key, value)
weakMap.delete(key)       weakSet.delete(key)
weakMap.has(key)          weakSet.has(key)</code></pre><p>WeakMap и WeakSet поддерживают операции только на отдельном элементе коллекции.</p></details><details><summary>Модуль</summary><p><dfn>Модуль</dfn> - это файл.<br>
Чтобы работал import/export, нужно указать <b>&lt;script type="module"&gt;</b>.<br>
<b>export</b> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.<br>
<b>import</b> позволяет импортировать функциональность из других модулей.<br></p><pre><code>&lt;!doctype html&gt;
&lt;script type="module"&gt;
import {sayHi} from './say.js';
document.body.innerHTML = sayHi('John');
&lt;/script&gt;</code></pre><p><dfn>У модулей</dfn>:<br>
- Отложенное (deferred) выполнение по умолчанию.<br>
- Загрузка внешних модулей (&lt;script type="module" src="..."&gt;) не блокирует обработку HTML и выполняются только после загрузки HTML документа.<br>
- Выполняются в порядке расположения в документе.<br>
- Для загрузки внешнего модуля с другого источника, он должен ставить заголовки CORS.<br>
- Дублирующиеся внешние скрипты игнорируются.<br>
- У модулей своя область видимости, обмен через import/export.<br>
- В модуле всегда включен "use strict".<br>
- Код в модуле выполняется только один раз.<br>
- Сборщик Webpack объединяет модули для производительности.<br>
<br>
<dfn>Синтаксис</dfn>:</p><pre><code><span>перед объявлением</span>
export default class/function/variable

<span>отдельный экспорт</span>
export {x as y, ...}

<span>реэкспорт</span>
export {x [as y], ...} from "module"

<span>реэкспорт всего кроме export default</span>
export * from "module"

<span>реэкспорт только export default </span>
export {default [as y], ...} from "module"

<span>именованный импорт из модуля</span>
import {x [as y], ...}

<span>импорт по умолчанию</span>
import x from "module"

<span>импорт по умолчанию</span>
import {default as x} from "module"

<span>импорт всего сразу</span>
import * as obj from "module"

<span>подключить модуль без присваивания переменной</span>
import "module"</code></pre><p>import/export могут быть вначале или вконце скрипта, но не в {...}.</p><pre><code><dfn>Именованный экспорт</dfn>                <dfn>Экпорт по умолчанию</dfn>
export class User {...}           export default class User {...}
import {User} from ...            import User from ...</code></pre><p>Выражение import (module) загружает модуль и возвращает промис,
результатом которого становится объект модуля, содержащий все его экспорты.</p><pre><code>say.js
export function hi() {
  alert('Привет');
}
export function buy() {
  alert('Пока');
}
export default function() {
  alert('Модуль загружен');
}

&lt;!doctype html&gt;
&lt;script&gt;                    
  async function load() {                             
    let say = await import('./say.js');         
    say.hi();       <span>Привет</span>
    say.buy();      <span>Пока</span>
    say.default();  <span>Модуль загружен</span>
  }                                               
&lt;/script&gt;
&lt;button onclick = "load"&gt;Нажми меня &lt;/button&gt;</code></pre><p>Динамический импорт работает в обычных скриптах и не требует указания <b>script type="module"</b>.<br>
<em>import()</em> - это не функция, а спец.синтаксис, как <b>super()</b>.</p><img src="../img/js/promise.png" alt=""></details><details><summary>Browser</summary><img src="../img/js/windowJS.png" alt=""><details><summary>Window</summary><p><dfn>Window</dfn> = <b>globalThis + DOM + BOM</b> - глобальный объект JS в браузере.<br>
<em>Object <- EventTarget <- Window</em> - интерфейс Window наследует свойства интерфейса EventTarget
и реализует свойства из WindowOrWorkerGlobalScope и миксин WindowEventHandlers.<br>
Объект Window реализует интерфейс Window.<br>
У каждого окна и у каждой вкладки свой объект Window.<br>
глобальные функции доступны как методы глобального объекта</p><pre><code>functionsayHi() {       
    alert('Hello');
}
window.sayHi();</code></pre><p><dfn>Window.properties</dfn>:<br>
<em>opener</em> - ссылка на открывающее окно,<br>
<em>closed</em> - true (закрыто), false (открыто),<br>
<em>frames</em> - коллекция объектов window вложенных ифреймов<br>
<em>parent</em> - ссылка на родительское окно<br>
<em>top</em> - ссылка на окно самого верхнего уровня<br>
<br>
<dfn>Window.methods</dfn>:<br>
<em>open (url, name, params)</em> - открывает новое окно и возвращает ссылку на него.<br>
<em>close()</em><br>
<em>focus()</em><br>
<em>blur()</em><br>
<em>alert("Hello")</em> - показывает сообщение<br>
<em>result = promt(title, [default])</em>; - показывает сообщение и запрашивает у пользователя
ввод текста.<br> Возвращает напечатанный в поле ввода текст или null.<br>
<em>result = confirm (question)</em>; - показывает сообщение и ждёт, пока пользователь 
нажмёт ОК или Отмена.<br> Возвращает true если нажата ОК и fasle - если отмена.<br>
<em>iframe.contentWindow</em> - объект Window внутри тега &lt;iframe&gt;<br>
</p></details><details><summary>BOM</summary><p><em>Browser Object Model</em> - объектная модель браузера.<br>
<em>Window.navigator</em> - информация о браузере пользователя.<br>
<em>Window.screen</em> - информация об экране пользователя.<br>
<em>Window.location</em> - адресная строка: текущие компоненты.<br>
<em>Window.frames</em> - фреймы и ифреймы.<br>
<em>Window.history</em> - история посещений (url), движения вперед и назад в окне.<br>
<em>Window.XMLHttp Request</em> - встроенный объект для Http запросов к серверу без перезагрузки страницы.<br>
<em>Window.document</em> - DOM-документ загруженный в окно.<br>
https://html.spec.whatwg.org
</p></details><details><summary>DOM</summary><p><dfn>Document Object Model</dfn> - объектная модель документа, представляет всё содержимое страницы в виде объектов.<br></p><code>document.body.style.background = "red"</code><p>Object <- EventTarget <- Node <- Document<br>
html-документы представленны в браузере в виде дерева DOM.<br>
<br>
<dfn>Веб-воркер</dfn> — это JavaScript, который работает в фоновом режиме, 
независимо от других скриптов, не влияя на производительность страницы. <br>
Вы можете продолжать делать все, что захотите: щелкать, выбирать объекты и т. д.,
пока веб-воркер работает в фоновом режиме.<br>
https://dom.spec.whatwg.org<br>
https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov
</p></details><details><summary>Node</summary><p><dfn>Node</dfn> - абстрактный класс.<br>
Обеспечивает базовую функциональность для всех узлов.<br>
Объекты класса Node никогда не создаются, но от него наследуются.<br>
<br>
<dfn>Классы</dfn>:<br>
<dfn>Text</dfn> - для текстовых узлов. Содержат текст.<br>
<dfn>Comment</dfn> - для узлов-комментариев. Иногда в них можно включить информацию, которая 
не будет поазана, но будет доступна в DOM для чтения JS.<br>
<dfn>Element</dfn> - для узлов-элементов. HTML-тэги - строительные блоки документа.<br>
Обеспечивает навигацию на уровне узлов-элементов и служит базой
для классов SVGElement, XMLElement, HTMLElement.<br>
<br>
Текст, комментарий и тэг - это DOM-узел.<br>
Каждый DOM-узел принадлежит своему классу.<br>
Для наследования используют классы, основанные на прототипах.<br>
Классы формируют иерархию.<br>
Весь набор свойств и методов является результатом наследования.<br>
<dfn>DOM-узлы</dfn> - это обычные JS объекты. Реализация соответствующего класса.<br>
<dfn>DOM-элемент</dfn> - это JS объект тэга.<br>
<br>
<dfn>HTMLElement</dfn> - является базовым классом для всех остальных HTML-элементов.<br>
От него наследуют элементы:<br>
<dfn>HTMLInputElement</dfn> - класс для тега &lt;input&gt;<br>
<dfn>HTMLBodyElement</dfn> - класс для тега &lt;body&gt;<br>
<dfn>HTMLAnchorElement</dfn> - класс для тега &lt;a&gt;<br>
и т.д., <br>
каждому тегу соответствует свой класс, который представляет свойства и методы:<br>
<dfn>value</dfn> - значение для &lt;input&gt;, &lt;select&gt; и &lt;textarea&gt; (HTMLInputElement, HTMLSelectElement, ...).<br>
<dfn>href</dfn> - адрес ссылки "href" для &lt;a href="..."&gt; (HTMLAnchorElement).<br>
<dfn>id</dfn> - значение атрибута "id" для всех элементов (HTMLElement).<br>
<br>
console.log(elem) выводит элемент в виде DOM-дерева.<br>
console.dir(elem) выводит элемент в виде DOM-объекта, это удобно для анализа его свойств.<br>
<br>
Для изменения элементов или проверки DOM-дерева можем использовать инструменты разработчика в браузере.<br>
</p></details><details><summary>DOM-navigation</summary><img src="../img/js/Навигация DOM.png" alt=""><p><dfn>Дочерние узлы (дети)</dfn> - непосредственные дети-элементы узла.<br>
<dfn>Потомки</dfn> - все элементы, внутри данного, ключая детей, их детей и т.д.<br>
Коллекция childNodes содержит список всех детей, включая текст.<br></p><pre><code>eldfn.childNodes[0] === eldfn.firstChild
eldfn.childNodes[eldfn.childNodes.length-1] === eldfn.lastChild</code></pre><p><dfn>Соседи</dfn> - узлы, у которых один и тот же родитель.<br>
&lt;<b>body</b>&gt; - следующий или правый сосоед &lt;<b>head</b>&gt;<br>
&lt;<b>head</b>&gt; - предыдущий или левый сосед &lt;<b>body</b>&gt;<br></p><pre><code>const bodyElement = document.body;
const firstChildNode = bodyElement.firstChild; <span>- первый узел</span>
const lastChildNode = bodyElement.lastChild; <span>- последний узел</span></code></pre><br><p>список всех детей (узлов) объекта (в данном случае body) в виде коллекции</p><code>const childNodes = bodyElement.childNodes;</code><br><p>проверяет есть ли дочерние узлы у объекта true or false</p><code>bodyElement.hasChildNodes()</code><br><p><dfn>Коллекция</dfn> - это псевдомассив:<br>
можно перебирать с помощью <b>for( of ) {}</b> и <b>forEach()</b>
методы массива не работают<br>
изменять элемент коллекции как в массиве не получится, только через специальные методы<br></p><pre><code>bodyElement.previousSibling; <span>- предыдущий соседний узел</span>
bodyElement.nextSibling; <span>- следующий соседний узел</span>
bodyElement.parentNode; <span>- родительский узел</span></code></pre><br><p><dfn>Для элементов (тегов)</dfn>:</p><pre><code>bodyElement.childNodes; <span>- получаем коллекцию всех дочерних узлов</span>
bodyElement.children; <span>- получаем коллекцию всех дочерних элементов (тегов)</span>
bodyElement.firstElementChild; <span>- первый элемент</span>
bodyElement.lastElementChild; <span>- последний элемент</span>
bodyElement.previousElementSibling; <span>- предыдущий соседний элемент</span>
bodyElement.nextElementSibling; <span>- следующий соседний элемент</span>
bodyElement.parentElement; <span>- родительский элемент</span></code></pre><br><p><dfn>Поиск произвольного элемента</dfn>:<br>
возвращает статичную коллекцию со всеми элементами внутри elem, соответствующие указанному CSS-селектору (класс (с точкой впереди), тег, вложенные теги, атрибут, id и т.д.)</p><code>elem.querySelectorAll(CSS);</code><br><p>проверяет только последний указанный в CSS-селекторе элемент без учета контекста используется чаще других, ищет и возвращает первый попавшийся объект по указанному CSS-селектору</p><code>querySelector(CSS);</code><br><p>ищет и возвращает элемент по id, ищет только в document</p><code>document.getElementById(id без решетки);</code><br><p>возвращает живую коллекцию, ищет где угодно</p><code>getElementsByTagName(тег);</code><br><p>возвращает живую коллекцию, ищет где угодно</p><code> getElementsByClassName(класс без точки впереди);</code><br><p>возвращает живую коллекцию, ищет только в document</p><code>document.getElementsByName(атрибут name);</code><br><p>живая коллекция - содержит в себе всегда актуальную информацию с учетом изменений в дереве DOM<br></p><img src="../img/js/querySelector.png" alt=""><br><p>ищет ближайшего предка, который соответствует указанному css-селектору</p><code>elem.closest(css)</code><br><p>ничего не ищет, проверяет соответствует ли элемент css селектору, возвращает true or false</p><code>elem.matches(css)</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта как есть</p><code>const textEldfnentContent = textElement.innerHTML;</code><p>заменил содержимое объекта</p><code>textElement.innerHTML = `Новое содержимое объекта`;</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта и сам объект</p><code>const textEldfnentContent = textElement.outerHTML;</code><p>заменил сам объект</p><code>textElement.outerHTML = `&lt;p>Новое содержимое объекта&lt;/p>`;</code><br><p>получил объект</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил содержимое объекта без тегов</p><code>const textEldfnentContent = textElement.textContent;</code><p>заменил содержимое объекта, но теги вставляються как текст позволяет записывать получаемый текст безопасно</p><code>textElement.textContent = `&lt;p>Новое содержимое объекта&lt;/p>`;</code><br><p>получил объект с классом .someClass__text</p><code>const textElement = document.querySelector('.someClass__text');</code><p>получил следующий объект - комментарий</p><code>const getComment = textElement.nextSibling;</code><p>вывел текст комментария в консоль</p><code>console.log(getComment.data);</code><p>заменил текст комментария</p><code>getComment.data = `Новый текст`;</code><br><p><dfn>Методы поиска элементов в DOM</dfn>:<br>
<em>querySelector</em> - ищет внутри элемента по CSS-selector<br>
<em>querySelectorAll</em> - <br>
<em>getElementById</em> - ищет по id<br>
<em>getElementsByName</em> - возвращает коллекцию, ищет по имени<br>
<em>getElementsByTagName</em> - возвращает коллекцию, ищет внутри элемента по тегу или "*"<br>
<em>getElementsByClassName</em> - возвращает коллекцию, ищет внутри элемента по class<br>
<em>elem.matches(css)</em> - проверяет, удовлетворяет ли элемент CSS-селектору<br>
<em>elem.closest(css)</em> - ищет ближайшего предка<br>
<em>elemA.contains(eldfnB)</em> - вернет true если elemB находится внутри elemA или elemA == elemB<br>
</p></details><details><summary>Document</summary><p><dfn>Document</dfn> - интерфейс доступа к узлам, его реализует объект document.<br>
<dfn>document</dfn> - объект DOM, входная точка в DOM<br></p><br><p>получить объект html со всем его содержимым</p><code>const htmlEldfnent = document.documentEldfnent;</code><p>получить объект head со всем его содержимым</p><code>const headEldfnent = document.head;</code><p>получить объект body со всем его содержимым</p><code>const bodyEldfnent = document.body;</code><br><p><dfn>DOMContentLoaded</dfn> генерируется на document, когда DOM готов и к нему можно применить JS.<br>
Изображения и другие ресурсы (стили и т.п.) всё ещё могут продолжать загружаться.<br>
<em>window.onload</em> - страница и все ресурсы загружены<br>
<em>window.beforeunload</em> - пользователь покидает страницу.<br>
Если отменить событие, то браузер спросит хочет ли пользователь уйти.<br>
<em>window.unload</em> - пользователь окончательно уходит, можно сделать сетевой запрос.<br>
<em>document.readyState</em> - текущее состояние загрузки документа.<br></p><br><p>Изменения можно отследить с помощью события <dfn>readyStateChange</dfn>:<br>
<b>loading</b> - документ грузится<br>
<b>interactive</b> - документ прочитан, происходит перед DOMContentLoaded<br>
<b>complete</b> - документ и ресурсы загружены, происходит перед window.onload<br></p><br><p>Скрипт должен дождаться пока загрузятся стили.<br>
Скрипты <b><&lt;script&gt;... &lt;/script&gt;</b> или <b><&lt;script src="..."&gt; &lt;/script&gt;</b> блокируют DOMContentLoaded.<br>
Скрипты созданные через <b>document.createElement('script')</b>, добавленные на страницу и скрипты с атрибутами async или defer не блокируют DOMContentLoaded.<br>
Динамически загружаемые скрипты по умолчанию ведут себя как async,</p><pre><code>script.async = false; <span>- отмена async-поведения</span>
let script = document.createElement('script');
script.src = "путь/к/скрипту";
document.body.append(script);</code></pre><p><em>async</em> - скрипты выполняются по загрузке, DOMContentLoaded не имеет значения.<br>
<em>defer</em> - скрипты выполняются по расположению в докумете. Скрипт ждёт загружки документа выполняется перед DOMContentLoaded.<br>
<em>defer</em> работает только у внешних скриптов - у которых есть <b>src="..."</b>, все элементы с src="..." дают события:<br>
<b>load</b> - при успешной загрузке,<br>
<b>error</b> - при ошибке<br>
<em>&lt;iframe&gt;</em> - исключение: всегда даёт load, даже при ошибке.<br>
Событие <em>readystatechange</em> также работает для ресурсов.<br>
Обработчики onload/onerror отслеживают только сам процесс загрузки.<br>
<em>Window.onerror</em> - позволяет "поймать" ошибки в скрипте.<br>
Скрипт одного сайта не может получить детали ошибки скрипта с другого сайта, нужно поставить тегу  атрибут crossorigin 
и специальные заголовки на удалённом сервере.<br>
<em>MutationObserver</em> - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.<br></p><code>let observer = newMutationObserver(callback); - создать наблюдатель</code><p><em>observer.observe(node, config)</em>; - прикрепить наблюдателя к DOM-узлу.<br>
<em>observer.disconnect()</em>; - останавливает наблюдение.<br>
<em>observer.takeRecords()</em>; - получает список необработанных записей измененений, которые произошли, 
но колбэк для них ещё не выполнился.<br></p><br><p>В основе выделения лежит <dfn>Range(диапозон)</dfn> - пара граничных точек: начало и конец диапозона.<br>
<dfn>Range</dfn> - общий, объект для управления диапозоном.<br>
Выделение в документе представлено объектом Selection, который можно получить как 
<b>window.getSelection()</b> или <b>document.getSelection()</b>.<br>
<dfn>Selection</dfn> (выделение) имеет начальную границу (якорь) и конечную (фокус).<br></p><br><p>Основные свойства выделения:<br>
<em>anchorNode</em> - узел начала выделения<br>
<em>anchorOffset</em> - смещение в anchorNode, где начинается выделение<br>
<em>focusNode</em> - узел окончания выделения<br>
<em>focusOffset</em> - смещение в focusNode, где выделение заканчивается<br>
<em>inCollapsed</em> - true, если диарозон выделения пуст или не существует<br>
<em>rangeCount</em> - количество диапозонов в выделении<br></p><br><p><dfn>document.cookie</dfn> предоставляет доступ к куки:<br>
- операция записи изменяет только те куки, которые было указано<br>
- имя и значение куки должны быть закодированы<br>
- одно уки вмещает до 4 kb данных, количество куки зависит от браузера.<br></p><br><p><dfn>Настройки куки</dfn>:<br>
<em>path = /</em> - по умолчанию текущий путь, делает куки видимыми только по указанному пути и ниже<br>
<em>domain = site.com</em> - по умолчанию куки видно только на текущем домене, если явно указан домен, 
то куки видно и на поддоменах<br>
<em>expires или max-age</em> - устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.<br>
<em>secure</em> - делает куки доступными только при использовании HTTPS<br>
<em>somesite</em> - запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки<br></p><br><p><dfn>Методы создания узлов</dfn>:
<em>document.createElement(tag)</em> - создаёт элемент с заданным тегом<br>
<em>document.createTextNode(value)</em> - создаёт текстовый узел<br>
<em>document.write(html)</em> - добавляет html на страницу до завершения её загрузки.<br></p><br><p>После загрузки затирает начальный документ.<br>
<em>const newElement = document.createElement(`div`)</em>; - создал элемент: тег div<br>
<em>const newText = document.createTextNode(`Новый текст`)</em>; - создал текстовый узел<br>
<em>elem.cloneNode(deep)</em> - клонирует элемент, если deep == true, то со всеми дочерними элементами.<br></p><br><p>Вставка и удаление узлов:<br>
<em>node.append(...nodes or strings)</em> - вставляет в node в конец<br>
<em>node.prepend(...nodes or strings)</em> - вставляет в node в начало<br>
<em>node.before(...nodes or strings)</em> - вставляет прямо перед node<br>
<em>node.after(...nodes or strings)</em> - вставляет сразу после node<br>
<em>node.replaceWith(...nodes or strings)</em> - заменяет node<br>
<em>node.remove()</em> - удаляет node<br>
<em>elem.beforebegin</em> - вставляет html прямо перед elem<br>
<em>elem.afterbegin</em> - вставляет html в elem в начало<br>
<em>elem.beforeend</em> - вставляет html в elem в конец<br>
<em>elem.afterend</em> - вставляет html сразу после elem<br>
<em>elem.insertAdjacentText</em> - вставляет текстовые строки<br>
<em>elem.insertAdjacentElement</em> - вставляет элементы<br>
<em>textElement.before(newElement)</em>; - вставил newElement перед textElement<br>
<em>textElement.after(newElement)</em>; - вставил newElement после textElement<br>
<em>textElement.prepend(newElement)</em>; - вставил newElement в начало внутри объекта textElement<br>
<em>textElement.append(newElement)</em>; - вставил newElement в конец внутри объекта textElement<br>
либо<br>
<em>textElement.append(newElement, `Новый текст`)</em>; - можно вставлять через запятую, но теги вставляються как текст<br>
<em>textElement.insertAdjacentHTML('pos', `ins`)</em>; - позволяет вставить в DOM что угодно<br>
<b>pos</b> - место вставки по отношению к textElement<br>
<b>beforebegin</b> - вставить перед textElement<br>
<b>afterbegin</b> - вставить в начало textElement<br>
<b>beforeend</b> - вставить в конец textElement<br>
<b>afterend</b> - вставить после textElement<br>
<b>ins</b> - то что вставляем, позволяет вставить теги<br>
<em>insertAdjacentText()</em>;<br>
<em>insertAdjacentElement()</em>;<br>
<em>textElement.append(oldElement)</em>; - перенес существующий oldElement в конец textElement<br>
<em>let cloneOldElement = oldElement.cloneNode()</em>; - клонировал без дочерних элементов<br>
<em>let cloneOldElement = oldElement.cloneNode(true)</em>; - клонировал с дочерними элементами<br>
<em>textElement.remove()</em>; - удаление объекта<br>
<em>const elementClassNames = element.className</em>; - получил все классы объекта element<br>
<em>element.className = "red"</em>; - заменил все классы на класс red<br>
<em>element.classList.add('active')</em>; - добавить класс<br>
<em>element.classList.remove('active')</em>; - удалить класс<br>
<em>element.classList.toggle('active')</em>; - добавить класс если его нет, а если есть, то удалить<br>
<em>element.classList.contains('active')</em>; - проверяет наличие класса, возвращает true or false<br>
<em>element.style.color = "red"</em>; - получаем доступ к атрибуту style HTML-тега и задаём цвет<br>
<em>console.log(element.style.marginBottom)</em>; - вывод в консоль значения css-свойство атрибута style HTML-тега объекта element<br>
<em>element.style.color = ""</em>; - удалил css-свойство из атрибута style HTML-тега<br>
записываю сразу несколько css-свойств в атрибут style, перезаписывает style полностью<br></p><pre><code>element.style.cssText = `
margin-bottom: 30px;
color: red;
`;</code></pre><br><p><em>const elementStyle = getComputedStyle(eldfnent)</em>; - получил вычисленные стили элемента<br>
<em>console.log(elementStyle.fontSize)</em>; - выводим вычисленое значение размера шрифта<br>
<em>const elementBeforeStyle = getComputedStyle(element, "::before")</em>; - получил стили псевдоэлемента<br>
<em>console.log(elementBeforeStyle.backgroundColor)</em>; - выводим цвет фона, который реализован с помощью ::before<br>
<em>getComputedStyle()</em>; - работает только для чтения<br>
<em>const paddingLeft = parseInt(elementStyle.paddingLeft)</em>; - сразу перевожу значение из строки в число<br>
<em>element.style.marginLeft = "20px"</em>; - задавать значения всегда с единицами измерения<br>
<br>
Устаревшие методы (возвращают node):<br>
<em>parent.appendChild(node)</em><br>
<em>parent.insertBefore(node, nextSibling)</em><br>
<em>parent.removeChild(node)</em><br>
<em>parent.replaceChild(newEldfn, node)</em><br>
<br>
<em>document.forms</em> - живая коллекция всех форм на странице <b>document.forms[name/index]</b><br>
Элементы <em>&lt;form&gt;</em> или <em>&lt;fieldset&gt;</em> доступны через <b>form.elements[name/index]</b> или <b>form[name/index]</b>.<br>
Элементы хранят ссылку на свою форму в свойстве <b>element.form</b>.<br>
Значения элементов формы доступны через <b>input.value</b>, <b>textarea.value</b>, <b>select.value</b> и т.д. либо <b>input.cheked</b> для чекбоксов и переключателей.<br>
<br>
Для <em>&lt;select&gt;</em> можно получить индекс выбранного пункта через: <b>select.selectedIndex</b> либо <b>select.options</b>.<br>
Элемент получает фокус когда пользователь кликает по нему или использует Tab.<br>
<br>
HTML-атрибут <b>auto-focus</b> - устанавливает фокус при загрузке страницы.<br>
HTML позволяет делать валидацию с помощью атрибутор required, pattern и т.д.<br>
События <b>focus и blur</b> срабатывают на фокусировке/потере фокуса элемента и не всплывают, но можно использовать фазу перехвата или focusin/focusout.<br>
<b>tabindex</b> делает фокусируемым любой элемент.<br>
<br>
<em>document.activeElement</em> - текущий элемент с фокусом.<br>
<em>const form = document.forms[0]</em> - получить форму по индексу коллекции<br>
<em>const form = document.forms.main</em> - по аттрибуту тега name (name="main")<br>
<br>
<em>document.querySelectorAll('form')</em> - неживая коллекция<br></p><pre><code>const form = document.forms.main<br>
console.log(form.elements) -  вывел элементы формы<br></code></pre><br><p><em>focus, blur</em> - события не всплывают<br>
<br>
<em>focus(), blur()</em> - методы. Аттрибут taindex = -1 на клавишу tab не реагирует, но можно установить фокус на елемент методом<br>
<em>document.activeElement</em> - получаем текущий элемент с фокусом<br>
<em>focusin / focusout</em> - события всплывают<br>
<br>
<dfn>События изменения данных:</dfn><br>
<em>change</em> - значение изменено. срабатывает в текстовом поле при потере фокуса, в остальных полях при выборе.<br>
<em>input</em> - значение изменено. Срабатывает немедлено при каждом изменении текстового поля.<br>
<em>cut/copy/paste</em> - свойство event.clipboardData даёт доступ на чтение/запись в буфер.<br>
<em>cut</em> - событие, срабатывает при вырезании<br>
<em>copy</em> - событие, срабатывает при копировании<br>
<em>paste</em> - событие, срабатывает при вставке<br>
<em>submit</em> - событие отправки данных формы, при <b>form.submit()</b> - форма отправится при потере фокуса<br>
<em>event.preventDefault()</em> - запретит выполнение события<br>
<br>
<dfn>Отправка формы:</dfn><br>
Нажать кнопку <b>&lt;input type="submit"&gt;</b> или <b>&lt;input type="image"&gt;</b><br>
Нажать Enter на любом поле<br>
При отправке формы по нажатию Enter в текстовом поле, генерируется событие <em>click</em> на кнопке <b>&lt;input type="submit"&gt;</b><br>
При отправке формы срабатывает событие <em>submit</em>, оно используется для проверки формы перед её отправкой на сервер 
или для отмены отправки и обработки её с помощью JS.<br>
<b>form.submit()</b> позволяет отправить форму из JS. Используют для создания и отправки собственных форм на сервер, 
при этом событие <em>submit</em> не генерируется.<br>
<br>
<dfn>scroll</dfn> - событие прокрутки позволяет реагировать на прокрутку страницы или элемента.<br></p><pre><code>window.addEventListener('scroll', function() {
  document.getEldfnentById('showScroll').innerHTML = pageYOffset + 'px';
});
</code></pre></details><details><summary>EventTarget</summary><p><dfn>EventTarget</dfn> - это абстрактный класс.<br>
Обеспечивает поддержание DOM-узлами событий.<br>
<br>
<dfn>Event</dfn>(Событие) - сигнал от браузера о том, что что-то произошло.<br>
Событию можно назначить обработчик - функцию, которая сработает, как только событие произошло.<br>
Способы назначения обработчиков событий:<br>
Атрибут HTML: <b>onclick="..."</b>.
DOM-свойство: <b>elem.onclick = function</b>.
Методы: <b>elem.addEventListener(event, handler[, phase])</b> для добавления<br>
<b>event</b> - имя события, например "click".<br>
<b>handler</b> - ссылка на функцию обработчик.<br>
<b>options</b> - дополнительный объект со свойствами:<br>
<b>once</b>: если true, тогда обработчик будет удалён после выполнения.<br>
<b>capture</b>: фаза, на которой должен сработать обработчик (false/true)<br>
<b>passive</b>: если true, то обработчик не вызовет preventDefault()<br>
<br>
Обработчик всегда хранится в свойстве DOM-объекта, а атрибут - лишь один из способов его инициализации.<br>
В DOM-свойстве один обработчик на один тип события, так как одно имя - одно свойство.<br>
Методы - самый гибкий и используемый способ.<br>
<b>addEventListener</b> поддерживает объекты в качестве обработчиков событий, вызывая метод объекта object.handleEvent(event).<br>
Убрать обработчик <b>elem.onclick = null</b>.<br>
Не используй <b>setAttribute</b> для обработчиков.<br>
Регистр DOM-свойства имеет значение, а HTML-атрибута - нет.<br>
Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.<br>
Любой обработчик получает объект события первым аргументом<br>
<em>event.type</em> - тип события, например "click"<br>
<em>event.clientX/event.clientY</em> - координаты курсора для событий мыши в момент клика относительно окна.<br>
<br>
<dfn>События</dfn>:<br>
<em>onclick="JScode"</em> - обработчик события, аттрибут тега.<br></p><code>const button = document.querySelector('.button');</code><p><em>button.onclick = function () {};</em> - нет возможности повесить на одно событие несколько обработчиков<br>
либо<br></p><code>function showClick() {}</code><p><em>button.onclick = showClick;</em> - нет возможности повесить на одно событие несколько обработчиков<br>
<em>button.addEventListener("click", function (e) {});</em> - можно назначить обработчик несколько раз<br>
либо<br></p><code>button.addEventListener("click", func);
function func(e) {}
<br></code><p><em>button.removeEventListener(event, handler);</em> - отключает обработчик<br>
<em>button.addEventListener(event, handler, options);</em> - можно добавить параметры<br></p><pre><code>const options {
  "capture: false", - фаза, на которой должен сработать обработчик (всплытие/погружение)
  "once": false, - если true, тогда обработчик будет удален после выполнения
  "passive": false - если true, то обработчик никогда не вызовет preventDefault()
}
либо
button.addEventListener("click", func, {"once": true});</code></pre><br><p>Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его
в качестве аргумента (event) функции - обработчику:<br>
<em>event.type</em> - тип события<br>
<em>event.target</em> - объект, на котором сработал обработчик<br>
<em>event.currentTarget</em> - объект, которому назначен обработчик<br>
<em>event.clientX</em> - положение курсора по Х<br>
<em>event.clientY</em> - положение курсора по Y<br>
<em>console.log(evant)</em> - посмотреть все детали события<br>
<em>event.stopPropagation()</em>; - остановка всплытия<br>
<br>
<dfn>Делегирование</dfn> - вешаем прослушку на родителя<br>
Отмена действий браузера по умолчанию:<br></p><pre><code>event.preventDefault(); - для addEventListener
либо
button.addEventListener("click", func, {"passive": true});

link.onclick = function () { - для onclick
  return false;
}</code><br></pre><p><dfn>Всплытие и погружение:</dfn><br>
целевой элемент <b>(event.target)</b> - самый глубоко вложенный элемент, над которым произошло событие.<br>
Сначала событие двигается вниз (погружение) от корня документа к event.target, по пути вызывая обработчики, 
поставленные через <b>addEventListener(..., true)</b>,<br>
где true - сокращенно <b>{capture: true}</b><br>
Далее обработчики на целевом элементе.<br>
Потом событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
поставленные через on&lt;event&gt; и addEventListener без третьего аргумента
или с третьим аргументом равным fasle.<br>
Каждый обработчик имеет доступ к свойствам события event:<br>
<em>event.target</em> - самый глубокий элемент, на котором произошло событие<br>
<em>event.currentTarget(=this)</em> - элемент, на котором в данный момент сработал обработчик 
(тот, на котором "висит" конкретный обработчик)<br>
<em>event.eventPhase</em> - не какой фазе он сработал: (погружение = 1, фаза цели = 2, всплытие = 3)<br>
<br>
Любой обработчик может остановить событие вызовом <b>event.stopPropagation()</b>.<br>
Всплытие и погружение являются основой для делегирования событий.<br>
Делегирование событий используется при схожей обработке многих элементов.<br>
Вешаем обработчик на контейнер.<br>
В обработчике проверяем целевой элемент <b>event.target</b>.<br>
Если событие произошло на нужном элементе, то обрабатываем его.<br>
<br>
Использование:<br>
Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.<br>
Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.<br>
Удобство изменений DOM: можно массово добавлять или удалятьэлементы путём изменения innerHTML и ему подобных.<br>
<br>
Событие должно всплывать. Низкоуровневые обработчики не должны вызывать event.stopPropagation().<br>
Два способа отменить действие браузера по умолчанию:<br>
- <em>event.preventDefault()</em> - основной способ<br>
либо
- &lt;a href="/" onclick = "event.preventDefault()"&gt;здесь&lt;/a&gt;<br>
Опция <b>passive</b>: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено.<br>
Это сообщит браузеру, что он не должен ждать выполнения всех обработчиков, 
а ему следует сразу приступать к выполнению действия по умолчанию, например к прокрутке.<br>
event.defaultPrevented равно true если событие по умолчанию отменено, иначе false.<br>
Чтобы сгенерировать событие из кода, вначале нужно создать объект события<br></p><code>let event = newEvent(name[, options]);</code><p>Базовый конструктор <em>Event(name, options)</em> принимает обязательное имя события и options - объект с тремя свойствами:<br>
- <em>bubbles: true</em> - чтобы событие всплывало<br>
- <em>cancelable: true</em> - если нужно, чтобы работал event.preventDefault()<br>
- <em>composed: true/false</em> - если true, то событие будет всплывать наружу за пределы Shadow DOM.<br>
По умолчанию все три свойства - false:<br></p><code>{bubbles: false, canselable: false, composed: false}.</code><p><em>elem.dispatchEvent(event)</em> - запускает объект события на элементе.<br>
<em>event.isTrusted</em> - true для событий от пользователя и false для генерирующих.<br>
<em>on&lt;event&gt;</em> - для встроенных событий.<br>
<em>addEventListener</em> - для генерируемых.<br>
При создании встроенных событий использовать конструкторы встроенных событий (newMouseEvent("click") и др.)<br>
Для пользовательских событий применять конструктор CustomEvent.<br>
event.detail позволяет передавать информацию в объекте события.<br>
Генерировать встроенные события в случаях:<br>
- явный грубый хак, чтобы заставить работать сторонние библиотеки, если нет другого способа.<br>
- скриптом нажать на кнопку для автоматического тестирования.<br>
<br>
<dfn>События мыши:</dfn><br>
<em>click</em> - кликнули на элемент левой кнопкой мыши (на устройсвах с сенсорными экранами - при касании).<br>
contextmenu - происходит, когда кликнули на элемент правой кнопкой мыши<br>
<em>mouseover/mouseout</em> - когда мышь наводится на/покидает элемент.<br>
<em>mousedown/mouseup</em> - когда нажали/отжали кнопку мыши на элементе.<br>
<em>mousemove</em> - при движении мыши.<br>
Комплексные события состоят из простых, обработчики событий вызываются в следующем порядке:<br>
<b>mousedown -> mouseup -> click</b><br>
Свойство события мыши which - какая кнопка мыши нажата:<br>
- <b>event.which == 1</b> - левая кнопка<br>
- <b>event.which == 2</b> - средняя кнопка<br>
- <b>event.which == 3</b> - правая кнопка<br>
Клавиши - модификаторы (true если нажаты): <b>altKey, ctrKey и metaKey (Mac)</b>.<br>
В Мас обычно Cmd вместо ctrl, поэтому лучше проверить: <b>if(e.metaKey || e.ctrlKey)</b>.<br>
Координаты относительно окна: clientX, clientY.<br>
Координаты относительно документа: pageX/pageY.<br>
Запрет копирования:<b> &lt;div oncopy = "alert('Копрование запрещено!'); return false"&gt;</b><br>
При быстром движении мыши события не будут возникать на промежуточных элементах.<br>
Браузер периодически проверяет позицию курсора и при изменении генерирует событие mousemove.<br>
Если был mouseover, то будет и mouseout.<br>
События mouseover/out и mouseenter/leave имеют дополнительное свойство relatedTarget.<br>
Для события mouseover:<br>
<em>event.target</em> - это элемент, на который курсор пришёл.<br>
<em>event.relatedTarget</em> - это элемент, с которого курсор пришёл (target -> relatedTarget)<br>
<em>event.relatedTarget</em> равно null - указатель мыши пришёл из-за или ушёл за пределы окна.<br>
В любой момент времени указатель может быть только над одним элементом - над самым глубоко вложенным.<br>
События <b>mouseover/out</b> возникают, когда происходит переход с родительского элемента на потомка.<br>
События <b>mouseenter/leave</b> не всплывают и генерируются, когда курсор переходит или уходит на элемент в целом (без учёта потомков).<br>
<br>
<dfn>Простые</dfn>:<br>
<em>mousedown / mouseup</em> - кнопка мыши нажата / отпущена над элементом<br>
<em>mouseover / mouseout</em> - курсор мыши появляется над элементом и уходит с него<br>
<br>
<dfn>mouseover</dfn>:<br>
<em>event.target</em> - элемент откуда ушёл курсор<br>
<em>event.relatedTarget</em> - элемент куда ушёл курсор<br><br>
<br>
<dfn>mouseout</dfn>:<br>
<em>event.target</em> - элемент куда пришёл курсор<br>
<em>event.relatedTarget</em> - элемент откуда пришёл курсор<br>
<br>
<em>mousemove</em> - каждое движение мыши над элементом генерирует это событие<br>
<em>contextmenu</em> - вызывается при попытке открытия контекстного меню<br>
<br>
<dfn>Комплексные</dfn>
<em>click - mousedown и mouseup</em> над одним и тем же элементом<br>
<em>dblclick</em> - двойной клик на элементе<br>
<br>
<em>event.which = 1</em> - нажата основная кнопка мыши (левая)<br>
<em>event.which = 2</em> - нажата средняя кнопка мыши (колесо)<br>
<em>event.which = 3</em> - нажата не основная кнопка мыши (правая)<br>
<br>
<em>mouseover / mouseout</em> - всплывают, можно использовать делегирование,<br>
<em>mouseenter / mouseleave</em> - нет<br>
<br>
<dfn>Базовый алгоритм Drag'n'Drop.</dfn><br>
При mousedown - готовим элемент к перемещению (если нужно создаём его копию).<br>
При mousemove передвигаем элемент на новые координаты путём смены left/top и position: absolute.<br>
При mouseup - остановить перенос элемента и произвести окончание Drag'n'Drop.<br>
Ключевые идеи:<br>
<b>object.mousedown -> document.mousemove -> object.mouseup</b><br>
(обязательно отменить браузерный ondragstart)<br>
В начале перетаскивания запоминаем начальное смещение указателя относительно элемента(shiftX/shiftY) и сохраняем его при перетаскивании.<br>
Выявляем потенциальные цели переноса под указателем с помощью <b>document.elementFromPoint</b>.<br>
На mouseup завершить перенос: изменить данные, переместить элементы.<br>
<br>
<dfn>События указателя</dfn> (Pointer events) одновременно обрабатывают действия мыши, касания пера.<br>
Содержат свойства мыши и дополнительно свои:<br>
<em>pointerId</em> - идентификатор указателя, вызвавшего событие, генерируется браузером,
позволяет обрабатывать несколько указателей (стилус и мультитач).<br>
<em>pointerType</em> - тип указывающего устройства. Строка с одним из значений: "mouse", "pen" или "touch".<br>
<em>isPrimary</em> - равно true для основного указателя (первый палец в мультитач).<br>
При обработке переносов и сложных касаний нужно отменить действие браузера и ставить <b>touch-events: none</b> в CSS для элементов.<br>
Можно перенаправить (захватить) все события указателя на определённый элемент до наступления события pointerup/pointercancel.<br>
Два связанных с захватом события:<br>
<b>getpointercapture</b> срабатывает, когда элемент использует <b>setPointerCapture</b> для включения захвата.<br>
<b>lostpointercapture</b> срабатывает при освобождении от захвата:<br>
- явно с помощью <b>releasePointerCapture</b> или<br>
- автоматически при событии <b>pointerup/pointercancel</b>.<br>
<br>
<dfn>Сбытия указателя - мыши</dfn>:<br>
<em>pointerdown - mousedown</em><br>
<em>pointerup - mouseup</em><br>
<em>pointermove - mousdfnove</em><br>
<em>pointerover - mouseover</em><br>
<em>pointerenter - mouseenter</em><br>
<em>pointerleave - mouseleave</em><br>
<em>pointercancel - </em><br>
<em>getpointercapture - </em><br>
<em>lostpointercapture - </em><br>
<br>
<dfn>События клавиатуры</dfn>:<br>
<em>keydown</em> - происходит при нажатии клавиши<br>
<em>keyup</em> - при отпускании клавиши<br>
<em>event.code</em> - код нажатой клавиши ("KeyA", "ArrowLeft" и т.д.)<br>
<em>event.key</em> - клавиша с учетом регистра и раскладки клавиатуры символ ("A", "a" и т.д.)<br>
<em>event.repeat</em> - вернет true при срабатывании повтора на зажатой клавише<br>
Нажатие клавиши всегда генерирует клавиатурное событие, кроме клавиши Fn.<br>
<br>
<dfn>Прокрутка</dfn>:<br>
<em>scroll</em> - событие прокрутки<br>
<em>scrollY</em> - количество прокрученных пикселей по вертикали<br>
<em>scrollX</em> - количество прокрученных пикселей по горизонтали<br>
<br>
<dfn>Загрузка</dfn>:<br>
<em>DOMContentLoaded</em> - браузер полностью загрузил HTML, построил DOM-дерево, 
но внешние ресурсы могут быть ещё не загружены
срабатывает на объекте document<br>
<em>load</em> - браузер полностью загрузил HTML, и внешние ресурсы
срабатывает на объекте window<br>
<em>beforeunload / unload</em> - пользователь покидает сраницу<br>
<em>beforeunload</em> - можем вывести пользователю предупреждение о несохраненных данных в форме<br>
<em>unload</em> - пользователь уже ушёл состраницы, но можно поручить браузеру собрать статистику<br>
<br>
<em>document.readyState</em> - остояние загрузки:<br>
<em>loading</em> - документ загружается<br>
<em>interactive</em> - документ был полностью прочитан<br>
<em>complete</em> - документ был полностью прочитан и все ресурсы загружены<br>
<br>
События, отправленные сервером (SSE), позволяют веб-странице получать обновления с сервера.<br>
В случае событий, отправленных сервером, обновления приходят автоматически.<br>
</p></details><details><summary>Properties</summary><p>Когда браузер загружает страницу, он читает (парсит) HTML и генерирует DOM-объекты.<br>
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся
свойствами DOM-объектов.<br>
У каждого тега свои атрибуты:<br>
Атрибуты написаны в HTML, свойства - в DOM-объектах.<br>
Можно изменять DOM-узлы добавляя своё свойство.<br>
Методы для работы с атрибутами:<br>
<em>elem.hasAttribute(name)</em> - проверить на наличие<br>
<em>elem.getAttribute(name)</em> - получить значение<br>
<em>elem.setAttribute(name, value)</em> - установить значение<br>
<em>elem.removeAttribute(name)</em> - удалить атрибут<br>
<em>elem.attributes</em> - коллекция всех аттрибутов<br>
<br>
<dfn>Свойства</dfn>:<br>
<em>nodeType</em> - тип DOM-узла.<br>
Только для чтения.<br>
Его значение-числовое: 1- элементы, 3 - текстовые узлы и т.д.<br>
<br>
<em>nodeName/tagName</em> - возвращает название тега.<br>
Только для чтения.<br>
Для узлов - неэлементов описывает, что за узел.<br>
<br>
<em>innerHTML</em> - внутренее HTML-содержимое узла-элемента.<br>
Изменяемый.
С innerHTML вставка происходит "как HTML", со всеми HTML-тегами.<br>
<br>
<em>console.dir(element)</em>; - выведет список доступных свйоств DOM-объекта element<br>
<em>element.hasAttribute('some-name')</em>; - проверить наличие аттрибута name<br>
<em>element.getAttribute('some-name')</em>; - получить значение аттрибута name<br>
<em>element.setAttribute('some-name', value)</em>; - создать аттрибут (some-name) и установить в него значение (value)<br>
<em>element.removeAttribute('some-name')</em>; - удалить аттрибут name<br>
<em>element.tagName</em> - показывает какой тег у объекта<br>
<em>element.hidden = true</em>; - скрыть или показать объект<br></p><img src="../img/js/JS58.png" alt=""><br><img src="../img/js/JS59.png" alt=""><br><img src="../img/js/JS60.png" alt=""><br><img src="../img/js/JS61.png" alt=""><br><br><p><dfn>Размеры и координаты</dfn><br>
<em>const mainElement = document.documentElement</em>; - получил объект html<br>
<em>const mainElementWidth = mainElement.clientWidth</em>; - доступная ширина окна без прокрутки<br>
<em>const mainElementHeight = mainElement.clientHeight</em>; - доступная высота окна без прокрутки<br>
<em>const windowWidth = window.innerWidth</em>; - ширина окна с полосой прокрутки<br>
<em>const windowHeight = window.innerHeight</em>; - высота окна с полосой прокрутки<br>
<br>
Ширину и высоту всего документа (включая прокрученную часть) можно найти:<br></p><pre><code>let scrollWidth = Math.max(
  document.body.scrollWidth, document.documentElement.scrollWidth,
  document.body.offsetWidth, document.documentElement.offsetWidth,
  document.body.clientWidth, document.documentElement.clientWidth,
);

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);</code></pre><br><p><dfn>Метрики</dfn><br></p><img src="../img/js/metrics.png" alt=""><p><em>element.offsetParent</em>; - получаем родительский элемент, относительно которого позиционирован eldfnent<br>
<em>element.offsetLeft</em>; - отступ слева от родительского элемента element.offsetParent<br>
<em>element.offsetTop</em>; - отступ сверху от родительского элемента element.offsetParent<br>
<em>element.offsetWidth</em>; - общая ширина element<br>
<em>element.offsetHeight</em>; - общая высота element<br>
<em>element.clientTop</em>; element.clientLeft; - отступы внутренней части element от внешней<br>
<em>element.clientWidth</em>; element.clientHeight; - размеры объекта без рамок и полосы прокрутки<br>
<em>element.scrollWidth</em>; element.scrollHeight; - размеры объекта без рамок и полосы прокрутки, включая прокручиваемую часть внутри объекта<br>
<em>element.scrollLeft</em>; element.scrollTop; - размеры прокрученной области внутри объекта, можно считывать и задавать значения к объекту можно применять scrollBy, scrollTo, scrollIntoView<br>
<em>element.getBoundingClientRect()</em>; - получить координаты относительно окна браузера<br>
<em>element.getBoundingClientRect().top + window.pageYOffset</em>; - получить координаты относительно документа<br>
<em>const elem = document.eldfnentFromPoint(x, y)</em>; - узнать какой элемент находится по указанным координатам (координаты относительно окна браузера)<br>
<br>
<em>data-аттрибут</em> - для ввода нестандартных аттрибутов:<br>
<em>element.dataset.size = "1024"</em>; - установил в аттрибут data-size значение 1024<br>
<em>alert(document.body.innerHTML)</em>; - читаем текущее содержимое<br>
<em>document.body.innerHTML = 'Новый BODY!'</em>; - заменяем содержимое<br>
Если innerHTML вставляет в документ тег  - он становится частью HTML, но не запускается.<br>
<br>
<dfn>outerHTML</dfn> - полный HTML узла-элемента.<br>
Запись в elem.outerHTML заменяет elem во внешнем контексте.<br></p><pre><code>&lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;

alert(elem.outerHTML); - &lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;</code></pre><br><p><dfn>textContent</dfn> - текст внутри элемента: HTML за вычетом всех тегов.<br>
Запись в него помещает текст в элемент, при этом все спецюсимволы и теги интерпретируются как текст.<br>
Можно использовать для защиты от вставки произвольного HTML кода.<br>
<dfn>hidden</dfn> - если true, то скрывает элемент.<br>
<dfn>nodeValue и data</dfn> - содержимое узла-неэлемнта (текст, комментарий).<br>
Обычно используют data. Изменяемый.<br></p><pre><code>&lt;p&gt;Привет&lt;/p&gt;
// Комментарий

let comment = text.nextSibling;
alert(comment.data); - Комментарий

JS может прочитать if из свойства data и обработать инструкции:
// if isAdmin
Добро пожаловать, Админ!
// /if </code></pre><p>Лучше использовать DOM-свойства. Атрибуты используем тогда, когда нужны именно атрибуты.<br>
Например нестандартный атрибут. Если он начинается с data-, то нужно использовать dataset.<br></p><pre><code>&lt;body data-about = "Elephants"&gt;
alert(document.body.dataset.about); - Elephants</code></pre><p>Атрибут из нескольких слов data-order-state это свойство dataset.orderState<br>
Геометрические свойства (метрики) DOM-элементов<br>
<dfn>offsetParent</dfn> - ближайший CSS-позиционированный родитель или td, th, table, body.<br>
<dfn>offsetLeft/offsetTop</dfn> - позиция в пикселях верхнего левого угла offsetParent.<br>
<dfn>offsetWidth/offsetHeight</dfn> - внешняя ширина/высота элемента, включая рамки.<br>
<dfn>clientLeft/clientTop</dfn> - это border - отступ внутренней части элемента от внешней.<br>
<dfn>clientWidth/clientHeight</dfn> - ширина/высота сожержимого вместе <br>
с внутренними отступами padding, но без полосы прокрутки.<br>
<dfn>scrollWidth/scrollHeight</dfn> - ширина/высота содержимого с учетом <br>
прокрученной (невидимой) области элемента.<br>
<dfn>scrollLeft/scrollTop</dfn> - ширина/высота прокрученной сверху части элемента,
считается от верхнего левого угла.<br>
<br>
Все кроме scrollLeft/scrollTop доступны только для чтения.<br>
Если элемент, или любой его родитель, имеет display:none или отсутствует в документе, 
то все его метрики равны нулю (или null если это offsetParent).<br>
Лучше использовать свойства-метрики т.к. CSS-свойства width/height зависят от другого свойства - box-sizing,
которое определяет CSS-ширину/высоту.<br>
Изменение box-sizing сломает код.<br>
CSS-свойства width/height могут быть равны auto.<br>
Ширина/высота видимой части документа:<br>
document.documentElement.clientWidth/Height
Ширина/высота всего документа с прокрученной частью:<br></p><pre><code>let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);</code></pre><p><dfn>Прокрутка</dfn>:<br>
<em>window.pageYOffset/pageXOffset</em> - прокрутка окна.<br>
<em>window.scrollTo(pageX, pageY)</em> - абсолютные координаты.<br>
<em>window.scrollTo(0, 0)</em> - прокрутка в самое начало.<br>
<em>window.scrollBy(x, y)</em> - прокрутка относительно текущего места.<br>
<em>window.scrollBy(0, 10)</em> - прокручивает страницу на 10рх вниз.<br>
<em>window.scrollIntoView(top)</em> - прокрутить страницу, чтобы eldfn стал видимым
(выровнять относительно верхней/нижней части окна).<br>
<br>
Количество прокрученных пикселей (только для чтения):<br>
<em>const windowScrollTop = window.pageYOffset</em>; - количество пикселей прокрученных сверху<br>
<em>const windowScrollLeft = window.pageXOffset</em>; - количество пикселей прокрученных слева<br>
<em>window.scrollBy(x, y)</em>; - прокручивает страницу относительно текущего положения<br>
<em>window.scroll(x, y)</em>; - прокручивает страницу на абсолютные координаты<br>
<em>window.scrollTo(x, y)</em> - прокручивает страницу на абсолютные координаты<br>
<em>element.scrollIntoView(top)</em>; - прокрутит страницу до элемента element.<br>
          Если <b>top = true</b>, то элемент будет вверху страницы<br>
          Если <b>top = false</b>, то элемент будет внизу страницы<br>
Запретить или разрешить прокрутку:<br>
<em>document.body.style.overflow = "hidden"</em>; - добавляет <b>overflow = "hidden"</b> в аттрибут style тега body<br>
либо<br>
<em>document.body.classList.toggle('scroll-lock')</em>; - добавляет класс в тег body,<br>
потом нужно добавить в класс css-свойство <b>overflow = "hidden"</b><br>
<br>
Для прокрутки страницы из JS её DOM должен быть полностью построен.<br></p><code> document.body.style.overflow = "hidden"</code><p>Все координаты в контексте окна считаются от верхнего левого угла.<br>
<em>position: fixed</em>; - для координат относительно окна.<br>
<em>position: absolute</em>; - для координат относительно документа.<br>
Любая точка на странице имеет координаты:<br>
- относительно окна браузера - <b>elem.getBoundingClientRect()</b><br>
- относительно документа - <b>elem.getBoundingClientRect()</b> + прокрутка страницы.<br>
<em>document.elementFromPoint(x, y)</em> - возвращает самый глубоко вложенный элемент по координатам (х, у). <br>
Для координат вне окна возвращает null.<br>
<br>
<dfn>CSS</dfn>:<br>
CSS-событие <em>transitioned</em> - CSS-анимация завершена.<br>
Два способа задания стилей элементу:<br>
&lt;div class=" "&gt; - создать класс в CSS и использовать его<br>
&lt;div style="color:some"&gt; - писать стили в атрибуте style<br>
JS может менять и классы CSS и свойство style.<br>
Лучше использовать классы. Свойство style только если класс не подходит.<br>
Для управления классами существует два DOM-свойства:<br>
<em>className</em> - строковое значение, заменяет всю строку с классами.<br>
<em>classList</em> - объект с методами для управления одним классом.<br>
<br>
<dfn>Методы classList</dfn>:<br>
<em>elem.classList.add/remove("class")</em> - добавить/удалить класс.<br>
<em>elem.classList.toggle("class")</em> - добавит класс если его нет, иначе удалит.<br>
<em>elem.classList.contains("class")</em> - проверка наличия класса, возвращает true/false.<br>
<br>
Свойство style это объект со стилями в camelCase:<br></p><pre><code>background-color - elem.style.backgroundColor
z-index - elem.style.zIndex
border-left-width - elem.style.borderLeftWidth
style = "width: 100px" - elem.style.width = "100px"</code><br></pre><p>Чтобы удалить elem.style.display нужно присвоить пустую строку:<br></p><code>elem.style.display = "".</code><p>Свойство <em>style.cssText</em> - вся строка стилей атрибута style:</p><pre><code>&lt;div id = "div"&gt;Button&lt;/div&gt;

div.style.cssText = `
color: red !important;
background-color: yellow;
width: 100px;
text-align: center;`
alert(div.style.cssText);</code></pre><p><dfn>getComputedStyle(eldfn, [psevdo])</dfn> - возвращает объект для чтения окончательных стилей 
с учетом всех классов, после применения CSS и вычисления окончательных значений.<br>
eldfn - элемент, значения для которого нужно получить.<br>
psevdo - если нужен псевдоэлемент ::before.<br>
Без аргумента означает сам элемент.<br>
</p></details><details><summary>Storage</summary><p><dfn>localStorage и sessionStorage</dfn> - объекты вэб-хранилища, позволяют хранить пары ключ/значение в браузере.<br>
<em>key и value</em> - строки<br>
<em>Лимит 2 Mb</em> - зависит от браузера<br>
Данные не имеют срока хранения<br>
Данные привязаны к источнику (домен/протокол/порт)<br>
<dfn>localStorage</dfn> - используется между всеми вкладками и окнами одного источника совместно. Переживает перезапуск браузера.<br>
<dfn>sessionStorage</dfn> - разделяется в рамках вкладки браузера, среди ифреймов из того же источника.<br>
Переживает перезагрузку страницы, но не закрытие вкладки.<br>
<br>
<dfn>API</dfn>:<br>
<em>setItdfn(key, value)</em> - сохранить пару ключ/значение<br>
<em>getItdfn(key)</em> - получить данные по ключу key<br>
<em>rdfnoveItdfn(key)</em> - удалить значение по ключу key<br>
<em>clear()</em> - удалить всё<br>
<em>key(index)</em> - получить ключ по заданной позиции<br>
<em>length</em> - количество элементов в хранилище<br>
<em>Object.keys</em> - получить все ключи<br>
Если обращаться к ключам как к обычным свойствам объекта, то событие storage не срабатывает.<br>
<br>
<dfn>Событие storage</dfn>:<br>
Срабатывает при вызове <b>setItdfn, rdfnoveItdfn, clear</b><br>
Содержит все данные о произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea<br>
Срабатывает на всех объектах window, которые имеют доспут к хранилищу, кроме того где оно было сгенерировано 
(внутри вкладкидля sessionStorage, глобально для localStorage)<br>
<br>
<dfn>IndexedDB</dfn> - встроенная база данных типа ключ-значение, мощнее localStorage.<br>
Интерфейс для IndexedDB основан на событиях IndexedDB имеет встроенный механизм версионирования схемы, 
который отсутствует в серверных базах данных.<br>
IndexedDB работает на стороне клиента (в браузере) и у нас нет прямого доступа к данным.<br>
При публикации новой версии приложения возможно обновлять базу данных.<br>
<br>
<dfn>Использование</dfn>:<br>
Пoдключить обёртку над промисами (idb)<br>
Открыть базу данных: <b>idb.openDb(name, version, onupgradeneeded)</b><br>
Создание хранилищ объектов и индексов в обработчике onupgradeneeded<br>
Обновление версии - либо сравнивая номера версий, либо проверить что есть, а что нет.<br>
<br>
<dfn>Для запросов</dfn>:<br>
Создать транзакцию <b>db.transaction('books')</b> - можно указать readwrite.<br>
Получить хранилище объектов <b>transaction.objectStore('books')</b>.<br>
Для поиска по ключу вызвать метод непосредственно у хранилища объектов.<br>
Для поиска по любому полю объекта нужно создать индекс.<br>
Если данных не помещаются в памяти, то используй курсор.
</p></details></details></details><details><summary>React</summary><p><b>npx create-react-app название папки (проекта)</b><br>
  - создаст папку с названием проекта и стартовым шаблоном внутри.<br>
<em>JSX</em>:<br>
  - это синтаксический сахар для React.createElement.<br>
  - это расширение JS, чтобы объяснить React как выглядит UI.<br>
  - напоминает язык шаблонов, наделённый силой JavaScript.<br>
  - производит элементы React.<br>
  - преобразуется в JS функцию, которая возвращает JS объект.<br>
  После компиляции каждое JSX-выражение становится обычным вызовом JS-функции, результат которого  - объект JS.<br>
<br>
&lt;div&gt;&lt;/div&gt; = &lt;div/&gt; - если тэг пустой, то самозакрывающийся тэг.<br>
Если разделить выражение на строки, то его нужно обернуть в ().<br>
Запись атрибутов в camelCase.<br>
Кавычки (для строковых литералов), фигурные скобки (для JS-выражений), но не то и другое вместе.<br>
<br>
&lt;div tabIndex=”0”&gt;&lt;/div&gt; - литералы в строке<br>
&lt;img src={user.avatarUrl}&gt; - JS выражения в { }<br>
<br></p><pre><code>const name = ‘Иван-Царевич’; <span> - создали переменную</span>
<span>создали элемент с переменной внутри.</span>
const element = &lt;h1&gt;Здравствуй, {name}!&lt;/h1&gt;;
</code></pre><br><p>Элемент описывает то, что будет на экране.<br>
команда ReactDOM-у отрисовать созданный элемент</p><pre><code>ReactDOM.render(
  element,
  document.getElementById('root'))</code></pre><p>внутри элемента страницы с выбранным id<br>
<br>
<em>&lt;div/&gt</em>; - DOM-тэг с маленькой буквы<br>
<em>&lt;Welcome/&gt</em>; - компонент с большой.<br>
<br>
Первоначальный рендеринг компонента в DOM называется “монтированием” - (mounting).<br>
Каждый раз когда DOM-узел, созданный компанентом, удаляется, происходит “размонтирование” - (unmounting).<br>
<br>
<em>Методы жизненного цикла</em>:<br>
<em>componentDidMount() {...}</em> - запускается после того, как компонент отрендерился в DOM<br>
<em>componentWillUnmount() {...}</em> - запускается перед размонтированием<br>
<br>
Поля <em>this.props</em> и <em>this.state</em> в классах особенные, и их устанавливает сам React.<br>
Присвоить значение this.state можно только в конструкторе,
в остальных случаях только через изменение: <b>this.state({comment: ‘Привет’})</b>.<br>
Родитель-компонент передаёт своё состояние дочерним компонентам в виде пропса.<br>
Это однонаправленный поток данных.<br>
<br>
<em>this.props</em> и <em>this.state</em> могут обновляться асинхронно поэтому операции с ними нужно проводить внутри функции,
получая текущие значения в качестве параметров:<br></p><code>this.setState((state.props) => ({
  counter: state.counter + props.increment
}))</code><br><p><em>Обработка событий</em>:<br>
HTML: &lt;button onclick="activateLasers()"&gt; Активировать лазеры &lt;/button&gt;<br>
React: &lt;button onClick={activateLasers}&gt; Активировать лазеры &lt;/button&gt;<br>
activateLasers - это функция-обработчик события<br>
<br>
В React есть соглашение об именах:<br>
<em>on[имя события]</em> - для пропсов, отвечающих за события,<br>
<em>handle[имя события]</em> - для методов, обрабатывающих события.<br>
События в React в camelCase.<br>
<br>
Чтобы предотвратить обработчик события по умолчанию, нужно вызвать <b>preventDefault()</b>.<br></p><pre><code>function ActionLink() {
  function handleClick(e) {
    e.preventDefault()
    console.log(‘По ссылке кликнули’)
  }
  return (
    &lt;a href=”#”
    onClick={handleClick}&gt;
    Нажми на меня &lt;/a&gt;
  )
}</code></pre><br><p>Если ссылаться на метод как на ссылку - без вызова, т.е. без () поcле него, например, <b>onClick={this.handleClick}</b>,
этот метод нужно привязать к контексту:<br>
в конструкторе <b>this.handleClick = this.handleClick.bind(this)</b>;<br>
в render() &lt;button onClick={this.handleClick}&gt;<br>
или так:<br></p><pre><code>handleClick = () => {
  console.log('значение this: ', this)
}
&lt;button
  onClick={this.handleClick}&gt;
  Нажми на меня
&lt;/button&gt;</code></pre><p>или так:</p><pre><code>handleClick() {console.log('значение this: ', this)}
&lt;button onClick={this.handleClick()}&gt;
  Нажми на меня
&lt;/button&gt;</code><br></pre><p>Чтобы передать свой аргумент (например id строки) в обработчик события:<br>
<em>е</em> - событие React передаётся явно в стрелочных функциях и автоматически в bind.<br></p><pre><code>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;
  Удалить строку
&lt;/button&gt; <span>- Function.prototype.bind</span>

&lt;button onClick={(e) => this.deleteRow(id, e)}&gt;
  Удалить строку
&lt;/button&gt;</code></pre><p>- стрелочная функция - при каждом рендере создаётся новый коллбэк.<br>
Если этот коллбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.<br>
Снижение производительности.<br>
<br>
<em>Структура проекта</em>:<br>
<em>index.html</em> - точка входа в сайт<br>
<em>index.js</em> - подключает необходимое окружение (react, react-dom, index.css, App.js, serviceWorker.js)<br>
<em>index.css</em> - задаёт стили<br>
<em>serviceWorker.js</em><br>
<em>setupTests.js</em><br>
<em>context.js</em><br>
<em>App.js</em> - подключает (объединяет) все компоненты<br>
Файл .css можно не импортировать, т.к. React ищет его сам в своей папке, либо в папках выше.<br>
<br>
<em>Компонент</em>:<br>
Это функция или класс (работают одинаково).<br>
Один компонент - одна ответственность.<br>
Компонент содержит логику и разметку в JSX.<br>
Компоненты можно вкладывать в друг друга.<br>
<br>
Чтобы создать компонент нужно в файле с расширением js написать:<br>
<em>import React from 'react'</em>; - в начале<br>
и<br>
<em>export default App</em>; - в конце.<br>
<br>
Сначала создаём самый маленький компонент, потом вверх по иерархии.<br>
<br>
<em>Компонент в виде класса</em>:</p><pre><code>class Example extends React.Component {
  <span>конструктор объектов</span>
  constractor (props) {
  <span>обязательная ссылка на родителя</span>
  super (props)
  <span>задаём начальное состояние</span>
  this.state = { … }
}
  <span>говорит React что нужно отобразиь на экране</span>
  render() {
    <span>возвращает JSX объект</span>
    return…
  }
}</code></pre><p>В JS - классах всегда нужно вызывать <em>super</em> при объявлении конструктора подкласса.
Все классовые React - компоненты, у которых есть constractor 
должны начинаться с вызова <b>super (props)</b>.
<br>
<em>Компонент в виде функции (функциональный компонент)</em>:</p><pre><code><span>подключение</span>
import React from 'react';
…
const styles = { }

<span>принимает пропсы</span>
function Example (props) { 
  <span>либо так:</span>
  const Example = (props) => {{
    логика на JS
    разметка JSX
    <span>возвращает JSX объект</span>
    return …
    
  }
  export default Example
}

<span>компонент объявлен как класс</span>
class Clock extends React.Component {
  constructor (props) {
    super (props);
    <span>задаём начальное состояние
    при создании объекта</span>
    this.state = {date: new Date()};
  }

  componentDidMount() {
    <span>метод жизненного цикла,
    который React вызывает когда коипонент &lt;Clock/&gt;
    примонтируется в DOM</span>

    <span>вызываем метод tick() каждую секунду</span>
    this.timerID = setInterval ( 
    () => this.tick(), 1000
    );
  }

  componentWillUnmount() {
    <span>метод жизненного цикла,
    который Ract вызывает когда компонент &lt;Clock/&gt;
    удалится из DOM</span>
  }

  tick() {
    this.setState({
      <span>обновляем состояние компонента,
      присваивая новое значение свойства date</span>
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          Привет мир!
        &lt;/h1&gt;

        &lt;h2&gt;
          Сейчас {this.state.date.toLocaleTimeString()}
        &lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock/&gt;,
  document.getElementById('root')
);</code></pre><br><p><em>Пропс</em>:<br>
<em>JSON</em> - объявляем объект в переменную:</p><pre><code>const user = {
  firstName = ‘Марья’,
  lastName = ‘Маревна’
}</code></pre><p>и обращаемся к пропсам:</p><pre><code>user.firstName
user.lastName</code></pre><br><p><em>this.props</em> - объект, кототрый содержит свойства, которые были определены тем, кто вызывает этот компонент.<br>
Вложенный контент может быть доступен через <b>props.children</b></p><pre><code><span>в props получаем значения value и onClick
из класса Board ниже</span>
function Square (props) { 
  return(
    &lt;button onClick={props.onClick}&gt;
      {props.value}
    &lt;/button&gt;
  )}

<span>возвращаем кнопку для подстановки
 в качестве объекта this
 в блок render в классе Board</span>
                                                                                              
class Board extends React.Component{
  <span>props i из блока render() ниже</span>
  renderSquare(i){
    <span>в компанент Square втуливаем значения value и onClick</span>
    return(
      &lt;Square
        <span>собираем получаемые пропсы в массив</span>
        value = {this.props.square[i]}
        <span>создаём обработчик на событие onClick для каждого пропса i</span>
        onClick = {() = this.props.onClick(i)}
      /&gt;
    )
  }
  render() {
    return(
      <span>передаем в функцию renderSquaer
      (props.value) - 0 или 1 или 2</span>
      &lt;div&gt;
        {this.renderSquare(0)}
        {this.renderSquare(1)}
        {this.renderSquare(2)}
      &lt;/div&gt;
    )
  }
}

<span>компонент объявлен как функция</span>
function Welcome(props) {
  return (
    &lt;h1&gt;
      Привет, {props.name}!
    &lt;/h1&gt;
  );
}
<span>или так:</span>
<span>компонент объявлен как класс</span>
class Welcome extends React.Component { 
  render () {
    return (
      &lt;h1&gt;
        Привет, {this.props.name}!
      &lt;/h1&gt;
    );
  }
}

const element = &lt;Welcome name="Алиса"/&gt;;
ReactDOM.render(
  element,
  document.getElementById('root')
);</code></pre><p>name=”Алиса” - передаётся в функцию Welcome в виде объекта <b>{name: 'Алиса'}</b> - это props.<br>
Функция Welcome возвращает элемент &lt;h1&gt;Привет, Алиса!&lt;/h1&gt; в ReactDOM.<br>
<br>
Пропсы нужно только читать.<br>
React-компоненты не меняют свои входные данные.<br>
Компонент никогда не должен что-то записывать в свои пропсы:</p><pre><code>function sum(a, b) {
  return a + b;
}
<span>а вот так нельзя:</span>
function withdraw(account, amount) {
  account.total -= amount;
}</code></pre><p>Передать пропс можно от родителя к потомку пропустив несколько промежуточных потомков
напрямую с помощью <b>React.createContext()</b>.<br>
Для этого создаём отдельный файл context.js и используем &lt;Context.Provider&gt;.<br>
<br>
<em>Файл context.js</em>:</p><pre><code>import React from 'react'
const Context = React.createContext()
export default Context
<span>с помощью Context.Provider
передаю любое JS сквозь всех потомков</span>
&lt;Context.Provider value={{ … }}&gt;
&lt;div className=”...”&gt;
&lt;h1&gt; Hello world! &lt;/h1&gt;
&lt;Example/&gt;
&lt;/div&gt;
&lt;/Context.Provider&gt;</code></pre><p><em>Состояние</em>:<br>
Сохранять и изменять можно только состояния <em>(state)</em>.<br>
Конкретный state контролируется и доступен только конкретному компоненту.<br>
Состояние содержит данные, специфичные для этого компонента. Они могут изменятся со временем.<br>
Состояние определяется пользователем и должно быть простым объектом JS.<br>
Состояние можно изменять только через <b>setState()</b>, присвоить состоянию значение напрямую можно только в конструкторе.<br>
Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.<br>
Этот процесс называется “нисходящим” (“top-down”) или “однонаправленным” (“unidirectional”) потоком данных.<br>
<br>
Если несколько компонентов должны отражать одни и теже изменяющиеся данные, 
то нужно поднимать общее состояние до ближайшего общего предка.<br>
Чтобы собрать данные из нескольких дочерних элементов, или чтобы дать возможность двум компонентам общаться,
вам нужно объявить общее состояние внутри родительского компонента.<br>
Родительский компонент может передать состояние обратно дочерним элементам с помощью пропсов.<br>
Это поддерживает синхронизацию дочерних компонентов друг с другом и с родительким компонентом.<br>
<br>
<em>Хуки</em>:</p><code>const [todos, setTodos] = React.useState([ ])</code><p>Это функции, с которыми можно “подцепиться” к состоянию
и к методам жизненного цикла React из функциональных компонентов.<br>
Хуки не работают в классах, а используются вместо них.<br>
Хуки вызывают только на верхнем уровне (не в циклах, условиях и т.д.)<br>
Хуки вызывают только из функциональных компонентов React, не из обычных JS-функций.<br>
Если имя функции начинается с use (useSamething) и использует другие хуки,
то такая функция это пользовательский хук.<br>
<br>
<em>useState(i)</em> - возвращает массив из двух элементов:<br>
  состояние (это state - состояние) и функцию, которая изменяет это состояние.<br>
  Имена даём возвращаемому состоянию и функции произвольно.<br>
<br>
<em>useEffect(i)</em> - React запускает эффекты useEffect(() => {...}) после каждого рендера, включая первый рендер.</p><pre><code>useEffect(() => {
fetch('http://…')
  .then(responce=>responce.json())
  .then(todos=>{
    setTodos(todos)
  })
}, [])</code></pre><br><p>вызвать хук можно либо</p><pre><code>import React, { useEffect } from 'react'
useEffect(i) {...}
<span>либо</span>
React.useEffect(i) {...}</code></pre><br><p>Сравнение хука и класса:<br>
<em>Хук</em>:</p><pre><code><span>подключение хука</span>
import React, {useState} from 'react'
function Example() {
  <span>0 это начальное состояние,
  это может быть не объект</span>
  const [count, setCount] = useState(0)
  return (
    &lt;div&gt;
      &lt;p&gt;Вы нажали {count} раз &lt;/p&gt;
      &lt;button
        onClick={() => setCount(count + 1)}
      &gt;
        Нажми на меня
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre><br><p><em>Класс</em>:</p><pre><code>class Example extends React.Component {
  constractor (props) {
    super (props)
    this.state = {
      count: 0
    }
  }
  render () {
    return (
      &lt;div&gt;
        &lt;p&gt;
          Вы нажали {this.state.count} раз
        &lt;/p&gt;
        &lt;button 
          onClick={() => this.setState({
            count.this.state.count + 1
          })}
        &gt;
            Нажми на меня
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre><p>Чтобы наделить функциональный компонент состоянием нужно либо преобразовать его в класс, либо добавить в него хук.<br>
React запоминает значение переменной состояния между вызовами функции.<br>
<em>Итого</em>:</p><pre><code><span>подключаем хук</span>
import React, {useState} from 'react'
<span>добавляем переменную в функцию</span>
const [count, setCount] = useState(0)
<span>вызываем функцию изменения</span>
&lt;button onClick={() => setCount(count + 1)}&gt;</code></pre><br><p><em>Хук еффекта выполняет побочные действия</em>:<br>
- загрузка данных<br>
- оформление подписки и изменение DOM вручную<br>
- представляет собой совокупность методов componentDidMount, componentDidUpdate и componentWillUnmount.<br>
<br>
Эффекты позволяют выполнить дополнительный код после того, как React обновил DOM, т.е. после каждого рендера.<br>
Любой эффект может возвратить функцию, которая сбросит его.<br>
React будет сбрасывать эффект перед тем, как компонент размонтируется. Например оформление и отмена подписки:</p><pre><code>import React , {useState, useEffect} from 'react'
function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null)
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline)
    }
    ChatAPI.subscribeToFriendStatus(
      props.friend.id,
      handleStatusChange
    )
    <span>сброс эффекта</span>
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(
        props.friend.id,
        handleStatusChange
      )
    }
  })
  if (isOnline === null) {
    return ‘Загрузка…’
  }
  return isOnline ? ‘В сети’ : ‘Не в сети’
}</code></pre><p>Чтобы React выполнял эффект только в случае изменения нужен второй аргумент в виде массива,
с которым будет сравниваться значение первого аргумента.<br>
При каждом рендере react сравнивает новое значение переменной в первом аргументе со старым значением переменной,
указанным во втором аргументе (в массиве).</p><pre><code><span>стрелочная функция это первый аргумент эффекта</span>
useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline)
  }
  ChatAPI.subscribeToFriendStatus(
    props.friend.id,
    handleStatusChange
  )
  return() => {
    ChatAPI.unsubscribeFromFriendStatus(
      props.friend.id,
      handleStatusChange
    )
  }
}
<span>это второй аргумент эффекта
со старым значением переменной,
по которому будет сравнение первого аргумента:
повторно подписаться только если
props.friend.id изменился.</span>
[props.friend.id])</code></pre><br><p><em>Обычный эффект без сброса</em>:</p><pre><code>import React, {useState, useEffect} from 'react'
function Example() {
  const [count, setCount] = useState(0)
  useEffect(() => {
    document.title = `Вы нажали ${count} раз`
<span>перезапускать эффект только если count поменялся</span>
  }, [count])
  return (
    &lt;div&gt;
      &lt;p&gt;
        Вы нажали {count} раз
      &lt;/p&gt;
      &lt;button
        onClick={() => setCount(count + 1)}
      &gt;
        Нажми на меня
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre><br><p>Для корректной работы с хуками нужно установить плагин для ESLint:<br>
<b>npm i eslint-plugin-react-hooks --save -dev</b></p><pre><code>useContext:
import React, {useContext} from 'react'
const themes = {
  light: {
    foreground: “#000000”,
    background: “#eeeeee”
  }
  dark: {
    foreground: “#ffffff”,
    background: “#222222”
  }
}
<span>создаём объект контекста со свойством light</span>
const ThemeContext = React.createContext(themes.light)
function App() {
  return(
    <span>значение value определяет текущее значение</span>
    &lt;ThemeContext.Provider
      value={themes.dark}
    &gt;
    <span>передаваемого в Toolbar контекста.
    При обновлении значения - новый рендер.</span>
    &lt;Toolbar/&gt;
    <span>Меняем контекст на тёмную тему.</span>
    &lt;/ThemeContext.Provider&gt;
  )								
}
<span>передаём контекст потомку</span>
function Toolbar (props) {
  return(
    &lt;div&gt;
      &lt;ThemedButton/&gt;
    &lt;/div&gt;
  )
}
function ThemedButton() {
<span>используем контекст с тёмной темой</span>
  const theme = useContext(ThemeContext)
  return (
    &lt;button style={{background: theme.background, color: theme.foreground}}&gt; Я стилизован темой из контекста! &lt;/button&gt;
  )
}</code></pre><br><p><em>Управляемый компонент</em>:<br>
Если форму обрбатывать с помощью JS-функции, у которой есть доступ к введённым данным,
то такая форма называется “управляемым компонентом”.<br>
Библиотека Formik.<br>
Или, другими словами, <em>управляемый компонент</em> - это элемент формы рендер,
поведение при пользовательском вводе и значение которого контролирует React.<br></p><pre><code>class NameForm extends React.Component{
  constructor(props){
    super(props)
    this.state={value:' '}
    this.handleChange=this.handleChange.bind(this)
    this.handleSubmit=this.handleSubmit.bind(this)
  }
  handleChange(event) {
    this.setState({value: event.target.value})
  }
  handleSubmit(event){
    alert('Отправленное имя: ' + this.state.value)
    <span>отменяем действие по умолчанию</span>
    event.preventDefault()
  }
  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Имя:
          &lt;input
            type=”text”
            value={this.state.value}
            onChange={this.handleChange}
          /&gt;
        &lt;/label&gt;
        &lt;input
          type=”Submit”
          value=”Отправить”
        /&gt;
      &lt;/form&gt;
    )
  }
}</code></pre><br><p>в атрибуте value всегда будет отражаться React состояние <b>this.state.value</b>,
а каждое нажатие клавиш через <b>handleChange</b> будет это состояние изменять и React будет обновлять поле ввода по мере печатанья.</p><pre><code>&lt;textarea&gt;
  также как
&lt;input/&gt;
&lt;textarea
  value={this.state.value}
  onChange={this.handleChange}
&gt;</code></pre><p>Чтобы использовать несколько тегов input нужно каждому дать свой атрибут name.</p><pre><code>&lt;select&gt;
  &lt;option value=”grapefruit”&gt;
    Грейпфрут
  &lt;/option&gt;
  &lt;option value=”lime”&gt;
    Лайм
  &lt;/option&gt;
  &lt;option selected value=”coconut”&gt;
    Кокос
  &lt;/option&gt;
  &lt;option value=”mango”&gt;
    Манго
  &lt;/option&gt;
&lt;/select&gt;</code></pre><p>если в value передать массив, то можно выбрать несколько опций:</p><code>&lt;select multiple={true} value={[‘Б’, ‘В’]}&gt;</code><p>в React выбранный элемент присваивается в конструкторе по умолчанию:<br>
<b>this.state={value='cocnut'}</b>,<br>
а потом изменяется через setState:<br>
<b> &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;/select&gt</b>;<br>
Если установить значение value, то пользователь изменить его не сможет:<br></p><code>ReactDOM.render(&lt;input value=”Привет”/&gt;)</code><p>Для любых изменяемых данных в React -приложении должен быть один “источник истины” (state).<br>
Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.<br>
Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка.<br>
Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами,
вы должны полагаться на однонаправленный поток данных
  - это водопад пропсов от родителя к потомку,
в который каждый компонент добавляет свой state в виде пропса (props).<br>
<br>
<em>Композиция</em>:<br>
Вместо наследования:</p><pre><code>function FancyBorder(props) {
  return (
      <span>поместить в div всё,
      что выделено тэгом
      &lt;FancyBorder&gt;</span>
    &lt;div
      className={'FancyBorder FancyBorder-' + props.color}
    &gt;
      {props.children}
    &lt;/div&gt;
  )
}
function Dialog(props) {
  return (
      <span>определяю тэг &lt;FancyBorder&gt;
      и его содержимое для подстановки</span>
    &lt;FancyBorder color="blue"&gt;
      &lt;h1 className="Dialog-title"&gt;
        {props.title}
      &lt;/h1&gt;
      &lt;p className="Dialog-message"&gt;
        {props.message}
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  )
}
function WelcomDialog() {
  return (
    <span>определяю компонент для рендера
    и задаю значение пропсов</span>
    &lt;Dialog
      title="Welcom"
      message="Thank you for visiting our spacecraft!"
    /&gt;
  )
}
ReactDOM.render(
  &lt;WelcomDialog/&gt;,
  document.getElementById('root')
)</code></pre><br><p><em>Ключи</em>:<br>
Ключи помогают React определить, какие элементы были изменены, добавлены или удалены.</p><pre><code>const todoItems = todos.map((todo) => 
  &lt;li key={todo.id}&gt;
    {todo.text}
  &lt;/li&gt;
)
function NumberList(props) {
  const numbers = props.numbers
  <span>функция map() преобразует массив numbers в список</span>
  const listItems = numbers.map((number) =>
    &lt;ListItem
      <span>ключ нужно определить внутри массива, ключ это строка</span>
      key={number.toString()}
      value={number}
    /&gt;
  )
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  )
}
<span>или так:</span>
function NumberList(props) {
  const numbers = props.numbers
  return (
    &lt;ul&gt;
      {numbers.map((number) => 
        &lt;ListItem
          key={number.toString()}
          value={number}
        /&gt;
      )}
    &lt;/ul&gt;
  )
}</code></pre><br><p><em>Валидирование типов</em>:<br>
Библиотека prop-types нужна для задания типов переменных:<br>
<b>npm i prop-types</b>.</p><pre><code>import PropTypes from 'prop-types'

function Example ({prop1, prop2, prop3}) {...}
Example.propTypes={
  prop1: PropTypes.object.isRequired,
  prop2: PropTypes.number,
  prop3: PropTypes.func.isRequired,
}
export default Example</code></pre><br><p><em>Условный рендеринг</em>:</p><pre><code>if (isLoggedIn) {
  return &lt;UserGreeting/&gt;;
}
return &lt;GuestGreeting/&gt;;

{
  unreadMessages.length > 0 && 
  &lt;h2&gt;
    у вас {unreadMessages.length} непрочитанных сообщений.
  &lt;/h2&gt;
}
Пользователь 
  &lt;b&gt;{
    isLoggedIn ? 'сейчас' : 'не'
  }&lt;/b&gt;
на сайте.</code></pre><br><img src="../img/js/react/react.png" alt=""><img src="../img/js/react/react0.png" alt=""><img src="../img/js/react/React1.png" alt=""><img src="../img/js/react/React2.png" alt=""><img src="../img/js/react/React3.png" alt=""><img src="../img/js/react/React4.png" alt=""><img src="../img/js/react/React5.png" alt=""><img src="../img/js/react/React6.png" alt=""><img src="../img/js/react/React7.png" alt=""><img src="../img/js/react/React8.png" alt=""><img src="../img/js/react/React9.png" alt=""><img src="../img/js/react/React10.png" alt=""><img src="../img/js/react/React11.png" alt=""><img src="../img/js/react/React12.png" alt=""><img src="../img/js/react/React13.png" alt=""><img src="../img/js/react/React14.png" alt=""><img src="../img/js/react/React15.png" alt=""><img src="../img/js/react/React16.png" alt=""><img src="../img/js/react/React17.png" alt=""><img src="../img/js/react/React18.png" alt=""><img src="../img/js/react/React19.png" alt=""><img src="../img/js/react/React20.png" alt=""><img src="../img/js/react/React21.png" alt=""><img src="../img/js/react/React22.png" alt=""><img src="../img/js/react/React23.png" alt=""><img src="../img/js/react/React24.png" alt=""><img src="../img/js/react/React25.png" alt=""><img src="../img/js/react/React26.png" alt=""><img src="../img/js/react/React27.png" alt=""><img src="../img/js/react/React28.png" alt=""><img src="../img/js/react/React29.png" alt=""><img src="../img/js/react/React30.png" alt=""><img src="../img/js/react/React31.png" alt=""><img src="../img/js/react/React32.png" alt=""><img src="../img/js/react/React33.png" alt=""><img src="../img/js/react/React34.png" alt=""></details><details><summary>Redux</summary><a href="https://redux.js.org/introduction/getting-started">Redux</a><p>Весь базовый функционал redux умещается в малюсенький файлик</p><pre><code>function createStore(reducer, initialState) {
  let state = initialState
  return {
    dispatch: action => { state = reducer(state, action) },
    getState: () => state
  }
}</code></pre><br><p><dfn>createStore</dfn> - возвращает объект с полем “dispatch”.<br>
<dfn>dispatch</dfn> - это функция, которая всего лишь применяет редюсер к нашему текущему состоянию
<b>(newState = reducer(state, action))</b>.<br>
<br>
С этими 7 строками уже можно писать TodoApp.<br>
Инициализация хранилища:</p><pre><code>function todosReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: action.id,
          text: action.text,
          completed: false
        }
      ]
    case 'TOGGLE_TODO':
      return state.map(todo => {
        if (todo.id === action.id) {
          return { ...todo, completed: !todo.completed }
        }
        return todo
      })
      default: return state
  }
}

const initialTodos = []

const store = createStore(todoReducer, initialTodos)</code></pre><br><p>Использование:</p><pre><code>store.dispatch({
  type: 'ADD_TODO',
  id: 1,
  text: 'Понять на сколько redux прост'
})

store.getState() -  [{ 
                      id: 1,
                      text: ‘Понять насколько redux прост’,
                      completed: false
                    }]
store.dispatch({
  type: 'TOGGLE_TODO',
  id: 1
})

store.getState() -  [{
                      id: 1,
                      text: ‘Понять насколько redux прост’,
                      completed: true
                    }]</code></pre><br><p>Метод combineReducers позволяет вместо того, чтобы создавать один огромный reducer для всего состояния приложения сразу, разбивать его на отдельные модули.</p><pre><code>function counterReducer(state, action) {
  if (action.type === 'ADD') {
    return state + 1
  } else {
    return state
  }
}

const reducer = combineReducers({
  todoState: todoReducer, 
  counterState: counterReducer
})

const initialState = {
  todoState: [],
  counterState: 0,
}

const store = createStore(reducer, initialState)</code></pre><br><p>Если упростить, то:</p><pre><code>function reducer(state, action) {
  return {
    todoState: todoReducer(state, action),
    counterState: counterReducer(state, action),
  }
}</code></pre><br><p>Но этот код плохо масштабируется.<br>
Если у нас 2 “под-состояния”, нам нужно дважды написать (state, action),
а хорошие программисты так не делают.<br>
Если редюсоров и стэйтов много, то через обработку коллекции редюсеров:</p><pre><code>function combineReducers(reducersMap) {
  return function combinationReducer(state, action) {
    const nextState = {}
    Object.entries(reducersMap).forEach(([key, reducer]) => {
      nextState[key] =  reducer(state[key], action)
    })
    return nextState
  }
}</code></pre><br><p><dfn>middleware в разрезе redux</dfn> - это какая-то штука, которая слушает все dispatch и при определенных условиях делает что-то.</p><pre><code>const createStoreWithMiddleware = applyMiddleware(somdfniddleware)(createStore)
const store = createStoreWithMiddleware(reducer, initialState)</code></pre><br><p><dfn>applyMiddleware</dfn> переопределяет метод dispatch, добавляя перед (или после) обновлением состояния какую-то пользовательскую логику.<br>
самый популярный middleware от создателей redux - <dfn>redux-thunk</dfn>, чаще всего используют при асинхронных операциях.<br>
Его смысл сводится к тому, что можно передавать в store.dispatch сложные функции<br></p><pre><code>const thunk = store => dispatch => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState)
  }
  return dispatch(action)
}</code></pre><br><p>метод createStore принимал атрибуты (reducer, initialState) и возвращал объект с ключами { dispatch, getSate }.<br>
метод applyMiddleware берёт уже реализованный метод createStore и переопределяет его возвращаемое значение:</p><pre><code>function applyMiddleware(middleware) {
  return function createStoreWithMiddleware(createStore) {
    return (reducer, state) => {
      const store = createStore(reducer, state)
      return {
        dispatch: action => middleware(store)(store.dispatch)(action),
        getState: store.getState,
      }
    }
  }
}</code></pre><br><p><dfn>form</dfn>:</p><pre><code>import { useDispatch } from 'react-redux'
import { createPost } from 'actions/posts'

const [postData, setPostData] = useState({
  creator: ' ',
  title: ' ',
  message: ' '
})

const dispatch = useDispatch()

const handleSubmit = (e) => {
  e.preventDefault()
  dispatch(createPost(postData))
}</code></pre><br><p><dfn>action</dfn>:</p><pre><code>export const createPost = (post) => async (dispatch) => {
try {
  const { data } = await api.createPost(post)
  dispatch ({ type: 'CREATE', payload: data })
  } catch (error) {
    console.log(error)
  }
}</code></pre><br><p><dfn>api</dfn>:</p><code>export const createPost = (newPost) => axios.post(url, newPost)</code><br><p><dfn>server/controllers</dfn>:</p><pre><code>export const createPost = async (req, res) => {
  const post = req.body;
  const newPostMessage = new PostMessage({
    …post,
    creator: req.userId,
    createdAt: new Date().toISOString()
  })

  try {
    await newPostMessage.save();
    res.status(201).json(newPostMessage);
  } catch (error) {
    res.status(409).json({ message: error.message });
  }
}</code></pre><br><p><dfn>server/models</dfn>:</p><pre><code>import mongoose from 'mongoose'

const postSchdfna = mongoose.Schdfna({
  title: String,
  message: String,
  name: String,
  creator: String,
  tags: [String],
  selectedFile: String,
  likes: { type: [String], default: [] },
  createdAt: {
    type: Date,
    default: new Date(),
  },
})

export default mongoose.model('PostMessage', postSchdfna);</code></pre><br><p><dfn>reducers</dfn>:</p><pre><code>export default (post = [ ], action) => {
  switch (action.type) {
    case 'FATCH_ALL':
      return action.payload;
    case 'CREATE':
      return [ …posts, action.payload ];
    default: return posts;
  }
}</code></pre><br><img src="../img/js/react/redux.jpg" alt=""></details><details><summary>SQL</summary><a href="https://dbdiagram.io/home">Diagram</a><details><summary>Определение (Definition)</summary><p><dfn>SQL</dfn> — применяется для создания, модификации и управления данными в реляционной базе данных, 
управляемой соответствующей системой управления базами данных.<br>
В базовом варианте SQL является информационно-логическим языком, а не языком программирования. <br>
<br>
<dfn>Система управления базами данных (СУБД)</dfn> — совокупность программных и лингвистических средств
общего или специального назначения, обеспечивающих управление созданием и использованием баз данных. <br>
<br>
<dfn>База данных (БД)</dfn> - под базой данных (БД) понимают хранилище структурированных данных, 
при этом данные должны быть непротиворечивы, минимально избыточны и целостны. <br>
<br>
<dfn>Реляционная база данных</dfn> — база данных, основанная на реляционной модели данных. <br>
Реляционные БД представляют связанную между собой совокупность таблиц-сущностей базы данных. <br>
Каждая таблица БД представляется как совокупность строк и столбцов, где строки соответствуют
экземпляру объекта, конкретному событию или явлению, а столбцы - атрибутам (признакам,
характеристикам, параметрам) объекта, события, явления. <br>
При практической разработке БД таблицы-сущности зовутся таблицами, строки-экземпляры - записями,
столбцы-атрибуты - полями. <br>
<br>
<em>Преимущества SQL</em> - наличие стандартов и независимость от конкретной СУБД. <br>
<em>Недостатки SQL</em> - сложность. <br></p><br><p><dfn>Классификация по модели данных:</dfn><br>
<em>Иерархическая</em><br>
<em>Объектная и объектно-ориентированная</em><br>
<em>Объектно-реляционная</em><br>
<em>Реляционная</em><br>
<em>Сетевая</em><br>
<em>Функциональная</em><br>
<br></p><p><dfn>Типы отношений:</dfn><br>
<em>Один к одному (one-to-one)</em> <br>
<em>Один ко многим (one-to-many)</em> <br>
<em>Многие к одному (many-to-one)</em> <br>
<em>Многие ко многим (many-to-many, реализуется через отдельную таблицу)</em> <br></p><img src="../img/sql/SQL12.png" alt=""><p>Источник:<a href="https://drawsql.app/">Рисовать диаграмму БД онлайн</a><a href="https://sql-ex.ru/?Lang=0">sql-ex</a><a href="https://sqlbolt.com/lesson/">sqlbolt</a><a href="https://sql-academy.org/ru/guide">sql-academy</a><a href="https://www.w3schools.com/sql/default.asp">W3Schools SQL Tutorial</a><a href="https://www.w3schools.com/sql/exercise.asp?">w3schools SQL Exercises</a></p></details><details><summary>Операторы определения данных (Data Definition Language, DDL)</summary><p><dfn>CREATE</dfn> - создает объект БД (саму базу, таблицу, представление, пользователя и т. д.)<br>
to create a new SQL database<br>
<dfn>CREATE DATABASE</dfn> database name;<br>
Создать таблицу table со столбцами id, field_1, field_2, field_3.<br>
По каждому столбцу заданы тип и количество символов.<br></p><pre><code><dfn>CREATE TABLE</dfn> table(
  id <dfn>INT PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);</code></pre><p><dfn>DESCRIBE</dfn> table - информация о таблице<br>
<dfn>PRIMARY KEY</dfn> - уникальный идентификатор записей.<br>
<dfn>FOREIGN KEY</dfn> - внешний ключ, значения идентификатора записей в связанной таблице.<br>
<dfn>SERIAL</dfn> - автоинкремент идентификатора в PostgreSQL<br>
<dfn>AUTO_INCREMENT</dfn> - автоинкремент идентификатора в MySQL<br></p><pre><code><dfn>CREATE TABLE</dfn> table(
  id <dfn>SERIAL PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);
</code></pre><p>Ограничения на уровне таблицы:<br>
Значения в столбцах id и field_1 уникальные и не пустые<br>
Значения столбца field_table_2_id - ссылки на id таблицы table_2<br>
Либо RESTRICT - запретить удалять id таблицы table_2<br>
Либо CASCADE -  при удалении id таблицы table_2, удалить соответствующие записи<br>
Ограничение с именем positive_field<br>
Значения в столбце field_3 должны быть положительными<br></p><pre><code><dfn>CREATE TABLE</dfn> table_1(
  id <dfn>PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100) <dfn>UNIQUE NOT NULL</dfn>, 
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>,
  field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id)
  <dfn>ON DELETE RESTRICT</dfn>
  <dfn>CONSTRAINT</dfn> positive_field
  <dfn>CHEK</dfn> (field_3 >= 0)
);</code></pre><p>Уникальный идентификатор состоит из двух столбцов</p><pre><code><dfn>CREATE TABLE</dfn> table_1(
  field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id),
  field_table_3_id <dfn>INT REFERENCES</dfn> table_3(id),
  quantity <dfn>INT</dfn>,
  <dfn>PRIMARY KEY</dfn>(field_table_2_id, field_table_3_id)
);</code></pre><p><dfn>ALTER</dfn> - изменяет объект
Изменить таблицу table, добавить столбец field_4 с типом BOOLEAN</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>ADD COLUMN</dfn> field_4 <dfn>BOOLEAN</dfn>;</code><br></pre><p>Изменить таблицу table, удалить столбец field_4</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>DROP COLUMN</dfn> field_4;</code><br></pre><p>Изменить таблицу table, переименовать столбец field_4 в field_5</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>RENAME COLUMN</dfn> field_4 <dfn>TO</dfn> field_5;</code><br></pre><p>Изменить таблицу table, переименовать в another_table</p><pre><code><dfn>ALTER TABLE</dfn> table 
<dfn>RENAME TO</dfn> another_table;</code><br>     </pre><p><dfn>DROP</dfn> - удаляет объект</p><code><dfn>DROP TABLE</dfn> table </code><p>Скрипт создания таблицы:</p><pre><code><dfn>DROP TABLE IF EXISTS</dfn> table;
<dfn>CREATE TABLE</dfn> table(
  id <dfn>SERIAL PRIMARY KEY</dfn>,
  field_1 <dfn>VARCHAR</dfn>(100),
  field_2 <dfn>VARCHAR</dfn>(30),
  field_3 <dfn>INT</dfn>
);</code><br></pre><p><dfn>BACKUP</dfn> - резервное копирование</p><pre><code><dfn>BACKUP DATABASE</dfn> testDB
<dfn>TO DISK</dfn> = 'D:\backups\testDB.bak'; 
</code></pre></details><details><summary>Операторы манипуляции данными (Data Manipulation Language, DML)</summary><details><summary>SELECT</summary><p><dfn>SELECT</dfn> - выбирает данные, удовлетворяющие заданным условиям, </p><code><dfn>SELECT * FROM</dfn> table</code><p>Для примера используем таблицу table со столбцами field_1, field_2 и т.д.
У каждого столбца свои значения value_1, value_2, value_3 и т.д.
Выбираю столбец (field_1) и столбец (field_2) из таблицы (table)</p><pre><code><dfn>SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table;</code></pre><p>Ключевое слово AS назначает псевдоним f1 столбцу field_1</p><pre><code><dfn>SELECT</dfn> field_1 <dfn>AS</dfn> f1
<dfn>FROM</dfn> table;</code></pre><p>Выбрать только уникальные значения столбца field_1</p><pre><code><dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
<dfn>FROM</dfn> table;</code></pre><p>Выбрать первых 10 уникальных значений столбца field_1</p><pre><code><dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
<dfn>FROM</dfn> table
<dfn>LIMIT</dfn> 10;</code></pre><p>Выбрать из таблицы table все строки со значением value в столбце field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2 = 'value';</code></pre><p>Ключевое слово WHERE и фильтр field_2 = 'value'</p><pre>Используем в <dfn>WHERE</dfn>:
  =         Равно
  <>, !=    Неравно
  >         Больше
  >=        Больше или равно
  <         Меньше
  <=        Меньше или равно
  BETWEEN   Значение в диапозоне
  IN        Значение в списке
  LIKE      Соответствие шаблону
  AND       Логическое И
  OR        Логическое ИЛИ
  NOT       Логическое НЕ
</pre><p>Выбрать из таблицы table все строки со значениями от value_1 по value_2 в столбце field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>BETWEEN</dfn> value_1 AND value_2;
</code></pre><p>Выбрать из таблицы table все строки со значениями по списку IN из столбца field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>IN</dfn> (value_1, value_2, value_3);
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбе field_2 значение содержит value</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>LIKE</dfn> '%value%';</code></pre><p>Спец.символы в шаблонах LIKE:<br>
<dfn>%</dfn> - любое количество символов (можно и без символов)<br>
<dfn>_</dfn> - ровно один символ
</p><p>Return all customers starting with "a", "b", "c", "d", "e" or "f":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[a-f]%';
</code></pre><p>Return all customers starting with either "b", "s", or "p":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[bsp]%';
</code></pre><p>Return all customers starting with NOT either "b", "s", or "p":</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
<dfn>WHERE</dfn> City <dfn>LIKE</dfn> '[!bsp]%';
</code></pre><p>Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>AND</dfn> field_2 = value_2;
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 либо в столбце field_2 значение value_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>OR</dfn> field_2 = value_2;
</code></pre><p>Выбрать из таблицы table все строки со значениями вне списка IN из столбца field_2</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_2
<dfn>NOT IN</dfn> (value_1, value_2, value_3);
</code></pre><p>Порядок сортировки в ORDER BY:<br>
<dfn>ASC</dfn> (ascending) - сортировка по возрастанию (по умолчанию)<br>
<dfn>DESC</dfn> (descending) - сортировка по убыванию<br>
</p><p>Выбрать из таблицы table все строки и отсортировать их по столбцу field_3
Сортировка данных по столбцу field_3, по умолчанию это ASC</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3</code></pre><p>Сортировка данных по столбцу field_3 по убыванию</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
</code></pre><p>Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 и отсортировать по столбцу field_3 по убыванию</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
</code></pre><p>Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2 и отсортировать по столбцу field_3 по убыванию и вывести первые пять строк</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>AND</dfn> field_2 = value_2
<dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>
<dfn>LIMIT</dfn> 5;
</code></pre><p>Выбрать из таблицы table все строки и отсортировать по двум столбцам</p><pre><code><dfn>SELECT</dfn> *
<dfn>FROM</dfn> table
<dfn>ORDER BY</dfn> field_3, field_2;
</code></pre><p>Выбрать из таблицы table столбец field_1 строки в котором не имеют значений</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NULL</dfn>; 
</code></pre><p>Выбрать из таблицы table столбец field_1 строки в котором имеют значения</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NOT</dfn> <dfn>NULL</dfn>;
</code></pre><p>The EXISTS operator is used to test for the existence of any record in a subquery.
The EXISTS operator returns TRUE if the subquery returns one or more records.</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> <dfn>EXISTS</dfn>
(<dfn>SELECT</dfn> field_2
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition); 
</code></pre><p>ANY means that the condition will be true if the operation is true for any of the values in the range.</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = <dfn>ANY</dfn>
(<dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition);
</code></pre><p>ALL means that the condition will be true only if the operation is true for all values in the range.</p><pre><code><dfn>SELECT</dfn> <dfn>ALL</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition;code.
<dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = <dfn>ALL</dfn>
(<dfn>SELECT</dfn> field_2
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> condition);
</code></pre><p>Copy all columns into a new table</p><pre><code><dfn>SELECT</dfn> *
<dfn>INTO</dfn> newtable [IN externaldb]
<dfn>FROM</dfn> oldtable
<dfn>WHERE</dfn> condition;
</code></pre><p>The following SQL statement uses the IN clause to copy the table into a new table in another database</p><pre><code><dfn>SELECT</dfn> *
<dfn>INTO</dfn> CustomersBackup2017
<dfn>IN</dfn> 'Backup.mdb'
<dfn>FROM</dfn> Customers;
</code></pre><p>The following SQL statement copies only a few columns into a new table</p><pre><code><dfn>SELECT</dfn> CustomerName, ContactName
<dfn>INTO</dfn> CustomersBackup2017
<dfn>FROM</dfn> Customers;</code></pre><br><p><dfn>Агрегатные функции:</dfn>
<br>
<dfn>COUNT</dfn> - Возвращает количество строк источника записей
Считает количество записей в таблице table</p><pre><code><dfn>SELECT</dfn> <dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table</code></pre><p>Считает количество записей в столбцe field_2 таблицы table</p><pre><code><dfn>SELECT</dfn> <dfn>COUNT</dfn>(field_2)
<dfn>FROM</dfn> table</code></pre><p>Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам и посчитать сколько записей каждого вида</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
</code></pre><p>Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать сколько записей каждого вида в столбце field_3 и вывести в новом столбе field_3</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(field_2) AS field_3
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br><p><dfn>SUM</dfn> - Возвращает сумму значений в указанном столбце.
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать сколько записей каждого вида и суммировать значения в столбце field_3 соответствующих сгруппированным видам</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>COUNT</dfn>(*),
<dfn>SUM</dfn>(field_3)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br>  <p><dfn>AVG</dfn> - Возвращает среднее значение в указанном столбце.
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
посчитать среднее значение по каждому виду в столбце field_3.
Среднее расчитывается со знаками после запятой.</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>AVG</dfn>(field_3) 
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
</code></pre><p>Посчитать среднее без знака после запятой</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>SUM</dfn>(field_3)/<dfn>COUNT</dfn>(*)
<dfn>AS</dfn> average 
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2</code></pre><br><p><dfn>MIN</dfn> - Возвращает минимальное значение в указанном столбце
Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
определить минимальное и максимальное значение каждого вида в столбце field_3, вывести столбец field_2 
с групированными значениями, столбец минимальных и столбец максимальных значений каждого вида,
отсортировать по убыванию по столбцу максимальных значений</p><pre><code><dfn>SELECT</dfn> field_2,
<dfn>MIN</dfn>(field_3),
<dfn>MAX</dfn>(field_3)
<dfn>FROM</dfn> table
<dfn>GROUP BY</dfn> field_2
<dfn>ORDER BY MAX</dfn>(field_3) <dfn>DESC</dfn></code></pre><br><p><dfn>MAX</dfn> - Возвращает максимальное значение в указанном столбцe.
Считает все функции в таблице table</p><pre><code><dfn>SELECT COUNT</dfn>(*),
<dfn>MIN</dfn>(field_2),
<dfn>MAX</dfn>(field_2),
<dfn>SUM</dfn>(field_2),
<dfn>AVG</dfn>(field_2)
<dfn>FROM</dfn> table</code></pre><br><p><dfn>LENGTH()</dfn> - возвращает длину строки</p><pre><code><dfn>SELECT</dfn> field_1
<dfn>FROM</dfn> table
<dfn>WHERE LENGTH</dfn>(field_2) > 15;
</code></pre><p>Вывести id строк, в которых значение temperature больше temperature предыдущего дня </p><pre><code><dfn>SELECT</dfn> current_day.id
<dfn>FROM</dfn> Weather <dfn>AS</dfn> current_day
<dfn>WHERE EXISTS</dfn> (
  <dfn>SELECT</dfn> 1
  <dfn>FROM</dfn> Weather <dfn>AS</dfn> yesterday
  <dfn>WHERE</dfn> current_day.temperature > yesterday.temperature
  <dfn>AND</dfn> current_day.recordDate = yesterday.recordDate + 1
);</code></pre><br><p><dfn>Подзапросы (subqueries)</dfn>:<br>
Сначала выполняются подзапросы.
Выбрать из таблицы table все строки со значением value_3 в столбце field_1,
отсортировать по видам в столбце field_2, посчитать количество строк по каждому виду,
отсортировать виды, у которых количество строк больше 10.
HAVING работает с результатами группировки</p><pre><code><dfn>SELECT</dfn> field_2, <dfn>COUNT</dfn>(*)
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_1 = value_3
<dfn>GROUP BY</dfn> field_2
<dfn>HAVING COUNT</dfn>(*) > 10
</code></pre><p>Выбрать столбцы field_2 и field_3 из таблицы table и выбрать максимальное значение столбца field_3 таблицы table</p><pre><code><dfn>SELECT</dfn> field_2, field_3
<dfn>FROM</dfn> table
<dfn>WHERE</dfn> field_3 = (
  <dfn>SELECT</dfn> <dfn>MAX</dfn>(field_3) 
  <dfn>FROM</dfn> table)
</code></pre><p>Выбрать столбцы field_2 и field_3 из таблицы table_1 и отобрать строки, id которых есть в столбце field_table_1_id таблицы table_2</p><pre><code><dfn>SELECT</dfn> field_2, field_3
<dfn>FROM</dfn> table_1
<dfn>WHERE</dfn> id <dfn>IN</dfn> (
  <dfn>SELECT</dfn> field_table_1_id 
  <dfn>FROM</dfn> table_2)
</code></pre><p>Выбрать значения id таблицы table_1 у которых в столбце field_3 значение value_1,
увеличить значения столбца field_2 на 500 в строках, 
у которых значение в столбце field_table_1_id равно значениям отобранных id</p><pre><code><dfn>UPDATE</dfn> table_2
<dfn>SET</dfn> field_2 = field_2 + 500
<dfn>WHERE</dfn> field_table_1_id = (
  <dfn>SELECT</dfn> id 
  <dfn>FROM</dfn> table_1
  <dfn>WHERE</dfn> field_3 = value_1)</code></pre><br><p><dfn>Представления</dfn>:<br>
Представление <dfn>VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.<br>
Данные в представлении не хранятся, представление ссылается на таблицу.<br>
Представление можно создавать из нескольких таблиц.<br>
Используется как обычная таблица.<br>
Применяется для ограничения доступа к данным, сокрытия реализации базы данных,
для избегания повторять выполнение сложных запросов и составных таблиц.<br>
Удалить представление <dfn>DROP VIEW</dfn></p><pre><code><dfn>CREATE VIEW</dfn> table_v field_1, field_2
<dfn>AS SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table</code></pre><p>Материализованное представление <dfn>MATERIALIZED VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.
Поддерживаются не всеми СУБД.
Данные храняться в представлении.
Представление можно создавать из нескольких таблиц.
Используется как обычная таблица.
Применяется для часто используемых запросом с длительным выполнением.
В случае изменения данных в таблице, на которую ссылается материализованное представление, <br>
выполнить <dfn>REFRESH MATERIALIZED VIEW</dfn> table_v <br>
Удалить материализованное представление <dfn>DROP MATERIALIZED VIEW</dfn></p><pre><code><dfn>CREATE MATERIALIZED VIEW</dfn> table_v field_1, field_2
<dfn>AS SELECT</dfn> field_1, field_2
<dfn>FROM</dfn> table</code></pre><br><p><dfn>Индексы</dfn>:<br>
Индексы - повышают производительность выполнения запросов <dfn>SELECT</dfn>.<br>
СУБД применяют индексы при выполнении операторов автоматически.<br>
Создать индекс<br>
Название индекса table_field_idx<br>
Индекс создаётся для столбца field таблицы table<br></p><pre><code><dfn>CREATE INDEX</dfn> table_field_idx
<dfn>ON</dfn> table(field)</code></pre><p>Удаление индекса</p><code><dfn>DROP INDEX</dfn> table_field_idx;</code></details><details><summary>CASE</summary><p>The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement).<br>
So, once a condition is true, it will stop reading and return the result.<br>
If no conditions are true, it returns the value in the ELSE clause.<br>
If there is no ELSE part and no conditions are true, it returns NULL.</p><pre><code><dfn>CASE</dfn>
  <dfn>WHEN</dfn> condition1 <dfn>THEN</dfn> result1
  <dfn>WHEN</dfn> condition2 <dfn>THEN</dfn> result2
  <dfn>WHEN</dfn> conditionN <dfn>THEN</dfn> resultN
  <dfn>ELSE</dfn> result
<dfn>END</dfn>; 
</code></pre></details><details><summary>JOIN</summary><p>Внутренее объединение INNER:<br>
Внутренее объединение - это соединение строк из одной таблицы 
для которых есть соответствующие строки из другой таблицы.<br>
<br>
<dfn>Неявное объединение:</dfn><br>
Выбрать все столбцы из таблицы table_1 и table_2,<br>
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p><pre><code><dfn>SELECT</dfn> * 
<dfn>FROM</dfn> table_1, table_2
<dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id</code></pre><p>либо</p><pre><code><dfn>SELECT</dfn> * <dfn>FROM</dfn> table_1 
<dfn>CROSS</dfn> <dfn>JOIN</dfn> table_2 
<dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id</code></pre><br><p><dfn>Явное объединение:</dfn><br>
Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p><pre><code><dfn>SELECT</dfn> table_1.field.2, table_2.field_3
<dfn>FROM</dfn> table_1 <dfn>JOIN</dfn> table_2 
<dfn>ON</dfn> table_1.id = table_2.field_table_1_id</code></pre><br><p>Псевдонимы</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><p>либо</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 t1 <dfn>JOIN</dfn> table_2 t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><p>Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2,
отобрать строки где значение в столбце field_2 таблицы table_1 равно value_1
и где значение в столбце field_3 таблицы table_2 равно value_4, отсортировать по столбцу field_2 таблицы table_2</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id
<dfn>WHERE</dfn> t1.field_2 = value_1
<dfn>AND</dfn> t2.field_3 = value_4
<dfn>ORDER BY</dfn> t2.field_2 DESC</code></pre><br><p>Внешнее объединение {[LEFT] | [RIGHT] | [FULL]} OUTER:
Внутренее объединение - это соединение строк из одной таблицы 
для которых нет соответствующих строк из другой таблицы.</p><br><p><dfn>LEFT</dfn> - все строки таблицы слева от ключевого слова <dfn>JOIN</dfn></p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>LEFT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p><dfn>RIGHT</dfn> - все строки таблицы справа от ключевого слова <dfn>JOIN</dfn></p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>RIGHT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p><dfn>FULL</dfn> - все строки обеих таблиц</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
<dfn>FULL OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
<dfn>ON</dfn> t1.id = t2.field_table_1_id</code></pre><br><p>Перекрёсное объединение CROSS:
Перекрёсное объединение - это соединение строк из обоих таблиц 
по принципу каждая с каждой.</p><pre><code><dfn>SELECT</dfn> t1.field.2, t2.field_3
<dfn>FROM</dfn> table_1 <dfn>CROSS JOIN</dfn> table_2
</code></pre></details><details><summary>INSERT</summary><p><dfn>INSERT</dfn> добавляет новые данные
Вставить в таблицу table значение value_2 в столбец field_1, value_4 в столбец field_2</p><pre><code><dfn>INSERT INTO</dfn> table (field_1, field_2)
<dfn>VALUES</dfn> (value_2, value_4);</code></pre><p>Copy all columns from one table to another table</p><pre><code><dfn>INSERT</dfn> <dfn>INTO</dfn> table2
<dfn>SELECT</dfn> * <dfn>FROM</dfn> table1
<dfn>WHERE</dfn> condition;</code></pre><p>Copy only some columns from one table into another table</p><pre><code><dfn>INSERT</dfn>
<dfn>INTO</dfn> table2 (column1, column2, column3, ...)
<dfn>SELECT</dfn> column1, column2, column3, ...
<dfn>FROM</dfn> table1 <dfn>WHERE</dfn> condition;
</code></pre></details><details><summary>UPDATE</summary><p><dfn>UPDATE</dfn> изменяет существующие данные
Обновить значения value_3 в столбец field_2, value_2 в столбец field_3, в строке с id = 1</p><pre><code><dfn>UPDATE</dfn> table
<dfn>SET</dfn> field_2 = value_3, field_3 = value_2
<dfn>WHERE</dfn> id = 1</code></pre><p>Обновить значения во всех строках где в столбце field_2 значение value_1, 
вставить в столбец field_3 значение value_2</p><pre><code><dfn>UPDATE</dfn> table
<dfn>SET</dfn> field_3 = value_2
<dfn>WHERE</dfn> field_2 = value_1
</code></pre></details><details><summary>DELETE</summary><p><dfn>DELETE</dfn> удаляет данные<br>
Удалить из таблицы table строку с id = 2</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> id = 2</code><p>Удалить из таблицы table строки со значением value_1 в столбце field_2</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> field_2 = value_1</code><p>Удалить из таблицы table все данные</p><code><dfn>DELETE</dfn> <dfn>FROM</dfn> table</code><p>to delete all data inside a table.</p><code><dfn>TRUNCATE</dfn> <dfn>TABLE</dfn> table;</code></details><details><summary>UNION</summary><p><dfn>UNION</dfn> – объединение:<br>
применяется для объединения результатов двух SQL-запросов
в единую таблицу, состоящую из схожих строк.<br> Оба запроса должны
возвращать одинаковое число столбцов и совместимые типы данных
в соответствующих столбцах!!!</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>UNION</dfn> <dfn>ALL</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details><details><summary>INTERSECT</summary><p><dfn>INTERSECT</dfn> - Пересечение:<br>
Пересечение — множество, состоящее из элементов, которые
одновременно принадлежат всем данным множествам.<br>
<dfn>INTERSECT</dfn>, также как и <dfn>UNION</dfn> обладает ограничением на результат
запросов, которые должны быть совместимы по объединению</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>INTERSECT</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details><details><summary>MINUS или EXCEPT</summary><p><dfn>MINUS или EXCEPT</dfn> - Разность:<br>
Разность двух множеств — это операция, результатом которой
является множество, в которое входят все элементы первого
множества, не входящие во второе множество</p><pre><code><dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
<dfn>MINUS</dfn> <span>либо</span> <dfn>EXCEPT</dfn>
<dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
</code></pre></details></details><details><summary>Операторы определения доступа к данным (Data Control Language, DCL)</summary><p><dfn>GRANT</dfn> - предоставляет пользователю (группе) разрешения на определенные операции с объектом<br>
<dfn>REVOKE</dfn> - отзывает ранее выданные разрешения<br>
<dfn>DENY</dfn> - задает запрет, имеющий приоритет над разрешением<br>
</p></details><details><summary>Операторы управления транзакциями (Transaction Control Language, TCL)</summary><p><dfn>Транзакция</dfn> - последовательность команд SQL, 
которые должны быть выполнены полностью или не выполнены вообще.
<br>
Например перевод денег со счёта на счёт</p><pre><code><dfn>START</dfn> <dfn>TRANSACTION</dfn>;
<dfn>UPDATE</dfn> accounts
<dfn>SET</dfn> balance = balance - 15000
<dfn>WHERE</dfn> account_number = 1234567;
<dfn>UPDATE</dfn> accounts
<dfn>SET</dfn> balance = balance + 15000
<dfn>WHERE</dfn> account_number = 9876543;
</code></pre><p><dfn>COMMIT</dfn> применяет транзакцию, записывает изменения в базу данных<br>
либо<br>
<dfn>ROLLBACK</dfn> откатывает все изменения, сделанные в контексте текущей транзакции<br>
В PostgreSQL <dfn>START TRANSACTION</dfn> и <dfn>AUTOCOMMIT</dfn> включён по умолчанию.<br>
<dfn>SET AUTOCOMMIT</dfn> = value; value может быть 1 (ON) либо 0 (OFF)<br>
<dfn>SAVEPOINT</dfn> - делит транзакцию на более мелкие участки
</p></details></details><details><summary>WordPress</summary><details><summary class="menu__submenu">Источники</summary><a href="https://developer.wordpress.org/">WordPress<br></a><a href="https://developer.wordpress.org/block-editor/reference-guides/">Guides<br></a><a href="https://developer.wordpress.org/reference/functions/">wp core functions<br></a><a href="https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page/">wp story book<br></a><a href="https://codex.wordpress.org/">Codex<br></a><a href="https://codex.wordpress.org/Theme_Unit_Test">Theme_Unit_Test<br></a><a href="https://wordpress.org/plugins/theme-check/">Theme-check<br></a><a href="https://wordpress.org/plugins/debug-bar/">Debug-bar<br></a><a href="https://wordpress.org/plugins/query-monitor/">Query-monitor<br></a><a href="https://wordpress.org/plugins/cmb2/">custom fields & metaboxes classic theme PHP adding<br></a><a href="https://gutenberg.10up.com/">custom fields & metaboxes block theme React adding<br></a><a href="https://happyprime.github.io/wphtml-converter/">Convert WordPress block HTML to its JavaScript object or PHP array forms.<br></a><a href="https://wp-kama.ru">WP-Kama<br></a><a href="https://developer.woocommerce.com/docs/">Woocommerce<br></a><a href="https://github.com/ndiego/editor-curation-examples">Отключение и блокировка блоков</a><a href="https://www.briancoords.com/">Brian Coords</a><p>Plugins:<br>
Advanced Custom Fields PRO<br>
Contact Form 7<br>
Site Kit by Google<br>
SVG Support<br>
UpdraftPlus - Backup/Restore<br>
Wordfence Security<br>
Select Yoast SEO<br>
Yoast SEO<br>
Cyr to lat<br>
Show current template<br>
</p></details><details><summary class="menu__submenu">ACF</summary><a href="https://www.youtube.com/watch?v=Q5zcWpRMl9s">ACF</a><p>Стандартный вывод информации из ACF (текст, ссылка на картинку и т.п.):</p><code>&lt;?php the_field('имя_поля'); ?&gt;</code><br><p>Вывод повторителя:</p><pre><code>&lt;?php if(get_field('имя_повторителя')): ?&gt;
  &lt;?php while(has_sub_field('имя_повторителя')) : ?&gt;
    &lt;div&gt;
      &lt;img(src="&lt;?php the_sub_field('имя_поля'); ?&gt;"&gt;
    &lt;/div&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Повторитель в повторителе:</p><pre><code>&lt;?php if(get_field('имя_повторителя_1')): ?&gt;
  &lt;?php while(has_sub_field('имя_повторителя_1')) : ?&gt;
    &lt;div&gt;
      &lt;mg(src="&lt;?php the_sub_field('имя_поля_повторителя_1'); ?&gt;"&gt;
      &lt;ul&gt;
        &lt;?php if(get_sub_field('имя_повторителя_2')): ?&gt;
        &lt;?php while(has_sub_field('имя_повторителя_2')) : ?&gt;
          &lt;?php the_sub_field('имя_поля_повторителя_2'); ?&gt;
        &lt;?php endwhile; ?&gt;
        &lt;?php endif; ?&gt;
    &lt;/div&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Вывод группы полей:</p><pre><code>&lt;?php if( have_rows('имя_группы') ): ?&gt;
&lt;?php while( have_rows('имя_группы') ): the_row(); ?&gt;
  &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
    &lt;i class="fa fa-vk" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
  &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
    &lt;i class="fa fa-facebook" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
&lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Галерея”</p><pre><code>&lt;?php if ($img_gallery = get_field("имя_галереи")) : ?&gt;
  &lt;?php foreach ($img_gallery as $img) : ?&gt;
    &lt;?php if ($img) : ?&gt;
      &lt;?= "&lt;img
        src="&lt;?= esc_url($img['sizes']['thumbnail']) ?&gt;"
        alt="&lt;?= esc_attr($img['alt']) ?&gt;"
        loading="lazy"
        width="&lt;?= esc_attr($image_array['width']) ?&gt;"
        height="&lt;?= esc_attr($image_array['height']) ?&gt;"
      /&gt;" ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endforeach; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Объект записи”</p><pre><code>&lt;?php if ($post_objects = get_field("имя_объекта_записи")) : ?&gt;
  &lt;?php
  foreach ($post_objects as $post) : setup_postdata($post); ?&gt;
    &lt;?php if ($post) : ?&gt;
      &lt;?php the_title(); ?&gt;
      &lt;?php the_excerpt(); ?&gt;
      &lt;?php the_field("имя_поля_объекта_записи"); ?&gt;
      &lt;?php the_permalink(); ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endforeach; ?&gt;
  &lt;?php wp_reset_postdata(); ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Гибкое содержание”</p><pre><code>&lt;?php if (have_rows('имя_гибкого_содержания')) : ?&gt;
  &lt;?php while (have_rows('имя_гибкого_содержания')) : the_row(); ?&gt;
    &lt;?php if (get_row_layout() == 'hero') : ?&gt;
      &lt;?php get_template_part("template-parts/hero-section") ?&gt;
    &lt;?php elseif (get_row_layout() == 'about') : ?&gt;
      &lt;?php get_template_part("template-parts/about-section") ?&gt;
    &lt;?php elseif (get_row_layout() == 'contacts') : ?&gt;
      &lt;?php get_template_part("template-parts/contacts-section") ?&gt;
    &lt;?php endif; ?&gt;
  &lt;?php endwhile; ?&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Тип поля “Ссылка”</p><pre><code>&lt;?php if (get_field('имя_ссылки')) : ?&gt;
  &lt;a
    href="&lt;?= get_field('имя_ссылки')['url'] ?&gt;"
    target="&lt;?= get_field('имя_ссылки')['target'] ?&gt;"&gt;
    &lt;?= get_field('имя_ссылки')['title'] ?&gt;
  &lt;/a&gt;
&lt;?php endif; ?&gt;</code></pre><br><p>Вывод поля ACF только если оно заполнено</p><pre><code>&lt;?php if (get_field("имя_поля")) { ?&gt;
  &lt;?php the_field("имя_поля"); ?&gt;
&lt;?php } ?&gt;</code></pre><br><p>Страница опций ACF</p><pre><code>if (function_exists("acf_add_options_page")) {
  acf_add_options_page(array(
    "page_title" => "Опции темы",
    "menu_title" => "Опции темы",
    "menu_slug"  => "theme_settings",
  ));
}</code></pre><br><p>Вывод полей из страницы с опций</p><code>&lt;?php the_field("имя_поля", "option"); ?&gt;</code><p>Для нумерации строк в плагине Advanced Custom Fields (ACF) необходимо использовать функцию get_field(), которая позволяет извлечь данные из поля.<br>
В примере ниже строки будут нумероваться с помощью цикла for:</p><pre><code>&lt;?php if( have_rows('service') ): $i = 0; ?&gt;
&lt;?php while ( have_rows('service') ) : the_row(); $i++; ?&gt;
  &lt;?php echo $i; ?&gt;
&lt;? endwhile; endif; ?&gt;
</code></pre></details><details><summary class="menu__submenu">functions.php</summary><p>Есть несколько причин, по которым вы можете увидеть сломанный сайт с белым экраном.<br>
Одна из таких причин — когда файл functions.php(или любой файл PHP) имеет пробел после закрывающего ?></p><pre><code>&lt;?php
add_action( 'after_setup_theme', function () {
  add_theme_support( 'wp-block-styles' );
});
<span>подключить файл из родительской темы</span>
include get_parent_theme_file_path( 'inc/helpers.php' );
<span>подключить файл из дочерней темы</span>
include get_theme_file_path( 'inc/helpers.php' );
<span>функция загрузки таблиц стилей для каждого блока в редакторе и на фронтенде wp_enqueue_block_style()</span>   
add_action( 'wp_enqueue_scripts', function () {
  <span>ставлю в очередь navigation.js</span>
  wp_enqueue_script( 'theme-slug-navigation',
    get_parent_theme_file_uri( 'assets/js/navigation.js' ),
    array(),
    wp_get_theme()->get( 'Version' ),
    true
  );
  <span>добавляю JS в head область на фронтенде</span>
  wp_add_inline_script( 'theme-slug-navigation',
    'console.log( "Testing" );'
  );
});
<span>JS для редактора блоков</span>
add_action( 'enqueue_block_editor_assets',
  'theme_slug_enqueue_editor_scripts', function () {
    <span>ставлю в очередь editor.js для редактора</span>
    wp_enqueue_script('theme-slug-editor',
      get_parent_theme_file_uri( 'assets/js/editor.js' ),
      array(),
      wp_get_theme()->get( 'Version' ),
      true
    );
  });</code></pre><p>Список включенных скриптов - wp-includes/script-loader.php<br>
Обращение к файлу изображения:<br></p><code>&lt;img(src="&lt;?php echo esc_url( get_theme_file_uri( 'assets/img/example.webp' ) ); ?&gt;" alt="" /&gt;</code><p>Шрифты подключать через theme.json</p></details><details><summary class="menu__submenu">wp-config.php</summary><pre><code>if ( ! defined( 'WP_DEBAG' ) ) {
  define('WP_DEBAG', true);
}

if ( ! defined( 'SCRIPT_DEBUG' ) ) {
  define('SCRIPT_DEBUG', true);
}

if ( ! defined( 'WP_DEBUG_DISPLAY' ) ) {
  define('WP_DEBUG_DISPLAY', false);
}

if ( ! defined( 'WP_DEBUG_LOG' ) ) {
  define('WP_DEBUG_LOG', ABSPATH . '/wp-content/' . date('Y-m-d', strtotime('now')) . '-debug.log');
}

if ( ! defined( 'WP_DEVELOPMENT_MODE' ) ) {
  define('WP_DEVELOPMENT_MODE', 'all');
}
</code></pre></details><details><summary class="menu__submenu">block</summary><details><summary>Создать блок</summary><p>Создать блок</p><code>npx @wordpress/create-block kweblock --namespace=kweb --variant=dynamic</code><p>Чтобы добавить ещё блок добавить --no-plugin</p><p>Автоформат добавить в package.json</p><code>"prettier": "@wordpress/prettier-config"</code><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/registration-of-a-block/--><p><dfn>register_block_type()</dfn> - регистрация нового блока php,<br>
возвращает WP_Block_Type, с данными:<br>
$attributes: Массив атрибутов блока.<br>
$content: разметка блока, хранящаяся в базе данных, если таковая имеется.<br>
$block: Экземпляр класса WP_Block, который представляет отображаемый блок (метаданные блока).<br>
генерит разметку на фронте либо<br>
render_block и render_callback() указывают что отобразить<br>
<dfn>registerBlockType()</dfn> - регистрация нового блока index.js (@wordpress/blocks),<br>
возвращает WPBlock и регистрирует edit.js в редакторе<br>
<dfn>wp_register_script()</dfn> - регистрация скрипта, пакет @wordpress/scripts<br>
<dfn>wp_register_style()</dfn> - регистрация стиля
</p><p>установить @wordpress/scripts отдельно</p><code>npm install --save-dev @wordpress/scripts</code><p>добавить скрипты в package.json</p><pre><code>"scripts": {
  "build": "wp-scripts build",
  "format": "wp-scripts format",
  "lint:js": "wp-scripts lint-js",
  "start": "wp-scripts start"
}</code></pre><p>Минимальный набор:<br>
в папке wp-content/plugins/my-app создать<br>
- my-app.php – для создания страницы плагина<br>
- src/index.js – для JavaScript-приложения<br>
- src/style.css – для стилей<br>
- package.json – для процесса сборки<br>
В файле package.json<br></p><pre><code>{
  "name": my-app",
  "version": "1.1.0",
  "private": true,
  "description": "My App",
  "author": "Me",
  "license": "GPL-2.0-or-later",
  "keywords": [
    "WordPress",
    "block"
  ],
  "homepage": "https://github.com/WordPress/gutenberg-examples/",
  "repository": "git+https://github.com/WordPress/gutenberg-examples.git",
  "bugs": {
    "url": "https://github.com/WordPress/gutenberg-examples/issues"
  },
  "main": "build/index.js",
  "devDependencies": {
    "@wordpress/scripts": "^24.0.0"
  },
  "scripts": {
    "build": "wp-scripts build",
    "format": "wp-scripts format",
    "lint:js": "wp-scripts lint-js",
    "packages-update": "wp-scripts packages-update",
    "start": "wp-scripts start"
  }
}
</code></pre><p>регистрирую блок в index.js<br>
переопределять реализацию save() не нужно<br>
edit() отображает блок в редакторе</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useSelect } from '@wordpress/data';
import { useBlockProps } from '@wordpress/block-editor';

registerBlockType( 'gutenberg-examples/example-dynamic', {
  apiVersion: 3,
  title: 'Example: last post',
  icon: 'megaphone',
  category: 'widgets',

  edit: () => {
    const blockProps = useBlockProps();
    const posts = useSelect( ( select ) => {
      return select( 'core' ).getEntityRecords( 'postType', 'post' );
    }, [] );

    return (
      &lt;div { ...blockProps }&gt;
        { ! posts && 'Loading' }
        { posts && posts.length === 0 && 'No Posts' }
        { posts && posts.length > 0 && (
          &lt;a href={ posts[ 0 ].link }&gt;
            { posts[ 0 ].title.rendered }
          &lt;/a&gt;
        ) }
      &lt;/div&gt;
    );
  },
} );</code></pre><p>регистрирую блок в plugin.php<br>
разметку возвращаю из gutenberg_examples_dynamic_render_callback()</p><pre><code>&lt;?php
/**
* Plugin Name: Gutenberg examples dynamic
*/
function gutenberg_examples_dynamic_render_callback( $block_attributes, $content ) {
  $recent_posts = wp_get_recent_posts( array(
    'numberposts' => 1,
    'post_status' => 'publish',
  ) );
  if ( count( $recent_posts ) === 0 ) {
    return 'No posts';
  }
  $post = $recent_posts[ 0 ];
  $post_id = $post['ID'];
  return sprintf(
    '&lt;a class="wp-block-my-plugin-latest-post" href="%1$s"&gt;%2$s&lt;/a&gt;',
    esc_url( get_permalink( $post_id ) ),
    esc_html( get_the_title( $post_id ) )
  );
}

function gutenberg_examples_dynamic() {
  <span>automatically load dependencies and version</span>
  $asset_file = include( plugin_dir_path( __FILE__ ) . 'build/index.asset.php');
  wp_register_script(
    'gutenberg-examples-dynamic',
    plugins_url( 'build/block.js', __FILE__ ),
    $asset_file['dependencies'],
    $asset_file['version']
  );
  register_block_type( 'gutenberg-examples/example-dynamic', array(
    'api_version' => 3,
    'editor_script' => 'gutenberg-examples-dynamic',
    'render_callback' => 'gutenberg_examples_dynamic_render_callback'
  ) );
}
add_action( 'init', 'gutenberg_examples_dynamic' );</code></pre><p>Рендеринг на стороне сервера рассматривается как запасной вариант;<br>
рендеринг на стороне клиента в JavaScript всегда предпочтительнее;<br>
использует пакет wp-server-side-render</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import ServerSideRender from '@wordpress/server-side-render';
import { useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-dynamic', {
  apiVersion: 3,
  title: 'Example: last post',
  icon: 'megaphone',
  category: 'widgets',
  edit: function ( props ) {
    const blockProps = useBlockProps();
    return (
      &lt:div { ...blockProps }&gt;
        &lt:ServerSideRender
          block="gutenberg-examples/example-dynamic"
          attributes={ props.attributes }
        /&gt;
      &lt:/div&gt;
    );
  },
} );
</code></pre></details><details><summary>InnerBlocks</summary><p>один блок может содержать только один InnerBlocks компонент.</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { InnerBlocks, useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-06', {
  // ...
  edit: () => {
    const blockProps = useBlockProps();
    return (
      &lt;div { ...blockProps }&gt;
        &lt;InnerBlocks /&gt;
      &lt;/div&gt;
    );
  },
  save: () => {
    const blockProps = useBlockProps.save();
    return (
      &lt;div { ...blockProps }&gt;
        &lt;InnerBlocks.Content /&gt;
      &lt;/div&gt;
    );
  },
} );</code></pre><p>ограничитель какие блоки могут быть прямыми потомками</p><pre><code>const { allowedBlocks } = attributes;
//...
&lt;InnerBlocks allowedBlocks={ allowedBlocks } /&gt;;</code></pre><p>allowedBlocks - указывает какие потомки могут быть прямыми потомками<br>
parent - для вложенного блока, может быть только прямым потомком<br>
ancestor - для вложенного блока, может быть только потомком</p><pre><code>{
  "title": "Column",
  "name": "core/column",
  "parent": [ "core/columns" ],
}
//...
{
  "title": "Comment Author Name",
  "name": "core/comment-author-name",
  "ancestor": [ "core/comment-template" ],
}
//...
{
  "title": "Navigation",
  "name": "core/navigation",
  "allowedBlocks": [ "core/navigation-link", "core/search", "core/social-links", "core/page-list", "core/spacer" ],
}</code></pre><p>useInnerBlocksProps - хук для большего контроля над разметкой внутренних областей блоков</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useBlockProps, useInnerBlocksProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-06', {
  edit: () => {
    const blockProps = useBlockProps();
    const { children, ...innerBlocksProps } = useInnerBlocksProps( blockProps );
    return (
      &lt;div {...innerBlocksProps}&gt;
        { children }
        <!-- Insert any arbitrary html here at the same level as the children -->
      &lt;/div&gt;
    );
  },
} );</code></pre><p>по умолчанию блоки в InnerBlocks отображаются вертикально<br>
горизонтально их ориентировать с помощью css</p><code>&lt;InnerBlocks orientation="horizontal" /&gt;</code><p>отображает значки перемещения блоков в дочерних блоках горизонтально и обеспечивает правильную работу перетаскивания.</p><p>блок по умолчанию из списка дозволенных</p><code>&lt;InnerBlocks defaultBlock={['core/paragraph', {placeholder: "Lorem ipsum..."}]} directInsert /&gt;</code><p>набор блоков, которые предварительно заполняют компонент InnerBlocks, пока нет своего содержимого.</p><pre><code>const MY_TEMPLATE = [
  [ 'core/image', {} ],
  [ 'core/heading', { placeholder: 'Book Title' } ],
  [ 'core/paragraph', { placeholder: 'Summary' } ],
];
//...
edit: () => {
  return (
    &lt;InnerBlocks
      template={ MY_TEMPLATE }
      templateLock="all"
    /&gt;
  )&gt;
},</code></pre><p>templateLock - свойство, чтобы заблокировать шаблон</p><!-- https://github.com/WordPress/gutenberg/tree/HEAD/packages/block-editor/src/components/inner-blocks/README.md#templatelock--></details><details><summary>Изменить блок</summary><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/javascript-in-the-block-editor/--><p>Создать файл webpack.config.js и добавить свой код для выполнения webpack</p><pre><code>const defaultConfig = require("@wordpress/scripts/config/webpack.config");
var config = {
  ...defaultConfig,
  entry: {
    ...defaultConfig.entry(),
    "custom/index": "./src/custom/index.js",
  },
};</code></pre><p>Внутри папки src создать папку custom и в ней файл index.js</p><pre><code>import { unregisterBlockType } from "@wordpress/blocks";
import domReady from "@wordpress/dom-ready";
const unregisterBlocks = ["core/verse"];
domReady(function () {
  unregisterBlocks.forEach(block) => {
    unregisterBlockType(block);
  });
});</code></pre><p>В файле kweblock.php добавить код для подключения функционала из custom/index.js</p><pre><code>function kweblock_enqueue_editor_modifications() {
  $asset_file = include plugin_dir_path( __FILE__ ) . 'build/custom/index.assets.php';
  wp_enqueue_script(
    'kweblock_enqueue_editor_modifications',
    plugins_url( '/build/custom/index.js', __FILE__ ),
    $asset_file['dependencies'],
    $asset_file['version'],
    true
  );
}
add_action( 'enqueue_block_editor_assets', 'kweblock_enqueue_editor_modifications' );</code></pre><!-- new variation for the Media & Text block--><pre><code>function example_enqueue_block_variations() {
  wp_enqueue_script(
    'example-enqueue-block-variations',
    get_template_directory_uri() . '/assets/js/variations.js',
    array( 'wp-blocks' ),
    wp_get_theme()->get( 'Version' ),
    false
  );
}
add_action( 'enqueue_block_editor_assets', 'example_enqueue_block_variations' );</code></pre><!-- in variations.js file:--><pre><code>wp.blocks.registerBlockVariation(
  'core/media-text',
  {
    name: 'media-text-custom',
    title: 'Media & Text Custom',
    attributes: {
      align: 'wide',
      backgroundColor: 'tertiary'
    },
  }
);</code></pre><p>создать шаблон блока типа post сразу с подгрузкой других блоков</p><pre><code>add_action( 'init', function() {
  $post_type_object = get_post_type_object( 'post' );
  $post_type_object->template = array(
    array( 'core/image' ),
    array( 'core/heading' )
  );
} );</code></pre><!-- https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/extending-the-query-loop-block/--><a href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-variations/">Вариации Query Loop block</a><p>Для того чтобы вариация цикла запросов работала правильно, нам необходимо:
– Зарегистрировать вариацию блока для core/query блока с некоторыми значениями по умолчанию
– Определить макет для вариации блока
– Использовать namespaceатрибут в isActiveсвойстве вариации блока</p><pre><code>const MY_VARIATION_NAME = 'my-plugin/books-list';
registerBlockVariation( 'core/query', {
  name: MY_VARIATION_NAME,
  title: 'Books List',
  description: 'Displays a list of books',
  <span>указываю активную вариацию, можно итак: isActive: [ 'namespace' ],</span>
  isActive: ( { namespace, query } ) => {
    return (
      namespace === MY_VARIATION_NAME
      && query.postType === 'book'
    );
  },
  icon: <span>An SVG icon can go here</span>,
  attributes: {
    namespace: MY_VARIATION_NAME,
    query: {
      perPage: 6,
      pages: 0,
      offset: 0,
      <span>предопределил тип записи для цикла запросов</span>
      postType: 'book',
      order: 'desc',
      orderBy: 'date',
      author: '',
      search: '',
      exclude: [],
      sticky: '',
      inherit: false,
    },
  },
  <span>включил отображение блока в редакторе</span>
  scope: [ 'inserter' ],
  }
);</code></pre><p>Блок Query Loop определяет, есть ли активная вариация и есть ли для неё шаблоны.<br>
Если есть, то эти шаблоны будут единственными, если нет - шаблоны по умолчанию.</p><a href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-patterns/">привязать шаблон</a><p>отключить элементы управления запросами allowedControls<br>
inherit – переключатель наследованияя запроса непосредственно из шаблона.<br>
postType – список доступных типов сообщений.<br>
order – список для выбора порядка запроса.<br>
sticky – список для выбора способа обработки прикрепленных сообщений.<br>
taxQuery – фильтры таксономий для текущего выбранного типа записи.<br>
author – Показывает поле ввода для фильтрации запроса по автору.<br>
search – Показывает поле ввода для фильтрации запроса по ключевым словам.<br>
format – Показывает поле ввода для фильтрации запроса по массиву/коллекции форматов .<br>
parents – Показывает поле ввода для фильтрации запроса с использованием родительской(их) сущности(ей).</p><pre><code>{
  <span>variation properties</span>
  allowedControls: [ 'inherit', 'order', 'taxQuery', 'search' ],
}</code></pre><p>пустой массив скроет все элементы управления<br>
<br>
Подключить пользовательские элементы управления через хук React подключенный к фильтру блока</p><pre><code>import { InspectorControls } from '@wordpress/block-editor';
export const withBookQueryControls = ( BlockEdit ) => ( props ) => {
  <span>We only want to add these controls if it is our variation,</span>
  <span>so here we can implement a custom logic to check for that, similar</span>
  <span>to the `isActive` function described above.</span>
  <span>The following assumes that you wrote a custom `isMyBooksVariation`</span>
  <span>function to handle that.</span>
  return isMyBooksVariation( props ) ? (
    &lt;&gt;
      &lt;BlockEdit key="edit" { ...props } /&gt;
      &lt;InspectorControls&gt;
        &lt;BookAuthorSelector /&gt; { /** Our custom component */ }
      &lt;/InspectorControls&gt;
    &lt;/&gt;
  ) : (
    &lt;BlockEdit key="edit" { ...props } /&gt;
  );
};
addFilter( 'editor.BlockEdit', 'core/query', withBookQueryControls );</code></pre><p>Подключить пользовательские элементы управления через фильтр query_loop_block_query_vars</p><pre><code>{
  <span>variation properties</span>
  attributes: {
    <span>variation attributes</span>
    query: {
      <span>more query settings if needed</span>
      postType: 'book',
      <span>Our custom query parameter</span>
      bookAuthor: 'J. R. R. Tolkien'
    }
  }
}</code></pre><p>подключаюсь к фильтру на фронте (когда есть доступ к блоку)</p><pre><code>if( 'my-plugin/books-list' === $block[ 'attrs' ][ 'namespace' ] ) {
  add_filter(
    'query_loop_block_query_vars',
    function( $query ) {
      <span>You can read your block custom query parameters here and build your query</span>
    },
  );
}</code></pre><p>подключаюсь к запросу API записи в редакторе через фильтр rest_{$this->post_type}_query</p><pre><code>add_filter(
  'rest_book_query',
  function( $args, $request ) {
    <span>We can access our custom parameters from here</span>
    $book_author = $request->get_param( 'bookAuthor' );
    <span>your custom query logic</span>
  }
);</code></pre><!-- https://developer.wordpress.org/block-editor/reference-guides/filters/block-filters/--><p>изменить поведение или отключить блок</p><!-- https://developer.wordpress.org/block-editor/reference-guides/packages/packages-plugins/--><!-- https://developer.wordpress.org/block-editor/reference-guides/packages/packages-edit-post/--><p>registerPlugin - определить все элементы пользовательского интерфейса плагина в одном месте</p><!-- https://developer.wordpress.org/block-editor/reference-guides/filters/editor-filters/--><p>отфильтровать редактор</p></details><details><summary>CSS</summary><!-- https://github.com/WordPress/block-development-examples--><p>Inline style - передаю стили в хук React useBlockProps</p><pre><code>import { registerBlockType } from '@wordpress/blocks';
import { useBlockProps } from '@wordpress/block-editor';
registerBlockType( 'gutenberg-examples/example-02-stylesheets', {
  edit() {
    const greenBackground = {
      backgroundColor: '#090',
      color: '#fff',
      padding: '20px',
    };
    const blockProps = useBlockProps( { style: greenBackground } );
    return (
      &lt;p { ...blockProps }&gt;Hello World (from the editor, in green).&lt;/p&gt;
    );
  },
  save() {
    const redBackground = {
      backgroundColor: '#900',
      color: '#fff',
      padding: '20px',
    };
    const blockProps = useBlockProps.save( { style: redBackground } );
    return (
      &lt;p { ...blockProps }&gt;Hello World (from the frontend, in red).&lt;/p&gt;
    );
  },
} );</code></pre><!-- useBlockProps - обёртка блока--><!-- https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#block-wrapper-props--><p>Хук useBlockProps автоматически включает имя класса для блока,
генерирует имя для каждого блока, используя имя блока с префиксом wp-block-,
заменет / разделитель пространства имен символом -.</p><!-- https://developer.wordpress.org/block-editor/getting-started/fundamentals/block-in-the-editor/--><p><dfn>useBlockProps()</dfn> - позволяет изменить аттрибуты в оболочке блока,
определяет внешнюю разметку блока в редакторе
(это хук из @wordpress/block-editor)
<dfn>useBlockProps.save()</dfn> - добавляет классы и атрибуты при сохранении в базу
<dfn>get_block_wrapper_attributes()</dfn> - добавляет классы и атрибуты при динамическом рендере
wp-block - класс с общими для блоков настройками</p><!-- то же самое, но через отдельные файлы--><p>block.json</p><pre><code>{
  "apiVersion": 3,
  "name": "gutenberg-examples/example-02-stylesheets",
  "title": "Example: Stylesheets",
  "icon": "universal-access-alt",
  "category": "layout",
  "editorScript": "file:./block.js",
  "editorStyle": "file:./editor.css",
  "style": "file:./style.css"
}</code></pre><p>editor.css - green background</p><pre><code>.wp-block-gutenberg-examples-example-02-stylesheets {
  background: #090;
  color: white;
  padding: 20px;
}</code></pre><p>style.css - red background</p><pre><code>.wp-block-gutenberg-examples-example-02-stylesheets {
  background: #900;
  color: white;
  padding: 20px;
}</code></pre><p>Если использовать `@wordpress/scripts`, то необходимо импортировать таблицу стилей в соответствующий файл JavaScript<br>
В `edit.js` - `import './editor.scss';`<br>
В `index.js` - `import './style.scss';`<br>
В `view.js` - `import './view.scss';`</p><p>для включения нескольких файлов использовать wp_enqueue_style на хуках:<br>
enqueue_block_editor_assets – загружать только в режиме редактора<br>
enqueue_block_assets – загружается как в интерфейсе, так и в редакторе<br>
переменная стиля из theme.json в style.scss:</p><code>var(--wp--preset--color--contrast)</code><p>переменная стиля из theme.json в json файле:</p><code>var:preset|color|contrast</code></details><details><summary>Editor</summary><p>@wordpress/block-editor - пакет позволяет создавать автономные редакторы блоков,
библиотека JavaScript, которая обеспечивает основную функциональность редактора.</p><a href="https://developer.wordpress.org/block-editor/how-to-guides/platform/custom-block-editor/">Собственный редактор блоков</a><p>@wordpress/components and @wordpress/block-editor - пакеты для редактора<br>
для отдельной установки:</p><code>npm install --save @wordpress/components</code><p>storybook - https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page<br>
Block Toolbar - компонент BlockControls (@wordpress/block-editor)<br>
Settings Sidebar - компонент InspectorControls (@wordpress/block-editor)<br>
CSS компонентов находится по адресу node_modules/@wordpress/components/build-style/style.css<br>
в консоле браузера wp.data.select('core/editor').getBlocks() - вернет все доступные блоки
</p></details><details><summary>Работа с данными</summary><p>@wordpress/core-data - предоставляет resolvers, selectors и actions для работы с API ядра WordPress
</p></details></details></details><details><summary>Laravel</summary><details><summary>Framework</summary><p>Laravel - это фреймворк MVC, который использует шаблон проектирования MVC (Model-View-Controller).<br>
Он разделяет приложение на три основных компонента:<br>
- Модель (Model) - отвечает за работу с данными и бизнес-логикой приложения.<br>
- Представление (View) - отвечает за отображение данных пользователю.<br>
- Контроллер (Controller) - связывает модель и представление, обрабатывает запросы и управляет логикой приложения.<br>
</p><details><summary>Create app</summary><pre><code>laravel new example-app
cd example-app
php artisan sail:install</code></pre><p>добавить псевдоним в ~/.zshrc</p><pre><code>alias sail='zsh $([ -f sail ] && echo sail || echo vendor/bin/sail)'
alias sailar='zsh $([ -f sail ] && echo sail artisan || echo vendor/bin/sail artisan)'
sail artisan list
sail up -d
sailar migrate
http://localhost</code></pre><p>остановить контейнеры</p><code>sail stop </code><p>удалить контейнеры</p><code>sail down</code><p>удалить контейнеры и тома</p><code>sail down -v</code><p>удалить контейнеры, тома и образы</p><code>sail down --rmi all</code><p>удалить только тома</p><code>sail down --volumes</code><p>удалить контейнеры, которые не определены в docker-compose.yml</p><code>sail down --remove-orphans</code><p>пересобрать контейнеры</p><code>sail build</code><p>пересобрать контейнеры без кеша</p><code>sail build --no-cache</code><p>пересобрать контейнеры с обновлением образов без кеша</p><code>sail build --pull --no-cache</code><p>запуск очереди</p><code>sail artisan queue:work --queue=default --tries=3 --timeout=90 --sleep=3 --delay=0 --max-jobs=1000 --max-time=3600</code><p>версия php</p><code>sail php --version</code><p>выполнить скрипт php</p><code>sail php script.php</code><p>установить пакет</p><code>sail composer require laravel/sanctum</code><p>запустить скрипт npm</p><code>sail npm run dev</code><p>запустить yarn</p><code>sail yarn</code><p>запустить сервер на указанном хосте</p><code>sail artisan serve --host=yourhost</code><p>Обновить образы:</p><pre><code>docker compose down -v
sail build --no-cache
sail up -d
</code></pre></details><details><summary>Folder structure</summary><p>- app - основная папка приложения, код приложения<br>
- bootstrap - начальная загрузка приложения и кеширование<br>
- config - конфигурация приложения<br>
- database - миграции, фабрики, наполнители (seeders), sqlite<br>
- public - публичная папка приложения, точка входа всех запросов: index.php, оптимизированные ресурсы и автозагрузка<br>
- resources - рнеотимизированные и нескомпилированные ресурсы: шаблоны, images, js, css<br>
- routes - маршруты приложения на указанный метод<br>
- storage - временные файлы приложения: логи, скомпилированные шаблоны, файлы сессий и кеша<br>
- tests - тесты приложения<br>
- vendor - сomposer-зависимости приложения<br>
- node_modules - node-зависимости приложения<br>
- .gitignore - файл игнорирования git<br>
- .gitattributes - файл атрибутов git<br>
- .dockerignore - файл игнорирования docker<br>
- .docker-compose.yml - файл конфигурации docker<br>
- .env - файл окружения приложения<br>
- .env.example - пример файла окружения приложения<br>
- .editorconfig - файл конфигурации редактора<br>
- artisan - консольная команда приложения<br>
- composer.json - файл сomposer-зависимостей приложения<br>
- package.json - файл node-зависимостей приложения<br>
- phpunit.xml - файл конфигурации тестов приложения<br>
- vite.config.js - файл конфигурации vite приложения<br>
</p></details><details><summary>Lifecycle</summary><p>- Браузер - запрос пользователя<br>
- Apache / Nginx - веб сервер<br>
- public/index.php - загружает автозагрузчик<br>
- bootstrap/app.php - создаёт экземпляр фреймворка<br>
- laravel - создаёт экземпляр приложения и контейнер служб (регистрация всех сервис-провайдеров bootstrap/providers.php)<br>
- НТТР-ядро - запрос поступает НТТР-ядру (либо ядру консоли)<br>
- bootstrappers - массив загрузчиков для обработки ошибок, логирования, среда окружения, middleware<br>
- маршрутизатор - направляет запрос на указанный метод по маршруту<br>
- middleware - фильтрация НТТР-запросов<br>
- контроллер или представление - выполнение метода<br>
- middleware - фильтрация НТТР-ответов<br>
- НТТР-ядро - возвращает объект ответа в экзепмляр приложения<br>
- экземляр приложения - отправляет содержимое ответа в браузер<br>
- Браузер - рендеринг ответа<br></p><pre><code>Браузер
  Apache / Nginx -> public/index.php -> bootstrap/app.php
    laravel -> экземляр приложения
      НТТР-ядро -> bootstrappers
        маршрутизатор
          middleware                                   
            контроллер -> представление
          middleware
      НТТР-ядро
    экземляр приложения
Браузер
</code></pre></details><details><summary>Configuration</summary><p>- config/app.php - конфигурация приложения<br>
- config/database.php - конфигурация базы данных<br>
- config/queue.php - конфигурация очередей<br>
- config/mail.php - конфигурация почты<br>
- config/broadcasting.php - конфигурация широковещательных каналов<br>
- config/filesystems.php - конфигурация файловых систем<br>
- config/logging.php - конфигурация логирования<br>
- config/session.php - конфигурация сессий<br>
- config/services.php - конфигурация сервисов<br>
- config/queue.php - конфигурация очередей<br>
- config/cors.php - конфигурация CORS<br>
- config/sanctum.php - конфигурация Sanctum<br>
- config/schedule.php - конфигурация планировщика задач<br>
<br>
- .env - файл окружения приложения<br>
- .env.example - пример файла окружения приложения<br>
- .env.testing - файл окружения для тестов<br>
- .env.dusk.local - файл окружения для Dusk-тестов<br>
- .env.dusk.example - пример файла окружения для Dusk-тестов<br>
- .env.dusk.testing - файл окружения для Dusk-тестов<br>
<br>
- php artisan about - обзор конфигурации<br>
- php artisan about --only=environment - обзор определенного раздела конфигурации<br>
- php artisan config:show database - обзор  определенного файла конфигурации<br>
- $_ENV - суперглобальная переменная содержит все переменные, перечисленные в файле .env<br>
- 'debug' => env('APP_DEBUG', false) - использовать только в конфигурационных файлах для получения значений переменных конфигурации, второй параметр - значение по умолчанию если нет значения переменной<br>
- текущее окружение<br></p><pre><code>use Illuminate\Support\Facades\App;
$environment = App::environment();</code></pre><p>- php artisan env:encrypt - шифрование файла .env<br>
- доступ к значениям конфигурации<br></p><pre><code>use Illuminate\Support\Facades\Config;
$value = Config::get('app.timezone');
$value = config('app.timezone');</code></pre><p>- php artisan config:cache - кешировать все конфигурационные файлы в один файл при деплое<br>
- php artisan config:clear - очистки кэша конфигурации<br>
- php artisan config:publish - публикация файлов конфигурации для модификации<br>
- php artisan down - включить режим обслуживания<br>
- php artisan up - отключить режим обслуживания<br>
- php artisan optimize - оптимизация приложения<br>
- php artisan optimize:clear - очистка кеша приложения<br>
</p></details><details><summary>Logging</summary><p>- логирование - запись сообщений в журнал<br>
- лог-файл - файл, в который записываются сообщения<br>
- уровень логирования - уровень важности сообщения<br>
- канал (драйвер) логирования - способ записи сообщений в журнал<br>
- драйверы логирования: single, daily, syslog, errorlog, monolog, null, custom<br>
- конфигурация ведения журнала config/logging.php<br>
- изменить имя канала<br></p><pre><code>'stack' => [
  'driver' => 'stack',
  'name' => 'channel-name',
  'channels' => ['single', 'slack'],
],</code></pre><p>конфигурация для продакшина</p><pre><code>'channels' => [
  'stack' => [
    'driver' => 'stack',
    'channels' => ['syslog', 'slack'],  
    'ignore_exceptions' => false,
  ],
  'syslog' => [
    'driver' => 'syslog',
    'level' => env('LOG_LEVEL', 'debug'),
    'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
    'replace_placeholders' => true,
  ],
  'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
    'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
    'level' => env('LOG_LEVEL', 'critical'),
    'replace_placeholders' => true,
  ],
],</code></pre><p>- уровни журнала в порядке убывания критичности: emergency, alert, critical, error, warning, notice, info, и debug<br>
- уровень по умолчанию - debug<br>
- методы записи по уровням<br></p><pre><code>use Illuminate\Support\Facades\Log;
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);</code></pre><p>в контроллере</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Support\Facades\Log;
use Illuminate\View\View;
class UserController extends Controller
{
  - Показать профиль конкретного пользователя.
  public function show(string $id): View
  {
    Log::info('Showing the user profile for user: {id}', ['id' => $id]);
    return view('user.profile', [
      'user' => User::findOrFail($id)
    ]);
  }
}</code></pre><p>регистрировать в журнале id каждого запроса</p><pre><code>namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class AssignRequestId
{
  - Обработчик входящего запроса
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    $requestId = (string) Str::uuid();
    Log::withContext([
      'request-id' => $requestId
    ]);
    $response = $next($request);
    $response->headers->set('Request-Id', $requestId);
    return $response;
  }
}</code></pre><p>регистрировать id каждого запроса по всем каналам</p><pre><code>public function handle(Request $request, Closure $next): Response
  {
    $requestId = (string) Str::uuid();
    Log::shareContext([
      'request-id' => $requestId
    ]);
  }</code></pre><p>запись в указанный канал</p><pre><code>use Illuminate\Support\Facades\Log;
Log::channel('slack')->info('Something happened!');</code></pre><p>запись в несколько каналов</p><code>Log::stack(['single', 'slack'])->info('Something happened!');</code><p>создать канал по запросу</p><pre><code>use Illuminate\Support\Facades\Log;
Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
])->info('Something happened!');</code></pre><p>создать канал по запросу и включить в стэк</p><pre><code>use Illuminate\Support\Facades\Log;
$channel = Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
]);
Log::stack(['slack', $channel])->info('Something happened!');</code></pre><p>настроить канал вручную через свой класс</p><pre><code>'single' => [
  'driver' => 'single',
  'tap' => [App\Logging\CustomizeFormatter::class],
  'path' => storage_path('logs/laravel.log'),
  'level' => env('LOG_LEVEL', 'debug'),
  'replace_placeholders' => true,
],</code></pre><p>свой класс</p><pre><code>namespace App\Logging;
use Illuminate\Log\Logger;
use Monolog\Formatter\LineFormatter;
class CustomizeFormatter
{
  - Настроить переданный экземпляр регистратора.
  public function __invoke(Logger $logger): void
  {
    foreach ($logger->getHandlers() as $handler) {
      $handler->setFormatter(new LineFormatter(
        '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'
      ));
    }
  }
}</code></pre><p>указать обработчик</p><pre><code>'logentries' => [
  'driver'  => 'monolog',
  'handler' => Monolog\Handler\SyslogUdpHandler::class,
  'with' => [
    'host' => 'my.logentries.internal.datahubhost.company.com',
    'port' => '10000',
  ],
],</code></pre><p>задать форматирование</p><pre><code>'browser' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\BrowserConsoleHandler::class,
  'formatter' => Monolog\Formatter\HtmlFormatter::class,
  'formatter_with' => [
    'dateFormat' => 'Y-m-d',
  ],
],

либо
'newrelic' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\NewRelicHandler::class,
  'formatter' => 'default',
],</code></pre><p>обрабатывать сообщения перед их записью в журнал</p><pre><code>'memory' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\StreamHandler::class,
  'with' => [
    'stream' => 'php://stderr',
  ],
  'processors' => [
    // Simple syntax
    Monolog\Processor\MemoryUsageProcessor::class,

    // With options
    [
    'processor' => Monolog\Processor\PsrLogMessageProcessor::class,
    'with' => ['removeUsedContextFields' => true],
    ],
  ],
],</code></pre><p>создать канал через фабрику</p><pre><code>'channels' => [
  'example-custom-channel' => [
    'driver' => 'custom',
    'via' => App\Logging\CreateCustomLogger::class,
  ],
],</code></pre><p>класс фабрика</p><pre><code>namespace App\Logging;
use Monolog\Logger;
class CreateCustomLogger
{
  - Создать экземпляр собственного регистратора Monolog
  public function __invoke(array $config): Logger
  {
    return new Logger(/* ... */);
  }
}</code></pre><p>просмотр сообщений в журнале</p><pre><code>composer require laravel/pail
php artisan pail

либо
php artisan pail -v</code></pre><p>фильтровать вывод инфы</p><code>php artisan pail --filter="QueryException"</code><p>фильтровать по сообщениям</p><code>php artisan pail --message="User created" created"</code><p>фильтровать по уровням</p><code>php artisan pail --level=error</code><p>фильтровать по пользователю</p><code>php artisan pail --user=1</code></details><details><summary>Packages</summary><p>- Cashier (Stripe) - платежная система Stripe<br>
- Cashier (Paddle) - платежная система Paddle<br>
- Dusk - автоматизация и тестирование браузеров<br>
- Envoy - выполнение задач на удаленных серверах<br>
- Fortify - backend реализация authentication<br>
- Folio - роутер, основанный на страницах для упрощения маршрутизации<br>
- Homestead - локальная среда разработки на Vagrant<br>
- Horizon - панель управления и конфигурацию для Redis системы очередей<br>
- Mix - компиляция и минимизация файлов CSS и JavaScript<br>
- Octane - увеличивает производительность приложения<br>
- Passport - обеспечивает полную реализацию OAuth2 сервера для приложения<br>
- Pennant - комплект флагов без крафт. Флаги позволяют постепенно внедрять новые функции приложений, А/Б тестировать новые интерфейсы, дополнять стратегию развития на основе ствола<br>
- Pint - стиль кода, устанавливается по умолчанию<br>
- Precognition - предвидеть результат будущего HTTP-запроса, выполнит всю промежуточную обработку маршрута и разрешит зависимости контроллера, включая валидацию запросов формы без выполнения метода контроллера.<br>
- Prompts - добавление красивых и удобных форм к приложениям командной строки с функциями браузера<br>
- Pulse - сведения о производительности и использовании приложения<br>
- Reverb - масштабируемый в реальном времени WebSocket коммуникаций<br>
- Sail - взаимодействие со средой разработки Docker<br>
- Sanctum - система аутентификации для SPA (приложения с одной страницей), мобильные приложения и простые токены-API<br>
- Scout - полнотекстовоый поиск<br>
- Socialite аутентификация через соц.сети<br>
- Telescope предоставляет информацию о поступающих запросах, исключениях, записях записей, баз данных, задаваемых заданий, почтовых сообщений, уведомлениях, операциях кэша, запланированных задачах, переменных дампов и т.д.<br>
- Valet среда разработки для мак
</p></details><details><summary>Testing</summary><p>- pest: это обёртка для phpunit.<br>
- файл tests/Pest.php - конфигурация тестов<br>
- создаю тест</p><code>php artisan make:test</code><p>запускаю тест</p><code>php artisan test</code><p>- создание теста в tests/Feature</p><code>php artisan make:test UserTest</code><p>- создание теста в tests/Unit</p><code>php artisan make:test UserTest --unit</code><p>- создание юнит-теста с использованием Pest, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода</p><code>php artisan make:test UserTest --pest --unit --force --quiet --no-interaction --no-ansi</code><p>- php artisan test - запуск тестов<br>
- ./vendor/bin/phpunit - запуск тестов<br>
- ./vendor/bin/pest - запуск тестов<br>
<br>
- ./vendor/bin/phpunit tests/Feature/UserTest.php::testBasic<br>
- ./vendor/bin/phpunit tests/Unit/UserTest.php::testBasic<br>
<br>
- настроить переменные окружения testing можно в phpunit.xml<br>
- после внесения изменений выполнить очистку кэша<br></p><code>php artisan config:clear</code><p>- при тесторовании вместо .env можно использовать .env.testing<br>
- сгенерировать новый тестовый файл .env.testing<br></p><code>cp .env.example .env.testing</code><p>в UserTest</p><pre><code>test('basic', function () {
    expect(true)->toBeTrue();
});</code></pre><p>передать аргументы</p><code>php artisan test --testsuite=Feature --stop-on-failure</code><p>запуск тестов в командной строке</p><pre><code>./vendor/bin/phpunit
либо
./vendor/bin/pest
либо
php artisan test</code></pre><p>параллельный запуск тестов</p><pre><code>composer require brianium/paratest --dev
php artisan test --parallel
// настроить количество процессов - не более количества ядер ЦП на компьюторе
php artisan test --parallel --processes=4
// пересоздать тестовые базы данных
php artisan test --parallel --recreate-databases</code></pre><p>хуки параллельного тестирования:<br>
подготовка определенные ресурсы, используемые тестами<br>
$token - токен процесса<br>
$testCase - текущий тестовый класс<br></p><pre><code>namespace App\Providers;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\ParallelTesting;
use Illuminate\Support\ServiceProvider;
use PHPUnit\Framework\TestCase;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    ParallelTesting::setUpProcess(function (int $token) {});
    ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {});
    // Выполнится при создании тестовой базы данных...
    ParallelTesting::setUpTestDatabase(function (string $database, int $token) {
      Artisan::call('db:seed');
    });
    ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {});
    ParallelTesting::tearDownProcess(function (int $token) {});
  }
}</code></pre><p>доступ к текущему “токену” параллельного процесса из любого места приложения</p><code>$token = ParallelTesting::token();</code><p>отчет о покрытии тестами (требуется Xdebug или PCOV.)</p><code>php artisan test --coverage</code><p>задать минимальный порог покрытия тестами</p><code>php artisan test --coverage --min=80.3</code><p>получить список десяти самых медленных тестов</p><code>php artisan test --profile</code><p>- сделать запрос к приложению - вызвать в тесте методы get, post, put, patch, или delete<br>
- один тест - один запрос<br></p><pre><code>test('the application returns a successful response', function () {
  $response = $this->get('/');
  $response->assertStatus(200);
});</code></pre><p>настройки заголовков запроса</p><pre><code>test('interacting with headers', function () {
  $response = $this->withHeaders([
    'X-Header' => 'Value',
  ])->post('/user', ['name' => 'Sally']);
  $response->assertStatus(201);
});</code></pre><p>установить значения файлов Cookies</p><pre><code>test('interacting with cookies', function () {
  $response = $this->withCookie('color', 'blue')->get('/');
  $response = $this->withCookies([
    'color' => 'blue',
    'name' => 'Taylor',
  ])->get('/');
});</code></pre><p>установить данные сессии</p><pre><code>test('interacting with the session', function () {
  $response = $this->withSession(['banned' => false])->get('/');
});</code></pre><p>actingAs – аутентифицировать указанного пользователя как текущего</p><pre><code>use App\Models\User;
test('an action that requires authentication', function () {
  $user = User::factory()->create();
  $response = $this->actingAs($user)
            ->withSession(['banned' => false])
            ->get('/');
});</code></pre><p>с использованием гэйта</p><code>$this->actingAs($user, 'web')</code><p>проверка и отладка содержимого ответа</p><pre><code>test('basic test', function () {
  $response = $this->get('/');
  $response->dumpHeaders();
  $response->dumpSession();
  $response->dump();
});
либо
test('basic test', function () {
  $response = $this->get('/');
  $response->ddHeaders();
  $response->ddSession();
  $response->dd();
});</code></pre><p>тесты исключений</p><pre><code>use App\Exceptions\InvalidOrderException;
use Illuminate\Support\Facades\Exceptions;
test('exception is thrown', function () {
  Exceptions::fake();
  $response = $this->get('/order/1');
  Было ли выброшено исключение InvalidOrderException
  Exceptions::assertReported(InvalidOrderException::class);
  Было ли выброшено исключение InvalidOrderException с заданным сообщением
  Exceptions::assertReported(function (InvalidOrderException $e) {
    return $e->getMessage() === 'The order was invalid.';
  });
});</code></pre><p>указанное исключение и никаких исключений не было создано во время запроса</p><pre><code>Exceptions::assertNotReported(InvalidOrderException::class);
Exceptions::assertNothingReported();</code></pre><p>отключить обработку исключений для данного запроса</p><code>$response = $this->withoutExceptionHandling()->get('/');</code><p>проверить, что приложение не использует устаревшие функции</p><code>$response = $this->withoutDeprecationHandling()->get('/');</code><p>проверить, что код внутри замыкания генерирует исключение указанного типа</p><pre><code>$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  OrderInvalid::class
);</code></pre><p>проверить, что код внутри замыкания генерирует исключение указанного типа, а исключение равно заданому значению</p><pre><code>$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  fn (OrderInvalid $e) => $e->orderId() === 123;
);</code></pre><p>тесты JSON API<br>
методы для тестирования API-интерфейсов JSON и их ответов: json, getJson, postJson, putJson, patchJson, deleteJson, и optionsJson<br>
сделать запрос POST к /api/user<br></p><pre><code>test('making an api request', function () {
  $response = $this->postJson('/api/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    // метод assertJson используется для подтверждения наличия фрагмента JSON в ответе JSON
    ->assertJson([
      'created' => true,
    ]);
});</code></pre><p>получить доступ к данным ответа JSON как к массиву</p><code>expect($response['created'])->toBeTrue();</code><p>проверить, что массив в точности соответствует JSON</p><pre><code>test('asserting an exact json match', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertExactJson([
      'created' => true,
    ]);
});</code></pre><p>убедиться, что ответ JSON содержит данные по указанному пути</p><pre><code>test('asserting a json path value', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertJsonPath('team.owner.name', 'Darian');
});</code></pre><p>динамическое определение, должно ли утверждение выполниться</p><code>$response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);</code><p>последовательное тестирование ответов JSON</p><pre><code>use Illuminate\Testing\Fluent\AssertableJson;
test('fluent json', function () {
  $response = $this->getJson('/users/1');
  $response
    ->assertJson(fn (AssertableJson $json) =>
      $json->where('id', 1)
        // where - для присутствующего атрибута 
        ->where('name', 'Victoria Faith')
        ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
        ->whereNot('status', 'pending')
        // missing - для отсутствующего атрибута JSON
        ->missing('password')
        // etc - в объекте JSON могут присутствовать другие атрибуты
        ->etc()
      );
});</code></pre><p>проверить, что атрибут присутствует или отсутствует (has и missing)</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->has('data')
    ->missing('message')
);</code></pre><p>наличие или отсутствие нескольких атрибутов (hasAll и missingAll)</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->hasAll(['status', 'data'])
    ->missingAll(['message', 'code'])
);</code></pre><p>присутствует ли хотя бы один из заданного списка</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->has('status')
    ->hasAny('data', 'message', 'code')
);</code></pre><p>проверить маршрут, который возращает всех пользователей</p><pre><code>Route::get('/users', function () {
  return User::all();
});</code></pre><p>тест по первому пользователю</p><pre><code>$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has(3)
      ->first(fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );</code></pre><p>проверить маршрут, который возвращает коллекцию JSON с именованными ключами</p><pre><code>Route::get('/users', function () {
  return [
    'meta' => [...],
    'users' => User::all(),
  ];
})
тест
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3)
      ->has('users.0', fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );
либо
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3, fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );</code></pre><p>проверить тип</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('id', 'integer')
    ->whereAllType([
      'users.0.name' => 'string',
      'meta' => 'array'
    ])
);</code></pre><p>проверить наличие одного из типов, допустимые типы: string, integer, double, boolean, array, и null</p><pre><code>$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('name', 'string|null')
    ->whereType('id', ['string', 'integer'])
);</code></pre><p>тесты загрузки файлов<br>
протестировать форму загрузки аватара<br>
метод fake есть у класса UploadedFile и у фасада Storage<br></p><pre><code>use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
test('avatars can be uploaded', function () {
  Storage::fake('avatars');
  $file = UploadedFile::fake()->image('avatar.jpg');
  $response = $this->post('/avatar', [
    'avatar' => $file,
  ]);
  Storage::disk('avatars')->assertExists($file->hashName());
});</code></pre><p>подтвердить, что переданный файл не существует</p><pre><code>Storage::fake('avatars');
Storage::disk('avatars')->assertMissing('missing.jpg');</code></pre><p>указать ширину, высоту и размер изображения (в килобайтах)</p><code>UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);</code><p>создать pdf</p><code>UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);</code><p>явно определить MIME-тип файла</p><pre><code>UploadedFile::fake()->create(
  'document.pdf', $sizeInKilobytes, 'application/pdf'
);</code></pre><p>тесты шаблонов: assertSee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee и assertDontSeeText</p><pre><code>test('a welcome view can be rendered', function () {
  $view = $this->view('welcome', ['name' => 'Taylor']);
  $view->assertSee('Taylor');
});</code></pre><p>получить необработанное отрисованное содержимое шаблона</p><code>$contents = (string) $this->view('welcome');</code><p>добавить в глобальную коллекцию ошибок сообщения об ошибках</p><pre><code>$view = $this->withViewErrors([
  'name' => ['Please provide a valid name.']
])->view('form');
$view->assertSee('Please provide a valid name.');</code></pre><p>метод blade возвращает экземпляр Illuminate\Testing\TestView</p><pre><code>$view = $this->blade(
  '&lt;x-component :name="$name" /&gt;',
  ['name' => 'Taylor']
);
$view->assertSee('Taylor');</code></pre><p>метод component возвращает экземпляр Illuminate\Testing\TestComponent</p><pre><code>$view = $this->component(Profile::class, ['name' => 'Taylor']);
$view->assertSee('Taylor');</code></pre><a href="http://laravel.su/docs/12.x/http-tests#utverzdeniia-otvetov">доступные утверждения ответов</a><p>тесты аутентификации<br>
пользователь аутентифицирован<br></p><code>$this->assertAuthenticated($guard = null);</code><p>пользователь не аутентифицирован</p><code>$this->assertGuest($guard = null);</code><p>конкретный пользователь аутентифицирован</p><code>$this->assertAuthenticatedAs($user, $guard = null);</code><p>тесты валидации<br>
ответ содержит ошибки валидации для указанных ключей<br></p><pre><code>$response->assertInvalid(['name', 'email']);
// либо
$response->assertInvalid([
  'name' => 'The name field is required.',
  'email' => 'valid email address',
]);</code></pre><p>тесты консоли<br>
метод artisan для вызова Artisan-команды из теста,<br>
метод assertExitCode, проверить, что команда завершилась с указанным кодом (код 0 - успех, остальное - нет)<br></p><pre><code>test('console command', function () {
  $this->artisan('inspire')->assertExitCode(0);
});</code></pre><p>команда не завершилась с заданным кодом</p><pre><code>$this->artisan('inspire')->assertNotExitCode(1);
// либо
$this->artisan('inspire')->assertSuccessful();
$this->artisan('inspire')->assertFailed();</code></pre><p>тесты ввода/вывода<br>
метод expectsQuestion - имитировать ввод пользователя в консольных командах<br>
метод assertExitCode - ожидаемый код завершения команды<br>
метод expectsOutput - ожидаемый при выполнении команды текст<br></p><p>консольная команда</p><pre><code>Artisan::command('question', function () {
  $name = $this->ask('What is your name?');
  $language = $this->choice('Which language do you prefer?', [
    'PHP',
    'Ruby',
    'Python',
  ]);
  $this->line('Your name is '.$name.' and you prefer '.$language.'.');
});</code></pre><p>проверить команду</p><pre><code>test('console command', function () {
  $this->artisan('question')
    ->expectsQuestion('What is your name?', 'Taylor Otwell')
    ->expectsQuestion('Which language do you prefer?', 'PHP')
    ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')
    ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')
    ->assertExitCode(0);
});</code></pre><p>expectsSearch, чтобы имитировать ввод пользователя, результаты поиска и выбор</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->expectsSearch('What is your name?', search: 'Tay', answers: [
      'Taylor Otwell',
      'Taylor Swift',
      'Darian Taylor'
    ], answer: 'Taylor Otwell')
    ->assertExitCode(0);
});</code></pre><p>проверить, что команда не генерирует никакого вывода</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->doesntExpectOutput()
    ->assertExitCode(0);
});</code></pre><p>проверить часть вывода</p><pre><code>test('console command', function () {
  $this->artisan('example')
    ->expectsOutputToContain('Taylor')
    ->assertExitCode(0);
});</code></pre><p>команды ожидает ответа «да» или «нет»</p><pre><code>$this->artisan('module:import')
  ->expectsConfirmation('Do you really wish to run this command?', 'no')
  ->assertExitCode(1);</code></pre><p>проверить таблицу</p><pre><code>$this->artisan('users:all')
  ->expectsTable([
    'ID',
    'Email',
  ], [
    [1, 'taylor@example.com'],
    [2, 'abigail@example.com'],
  ]);</code></pre><p>включить генерацию консольных событий при выполнении тестов</p><pre><code>use Illuminate\Foundation\Testing\WithConsoleEvents;
uses(WithConsoleEvents::class);</code></pre><p>тесты БД<br>
сброс базы данных после каждого теста<br></p><pre><code>use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('basic example', function () {
  $response = $this->get('/');
});</code></pre><p>полностью сбросить БД
- использовать трейты Illuminate\Foundation\Testing\DatabaseMigrations или Illuminate\Foundation\Testing\DatabaseTruncation<br>
- использовать фабрику в тестах<br></p><pre><code>use App\Models\User;
test('models can be instantiated', function () {
    $user = User::factory()->create();
});</code></pre><p>использовать наполнитель в тестах</p><pre><code>use Database\Seeders\OrderStatusSeeder;
use Database\Seeders\TransactionStatusSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('orders can be created', function () {
  // Run the DatabaseSeeder...
  $this->seed();
  // Run a specific seeder...
  $this->seed(OrderStatusSeeder::class);
  Run an array of specific seeders...
    $this->seed([
      OrderStatusSeeder::class,
      TransactionStatusSeeder::class,
  ]);
});</code></pre><p>автоматически заполнять базу данных перед каждым тестом</p><pre><code>namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
  - Указывает, следует ли запускать наполнитель по умолчанию перед каждым тестом.
  - @var bool
  protected $seed = true;
}
либо
use Database\Seeders\OrderStatusSeeder;
protected $seeder = OrderStatusSeeder::class;</code></pre><p>таблица в базе данных содержит указанное количество записей</p><code>$this->assertDatabaseCount('users', 5);</code><p>таблица в базе данных не содержит записей</p><code>$this->assertDatabaseEmpty('users');</code><p>таблица в базе данных содержит записи, соответствующие переданным ключ/значение</p><pre><code>$this->assertDatabaseHas('users', [
  'email' => 'sally@example.com',
]);</code></pre><p>таблица в базе данных не содержит записей, соответствующих переданным ключ/значение</p><pre><code>$this->assertDatabaseMissing('users', [
  'email' => 'sally@example.com',
]);</code></pre><p>модель была «программно удалена»</p><code>$this->assertSoftDeleted($user);</code><p>модель не была «программно удалена»</p><code>$this->assertNotSoftDeleted($user);</code><p>данная модель существует в базе данныхuse App\Models\User;</p><pre><code>$user = User::factory()->create();
$this->assertModelExists($user);</code></pre><p>данной модели не существует в базе данных</p><pre><code>use App\Models\User;
$user = User::factory()->create();
$user->delete();
$this->assertModelMissing($user);</code></pre><p>ожидаемое числа запросов к базе данных во время выполнения теста</p><code>$this->expectsDatabaseQueryCount(5);</code><p>имитация:<br>
использовать подставной экземпляр объекта вместо создания самого объекта<br></p><pre><code>use App\Service;
use Mockery;
use Mockery\MockInterface;
test('something can be mocked', function () {
  $this->instance(
    Service::class,
    Mockery::mock(Service::class, function (MockInterface $mock) {
      $mock->shouldReceive('process')->once();
    })
  );
});
// либо
use App\Service;
use Mockery\MockInterface;
$mock = $this->mock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});</code></pre><p>имитировать несколько методов объекта</p><pre><code>use App\Service;
use Mockery\MockInterface;
$mock = $this->partialMock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});</code></pre><p>шпионы записывают любое взаимодействие между шпионом и тестируемым кодом</p><pre><code>use App\Service;
$spy = $this->spy(Service::class);
$spy->shouldHaveReceived('process');</code></pre><p>для контроллера</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller
{
  - Получить список всех пользователей приложения
  public function index(): array
  {
    $value = Cache::get('key');
    return [];
  }
}</code></pre><p>имитировать вызов фасада Cache</p><pre><code>use Illuminate\Support\Facades\Cache;
test('get index', function () {
  Cache::shouldReceive('get')
        ->once()
        ->with('key')
        ->andReturn('value');
  $response = $this->get('/users');
});</code></pre><p>шпионить за фасадом</p><pre><code>use Illuminate\Support\Facades\Cache;
test('values are be stored in cache', function () {
  Cache::spy();
  $response = $this->get('/');
  $response->assertStatus(200);
  Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);
});</code></pre><p>управлять текущим временем</p><pre><code>test('time can be manipulated', function () {
  // Travel into the future...
  $this->travel(5)->milliseconds();
  $this->travel(5)->seconds();
  $this->travel(5)->minutes();
  $this->travel(5)->hours();
  $this->travel(5)->days();
  $this->travel(5)->weeks();
  $this->travel(5)->years();
  // Travel into the past...
  $this->travel(-5)->hours();
  // Travel to an explicit time...
  $this->travelTo(now()->subHours(6));
  // Return back to the present time...
  $this->travelBack();
});
либо
$this->travel(5)->days(function () {
  // Test something five days into the future...
});
$this->travelTo(now()->subDays(10), function () {
  // Test something during a given moment...
});
либо
use Illuminate\Support\Carbon;
// Freeze time and resume normal time after executing closure...
$this->freezeTime(function (Carbon $time) { });
// Freeze time at the current second and resume normal time after executing closure...
$this->freezeSecond(function (Carbon $time) { })</code></pre><p>блокировка неактивных сообщений на форуме</p><pre><code>use App\Models\Thread;
test('forum threads lock after one week of inactivity', function () {
  $thread = Thread::factory()->create();
  $this->travel(1)->week();
  expect($thread->isLockedByInactivity())->toBeTrue();
});</code></pre><p>тесты браузера</p></details></details><details><summary>Application</summary><details><summary>Catalog namespace App</summary><p>- Broadcasting - классы широковещательных каналов<br>
- Console - пользовательские команды Artisan<br>
- Events - классы событий<br>
- Notifications - уведомления о событиях, которые происходят в приложении<br>
- Exceptions - классы исключений<br>
- Http - логика обработки поступающих запросов: классы контроллеров, middleware и запросов<br>
- Jobs - планировщики заданий<br>
- Listeners - обработчики событий<br>
- Controllers - логика обработки запросов<br>
- Middleware - фильтрация запросов<br>
- Mail - классы для работы с почтой<br>
- Models - классы моделей Eloquent для взаимодействия с таблицами базы данных<br>
- Policies - классы политик авторизации определяют возможные действия пользователя<br>
- Providers - классы поставщиков служб: таких как база данных, очереди, валидация и маршрутизация<br>
- Rules - классы правил валидации<br>
- Requests - правила валидации запроса<br>
- Resources - классы ресурсов API<br>
- Services - классы сервисов, которые реализуют бизнес-логику приложения<br>
- Traits - классы трейтов, которые могут быть использованы в других классах<br>
</p></details><details><summary>Routes</summary><p>- api.php - маршруты API<br>
- channels.php - маршруты широковещательной передачи<br>
- console.php - маршруты консоли<br>
- web.php - маршруты веб-приложения<br></p><p>маршрут это URI и поведение при запросе этого URI</p><pre><code>use Illuminate\Support\Facades\Route;
Route::get('/greeting', function () {
    return 'Hello World';
});</code></pre><p>маршруты для НТТР-методов</p><pre><code>Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);</code></pre><p>подмена метода формы</p><pre><code><form action="/example" method="POST">
    @method('PUT')
    @csrf
</form>

либо
<form action="/example" method="POST">
    <input type="hidden" name="_method" value="PUT">
    <input type="hidden" name="_token" value="{{ csrf_token() }}">
</form></code></pre><p>несколько методов на одном маршруте, указывать после маршрутов с методом (Route::get)</p><code>Route::match(['get', 'post'], '/', function () {});</code><p>все методы на одном маршруте, указывать после маршрутов с методом (Route::get)</p><code>Route::any('/', function () {});</code><p>перенаправить маршрут, третий параметр (301) необязательный</p><code>Route::redirect('/here', '/there', 301);</code><p>маршрут представления возвращает только НТМL-шаблон</p><code>Route::view('/welcome', 'welcome', ['name' => 'Taylor']);</code><p>список маршрутов</p><pre><code>php artisan route:list -v
php artisan route:list -vv
php artisan route:list --path=api
php artisan route:list --except-vendor
php artisan route:list --only-vendor</code></pre><p>настройка маршрутизации в bootstrap/app.php
параметры и зависимости маршрута</p><pre><code>use Illuminate\Http\Request;
Route::get('/posts/{post}/comments/{comment}', function (Request $request, string $postId, string $commentId) {});</code></pre><p>изменить ключ</p><pre><code>use App\Models\Post;
Route::get('/posts/{post:slug}', function (Post $post) {
    return $post;
});</code></pre><p>у необязательного параметра должно быть значение по умолчанию</p><pre><code>Route::get('/user/{name?}', function (?string $name = 'John') {
    return $name;
});</code></pre><p>формат маршрута в регулярном выражении</p><pre><code>Route::get('/user/{id}/{name}', function (string $id, string $name) {
    // ...
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);</code></pre><p>методы типовых шаблонов регулярных выражений</p><pre><code>whereNumber('id')
whereAlpha('name')
whereAlphaNumeric('name')
whereUuid('id')
whereUlid('id')
whereIn('category', ['movie', 'song', 'painting'])
whereIn('category', CategoryEnum::cases())</code></pre><p>глобальный шаблон в App\Providers\AppServiceProvider</p><pre><code>use Illuminate\Support\Facades\Route;
public function boot(): void
{
    Route::pattern('id', '[0-9]+');
}</code></pre><p>маршрут к методу контроллера</p><pre><code>use App\Http\Controllers\UserController;
Route::get('/user/{id}', [UserController::class, 'show']);</code></pre><p>маршрут для контроллера одиночного действия</p><pre><code>use App\Http\Controllers\ProvisionServer;
Route::post('/server', ProvisionServer::class);</code></pre><p>маршрут с middleware</p><code>Route::get('/profile', [UserController::class, 'show'])->middleware('auth');</code><p>с параметром для middleware</p><code>Route::put('/post/{id}', function (string $id) {})->middleware(EnsureUserHasRole::class.':editor,publisher');</code><p>маршрут ресурсного контроллера</p><code>Route::resource('photos', PhotoController::class);</code><p>редирект при отсутствии модели</p><pre><code>Route::resource('photos', PhotoController::class)
    ->missing(function (Request $request) {
        return Redirect::route('photos.index');
    });</code></pre><p>разрешить использовать программно удалённые модели</p><code>Route::resource('photos', PhotoController::class)->withTrashed();</code><p>выбор методов в ресурсном контроллере</p><pre><code>Route::resource('photos', PhotoController::class)->only([
    'index', 'show'
]);

Route::resource('photos', PhotoController::class)->except([
    'create', 'store', 'update', 'destroy'
]);</code></pre><p>при созданиии API-приложения без сохранения состояния создаём API-маршруты<br>
команда установит пакет Sanctum и создаст routes/api.php<br></p><code>php artisan install:api</code><p>ресурсные api-маршруты - маршруты без create и edit</p><code>Route::apiResource('photos', PhotoController::class);</code><p>маршрут к вложенному ресурсу</p><pre><code>Route::resource('photos.comments', PhotoCommentController::class);

создаст
/photos/{photo}/comments/{comment}</code></pre><p>при использовании уникальных идентификаторов, таких как автоинкрементные первичные ключи, для идентификации моделей в URI, использовать упрощенное вложение</p><pre><code>Route::resource('photos.comments', CommentController::class)->shallow();

создаст
/photos/{photo}/comments</code></pre><p>именование маршрутов</p><code>Route::get('/user/profile', [UserProfileController::class, 'show'])->name('profile');</code><p>именование ресурсных маршрутов</p><pre><code>Route::resource('photos', PhotoController::class)->names([
    'create' => 'photos.build'
]);</code></pre><p>именование параметров ресурсных маршрутов</p><pre><code>Route::resource('users', AdminUserController::class)->parameters([
    'users' => 'admin_user'
]);

создаст
/users/{admin_user}</code></pre><p>создание URL-адреса и перенаправление по именованному маршруту</p><pre><code>$url = route('profile');
return redirect()->route('profile');
return to_route('profile');</code></pre><p>именованный маршрут с параметроми</p><pre><code>Route::get('/user/{id}/profile', function (string $id) { })->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);</code></pre><p>проверка на был ли запрос на маршрут</p><cod>if ($request->route()->named('profile')) {}</cod><p>Ограничение ресурсных маршрутов - определяет дочерний вложенный ресурс и его поле, через которое он должен быть подключен</p><pre><code>Route::resource('photos.comments', PhotoCommentController::class)->scoped([
    'comment' => 'slug',
]);

создаст
/photos/{photo}/comments/{comment:slug}</code></pre><p>ресурсный маршрут должен быть последним</p><pre><code>Route::get('/photos/popular', [PhotoController::class, 'popular']);
Route::resource('photos', PhotoController::class);</code></pre><p>группировка маршрутов</p><pre><code>Route::middleware(['first', 'second'])->group(function () {
    Route::get('/', function () {}); // Использует middleware `first` и `second`
});

Route::controller(OrderController::class)->group(function () {
    Route::get('/orders/{id}', 'show');
    Route::post('/orders', 'store');
});

Route::prefix('admin')->group(function () {
    Route::get('/users', function () {}); // /admin/users
});

Route::name('admin')->group(function () {
    Route::get('/users', function () {})->name('users'); // admin.users
});</code></pre><p>маршруты поддоменов указывать перед маршрутами корневого домена</p><pre><code>Route::domain('{account}.example.com')->group(function () {
    Route::get('/user/{id}', function (string $account, string $id) {});
});</code></pre><p>посредник can для авторизации пользователя обновлять пост<br>
Первый параметр – имя действия, второй – параметр маршрута, передаваемый методу политики<br></p><pre><code>use App\Models\Post;

Route::put('/post/{post}', function (Post $post) {
    // Текущий пользователь может обновить пост...
})->middleware('can:update,post');

либо
use App\Models\Post;

Route::put('/post/{post}', function (Post $post) {
    // Текущий пользователь может обновить сообщение...
})->can('update', 'post');

либо
Route::post('/post', function () {
    // Текущий пользователь может создавать посты...
})->middleware('can:create,App\Models\Post');

либо
use App\Models\Post;

Route::post('/post', function () {
    // Текущий пользователь может создавать сообщения...
})->can('create', Post::class);</code></pre><p>привязка модели к маршруту<br></p><pre><code>use App\Models\User;

Route::get('/users/{user}', function (User $user) {
    return $user->email;
});

либо с контроллером
Route::get('/users/{user}', [UserController::class, 'show']);

use App\Http\Controllers\UserController;
use App\Models\User;

public function show(User $user)
{
    return view('user.profile', ['user' => $user]);
}</code></pre><p>привязка дочерней модели к родительской</p><pre><code>use App\Models\Post;
use App\Models\User;

Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
    return $post;
})->scopeBindings();

с группировкой
Route::scopeBindings()->group(function () {
    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
        return $post;
    });
});

не использовать области действия привязок
Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
    return $post;
})->withoutScopedBindings();</code></pre><p>связывание модели и URI в App\Providers\AppServiceProvider</p><pre><code>use App\Models\User;
use Illuminate\Support\Facades\Route;

public function boot(): void
{
    Route::model('user', User::class);
}

указать маршрут
Route::get('/users/{user}', function (User $user) {});</code></pre><p>поменять логику связывания модели и URI в App\Providers\AppServiceProvider</p><pre><code>use App\Models\User;
use Illuminate\Support\Facades\Route;

public function boot(): void
{
    Route::bind('user', function (string $value) {
        return User::where('name', $value)->firstOrFail();
    });
}</code></pre><p>ограничение частоты запросов</p><pre><code>use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;

protected function boot(): void
{
    RateLimiter::for('api', function (Request $request) {
        return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
    });
}

своё сообщение
RateLimiter::for('global', function (Request $request) {
    return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
        return response('Custom response...', 429, $headers);
    });
});

ограничение по статусу пользователя
RateLimiter::for('uploads', function (Request $request) {
    return $request->user()->vipCustomer()
                ? Limit::none()
                : Limit::perMinute(100);
});

отдельно по ip и id
RateLimiter::for('uploads', function (Request $request) {
    return $request->user()
                ? Limit::perMinute(100)->by($request->user()->id)
                : Limit::perMinute(10)->by($request->ip());
});

по маршрутам
Route::middleware(['throttle:uploads'])->group(function () {
    Route::post('/audio', function () {});

    Route::post('/video', function () {});
});</code></pre><p>вызывать маршруты только по названиям из Enums</p><pre><code>namespace App\Enums;

enum Category: string
{
    case Fruits = 'fruits';
    case People = 'people';
}

use App\Enums\Category;
use Illuminate\Support\Facades\Route;

Route::get('/categories/{category}', function (Category $category) {
    return $category->value;
});</code></pre><p>резевный маршрут, если запрос не соответствует ни одному маршруту</p><code>Route::fallback(function () {});</code><p>кешировать маршруты</p><code>php artisan route:cache</code><p>очистить кеш маршрутов</p><code>php artisan route:clear</code><p>перенаправление</p><pre><code>Route::get('/dashboard', function () {
    return redirect('/home/dashboard');
});

перенаправить обратно
Route::post('/user/profile', function () {
    return back()->withInput();
})->middleware('web');

на именованный маршрут
return redirect()->route('profile', ['id' => 1]);

на именованный маршрут с указанием модели
return redirect()->route('profile', [$user]);

на именованный маршрут с указанием столбца как ключа
return redirect()->route('/profile/{id:slug}', [$user]);

задать ключ маршрута в модели
public function getRouteKey(): mixed
{
    return $this->slug;
}

на метод контроллера
use App\Http\Controllers\UserController;

return redirect()->action([UserController::class, 'profile'], ['id' => 1]);

на внешний домен
return redirect()->away('https://www.google.com');

с записью в сессию своих данных
Route::post('/user/profile', function () {
    return redirect('/dashboard')->with('status', 'Profile updated!');
});

@if (session('status'))
    &lt;div class="alert alert-success"&gt;
        {{ session('status') }}
    &lt;/div&gt;
@endif

с записью в сессию данных ввода
return back()->withInput();

с HTML
return response()
            ->view('hello', $data, 200)
            ->header('Content-Type', $type);

с JSON
return response()
            ->json(['name' => 'Abigail', 'state' => 'CA'])
            ->withCallback($request->input('callback'));

заставить браузер пользователя загрузить файл
return response()->download($pathToFile, $name, $headers);

отображение файла в браузере без загрузки
return response()->file($pathToFile, $headers);
</code></pre></details><details><summary>Middleware</summary><p>посредники - это классы для проверки и фильтрации HTTP-запросов, HTTP-ответов, HTTP-заголовков, HTTP-тел, HTTP-методов<br>
создать посредник<br></p><pre><code>php artisan make:middleware MyMiddleware

либо указать путь к классу
php artisan make:middleware App\Http\Middleware\MyMiddleware

либо указать путь к классу и пространство имен
php artisan make:middleware App\Http\Middleware\MyMiddleware --namespace=App\Http\Middleware</code></pre><p>получает запрос, сравнивает значение токена из запроса и <br>
либо перенаправляет на домашнюю страницу,<br>
либо пропускает запрос дальше в приложение<br></p><pre><code>namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

выполняется до обработки запроса приложением
class MyMiddleware
{
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    if ($request->input('token') !== 'my-secret-token') {
      return redirect('/home');
    }
    return $next($request);
  }
}

выполняется после обработки запроса приложением
class MyMiddleware
{
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    return $next($request);
      // Выполнить действие
    return $response;
  }
}

с параметром
class EnsureUserHasRole
{
  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next, string $role): Response
  {
    if (! $request->user()->hasRole($role)) {}
    return $next($request);
  }
}</code></pre><p>глобальный стек посредников в файле bootstrap/app.php<br>
посредники web и api применяются к routes/web.php и routes/api.php<br>
управлять посредниками в bootstrap/app.php<br></p><pre><code>группировка
->withMiddleware(function (Middleware $middleware) {
  $middleware->appendToGroup('group-name', [
    First::class,
    Second::class,
  ]);
  $middleware->prependToGroup('group-name', [
    First::class,
    Second::class,
  ]);
})

добавить к группе
->withMiddleware(function (Middleware $middleware) {
    $middleware->web(append: [
        EnsureUserIsSubscribed::class,
    ]);

    $middleware->api(prepend: [
        EnsureTokenIsValid::class,
    ]);
})

заменить посредника в группе
$middleware->web(replace: [
    StartSession::class => StartCustomSession::class,
]);

удалить посредника в группе
$middleware->web(remove: [
    StartSession::class,
]);

псевдоним посредника
->withMiddleware(function (Middleware $middleware) {
    $middleware->alias([
        'subscribed' => EnsureUserIsSubscribed::class
    ]);
})

Route::get('/profile', function () {})->middleware('subscribed');</code></pre><p>защита маршрута</p><pre><code>Route::get('/flights', function () {
    // Только аутентифицированные пользователи могут получить доступ к этому маршруту...
})->middleware('auth');</code></pre><p>доступ только после подтверждения email</p><code>Route::get('/profile', function () {...})->middleware(['auth', 'verified']);</code><p>задать перенаправление пользователя в файле bootstrap/app.php</p><pre><code>middleware auth обнаружил неаутентифицированного пользователя
use Illuminate\Http\Request;

->withMiddleware(function (Middleware $middleware) {
    $middleware->redirectGuestsTo('/login');

    Используя замыкания
    $middleware->redirectGuestsTo(fn (Request $request) => route('login'));
})

middleware guest обнаружил аутентифицированного пользователя
use Illuminate\Http\Request;

->withMiddleware(function (Middleware $middleware) {
    $middleware->redirectUsersTo('/panel');

    Используя замыкание
    $middleware->redirectUsersTo(fn (Request $request) => route('panel'));
})</code></pre><p>указать какой guard из config/auth.php будет использоваться для аутентификации пользователя</p><pre><code>Route::get('/flights', function () {
    // Только аутентифицированные пользователи могут получить доступ к этому маршруту...
})->middleware('auth:admin');</code></pre><p>метод share может возвращать общие данные для всех страниц Inertia</p><pre><code>namespace App\Http\Middleware;

use App\Models\Post;
use Illuminate\Http\Request;
use Inertia\Middleware;

class HandleInertiaRequests extends Middleware
{
    // ...

    /**
    * Определяем реквизиты, которые используются по умолчанию.
    *
    * @return array<string, mixed>
    */
    public function share(Request $request)
    {
        return [
            ...parent::share($request),
            'auth' => [
                'user' => $request->user(),
                'permissions' => [
                    'post' => [
                        'create' => $request->user()->can('create', Post::class),
                    ],
                ],
            ],
        ];
    }
}
</code></pre></details><details><summary>Controllers</summary><p>контроллеры - это классы, которые обрабатывают HTTP-запросы и возвращают HTTP-ответы, представления, JSON, файлы, редиректы<br>
app/Http/Controllers - каталог контроллеров<br></p><code>php artisan make:controller UserController - создать контроллер</code><p>создать контроллер одиночного действия</p><code>php artisan make:controller ProvisionServer --invokable</code><p>with(['employer', 'tags']) чтобы избежать проблему n+1</p><pre><code>public function __invoke()
{
  $jobs = Job::query()
    ->with(['employer', 'tags'])
    ->where('title', 'LIKE', '%'.request('q').'%')
    ->get();
  return view('results', ['jobs' => $jobs]);
}</code></pre><p>указать middleware в контроллере</p><pre><code>class UserController extends Controller implements HasMiddleware
{
    public static function middleware(): array
    {
        return [
            'auth',
            new Middleware('log', only: ['index']),
            new Middleware('subscribed', except: ['store']),
        ];
    }
}</code></pre><p>реализовать middleware в контроллере</p><pre><code>public static function middleware(): array
{
    return [
        function (Request $request, Closure $next) {
            return $next($request);
        },
    ];
}</code></pre><table><caption>Methods</caption><thead><tr><th>Controller Method </th><th>Action</th></tr></thead><tbody><tr><td>index</td><td>view all</td></tr><tr><td>show</td><td>view one</td></tr><tr><td>create</td><td>show form for create</td></tr><tr><td>store</td><td>create</td></tr><tr><td>edit</td><td>show form for edit</td></tr><tr><td>update</td><td>update</td></tr><tr><td>destroy</td><td>delete</td></tr></tbody></table><p>создать ресурсный контроллер</p><pre><code>php artisan make:controller PhotoController --resource
либо
php artisan make:controller PhotoController -r
</code></pre><p>создать ресурсный контроллер с привязкой к моделе и валидацией</p><code>php artisan make:controller PhotoController --model=Photo --resource --requests</code><p>ресурсный api-контроллер - ресурсный контроллер без create и edit</p><code>php artisan make:controller PhotoController --api</code><p>зависимости в контроллер внедряем либо через конструктор,</p><pre><code>namespace App\Http\Controllers;

use App\Repositories\UserRepository;

class UserController extends Controller
{
    /**
    * Создать новый экземпляр контроллера.
    */
    public function __construct(
        protected UserRepository $users,
    ) {}
}

либо через параметры функции
namespace App\Http\Controllers;

use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
    * Сохранить нового пользователя.
    */
    public function store(Request $request): RedirectResponse
    {
        $name = $request->name;
        return redirect('/users');
    }
}</code></pre><p>получить параметр из маршрута</p><pre><code>маршрут
use App\Http\Controllers\UserController;
Route::put('/user/{id}', [UserController::class, 'update']);

контроллер
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class UserController extends Controller
{
    /**
    * Обновить конкретного пользователя.
    */
    public function update(Request $request, string $id): RedirectResponse
    {
        // Обновление пользователя...
        return redirect('/users');
    }
}
</code></pre></details><details><summary>Authentication</summary><p>- Аутентификация - процесс проверки подлинности пользователя, чтобы убедиться, что он тот, за кого себя выдает<br>
- конфигурация в config/auth.php<br>
- информацию об аутентифицированном пользователе хранится в сессии пользователя<br>
- файл cookie, отправленный браузеру, содержит идентификатор сессии, чтобы последующие запросы к приложению могли связать пользователя с правильной сессией<br>
- при каждом запросе к API удаленная служба отправляет API-токен, приложение проверяет входящий токен по таблице допустимых API-токенов и «аутентифицирует» запрос как выполняемый пользователем, связанным с этим API-токеном<br>
- библиотеки Passport и Sanctum ориентированы на аутентификацию токена API, встроенные службы аутентификации ориентированы на web-аутентификацию на основе файлов cookie<br>
- Passport – надежный и сложный пакет для аутентификации API, когда нужен весь функционал OAuth2<br>
- Sanctum –  простое и полное решение для аутентификации API, аутентификации SPA и мобильной аутентификации, включая поддержку «scopes» или «abilities»<br>
- Fortify - серверная служба аутентификации<br>
- встроенные службы аутентификации Laravel для запросов из веб-браузеров и доступны через фасады Auth и Session<br></p><pre><code>use Illuminate\Support\Facades\Auth;

// Получить текущего аутентифицированного пользователя ...
$user = Auth::user();

// Получить текущего аутентифицированного пользователя по идентификатору ...
$id = Auth::id();

// Получить текущего аутентифицированного пользователя из запроса
namespace App\Http\Controllers;

use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class FlightController extends Controller
{
    /**
    * Обновить информацию о рейсе.
    */
    public function update(Request $request): RedirectResponse
    {
        $user = $request->user();

        // ...

        return redirect('/flights');
    }
}</code></pre><p>статус аутентификации пользователя</p><pre><code>use Illuminate\Support\Facades\Auth;

if (Auth::check()) {
    // Пользователь вошел в систему...
}</code></pre><p>- в массиве guards файла config/auth.php указываются "охранники" для аутентификации пользователя<br>
- собственная аутентификации пользователей<br></p><pre><code>namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;

class LoginController extends Controller
{
    /**
    * Обработка попыток аутентификации.
    */
    public function authenticate(Request $request): RedirectResponse
    {
        $credentials = $request->validate([
            'email' => ['required', 'email'],
            'password' => ['required'],
        ]);

        if (Auth::attempt($credentials)) {
            $request->session()->regenerate();

            return redirect()->intended('dashboard');
        }

        return back()->withErrors([
            'email' => 'Предоставленные учетные данные не соответствуют нашим записям.',
        ])->onlyInput('email');
    }
}

// Дополнительные условия аутентификации
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
    // Аутентификация прошла успешно...
}

либо
use Illuminate\Database\Eloquent\Builder;

if (Auth::attempt([
    'email' => $email,
    'password' => $password,
    fn (Builder $query) => $query->has('activeSubscription'),
])) {
    // Аутентификация прошла успешно...
}

либо
if (Auth::attemptWhen([
    'email' => $email,
    'password' => $password,
], function (User $user) {
    return $user->isNotBanned();
})) {
    // Аутентификация прошла успешно...
}

// С указанием guard из config/auth.php
if (Auth::guard('admin')->attempt($credentials)) {}</code></pre><p>"запомнить меня" - поддерживать аутентификацию пользователя пока он не выйдет из системы вручную, в таблице users должен быть столбец remember_token</p><pre><code>use Illuminate\Support\Facades\Auth;

if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
    // Запоминаем пользователя...
}</code></pre><p>проверить было ли "запомнить меня"</p><pre><code>use Illuminate\Support\Facades\Auth;

if (Auth::viaRemember()) {}</code></pre><p>сразу после того, как пользователь регистрируется, можно пеередать экземпляр пользователя для аутентификации</p><pre><code>use Illuminate\Support\Facades\Auth;

Auth::login($user);

с "запомнить меня"
Auth::login($user, $remember = true);

с указанием guard
Auth::guard('admin')->login($user);</code></pre><p>аутентификация по id</p><pre><code>Auth::loginUsingId(1);

с "запомнить меня"
Auth::loginUsingId(1, remember: true);</code></pre><p>аутентификации пользователя только для одного запроса без сессии и cookie</p><code>if (Auth::once($credentials)) {}</code><p>встроенный способ аутентификации без страницы входа HTTP Basic</p><pre><code>Route::get('/profile', function () {
    // Только аутентифицированные пользователи могут получить доступ к этому маршруту...
})->middleware('auth.basic');</code></pre><p>для HTTP Basic и PHP FastCGI в .htaccess добавить</p><pre><code>RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]</code></pre><p>Basic HTTP-аутентификация без cookie</p><pre><code>namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;

class AuthenticateOnceWithBasicAuth
{
    /**
    * Обработка входящего запроса.
    *
    * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
    */
    public function handle(Request $request, Closure $next): Response
    {
        return Auth::onceBasic() ?: $next($request);
    }

}

далее
Route::get('/api/user', function () {
    // Только аутентифицированные пользователи могут получить доступ к этому маршруту...
})->middleware(AuthenticateOnceWithBasicAuth::class);</code></pre><p>- выход пользователя<br>
- удалить информацию аутентификации из сессии пользователя, аннулировать сессию пользователя и повторно сгенерировать его токен CSRF<br></p><pre><code>use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;

/**
* Выход пользователя из приложения.
*/
public function logout(Request $request): RedirectResponse
{
    Auth::logout();

    $request->session()->invalidate();

    $request->session()->regenerateToken();

    return redirect('/');
}</code></pre><p>аннулировать сессии на других устройствах, без аннулирования сессии на текущем устройстве</p><pre><code>в маршруте
Route::middleware(['auth', 'auth.session'])->group(function () {
    Route::get('/', function () {
        // ...
    });
});

в контроллере
use Illuminate\Support\Facades\Auth;

Auth::logoutOtherDevices($currentPassword);</code></pre><p>настроить время, через которое нужно повторно ввести пароль: password_timeout в config/auth.php</p><pre><code>форма подтверждения пароля
Route::get('/confirm-password', function () {
    return view('auth.confirm-password');
})->middleware('auth')->name('password.confirm');

далее
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Redirect;

Route::post('/confirm-password', function (Request $request) {
    if (! Hash::check($request->password, $request->user()->password)) {
        return back()->withErrors([
            'password' => ['Предоставленный пароль не соответствует нашим записям.']
        ]);
    }

    $request->session()->passwordConfirmed();

    return redirect()->intended();
})->middleware(['auth', 'throttle:6,1']);

далее
Route::get('/settings', function () {
    // ...
})->middleware(['password.confirm']);

Route::post('/settings', function () {
    // ...
})->middleware(['password.confirm']);</code></pre><p>добавить свой guard</p><pre><code>// в App\Providers\AppServiceProvider
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

/**
* Загрузка любых служб приложения.
*/
public function boot(): void
{
    Auth::viaRequest('custom-token', function (Request $request) {
        return User::where('token', (string) $request->token)->first();
    });
}

// в config/auth.php
'guards' => [
    'api' => [
        'driver' => 'jwt',
        'provider' => 'users',
    ],
],

либо
// в App\Providers\AppServiceProvider
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

/**
* Загрузка любых служб приложения.
*/
public function boot(): void
{
    Auth::viaRequest('custom-token', function (Request $request) {
        return User::where('token', (string) $request->token)->first();
    });
}

// в config/auth.php
'guards' => [
    'api' => [
        'driver' => 'custom-token',
    ],
],

// в маршруте
Route::middleware('auth:api')->group(function () {});</code></pre><p>собственный провайдер аутентификации пользователей для нереляционной базы данных</p><pre><code>в App\Providers\AppServiceProvider
namespace App\Providers;

use App\Extensions\MongoUserProvider;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    // ...

    /**
    * Загрузка любых служб приложения.
    */
    public function boot(): void
    {
        Auth::provider('mongo', function (Application $app, array $config) {
            // Возвращаем экземпляр Illuminate\Contracts\Auth\UserProvider...

            return new MongoUserProvider($app->make('mongo.connection'));
        });
    }
}

в config/auth.php
'providers' => [
    'users' => [
        'driver' => 'mongo',
    ],
],

'guards' => [
    'web' => [
        'driver' => 'session',
        'provider' => 'users',
    ],
],</code></pre><p>- Laravel автоматически перехеширует пароли пользователей при аутентификации<br>
- настроить сложность хеширования в config/hashing.php или в BCRYPT_ROUNDS из .env<br></p><pre><code>опубликовать config/hashing.php
php artisan config:publish hashing

отключить автоматическое хеширование
'rehash_on_login' => false,
</code></pre><details> <summary>Email verification</summary><p>автоматическая отправка электронного письма со ссылкой для подтверждения</p><pre><code>namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    use Notifiable;
}</code></pre><p>при регистрации пользователя вручную</p><pre><code>use Illuminate\Auth\Events\Registered;
event(new Registered($user));</code></pre><p>- в таблице users миграции 0001_01_01_000000_create_users_table.php столбец столбец email_verified_at для даты и времени подтверждения email<br>
- Чтобы правильно реализовать подтверждение электронной почты, необходимо определить три маршрута:<br>
- отображения пользователю уведомления об отправке ссылки подтверждения<br></p><pre><code>Route::get('/email/verify', function () {
    return view('auth.verify-email');
})->middleware('auth')->name('verification.notice');</code></pre><p>обработки запроса при нажатии на ссылку подтверждения</p><pre><code>use Illuminate\Foundation\Auth\EmailVerificationRequest;

Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
    $request->fulfill();

    return redirect('/home');
})->middleware(['auth', 'signed'])->name('verification.verify');</code></pre><p>повторная отправка ссылки подтверждения</p><pre><code>use Illuminate\Http\Request;

Route::post('/email/verification-notification', function (Request $request) {
    $request->user()->sendEmailVerificationNotification();

  return back()->with('message', 'Verification link sent!');
})->middleware(['auth', 'throttle:6,1'])->name('verification.send');</code></pre><p>изменить сообщение о подтверждении в App\Providers\AppServiceProvider</p><pre><code>use Illuminate\Auth\Notifications\VerifyEmail;
use Illuminate\Notifications\Messages\MailMessage;

public function boot(): void
{
    VerifyEmail::toMailUsing(function (object $notifiable, string $url) {
        return (new MailMessage)
            ->subject('Verify Email Address')
            ->line('Click the button below to verify your email address.')
            ->action('Verify Email Address', $url);
    });
}
</code></pre></details><details> <summary>Fortify</summary><p>установить Fortify<br></p><code>./sail composer require laravel/fortify<br></code><p>создать папки и роуты Fortify<br></p><code>./sail artisan fortify:install<br></code><p>обновить БД<br></p><code>./sail artisan migrate<br></code></details></details><details><summary>Session</summary><p>сессия - это способ хранения данных между запросами в виде массива, JSON и отдельных переменных в файлах, базе данных, кэше или в памяти<br>
по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
драйверы кеша и базы данных могут быть использованы для хранения данных сессии<br></p><pre><code>php artisan session:table
php artisan migrate</code></pre><p>по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
драйверы кеша и базы данных могут быть использованы для хранения данных сессии<br></p><pre><code>php artisan session:table
php artisan migrate</code></pre><p>настройка хранения сессии в config/session.php<br>
file – сессии хранятся в storage/framework/sessions.<br>
cookie – сессии хранятся в безопасных, зашифрованных файлах Cookies.<br>
database – сессии хранятся в реляционной базе данных.<br>
memcached / redis – сессии хранятся в одном из этих быстрых хранилищ на основе кеша.<br>
dynamodb – сессии хранятся в AWS DynamoDB.<br>
array – сессии хранятся в массиве PHP и не будет сохранены.<br>
по умолчанию database, данные сессии в таблице sessions в 0001_01_01_000000_create_users_table.php<br>
получить данные из сессии<br></p><pre><code>через экземпляр Request
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\View\View;

class UserController extends Controller
{
  public function show(Request $request, string $id): View
  {
    $value = $request->session()->get('key', 'default');
    $user = $this->users->find($id);
    return view('user.profile', ['user' => $user]);
  }
}

через глобальный помощник session
Route::get('/home', function () {
  // Получить часть данных из сессии...
  $value = session('key');
  // Получить часть данных из сессии с указанием значения по умолчанию...
  $value = session('key', 'default');
  // Сохранить часть данных в сессию...
  session(['key' => 'value']);
});

получить все данные сессии
$data = $request->session()->all();

получить часть данных сессии
$data = $request->session()->only(['username', 'email']);
$data = $request->session()->except(['username', 'email']);

получает и удаляет элемент из сессии
$value = $request->session()->pull('key', 'default');

наличие элемента в сессии не равного null
if ($request->session()->has('users')) {}

наличие элемента в сессии в т.ч. null
if ($request->session()->exists('users')) {}

элемент в сессии либо null, либо отсутствует
if ($request->session()->missing('users')) {}</code></pre><p>сохранить данные в сессию</p><pre><code>через экземпляр запроса...
$request->session()->put('key', 'value');

через глобальный помощник «session»...
session(['key' => 'value']);

вставка нового значения в значение сессии, которое является массивом
$request->session()->push('user.teams', 'developers');

увеличение и уменьшение целочисленных значений в сессии
$request->session()->increment('count');
$request->session()->increment('count', $incrementBy = 2);
$request->session()->decrement('count');
$request->session()->decrement('count', $decrementBy = 2);

сохранить элементы в сессии только для текущего запроса
$request->session()->now('status', 'Задача выполнена успешно!');

сохранить элементы в сессии только для следующего запроса
после следующего запроса данные будут удалены
$request->session()->flash('status', 'Задача выполнена успешно!');

для нескольких запросов одновременно, потом удаление
$request->session()->reflash();

сохранить отдельные данные для следующего запроса
$request->session()->keep(['username', 'email']);</code></pre><p>удалить все данные из сессии</p><pre><code>удалить единственный ключ...
$request->session()->forget('name');

удалить несколько ключей...
$request->session()->forget(['name', 'status']);

$request->session()->flush();</code></pre><p>идентификатор сессии</p><pre><code>повторно сгенерировать
$request->session()->regenerate();

повторно сгенерировать идентификатор сессии и удалить все данные из нее
$request->session()->invalidate();</code></pre><p>блокировка сессии</p><pre><code>Route::post('/profile', function () {})->block($lockSeconds = 10, $waitSeconds = 10);
Route::post('/order', function () {})->block($lockSeconds = 10, $waitSeconds = 10);

по умолчанию блокировка 10 сек и ожидание получения блокировки 10 сек
Route::post('/profile', function () {})->block();
</code></pre></details><details><summary>CSRF</summary><p>- CSRF - это атака, при которой злоумышленник отправляет запрос от имени пользователя без его ведома<br>
- Laravel использует токены CSRF для защиты от атак CSRF<br>
- токены CSRF хранятся в сессии пользователя и проверяются при каждом запросе<br>
- токены CSRF могут быть использованы только для POST, PUT, PATCH и DELETE запросов<br></p><p>токен CSRF хранится в сессии пользователя и изменяется каждый раз при повторном создании сессии<br>
токен CSRF хранится в сессии пользователя и проверяется при каждом запросе<br>
получить доступ к токену CSRF в контроллере или маршруте<br></p><pre><code>use Illuminate\Http\Request;

Route::get('/token', function (Request $request) {
    $token = $request->session()->token();

либо
    $token = csrf_token();
});</code></pre><p>в каждой форме с методом «POST», «PUT», «PATCH» или «DELETE» должен быть токен</p><pre><code>&lt;form method="POST" action="/profile"&gt;
    @csrf

либо
    &lt;input type="hidden" name="_token" value="{{ csrf_token() }}" /&gt;
&lt;/form&gt;</code></pre><p>исключить маршруты из проверки токена в файле bootstrap/app.php</p><pre><code>->withMiddleware(function (Middleware $middleware) {
    $middleware->validateCsrfTokens(except: [
        'stripe/*',
        'http://example.com/foo/bar',
        'http://example.com/foo/*',
    ]);
})</code></pre><p>добавить токен в HTML-заголовок X-CSRF-TOKEN</p><code>&lt;meta name="csrf-token" content="{{ csrf_token() }}"&gt;</code><p>добавить токен в заголовок X-XSRF-TOKEN</p><code>&lt;meta name="x-xsrf-token" content="{{ csrf_token() }}"&gt;</code><p>По умолчанию файл resources/js/bootstrap.js включает HTTP-библиотеку Axios, которая автоматически отправляет заголовок X-XSRF-TOKEN.</p></details><details><summary>Autherization</summary><p>авторизация - это процесс проверки прав доступа пользователя, основаная на политике и шлюзах, может быть выполнена с помощью:<br>
- middleware, контроллеров, моделей и шаблонов<br>
- фасадов, классов и функций<br>
- политик и шлюзов, могут быть определёны в любом месте приложения и использоваться вместе<br>
</p><details><summary>Gates</summary><p>шлюз - это функция проверки прав пользователя на действия без использования модели или ресурса, например просмотр панели управления администратора.<br></p><pre><code>App\Providers\AppServiceProvider.php
use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\Gate;

- может ли пользователь обновить модель
public function boot(): void
{
    Gate::define('update-post', function (User $user, Post $post) {
        return $user->id === $post->user_id;
    });
}

либо
use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;

public function boot(): void
{
    Gate::define('update-post', [PostPolicy::class, 'update']);
}</code></pre><p>Gate - объявляется в App\Providers\AppServiceProvider методом boot(),<br>
исспользуется для простых ограничений ролей.<br>
Аргументом всегда принимает пользоватля, к которому применяет ограничения.<br>
Дополнительные аргументы по необходимости.</p><pre><code>use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\Gate;

public function boot(): void
{
  Gate::define('update-post', function (User $user, Post $post) {
    return $user->id === $post->user_id;
  });
}</code></pre><p>Gate::define - объявляю Gate,<br>
'update-post' - название возможности предоставляемой пользователю<br>
function (User $user, Post $post) - вернёт true/false,<br>
true - этому пользователю можно пользоваться этой возможностью<br>
false - этому пользователю нельзя пользоваться этой возможностью<br>
<br>
Можно вынести логику в отдельный класс (политику)</p><pre><code>use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;

public function boot(): void
{
  Gate::define('update-post', [PostPolicy::class, 'update']);
}</code></pre><p>После этого в любом контроллере можем проверять роль конкрено указав пользователя</p><pre><code>if (Gate::forUser($user)->allows('update-post', $post)) {}
if (Gate::forUser($user)->denies('update-post', $post)) {}</code></pre><p>allows - разрешено ли<br>
denies - запрещено ли<br>
<br>
Проверять роль текущего пользователя с кастомным условием</p><pre><code>if (! Gate::allows('update-post', $post)) {
  abort(403);
}
if (Gate::denies('update-post', $post)) {
  abort(403);
}</code></pre><p>Проверять роль текущего пользователя встроенным методом</p><pre><code>Gate::authorize('update-post', $post);</code></pre><p>Проверить несколько возможностей</p><pre><code>if (Gate::any(['update-post', 'delete-post'], $post)) {
  // The user can update or delete the post...
}

if (Gate::none(['update-post', 'delete-post'], $post)) {
  // The user can't update or delete the post...
}</code></pre><p>В контроллере гейт может обратиться к политике.<br>
Первый параметр это название политики,<br>
второй - либо объект модели, если есть, либо класс модели</p><pre><code>Gate::authorize('update', $post);
<span>or</span>
Gate::authorize('update', App\Models\Post::class);</code></pre><p>Авторизация действий через шлюзы</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;

class PostController extends Controller
{
    /**
    * Обновить переданный пост.
    */
    public function update(Request $request, Post $post): RedirectResponse
    {
        if (! Gate::allows('update-post', $post)) {
            abort(403);
        }
        // Обновление поста...
        return redirect('/posts');
    }
}</code></pre><p>авторизован ли пользователь для выполнения действия (не аутентифицированный в настоящий момент)</p><pre><code>if (Gate::forUser($user)->allows('update-post', $post)) {
    // Пользователь может обновить пост...
}

if (Gate::forUser($user)->denies('update-post', $post)) {
    // Пользователь не может обновить пост...
}</code></pre><p>определить авторизацию нескольких действий одновременно</p><pre><code>if (Gate::any(['update-post', 'delete-post'], $post)) {
    // Пользователь может обновить или удалить пост...
}

if (Gate::none(['update-post', 'delete-post'], $post)) {
    // Пользователь не может обновить или удалить пост...
}</code></pre><p>метод authorize принимает действие и модель. Если действие не авторизовано, то выбросит исключение</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;

class PostController extends Controller
{
    /**
    * Обновить переданный пост.
    *
    * @throws \Illuminate\Auth\Access\AuthorizationException
    */
    public function update(Request $request, Post $post): RedirectResponse
    {
        Gate::authorize('update', $post);

        // Текущий пользователь может обновить пост в блоге...

        return redirect('/posts');
    }
}</code></pre><p>Имя класса определяет какую политику использовать при авторизации</p><pre><code>use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;

/**
* Создайте новый пост в блоге.
*
* @throws \Illuminate\Auth\Access\AuthorizationException
*/
public function create(Request $request): RedirectResponse
{
    Gate::authorize('create', Post::class);
    // Текущий пользователь может создавать посты в блоге...
    return redirect('/posts');
}</code></pre><p>- Методы шлюза для авторизации полномочий: allows, denies, check, any, none, authorize, can, cannot
- Директивы авторизации Blade: @can, @cannot, @canany
- Дополнительный контекст при принятии решений об авторизации</p><pre><code>use App\Models\Category;
use App\Models\User;
use Illuminate\Support\Facades\Gate;

Gate::define('create-post', function (User $user, Category $category, bool $pinned) {
    if (! $user->canPublishToGroup($category->group)) {
        return false;
    } elseif ($pinned && ! $user->canPinPosts()) {
        return false;
    }

    return true;
});

- [$category, $pinned] - дополнительный контекст для check
if (Gate::check('create-post', [$category, $pinned])) {
    // Пользователь может создать пост...
}</code></pre><p>ответ шлюза</p><pre><code>use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;

Gate::define('edit-settings', function (User $user) {
    return $user->isAdmin
                ? Response::allow()
                : Response::deny('Вы должны быть администратором.');
});</code></pre><p>получить полный возвращенный шлюзом ответ</p><pre><code>$response = Gate::inspect('edit-settings');

if ($response->allowed()) {
    // Действие разрешено...
} else {
    echo $response->message();
}</code></pre><p>настроить код статуса HTTP-ответа вручную</p><pre><code>use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;

Gate::define('edit-settings', function (User $user) {
    return $user->isAdmin
                ? Response::allow()
                : Response::denyWithStatus(404);
});</code></pre><p>ответ 404</p><pre><code>use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;

Gate::define('edit-settings', function (User $user) {
    return $user->isAdmin
                ? Response::allow()
                : Response::denyAsNotFound();
});</code></pre><p>before выполняется перед всеми другими проверками авторизации</p><pre><code>use App\Models\User;
use Illuminate\Support\Facades\Gate;

Gate::before(function (User $user, string $ability) {
    if ($user->isAdministrator()) {
        return true;
    }
});</code></pre><p>after выполненяется после всех других проверок авторизации</p><pre><code>use App\Models\User;

Gate::after(function (User $user, string $ability, bool|null $result, mixed $arguments) {
    if ($user->isAdministrator()) {
        return true;
    }
});</code></pre><p>встроенные провероки авторизации</p><pre><code>use App\Models\User;
use Illuminate\Support\Facades\Gate;

Gate::allowIf(fn (User $user) => $user->isAdministrator());

Gate::denyIf(fn (User $user) => $user->banned());
</code></pre></details><details><summary>Policies</summary><p>политики - это классы с логикой авторизации пользователя на действия с конкретной моделью или ресурсом.</p><pre><code>- создать политику с привязкой к модели
php artisan make:policy PostPolicy --model=Post</code></pre><p>Политика всегда относится к какой-то модели.<br>
Создать политику можно при создании модели либо отдельно.<br>
По конвенции название политики содержит название модели.</p><code>php artisan make:policy PostPolicy</code><p>Создать политику с методами для модели Post</p><code>php artisan make:policy PostPolicy --model=Post</code><p>Назвать политику можно не по конвенции,<br>
но тогда её нужно зарегистрировать в<br>
App\Providers\AppServiceProvider методом boot()</p><pre><code>use App\Models\ModelName;
use App\Policies\PolicyName;
use Illuminate\Support\Facades\Gate;

public function boot(): void
{
    Gate::policy(ModelName::class, PolicyName::class);
}</code></pre><table><caption>Methods</caption><thead><tr><th>Policy Method </th><th>Action</th></tr></thead><tbody><tr><td>viewAny</td><td>view all</td></tr><tr><td>view</td><td>view one</td></tr><tr><td>create</td><td>create & store</td></tr><tr><td>update</td><td>edit</td></tr><tr><td>delete</td><td>mark as delete</td></tr><tr><td>restore</td><td>unmark as delete</td></tr><tr><td>forceDelete</td><td>permanently delete</td></tr></tbody></table><p>- Laravel проверит наличие политик в app/Models/Policies, а затем в app/Policies.
- Имя политики должно совпадать с названием модели и иметь суффикс Policy.
- Регистрация политик вручную в в App\Providers\AppServiceProvider</p><pre><code>- своё имя
use Illuminate\Support\Facades\Gate;

Gate::guessPolicyNamesUsing(function (string $modelClass) {
    // Возвращаем имя класса политики для данной модели...
});

- регистрация
use App\Models\Order;
use App\Policies\OrderPolicy;
use Illuminate\Support\Facades\Gate;

public function boot(): void
{
    Gate::policy(Order::class, OrderPolicy::class);
}</code></pre><p>проверить совпадает ли id пользователя с user_id поста</p><pre><code>namespace App\Policies;
use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
    * Определить, может ли пользователь обновить пост.
    */
    public function update(User $user, Post $post): bool
    {
        return $user->id === $post->user_id;
    }
}</code></pre><p>вернуть более подробный ответ</p><pre><code>use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;

/**
* Определить, может ли пользователь обновить пост.
*/
public function update(User $user, Post $post): Response
{
    return $user->id === $post->user_id
                ? Response::allow()
                : Response::deny('You do not own this post.');
}</code></pre><p>настроить HTTP-ответ</p><pre><code>use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;

/**
* Определяет, может ли данный пользователь обновить указанный пост.
*/
public function update(User $user, Post $post): Response
{
    return $user->id === $post->user_id
                ? Response::allow()
                : Response::denyWithStatus(404);
}</code></pre><p>ответ 404</p><pre><code>use App\Models\Post;
use App\Models\User;
use Illuminate\Auth\Access\Response;

/**
* Определяет, может ли данный пользователь обновить указанный пост.
*/
public function update(User $user, Post $post): Response
{
    return $user->id === $post->user_id
                ? Response::allow()
                : Response::denyAsNotFound();
}</code></pre><p>имеет ли пользователь право создавать посты</p><pre><code>public function create(User $user): bool
{
    return $user->role == 'writer';
}</code></pre><p>- разрешить прохождение проверок авторизации для не аутентифицированных пользователей:<br>
- значение $user может быть как объявленного типа User, так и быть равным null<br></p><pre><code>namespace App\Policies;
use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
    * Определить, может ли пользователь обновить пост.
    */
    public function update(?User $user, Post $post): bool
    {
        return $user?->id === $post->user_id;
    }
}</code></pre><p>before будет выполнен перед любыми другими методами в политике</p><pre><code>use App\Models\User;

/**
* Выполнить предварительную авторизацию.
*/
public function before(User $user, string $ability): bool|null
{
    if ($user->isAdministrator()) {
        return true;
    }

    return null;
}</code></pre><p>- модель App\Models\User включает два метода авторизации: can и cannot<br>
- если для модели зарегистрирована политика, то can вызовет политику,<br>
- если нет политики, то can вызовет шлюз<br></p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PostController extends Controller
{
    public function update(Request $request, Post $post): RedirectResponse
    {
        if ($request->user()->cannot('update', $post)) {
            abort(403);
        }
        // Обновление поста...
        return redirect('/posts');
    }
}</code></pre><p>Имя класса определяет какую политику использовать при авторизации</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PostController extends Controller
{
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->cannot('create', Post::class)) {
            abort(403);
        }
        // Сохранение поста...
        return redirect('/posts');
    }
}</code></pre><p>в политике можно передать методу дополнительный контекст в массиве</p><pre><code>- в App\Policies\PostPolicy
/**
* Определить, может ли пользователь обновить пост.
*/
public function update(User $user, Post $post, int $category): bool
{
    return $user->id === $post->user_id &&
          $user->canUpdateCategory($category);
}

- с контекстом
/**
* Обновить пост.
*
* @throws \Illuminate\Auth\Access\AuthorizationException
*/
public function update(Request $request, Post $post): RedirectResponse
{
    Gate::authorize('update', [$post, $request->category]);
    // Текущий пользователь может обновить пост в блоге...
    return redirect('/posts');
}
</code></pre></details></details><details><summary>Requests</summary><p>- запросы позволяют создавать правила валидации, авторизации и преобразования данных в контроллерах, маршрутах и сервисах<br>
- создать запрос</p><code>php artisan make:request StoreUserRequest</code><p>создать запрос с правилами валидации</p><code>php artisan make:request StoreUserRequest --rules=store</code><p>запрос - это объект класса Illuminate\Http\Request<br>
доступ к запросу<br></p><pre><code>use Illuminate\Http\Request;

Route::get('/', function (Request $request) {});

либо
namespace App\Http\Controllers;

use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class UserController extends Controller
{
    public function store(Request $request): RedirectResponse
    {
        $name = $request->input('name');
        return redirect('/users');
    }
}</code></pre><p>путь запроса</p><pre><code>$uri = $request->path();  // путь запроса
if ($request->is('admin/*')) {}  // соответствие пути запроса шаблону
if ($request->routeIs('admin.*')) {}  // соответствие пути запроса именованному маршруту

получить полный URL для входящего запроса
$url = $request->url();
либо
$urlWithQueryString = $request->fullUrl();</code></pre><p>добавить строку запроса в массив переменных строки запроса</p><code>$request->fullUrlWithQuery(['type' => 'phone']);</code><p>получить строку запроса без указанного параметра</p><code>$request->fullUrlWithoutQuery(['type']);</code><p>получить host входящего запроса</p><pre><code>$request->host();
$request->httpHost();
$request->schemeAndHttpHost();</code></pre><p>получить метод запроса и проверить</p><pre><code>$method = $request->method();
if ($request->isMethod('post')) {}</code></pre><p>получить заголовок запроса</p><pre><code>второй параметр не обязательный
$value = $request->header('X-Header-Name', 'default');</code></pre><p>проверить наличие заголовка</p><code>if ($request->hasHeader('X-Header-Name')) {}</code><p>получить токен из заголовка Authorization</p><code>$token = $request->bearerToken();</code><p>получить ip-адрес клиента, который сделал запрос</p><pre><code>$ipAddress = $request->ip();

все ip-адреса с перенаправлением и прокси
$ipAddresses = $request->ips();</code></pre><p>тип контента, который запрашивает клиентт в заголовке Accept<br>
получить массив типов контента, принятые запросом</p><code>$contentTypes = $request->getAcceptableContentTypes();</code><p>true если один из типов контента принят запросом, иначе false</p><code>if ($request->accepts(['text/html', 'application/json'])) {}</code><p>указать предпочитаемый для запроса тип контента из массива</p><code>$preferred = $request->prefers(['text/html', 'application/json']);</code><p>если ждём только JSON</p><code>if ($request->expectsJson()) {}</code><p>получить запрос в формате PSR-7</p><pre><code>установить зависимости
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7

интерфейс в маршрут или контроллер
use Psr\Http\Message\ServerRequestInterface;

Route::get('/', function (ServerRequestInterface $request) {});
</code></pre></details><details><summary>Validate</summary><p>- валидация - это процесс проверки данных на соответствие определенным правилам с помощью встроенных, пользовательских правил, сообщений и кастомных атрибутов<br>
- создать класс запроса для валидации данных<br></p><pre><code>php artisan make:request StoreUserRequest

либо указать путь к классу
php artisan make:request App\Http\Requests\StoreUserRequest

либо указать путь к классу и пространство имен
php artisan make:request App\Http\Requests\StoreUserRequest --namespace=App\Http\Requests</code></pre><p>класс запроса в каталоге app/Http/Requests для валидации и авторизации данных<br></p><pre><code>namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class StoreUserRequest extends FormRequest
{
  public function authorize(): bool
  {
    return true;
  }
  public function rules(): array
  {
    return [
      'name' => 'required|string|max:255',
      'email' => 'required|string|email|max:255|unique:users',
      'password' => 'required|string|min:8|confirmed',
    ];
  }
}</code></pre><p>валидировать данные в контроллере<br></p><pre><code>use App\Http\Requests\StoreUserRequest;

class UserController extends Controller
{
    public function store(StoreUserRequest $request): RedirectResponse
    {
        // Данные валидированы...
        return redirect('/users');
    }
}</code></pre><p>валидировать данные в маршруте<br></p><pre><code>use App\Http\Requests\StoreUserRequest;

Route::post('/user', function (StoreUserRequest $request) {
    // Данные валидированы...
    return redirect('/users');
});</code></pre><p>валидировать данные в middleware<br></p><pre><code>use App\Http\Requests\StoreUserRequest;

class StoreUserMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $request->validateWithBag('user', (new StoreUserRequest())->rules());

        return $next($request);
    }
}</code></pre><p>валидация - проверка входящих данных</p><pre><code>- routes/web.php
use App\Http\Controllers\PostController;

Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);

- App\Http\Controllers\PostController.php
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class PostController extends Controller
{
    /**
    * Показать форму для создания нового сообщения в блоге.
    */
    public function create(): View
    {
        return view('post.create');
    }

    /**
    * Сохранить новую запись в блоге.
    */
    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

    либо
        $validatedData = $request->validate([
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
        ]);

    либо сохранение любых сообщений об ошибках в именованную коллекцию ошибок
        $validatedData = $request->validateWithBag('post', [
        'title' => ['required', 'unique:posts', 'max:255'],
        'body' => ['required'],
        ]);

        return redirect('/posts');
    }
}</code></pre><p>правило bail: прекратить выполнение правил валидации для атрибута после первой ошибки</p><pre><code>$request->validate([
    'title' => 'bail|required|unique:posts|max:255',
    'body' => 'required',
]);</code></pre><p>вложенные поля в HTTP-запросе</p><pre><code>$request->validate([
    'title' => 'required|unique:posts|max:255',
    'author.name' => 'required',
    'author.description' => 'required',
]);</code></pre><p>экранировать символ</p><pre><code>$request->validate([
    'title' => 'required|unique:posts|max:255',
    'v1\.0' => 'required',
]);</code></pre><p>при ошибке, Laravel перенаправит пользователя обратно и запишет все ошибки валидации и входящие данные запроса в сессию в массив $errors</p><pre><code>- /resources/views/post/create.blade.php
<h1>Создание поста блога</h1>

@if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

// Форма для создания поста блога</code></pre><p>локализация сообщений<br>
Каждое встроенное правило валидации Laravel содержит сообщение об ошибке в файле lang/en/validation.php<br></p><pre><code>опубликовать сообщения по умолчанию
php artisan lang:publish

чтобы создать свой перевод - скопируй lang/en/validation.php и отредактируй
resources/lang/ru/validation.php
'custom' => [
    'email' => [
        'required' => 'Нам нужно знать ваш адрес электронной почты!',
        'max' => 'Ваш адрес электронной почты слишком длинный!'
    ],
],</code></pre><p>заменить имя атрибута по умолчанию в языковых файлах</p><pre><code>resources/lang/en/validation.php

'attributes' => [
    'email' => 'email address',
],</code></pre><p>пользовательские имена для атрибутов в языковых файлах</p><pre><code>Validator::make($request->all(), [
    'credit_card_number' => 'required_if:payment_type,cc'
]);

resources/lang/ru/validation.php
'values' => [
    'payment_type' => [
        'cc' => 'кредитная карта'
    ],
],</code></pre><p>использование одного сообщения валидации для полей на основе массива</p><pre><code>'custom' => [
    'person.*.email' => [
        'unique' => 'Each person must have a unique email address',
    ]
],</code></pre><p>проверить наличие ошибок и вывести</p><pre><code>- /resources/views/post/create.blade.php
&lt;label for="title"&gt;Название сообщения&lt;/label&gt;
&lt;input
    id="title"
    type="text"
    name="title"
    class="@error('title') is-invalid @enderror"
/&gt;

@error('title')
    &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;
@enderror</code></pre><p>перезаполнить форму данными предыдущего запроса из сессии</p><pre><code>$title = $request->old('title');

либо
<input type="text" name="title" value="{{ old('title') }}"></code></pre><p>необязательные поля помечать nullable</p><pre><code>$request->validate([
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
    'publish_at' => 'nullable|date',
]);</code></pre><p>создать свой валидатор в контроллере, используя фасад Validator</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

class PostController extends Controller
{
    /**
    * Сохранить новую запись в блоге.
    */
    public function store(Request $request): RedirectResponse
    {
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->fails()) {
            return redirect('/post/create')
                        ->withErrors($validator) // передать ошибки в сессию в переменную $errors
                        ->withInput();
        }

        // Получить проверенные данные...
        $validated = $validator->validated();

        // Получить часть проверенных данных...
        $validated = $validator->safe()->only(['name', 'email']);
        $validated = $validator->safe()->except(['name', 'email']);

        // Сохранить сообщение блога...

        return redirect('/posts');
    }
}</code></pre><p>прекратить валидацию всех атрибутов после возникновения первой ошибки</p><code>if ($validator->stopOnFirstFailure()->fails()) {}</code><p>для автоматического перенаправления вызвать validate()</p><pre><code>Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();</code></pre><p>сохранить сообщения об ошибках в именованной коллекции ошибок</p><pre><code>Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validateWithBag('post');</code></pre><p>- именованные коллекции ошибок<br>
- с помощью именованных коллекций ошибок можно разделить ошибки валидации на разные группы<br>
- у каждой формы свой экземпляр MessageBag, содержащий ошибки валидации каждому экземпляру MessageBag можно присвоить имя (второй аргумент withErrors)<br></p><pre><code>задать имя коллекции ошибок
return redirect('/register')->withErrors($validator, 'login');

получить доступ к именованному экземпляру MessageBag из переменной $errors сессии
{{ $errors->login->first('email') }}</code></pre><p>собственные сообщения об ошибках в валидаторе</p><pre><code>$validator = Validator::make($input, $rules, $messages = [
    'required' => 'Поле :attribute является обязательным.',
]);</code></pre><p>кастомные сообщения об ошибке</p><pre><code>$messages = [
    'email.required' => 'Нам нужно знать ваш адрес электронной почты!',
];</code></pre><p>кастомные имена для атрибутов валидатора</p><pre><code>$validator = Validator::make($input, $rules, $messages, [
    'email' => 'Адрес электронной почты',
]);</code></pre><p> дополнительная валидация after()</p><pre><code>use Illuminate\Support\Facades\Validator;

$validator = Validator::make(/* ... */);
$validator->after(function ($validator) {
    if ($this->somethingElseIsInvalid()) {
        $validator->errors()->add(
            'field', 'Что-то не так с этим полем!'
        );
    }
});

if ($validator->fails()) {}</code></pre><p>условное добавление правил<br>
- не проверять поле, если другое поле имеет указанное значение exclude_if<br></p><pre><code>use Illuminate\Support\Facades\Validator;

$validator = Validator::make($data, [
    'has_appointment' => 'required|boolean',
    'appointment_date' => 'exclude_if:has_appointment,false|required|date',
    'doctor_name' => 'exclude_if:has_appointment,false|required|string',
]);</code></pre><p>не проверять поле, если другое поле не имеет указанное значение exclude_unless</p><pre><code>$validator = Validator::make($data, [
    'has_appointment' => 'required|boolean',
    'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
    'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
]);</code></pre><p>проверить поле если оно существует sometimes</p><pre><code>$validator = Validator::make($data, [
    'email' => 'sometimes|required|email',
]);</code></pre><p>проверка полей при условии</p><pre><code>создать валидатор
use Illuminate\Support\Facades\Validator;

$validator = Validator::make($request->all(), [
    'email' => 'required|email',
    'stars' => 'required|numeric',
]);

условие проверки
use Illuminate\Support\Fluent;

$validator->sometimes('reason', 'required|max:500', function (Fluent $input) {
    return $input->stars >= 100;
});

// reason - поле для проверки
// required|max:500 - правила проверки
// function (Fluent $input) - условие, при котором проверяем

либо
$validator->sometimes(['reason', 'cost'], 'required', function (Fluent $input) {
    return $input->stars >= 100;
});

либо
$input = [
    'channels' => [
        [
            'type' => 'email',
            'address' => 'abigail@example.com',
        ],
        [
            'type' => 'url',
            'address' => 'https://example.com',
        ],
    ],
];

$validator->sometimes('channels.*.address', 'email', function (Fluent $input, Fluent $item) {
    return $item->type === 'email';
});

$validator->sometimes('channels.*.address', 'url', function (Fluent $input, Fluent $item) {
    return $item->type !== 'email';
});</code></pre><p>валидация массивов</p><pre><code>правило array - список разрешенных ключей массива
use Illuminate\Support\Facades\Validator;

$input = [
    'user' => [
        'name' => 'Taylor Otwell',
        'username' => 'taylorotwell',
        'admin' => true,
    ],
];

Validator::make($input, [
    'user' => 'array:name,username',
]);

HTTP-запрос содержит поле photos[profile]
$validator = Validator::make($request->all(), [
    'photos.profile' => 'required|image',
]);

проверить каждый элемент массива
$validator = Validator::make($request->all(), [
    'person.*.email' => 'email|unique:users',
    'person.*.first_name' => 'required_with:person.*.last_name',
]);</code></pre><p>применить правила проверки к каждому элементу массива подлежащего проверке атрибута</p><pre><code>use App\Rules\HasPermission;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;

$validator = Validator::make($request->all(), [
    'companies.*.id' => Rule::forEach(function (string|null $value, string $attribute) {
        return [
            Rule::exists(Company::class, 'id'),
            new HasPermission('manage-company', $value),
        ];
    }),
]);</code></pre><p>указать индекс или позицию элемента массива в сообщении об ошибке</p><pre><code>use Illuminate\Support\Facades\Validator;

$input = [
    'photos' => [
        [
            'name' => 'BeachVacation.jpg',
            'description' => 'Фото моего пляжного отдыха!',
        ],
        [
            'name' => 'GrandCanyon.jpg',
            'description' => '',
        ],
    ],
];

Validator::validate($input, [
    'photos.*.description' => 'required',
], [
    'photos.*.description.required' => 'Пожалуйста, укажите описание для фото № :position.',
]);
// ссылаться на более глубокие вложенные индексы и позиции с использованием second-index, second-position, third-index, third-position</code></pre><p>валидация файлов</p><pre><code>для файла
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\File;

Validator::validate($input, [
    'attachment' => [
        'required',
        File::types(['mp3', 'wav'])
            ->min(1024)
            ->max(12 * 1024),
    ],
]);

либо с размерами kb, mb, gb и tb
File::image()
    ->min('1kb')
    ->max('10mb')

для изображения
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
use Illuminate\Validation\Rules\File;

Validator::validate($input, [
    'photo' => [
        'required',
        File::image()
            ->min(1024)
            ->max(12 * 1024)
            ->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500)),
            // dimensions - размер изображения
    ],
]);</code></pre><p>валидация паролей<br>
- объект правила Password для настройки требования к сложности пароля<br></p><pre><code>use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\Password;

$validator = Validator::make($request->all(), [
    'password' => ['required', 'confirmed', Password::min(8)],
]);

либо
// Требуется не менее 8 символов...
Password::min(8)

// Требуется хотя бы одна буква...
Password::min(8)->letters()

// Требуется хотя бы одна заглавная и одна строчная буква...
Password::min(8)->mixedCase()

// Требовать хотя бы одна цифра...
Password::min(8)->numbers()

// Требуется хотя бы один символ...
Password::min(8)->symbols()

// Убедиться, что пароль не был скомпрометирован
Password::min(8)->uncompromised()

// Все вместе
Password::min(8)
    ->letters()
    ->mixedCase()
    ->numbers()
    ->symbols()
    ->uncompromised()</code></pre><p>указать правила проверки паролей по умолчанию в одном месте приложения</p><pre><code>в App\Providers\AppServiceProvider
use Illuminate\Validation\Rules\Password;

public function boot(): void
{
    Password::defaults(function () {
        $rule = Password::min(8);

        return $this->app->isProduction()
                    ? $rule->mixedCase()->uncompromised()
                    : $rule;
    });
}

применить правила проверки паролей по умолчанию
'password' => ['required', Password::defaults()],</code></pre><p>отвалидированные данные<br>
- получить данные входящего запроса, которые действительно прошли проверку с помощью запроса формы или вручную созданного экземпляра валидатора</p><pre><code>вызвать метод validated в запросе формы или экземпляре валидатора: вернёт массив проверенных данных
$validated = $request->validated();
$validated = $validator->validated();

вызвать метод safe в запросе формы или экземпляре валидатора: вернёт экземпляр Illuminate\Support\ValidatedInput с методами only, except, и all
$validated = $request->safe()->only(['name', 'email']);
$validated = $request->safe()->except(['name', 'email']);
$validated = $request->safe()->all();

// Проверенные данные можно повторять...
foreach ($request->safe() as $key => $value) {}

// Доступ к проверенным данным можно получить как массив...
$validated = $request->safe();
$email = $validated['email'];

// Добавить поля к проверенным данным
$validated = $request->safe()->merge(['name' => 'Taylor Otwell']);

// Получить проверенные данные в виде экземпляра collection
$collection = $request->safe()->collect();</code></pre><p>собственные правила валидации<br>
- создать новый объект правил<br></p><pre><code>php artisan make:rule Uppercase

в app/Rules/Uppercase.php
namespace App\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;

class Uppercase implements ValidationRule
{
    /**
    * Запустить правило проверки.
    */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        if (strtoupper($value) !== $value) {
            $fail('The :attribute must be uppercase.');
        }
    }
}

применить правило
use App\Rules\Uppercase;

$request->validate([
    'name' => ['required', 'string', new Uppercase],
]);</code></pre><p>вызвать локализацию сообщения об ошибке</p><pre><code>if (strtoupper($value) !== $value) {
    $fail('validation.uppercase')->translate();
}

либо
$fail('validation.location')->translate([
    'value' => $this->value,
], 'fr')</code></pre><p>получить доступ к внешним данным из собственного класса правил</p><pre><code>namespace App\Rules;

use Illuminate\Contracts\Validation\DataAwareRule;
use Illuminate\Contracts\Validation\ValidationRule;

class Uppercase implements DataAwareRule, ValidationRule
{
    /**
    * Все данные находятся на проверке.
    *
    * @var array<string, mixed>
    */
    protected $data = [];

    // ...

    /**
    * Установите данные для проверки.
    *
    * @param  array<string, mixed>  $data
    */
    public function setData(array $data): static
    {
        $this->data = $data;

        return $this;
    }
}</code></pre><p>доступ к экземпляру валидатора, выполняющему проверку</p><pre><code>namespace App\Rules;

use Illuminate\Contracts\Validation\ValidationRule;
use Illuminate\Contracts\Validation\ValidatorAwareRule;
use Illuminate\Validation\Validator;

class Uppercase implements ValidationRule, ValidatorAwareRule
{
    /**
    * Экземпляр валидатора.
    *
    * @var \Illuminate\Validation\Validator
    */
    protected $validator;

    // ...

    /**
    * Установите текущий валидатор.
    */
    public function setValidator(Validator $validator): static
    {
        $this->validator = $validator;

        return $this;
    }
}</code></pre><p>собственное правило без создания класса через $fail</p><pre><code>use Illuminate\Support\Facades\Validator;
use Closure;

$validator = Validator::make($request->all(), [
    'title' => [
        'required',
        'max:255',
        function (string $attribute, mixed $value, Closure $fail) {
            if ($value === 'foo') {
                $fail("The {$attribute} is invalid.");
            }
        },
    ],
]);</code></pre><p>любые правила валидации не применяются, если проверяемый атрибут отсутствует или содержит пустую строку<br>
--implicit - подразумевает, что проверяемый атрибут является обязательным<br></p><code>php artisan make:rule Uppercase --implicit</code><p>запрос формы – кастомный класс запроса своей логики валидации и авторизации</p><pre><code>php artisan make:request StorePostRequest

app/Http/Requests
/**
* Получить массив правил валидации, которые будут применены к запросу.
*
* @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
*/
public function rules(): array
{
    return [
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ];
}

в контроллере
/**
* Сохранить новую запись в блоге.
*/
public function store(StorePostRequest $request): RedirectResponse
{
    // Входящий запрос прошел валидацию...

    // Получить проверенные входные данные...
    $validated = $request->validated();

    // Получить часть проверенных входных данных...
    $validated = $request->safe()->only(['name', 'email']);
    $validated = $request->safe()->except(['name', 'email']);

    // Сохранить апись в блоге...

    return redirect('/posts');
}</code></pre><p>дополнительная валидация после завершения начальной валидации</p><pre><code>use Illuminate\Validation\Validator;

/**
* Получите вызываемые объекты проверки «после» для запроса.
*/
public function after(): array
{
    return [
        function (Validator $validator) {
            if ($this->somethingElseIsInvalid()) {
                $validator->errors()->add(
                    'field',
                    'Something is wrong with this field!'
                );
            }
        }
    ];
}</code></pre><p>прекратить валидацию всех атрибутов после возникновения первой ошибки</p><pre><code>/**
* @var bool
*/
protected $stopOnFirstFailure = true;</code></pre><p>перенаправить при ошибке вручную</p><pre><code>/**
* @var string
*/
protected $redirect = '/dashboard';

либо
protected $redirectRoute = 'dashboard';</code></pre><p>авторизация запросов</p><pre><code>app/Http/Requests

use App\Models\Comment;
/**
* Определить, уполномочен ли пользователь выполнить этот запрос.
*/
public function authorize(): bool
{
    // route() - доступ к параметрам URI
    $comment = Comment::find($this->route('comment'));

    return $comment && $this->user()->can('update', $comment);
}
// user() - доступ к текущему аутентифицированному пользователю

либо если есть привязка модели к маршруту
public function authorize(): bool
{
    return $this->user()->can('update', $this->comment);
}

если логика авторизации обрабатывается в другом месте
public function authorize(): bool
{
    return true;
}</code></pre><p>изменить сообщения об ошибках</p><pre><code>app/Http/Requests

/**
* Получить сообщения об ошибках для определенных правил валидации.
*
* @return array&lt;string, string&gt;
*/
public function messages(): array
{
    return [
        'title.required' => 'A title is required',
        'body.required' => 'A message is required',
    ];
}</code></pre><p>изменить имя атрибута</p><pre><code>app/Http/Requests

/**
* Получить пользовательские имена атрибутов для формирования ошибок валидатора.
*
* @return array&lt;string, string&gt;
*/
public function attributes(): array
{
    return [
        'email' => 'email address',
    ];
}</code></pre><p>подготовить данные из запроса для валидации</p><pre><code>app/Http/Requests

use Illuminate\Support\Str;
/**
* Подготовить данные для валидации.
*/
protected function prepareForValidation(): void
{
    $this->merge([
        'slug' => Str::slug($this->slug),
    ]);
}</code></pre><p>нормализовать данные после валидации</p><pre><code>app/Http/Requests

/**
* Обработка успешной попытки валидации:
*/
protected function passedValidation(): void
{
    $this->replace(['name' => 'Taylor']);
}
</code></pre><details><summary>Exceptions</summary><p>- метод withExceptions в bootstrap/app.php управляет исключениями и выводом сообщений о них<br>
- $exceptions - экземпляр Illuminate\Foundation\Configuration\Exceptions<br>
- debug в config/app.php определяет сколько показать информации об ошибке<br>
- переменная окружения APP_DEBUG в .env при разработке = true, на продакшине false<br>
- выполняться, когда необходимо сообщить об исключении определенного типа<br>
- php artisan make:exception CustomException --render --report --force --quiet --no-interaction --no-ansi - создание пользовательского исключения с методами render и report, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода<br></p><pre><code>bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->report(function (InvalidOrderException $e) { });
})</code></pre><p>остановить регистрацию исключения в стек журналов логирования по умолчанию</p><pre><code>bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->report(function (InvalidOrderException $e) { })->stop();

либо
  $exceptions->report(function (InvalidOrderException $e) {
    return false;
  });
})</code></pre><p>определить свои собственные глобальные контекстные данные</p><pre><code>bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->context(fn () => [
    'foo' => 'bar',
  ]);
})</code></pre><p>добавить уникальный контекст для конкретного исключения</p><pre><code>namespace App\Exceptions;
use Exception;
class InvalidOrderException extends Exception
{
  - Получить контекстную информацию исключения
  public function context(): array
  {
    return ['order_id' => $this->orderId];
  }
}</code></pre><p>сообщить об исключении и продолжить обработку текущего запроса, не отображая страницу с ошибкой</p><pre><code>public function isValid(string $value): bool
{
  try {
    // Проверка `$value`
  } catch (Throwable $e) {
    report($e);
    return false;
  }
}</code></pre><p>об одном экземпляре исключения сообщать только один раз</p><pre><code>bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->dontReportDuplicates();
})
$original = new RuntimeException('Whoops!');
report($original); // сообщено
try {
  throw $original;
} catch (Throwable $caught) {
  report($caught); // проигнорировано
}
report($original); // проигнорировано
report($caught); // проигнорировано</code></pre><p>сообщения об исключениях записываются в журнал с указанием уровня серьезности и важности<br>
задать сообщению уровень для записи:<br></p><pre><code>bootstrap/app.php
use PDOException;
use Psr\Log\LogLevel;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->level(PDOException::class, LogLevel::CRITICAL);
})</code></pre><p>игнорировать исключения</p><pre><code>bootstrap/app.php
use App\Exceptions\InvalidOrderException;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->dontReport([
        InvalidOrderException::class,
    ]);
})

либо
namespace App\Exceptions;
use Exception;
use Illuminate\Contracts\Debug\ShouldntReport;
class PodcastProcessingException extends Exception implements ShouldntReport { }</code></pre><p>прекратить игнорировать определенный тип исключения</p><pre><code>use Symfony\Component\HttpKernel\Exception\HttpException;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->stopIgnoring(HttpException::class);
})</code></pre><p>по умолчанию Laravel преобразует исключения в HTTP-ответ, изменить тип исключения</p><pre><code>use App\Exceptions\InvalidOrderException;
use Illuminate\Http\Request;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->render(function (InvalidOrderException $e, Request $request) {
        return response()->view('errors.invalid-order', status: 500);
    });
})

либо
use Illuminate\Http\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->render(function (NotFoundHttpException $e, Request $request) {
        if ($request->is('api/*')) {
            return response()->json([
                'message' => 'Record not found.'
            ], 404);
        }
    });
})</code></pre><p>отобразить исключение в формате JSON</p><pre><code>use Illuminate\Http\Request;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->shouldRenderJsonWhen(function (Request $request, Throwable $e) {
        if ($request->is('admin/*')) {
            return true;
        }
        return $request->expectsJson();
    });
})</code></pre><p>настроить HTTP-ответ на исключение</p><pre><code>use Symfony\Component\HttpFoundation\Response;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->respond(function (Response $response) {
        if ($response->getStatusCode() === 419) {
            return back()->with([
                'message' => 'The page expired, please try again.',
            ]);
        }
        return $response;
    });
})</code></pre><p>поведение отчетов и отображение ошибок определено методами report и render</p><pre><code>namespace App\Exceptions;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
class InvalidOrderException extends Exception
{
    - Отчитаться об исключении.
    public function report(): void { }
    - Преобразовать исключение в HTTP-ответ.
    public function render(Request $request): Response
    {
        return response(/* ... */);
    }
}</code></pre><p>выбрать случайное количество исключений</p><pre><code>use Illuminate\Support\Lottery;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->throttle(function (Throwable $e) {
        return Lottery::odds(1, 1000);
    });
})</code></pre><p>выбрать исключения определённого типа</p><pre><code>use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->throttle(function (Throwable $e) {
        if ($e instanceof BroadcastException) {
            return Limit::perMinute(300);
        }
    });
})

либо
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->throttle(function (Throwable $e) {
        if ($e instanceof BroadcastException) {
            return Limit::perMinute(300)->by($e->getMessage());
        }
    });
})

либо
use App\Exceptions\ApiMonitoringException;
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Lottery;
use Throwable;
->withExceptions(function (Exceptions $exceptions) {
    $exceptions->throttle(function (Throwable $e) {
        return match (true) {
            $e instanceof BroadcastException => Limit::perMinute(300),
            $e instanceof ApiMonitoringException => Lottery::odds(1, 1000),
            default => Limit::none(),
        };
    });
})</code></pre><p>создать исключение</p><pre><code>abort(404);
abort(403, 'Unauthorized action.');
abort(403, 'Unauthorized action.', ['X-Header' => 'Value']);</code></pre><p>опубликовать стандартные шаблоны страниц ошибок</p><code>php artisan vendor:publish --tag=laravel-errors</code><p>шаблоны страниц ошибок если нет страницы для нужного кода ошибки</p><pre><code>resources/views/errors/4xx.blade.php
resources/views/errors/5xx.blade.php</code></pre><p>в resources/views/errors/404.blade.php</p><code><h2>{{ $exception->getMessage() }}</h2></code></details><details><summary>Error messages</summary><p>- вызов метода errors на экземпляре Validator вернёт экземпляр Illuminate\Support\MessageBag<br>
- переменная $errors - экземпляр Illuminate\Support\MessageBag, которая доступна для всех шаблонов<br>
- Illuminate\Support\MessageBag - набор методов для работы с сообщениями об ошибках<br>
- получить первое сообщение об ошибке для указанного поля<br></p><pre><code>$errors = $validator->errors();
echo $errors->first('email');</code></pre><p>получить массив всех сообщений для указанного поля</p><code>foreach ($errors->get('email') as $message) {}</code><p>получить все сообщения для каждого из элементов массива</p><code>foreach ($errors->get('attachments.*') as $message) {}</code><p>получить массив всех сообщений для всех полей</p><code>foreach ($errors->all() as $message) {}</code><p>провеить наличие сообщений об ошибках для указанного поля</p><code>if ($errors->has('email')) {}</code></details></details><details><summary>Input data</summary><p>- данные формы могут быть отправлены в запросе с помощью метода GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD, TRACE, CONNECT<br>
- получить из запроса данные JSON: заголовок Content-Type = application/json<br>
- получить из запроса данные формы: заголовок Content-Type = application/x-www-form-urlencoded<br></p><pre><code>все данные в виде массива
$input = $request->all();

все данные в виде коллекции
$input = $request->collect();

все данные как ассоциированный массив
$input = $request->input();

данные одного поля, второй параметр - значение по умолчанию
$name = $request->input('name', 'Sally');

данные формы содержащей массив, доступ к элементу через точку
$name = $request->input('products.0.name');
$names = $request->input('products.*.name');

все данные из строки запроса в виде ассоциативного массива
$query = $request->query();

данные отдельного параметра из строки запроса, второй параметр - значение по умолчанию
$name = $request->query('name', 'Helen');

в виде объекта String
$name = $request->string('name')->trim();

в виде целого числа
$perPage = $request->integer('per_page');

в логическом виде
$archived = $request->boolean('archived');

дата - имя параметра, формат вывода и часовой пояс
$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');

перечисление - имя параметра и класс перечислений
$status = $request->enum('status', Status::class);

перечесления в виде массива
$products = $request->enums('products', Product::class);

выборочное получение - либо массив, либо динамический список
$input = $request->only(['username', 'password']);
$input = $request->only('username', 'password');

$input = $request->except(['credit_card']);
$input = $request->except('credit_card');</code></pre><p>проверить начилие параметра в запросе (true/false)</p><pre><code>один параметр
if ($request->has('name')) {}

все из массива
if ($request->has(['name', 'email'])) {}

любой из массива
if ($request->hasAny(['name', 'email'])) {}

выполнит действие если в запросе присутствует параметр
$request->whenHas('name', function (string $input) {});

если параметр присутствует в за просе, то выполнит первое действие, если нет - то второе
$request->whenHas('name', function (string $input) {}, function () {});

проверить есть ли значение
if ($request->filled('name')) {}

проверить отсутствие или пустая строка
if ($request->isNotFilled('name')) {}

все ли отсутствуют или пустые
if ($request->isNotFilled(['name', 'email'])) {}

true если хоть один не пустой
if ($request->anyFilled(['name', 'email'])) {}

если не пустой, то выполнит действие
$request->whenFilled('name', function (string $input) {});

если нет значения, то выполнить второе действие
$request->whenFilled('name', function (string $input) {}, function () {});

проверить существует ли ключ параметра в запросе
if ($request->missing('name')) {}

если отсутствует, то первое действие, если присутствует - то второе
$request->whenMissing('name', function () {}, function () {});</code></pre><p>объединить существующие данные запроса с данными из ввода</p><pre><code>у существующих данных значение по ключу будет перезаписано
$request->merge(['votes' => 0]);

добавить в запрос данные из ввода если в запросе такого ключа нет
$request->mergeIfMissing(['votes' => 0]);</code></pre><p>сохранить данные предыдущего запроса</p><pre><code>сохранить входные данные в сессии, для доступа только во время следующего запроса
$request->flash();

выборочное сохранение
$request->flashOnly(['username', 'email']);
$request->flashExcept('password');

сохранение с перенаправлением
return redirect('/form')->withInput();
return redirect()->route('user.create')->withInput();
return redirect('/form')->withInput($request->except('password'));</code></pre><p>получить данные предыдущего запроса</p><pre><code>$username = $request->old('username');

для шаблона Blade
^lt;input type="text" name="username" value="{{ old('username') }}"&gt;</code></pre><p>получить значение cookie</p><code>$value = $request->cookie('name');</code><p>форматирование значений поля ввода настраивается Illuminate\Foundation\Http\Middleware\TrimStrings и Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull в bootstrap/app.php</p><p>загрузка файлов</p><pre><code>получить файл из запроса либо
$file = $request->file('photo');

либо динамически
$file = $request->photo;

проверить если файл в запросе
if ($request->hasFile('photo')) {}

валидация загрузки файла
if ($request->file('photo')->isValid()) {}

доступ к пути файла
$path = $request->photo->path();

доступ к расширению файла
$extension = $request->photo->extension();</code></pre><p>сохранить файл из запроса</p><pre><code>имя файла генерится автоматически, второй аргумент имя диска сохранения (необязательный)
$path = $request->photo->store('images', 's3');

задать имя файла
$path = $request->photo->storeAs('images', 'filename.jpg', 's3');</code></pre><p>доверенные прокси-сервера</p><pre><code>доверенные прокси указать в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustProxies(at: [
        '192.168.1.1',
        '10.0.0.0/8',
    ]);
})

заголовки доверенных прокси
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustProxies(headers: Request::HEADER_X_FORWARDED_FOR |
        Request::HEADER_X_FORWARDED_HOST |
        Request::HEADER_X_FORWARDED_PORT |
        Request::HEADER_X_FORWARDED_PROTO |
        Request::HEADER_X_FORWARDED_AWS_ELB
    );
})

доверять всем прокси
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustProxies(at: '*');
})</code></pre><p>доверенный host</p><pre><code>имя хоста, на которого реагировать указать в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustHosts(at: ['laravel.test']);
})

не доверять поддоменам хоста
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustHosts(at: ['laravel.test'], subdomains: false);
})

указать доверенные хосты в файле конфигурации
->withMiddleware(function (Middleware $middleware) {
    $middleware->trustHosts(at: fn () => config('app.trusted_hosts'));
})
</code></pre></details><details><summary>Response</summary><p>- ответ - это HTTP-ответ, который возвращается пользователю в виде HTML, JSON, XML, текстового файла, изображения, редиректа и т.д.<br>
- вернуть ответ в контроллере</p><pre><code>return response('Hello World', 200);

вернуть JSON-ответ
return response()->json(['name' => 'John Doe']);

вернуть JSONP-ответ
return response()->json(['name' => 'John Doe'], 200, [], JSON_PRETTY_PRINT);

вернуть редирект
return redirect('/home');

вернуть редирект с сообщением
return redirect('/home')->with('status', 'Profile updated!');</code></pre><p>вернуть ответ в маршруте</p><pre><code>преобразует в НТТР-ответ
Route::get('/', function () {
    return 'Hello World';
});

преобразует в JSON
Route::get('/', function () {
    return [1, 2, 3];
});

модель преобразует в JSON
use App\Models\User;

Route::get('/user/{user}', function (User $user) {
    return $user;
});

передать код и заголовок
Route::get('/home', function () {
    return response('Hello World', 200)
                  ->header('Content-Type', 'text/plain');
});

по одному заголовку
return response($content)
            ->header('Content-Type', $type)
            ->header('X-Header-One', 'Header Value')
            ->header('X-Header-Two', 'Header Value');

массив заголовков
return response($content)
            ->withHeaders([
                'Content-Type' => $type,
                'X-Header-One' => 'Header Value',
                'X-Header-Two' => 'Header Value',
            ]);

установить Cache-Control
Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
    Route::get('/privacy', function () {});
    Route::get('/terms', function () {});
});</code></pre><p>cookies</p><pre><code>добавить файл куки к ответу
return response('Hello World')->cookie(
    'name', 'value', $minutesб 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly
);

поставить куки в очередь для добавления к ответу когда он будет создан
use Illuminate\Support\Facades\Cookie;

Cookie::queue('name', 'value', $minutes);

либо
$cookie = cookie('name', 'value', $minutes);

return response('Hello World')->cookie($cookie);

удалить куки, обнулив срок действия
return response('Hello World')->withoutCookie('name');

либо Cookie::expire('name');

отключить шифрование и подпись куки в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
    $middleware->encryptCookies(except: [
        'cookie_name',
    ]);
})</code></pre><p>потоковые ответы</p><pre><code>function streamedContent(): Generator {
    yield 'Hello, ';
    yield 'World!';
}

Route::get('/stream', function () {
    return response()->stream(function (): void {
        foreach (streamedContent() as $chunk) {
            echo $chunk;
            ob_flush();
            flush();  // для отправки буферизованного содержимого
            sleep(2); // Simulate delay between chunks...
        }
    }, 200, ['X-Accel-Buffering' => 'no']);
});

JSON
use App\Models\User;

Route::get('/users.json', function () {
    return response()->streamJson([
        'users' => User::cursor(),
    ]);
});

отправить в ответ результат функции без записи на диск
use App\Services\GitHub;

return response()->streamDownload(function () {
    echo GitHub::api('repo')
                ->contents()
                ->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');</code></pre><p>создать свой ответ</p><pre><code>namespace App\Providers;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        Response::macro('caps', function (string $value) {
            return Response::make(strtoupper($value));
        });
    }
}

вызвать свой ответ в контроллере
return response()->caps('foo');
</code></pre></details></details><details><summary>Views</summary><details> <summary>Templates</summary><p>- шаблоны Blade - это HTML и директивы Blade в файле с расширением .blade.php, компилируются в обычные PHP-файлы и кэшируются<br>
- могут содержать: обычный PHP-код, другие шаблоны Blade, директивы Blade, секции и компоновщики (для создания многоразовых шаблонов) и компоненты (для многоразовых элементов интерфейса)<br></p><pre><code>создать Blade-шаблон
php artisan make:view greeting

для шаблонов blade вызов глобального помошника view
Route::get('/', function () {
  return view('greeting', ['name' => 'James']);
});

либо вызов фасада View
use Illuminate\Support\Facades\View;
return View::make('greeting', ['name' => 'James']);
greeting - имя файла, переменую name можно вывести в шаблоне
можно передать в шаблон массив данных

вызвать первый шаблон из массива
use Illuminate\Support\Facades\View;
return View::first(['custom.admin', 'admin'], $data);

существует ли шаблон
use Illuminate\Support\Facades\View;

if (View::exists('admin.profile')) {}

передать в шаблон отдельные данные
return view('greeting')
        ->with('name', 'Victoria')
        ->with('occupation', 'Astronaut');

вызвать resources/views/admin/profile.blade.php
return view('admin.profile', $data);

сделать данные доступными для всех шаблонов в App\Providers\AppServiceProvider
public function boot(): void
{
  View::share('key', 'value');
}
</code></pre></details><details><summary>Templates composers</summary><p>компоновщики шаблонов - это классы или анонимные функции, которые позволяют привязывать к шаблону перед его отрисовкой данные которые: <br>
- не зависят от контроллеров<br>
- зависят от других данных<br>
- зависят от других шаблонов<br>
- зависят от других компонентов<br>
- данные к шаблону, которые вызываются при его каждой отрисовке<br></p><pre><code>в App\Providers\AppServiceProvider
public function boot(): void
{
    // Использование компоновщиков на основе классов...
    Facades\View::composer('profile', ProfileComposer::class);

    // Использование анонимных компоновщиков...
    Facades\View::composer('welcome', function (View $view) {
        // ...
    });

    Facades\View::composer('dashboard', function (View $view) {
        // ...
    });
}

создать app/View/Composers/ProfileComposer.php
namespace App\View\Composers;
use App\Repositories\UserRepository;
use Illuminate\View\View;

class ProfileComposer
{
    /**
    * Создать нового компоновщика профиля.
    */
    public function __construct(
        protected UserRepository $users,
    ) {}

    /**
    * Привязать данные к шаблону.
    */
    public function compose(View $view): void
    {
        $view->with('count', $this->users->count());
    }
}</code></pre><p>прикрепить компоновщик к нескольким шаблонам</p><pre><code>use App\Views\Composers\MultiComposer;
use Illuminate\Support\Facades\View;

View::composer(
    ['profile', 'dashboard'],
    MultiComposer::class
);</code></pre><p>прикрепить компоновщик ко всем шаблонам</p><pre><code>use Illuminate\Support\Facades;
use Illuminate\View\View;

Facades\View::composer('*', function (View $view) {});</code></pre><p>создатели шаблонов выполняются сразу после создания экземпляра, не дожидаясь отрисовки шаблона</p><pre><code>use App\View\Creators\ProfileCreator;
use Illuminate\Support\Facades\View;

View::creator('profile', ProfileCreator::class);</code></pre><p>оптимизация шаблонов</p><pre><code>предварительная компиляции всех шаблонов при развёртывании
php artisan view:cache

очистка кеша шаблонов
php artisan view:clear</code></pre><p>удалить кешированные шаблоны</p><code>php artisan view:clear</code><p>поместить РНР код в шаблон Blade</p><code>{{ }}</code><p>текущее UNIX-время</p><code>{{ time() }}.</code><p>отключить экранирование данных (экранирование нужно для предотвращения XSS-атак)</p><code>Привет, {!! $name !!}</code><p>передать в HTML без обработки</p><pre><code>Привет, @{{ name }}
@@if()</code></pre><p>@verbatim - передать в HTML без обработки несколько строк</p><pre><code>@verbatim
    &lt;div class="container"&gt;
        Hello, {{ name }}.
    &lt;/div&gt;
@endverbatim</code></pre><p>передать массив шаблону в виде JSON</p><pre><code>&lt;script&gt;
    var app = {{ Js::from($array) }};
&lt;/script&gt;
</code></pre></details><details><summary>Blade directives</summary><p>- директивы Blade - это команды для выполнения действий в шаблонах Blade, начинаются с символа @, могут быть вложенными друг в друга и содержать<br>
параметры, другие директивы Blade, код (PHP, HTML, JavaScript, CSS)<br>
- условие<br></p><pre><code>@if (count($records) === 1)
    У меня есть одна запись!
@elseif (count($records) > 1)
    У меня есть несколько записей!
@else
    У меня нет записей!
@endif

@unless (Auth::check())
    Вы не вошли в систему.
@endunless

@isset($records)
    // Переменная $records определена и не равна null...
@endisset

@empty($records)
    // Переменная $records считается «пустой»...
@endempty

- аутентификация
@auth
    // Пользователь аутентифицирован...
@endauth

@guest
    // Пользователь не аутентифицирован...
@endguest

- аутентификация с правилом guard
@auth('admin')
    // Пользователь аутентифицирован...
@endauth

@guest('admin')
    // Пользователь не аутентифицирован...
@endguest

- ошибки валидации
&lt;input
    id="title"
    type="text"
    class="@error('title') is-invalid @enderror"
/&gt;

@error('title')
    &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;
@enderror

либо
&lt;input
    id="email"
    type="email"
    class="@error('email') is-invalid @else is-valid @enderror"
/&gt;</code></pre><p>стэки</p><pre><code>- добавить данные для отображения в других шаблонах
@push('scripts')
    &lt;script src="/example.js"&gt;&lt;/script&gt;
@endpush

- добавить при условии
@pushIf($shouldPush, 'scripts')
    &lt;script src="/example.js"&gt;&lt;/script&gt;
@endPushIf

- добавить в начало стэка
@prepend('scripts')
    Это будет первое...
@endprepend

- отобразить весь стэк
&lt;head&gt;
    @stack('scripts')
&lt;/head&gt;</code></pre><p>среда окружения</p><pre><code>@production
    // Содержимое, отображаемое только в эксплуатационном окружении...
@endproduction

@env('staging')
    // Приложение запущено в «переходном» окружении...
@endenv

@env(['staging', 'production'])
    // Приложение запущено в «переходном» или «рабочем» окружении...
@endenv</code></pre><p>секции</p><pre><code>- есть ли в секции наследуемого шаблона содержимое
@hasSection('navigation')
    &lt;div class="pull-right"&gt;
        @yield('navigation')
    &lt;/div&gt;

    &lt;div class="clearfix"&gt;&lt;/div&gt;
@endif

- нет ли в секции содержимого
@sectionMissing('navigation')
    &lt;div class="pull-right"&gt;
        @include('default-navigation')
    &lt;/div&gt;
@endif</code></pre><p>сессия</p><pre><code>- есть ли сессия
@session('status')
    &lt;div class="p-4"&gt;
        {{ $value }}
    &lt;/div&gt;
@endsession</code></pre><p>данные</p><pre><code>- передать данные от родителя к ребенку @aware
родитель
@props(['color' => 'gray'])

&lt;ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}&gt;
    {{ $slot }}
&lt;/ul&gt;

ребенок
@aware(['color' => 'gray'])

&lt;li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}&gt;
    {{ $slot }}
&lt;/li&gt;</code></pre><p>служба</p><pre><code>- подключить службу
@inject('metrics', 'App\Services\MetricsService')

&lt;div&gt;
    Ежемесячный доход: {{ $metrics->monthlyRevenue() }}.
&lt;/div&gt;</code></pre><p>HTTP-ответ</p><pre><code>- отдать в исходящий HTTP-ответ фрагмент шаблона
в шаблоне
@fragment('user-list')
    &lt;ul&gt;
        @foreach ($users as $user)
            &lt;li&gt;{{ $user->name }}&lt;/li&gt;
        @endforeach
    &lt;/ul&gt;
@endfragment

в роуте или контроллере
return view('dashboard', ['users' => $users])->fragment('user-list');

- отдать в исходящий HTTP-ответ фрагмент шаблона при условии (true - фрагмент, false - всё)
return view('dashboard', ['users' => $users])
    ->fragmentIf($request->hasHeader('HX-Request'), 'user-list');

- отдать в исходящий HTTP-ответ фрагмент шаблона несколько фрагментов
view('dashboard', ['users' => $users])
    ->fragments(['user-list', 'comment-list']);

view('dashboard', ['users' => $users])
    ->fragmentsIf(
        $request->hasHeader('HX-Request'),
        ['user-list', 'comment-list']
    );</code></pre><p>свитч</p><pre><code>@switch($i)
    @case(1)
        Первый case...
        @break

    @case(2)
        Второй case...
        @break

    @default
        Case по умолчанию...
@endswitch
</code></pre><p>циклы</p><pre><code>@for ($i = 0; $i < 10; $i++)
    Текущее значение {{ $i }}
@endfor

@foreach ($users as $user)
    &lt;p&gt;Это пользователь {{ $user->id }}&lt;/p&gt;
@endforeach

@forelse ($users as $user)
    &lt;li&gt;{{ $user->name }}&lt;/li&gt;
@empty
    &lt;p&gt;Нет пользователей&lt;/p&gt;
@endforelse

@while (true)
    &lt;p&gt;Я зацикливаюсь навсегда.&lt;/p&gt;
@endwhile

- пропуск текущей итерации @continue или завершение @break
@foreach ($users as $user)
    @if ($user->type == 1)
        @continue
    @endif

    &lt;li&gt;{{ $user->name }}&lt;/li&gt;

    @if ($user->number == 5)
        @break
    @endif
@endforeach

- пропуск и завершение при условии
@foreach ($users as $user)
    @continue($user->type == 1)

    &lt;li&gt;{{ $user->name }}&lt;/li&gt;

    @break($user->number == 5)
@endforeach

- информация о цикле в переменной $loop
@foreach ($users as $user)
    @if ($loop->first)
        Это первая итерация.
    @endif

    @if ($loop->last)
        Это последняя итерация.
    @endif

    &lt;p&gt;Это пользователь {{ $user->id }}&lt;/p&gt;
@endforeach

- $loop родительского цикла
@foreach ($users as $user)
    @foreach ($user->posts as $post)
        @if ($loop->parent->first)
            Это первая итерация родительского цикла.
        @endif
    @endforeach
@endforeach</code></pre><p>$loop->index - Индекс текущей итерации цикла (начинается с 0).<br>
$loop->iteration - Текущая итерация цикла (начинается с 1).<br>
$loop->remaining - Итерации, оставшиеся в цикле.<br>
$loop->count - Общее количество элементов в итерируемом массиве.<br>
$loop->first - Первая ли это итерация цикла.<br>
$loop->last - Последняя ли это итерация цикла.<br>
$loop->even - Четная ли это итерация цикла.<br>
$loop->odd - Нечетная ли это итерация цикла.<br>
$loop->depth - Уровень вложенности текущего цикла.<br>
$loop->parent - Переменная родительского цикла во вложенном цикле.<br>
</p><p>создать свою директиву</p><pre><code>- форматирует переданный $var (экземпляр DateTime)
App\Providers\AppServiceProvider

public function boot(): void
{
    Blade::directive('datetime', function (string $expression) {
        return "&lt;?php echo ($expression)->format('m/d/Y H:i'); ?&gt;";
    });
}

- вызвать
@datetime($var)
</code></pre><p>классы и стили по условию</p><pre><code>- класс
@php
    $isActive = false;
    $hasError = true;
@endphp

&lt;span @class([
    'p-4',        // числовой ключ отрисовывается всегда
    'font-bold' => $isActive,
    'text-gray-500' => ! $isActive,
    'bg-red' => $hasError,
])&gt;&lt;/span&gt;

&lt;span class="p-4 text-gray-500 bg-red"&gt;&lt;/span&gt;

- стиль
@php
    $isActive = true;
@endphp

&lt;span @style([
    'background-color: red',
    'font-weight: bold' => $isActive,
])&gt;&lt;/span&gt;

&lt;span style="background-color: red; font-weight: bold;"&gt;&lt;/span&gt;
</code></pre><p>атрибуты</p><pre><code>@checked
&lt;input
    type="checkbox"
    name="active"
    value="active"
    @checked(old('active', $user->active))
/&gt;

@selected
&lt;select name="version"&gt;
    @foreach ($product->versions as $version)
        &lt;option value="{{ $version }}" @selected(old('version') == $version)&gt;
            {{ $version }}
        &lt;/option&gt;
    @endforeach
&lt;/select&gt;

@disabled
&lt;button type="submit" @disabled($errors->isNotEmpty())&gt;Отправить&lt;/button&gt;

@readonly
&lt;input
    type="email"
    name="email"
    value="email@laravel.com"
    @readonly($user->isNotAdmin())
/&gt;

@required
&lt;input
    type="text"
    name="title"
    value="title"
    @required($user->isAdmin())
/&gt;</code></pre><p>@include подключение дочерних шаблонов (компоненты лучше)</p><pre><code>- включить шаблон
@include('shared.errors')

- включенный шаблон имеет доступ к родительским данным, добавить данные массивом
@include('view.name', ['status' => 'complete'])

- включить шаблон, который может отсутствовать
@includeIf('view.name', ['status' => 'complete'])

- включить шаблон по логическому условию
@includeWhen($boolean, 'view.name', ['status' => 'complete'])
@includeUnless($boolean, 'view.name', ['status' => 'complete'])

- включить первый шаблон из массива
@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])

__DIR__ и __FILE__ ссылаются на расположение кешированного, скомпилированного шаблона.</code></pre><p>@each отрисовка шаблона с коллекцией</p><pre><code>шаблон отрисовывается для каждого элемента в массиве
@each('view.name', $jobs, 'job' 'view.empty')
view.name - шаблон, $jobs - массив, job - текущий элемент массива, view.empty - шаблон если массив пустой</code></pre><p>@once сработает только раз</p><pre><code>@once
    @push('scripts')
        &lt;script&gt;
            // Ваш JavaScript...
        &lt;/script&gt;
    @endpush
@endonce

либо
@pushOnce('scripts')
    &lt;script&gt;
        // Ваш JavaScript...
    &lt;/script&gt;
@endPushOnce

либо
@prependOnce('scripts')
    &lt;script&gt;
        // Ваш JavaScript...
    &lt;/script&gt;
@endPrependOnce</code></pre><p>@php код РНР в шаблоне</p><pre><code>@php
    $counter = 1;
@endphp</code></pre><p>@use импорт класса</p><pre><code>без псевдонима
@use('App\Models\Flight')

с псевдонимом
@use('App\Models\Flight', 'FlightModel')</code></pre><p>отобразить часть страницы только, если пользователь авторизован</p><pre><code>@can('update', $post)
- Текущий пользователь может обновить пост...
@elsecan('create', App\Models\Post::class)
- Текущий пользователь может создавать новые посты...
@else
  ...
@endcan

@cannot('update', $post)
- Текущий пользователь не может обновить пост...
@elsecannot('create', App\Models\Post::class)
- Текущий пользователь не может создавать новые посты...
@endcannot

@canany(['update', 'view', 'delete'], $post)
- Текущий пользователь может обновить, просмотреть или удалить пост ...
@elsecanany(['create'], \App\Models\Post::class)
- Текущий пользователь может создать пост...
@endcanany

тоже самое 
@if (Auth::user()->can('update', $post))
- Текущий пользователь может обновить пост...
@endif

@unless (Auth::user()->can('update', $post))
- Текущий пользователь не может обновить пост...
@endunless</code></pre><p>если для действия не требуется экземпляр модели, то можно указать политику авторизации через класс</p><pre><code>@can('create', App\Models\Post::class)
- Текущий пользователь может создавать посты...
@endcan

@cannot('create', App\Models\Post::class)
- Текущий пользователь не может создавать посты...
@endcannot</code></pre><p>комментарии Blade не включаются в итоговый HTML</p><code>{{-- --}}</code></details><details><summary>Components</summary><p>компоненты - это многоразовые элементы интерфейса, созданые с помощью команды artisan или вручную на основе классов или анонимных функций<br>
и могут содержать:<br>
- другие компоненты, шаблоны и директивы Blade<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- атрибуты, которые могут быть переданы в шаблон<br>
- свойства, которые могут быть доступны из шаблона<br>
- слоты, которые могут быть заполнены другими компонентами или шаблонами<br></p><pre><code>- создать компонент на основе класса
php artisan make:component Alert

- на основе встроенного шаблона
php artisan make:component Alert --inline

- анонимный компонент
php artisan make:component forms.input --view

- отобразить компонент
&lt;x-forms.input /&gt;

- отобразить компонент на основе полученных значения или переменной
// $componentName = "secondary-button";
&lt;x-dynamic-component :component="$componentName" class="mt-4" /&gt;</code></pre><p>- компоненты автоматически обнаруживаются в каталогах app/View/Components и resources/views/components<br>
- если результат метода shouldRender в классе компонента равен false, то компонент не будет отображаться<br></p><pre><code>use Illuminate\Support\Str;

public function shouldRender(): bool
{
    return Str::length($this->message) > 0;
}</code></pre><p>выражения и переменные PHP передавать компоненту через атрибуты c символом : впереди</p><code>&lt;x-alert type="error" :message="$message"/&gt;</code><p>данные компонента, определённые в конструкторе класса как общедоступные свойства будут автоматически доступны в шаблоне компонента</p><pre><code>namespace App\View\Components;
use Illuminate\View\Component;
use Illuminate\View\View;

class Alert extends Component
{
    public function __construct(
        public string $type,
        public string $message,
    ) {}

    public function render(): View
    {
        return view('components.alert');
    }
}

&lt;div class="alert alert-{{ $type }}"&gt;
    {{ $message }}
&lt;/div&gt;</code></pre><p>аргументы конструктора в camelCase, а аргументы в атрибутах HTML в kebab-case</p><pre><code>public function __construct(
    public string $alertType,
) {}
&lt;x-alert alert-type="danger" /&gt;</code></pre><p>при одинаковых именах атрибута и переменной можно сократить</p><pre><code>- сокращенный синтаксис атрибутов...
&lt;x-profile :$userId :$name /&gt;

- эквивалентно...
&lt;x-profile :user-id="$userId" :name="$name" /&gt;</code></pre><p>так как Alpine.js тоже использует префикс :, то добавить ещё : для РНР</p><pre><code>- шаблон Blade
&lt;x-button ::class="{ danger: isDeleting }"&gt;
    Отправить
&lt;/x-button&gt;

- HTML
&lt;button :class="{ danger: isDeleting }"&gt;
    Отправить
&lt;/button&gt;</code></pre><p>в классе компонента можно задать метод</p><pre><code>- в классе
public function isSelected(string $option): bool
{
    return $option === $this->selected;
}

- в шаблоне
&lt;option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}"&gt;
    {{ $label }}
&lt;/option&gt;</code></pre><p>все атрибуты не из конструктора компонента автоматически добавляются в $attributes</p><pre><code>- HTML
&lt;div {{ $attributes }}&gt;
    Содержание компонента...
&lt;/div&gt;</code></pre><p>слияние атрибутов</p><pre><code>- компонент
&lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;
    {{ $message }}
&lt;/div&gt;

- шаблон
&lt;x-alert type="error" :message="$message" class="mb-4"/&gt;

- HTML
&lt;div class="alert alert-error mb-4"&gt;
    содержимое переменной $message
&lt;/div&gt;

либо
&lt;button {{ $attributes->merge(['type' => 'button']) }}&gt;
    {{ $slot }}
&lt;/button&gt;</code></pre><p>фильтрация атрибутов</p><pre><code>- оставит атрибут если true, остальные удалит
{{ $attributes->filter(fn (string $value, string $key) => $key == 'foo') }}

- начинается с
{{ $attributes->whereStartsWith('wire:model') }}

- не начинается с
{{ $attributes->whereDoesntStartWith('wire:model') }}</code></pre><p>проверить есть ли атрибут</p><pre><code>@if ($attributes->has('class'))
    &lt;div&gt;Атрибут class присутствует&lt;/div&gt;
@endif

@if ($attributes->has(['name', 'class']))
    &lt;div&gt;Все указанные атрибуты присутствуют&lt;/div&gt;
@endif

@if ($attributes->hasAny(['href', ':href', 'v-bind:href']))
    &lt;div&gt;Один из указанных атрибутов присутствует&lt;/div&gt;
@endif</code></pre><p>получить атрибут</p><pre><code>- получить значение атрибута
{{ $attributes->get('class') }}

- только по ключу
{{ $attributes->only(['class']) }}

- кроме тех кто с ключом
{{ $attributes->except(['class']) }}
</code></pre><details><summary>Anonymous Components</summary><p>анонимные компоненты - это компоненты, которые не имеют класса и создаются с помощью встроенного шаблона в resources/views/components<br></p><pre><code>resources/views/components/alert.blade.php
- в шаблоне
&lt;x-alert/&gt;

либо
resources/views/components/inputs/button.blade.php
- в шаблоне
&lt;x-inputs.button/&gt;</code></pre><p>компонент из нескольких компонентов</p><pre><code>/resources/views/components/accordion/accordion.blade.php
/resources/views/components/accordion/item.blade.php

&lt;x-accordion&gt;
    &lt;x-accordion.item&gt;
        ...
    &lt;/x-accordion.item&gt;
&lt;/x-accordion&gt;</code></pre><p>переменные и атрибуты</p><pre><code>- в компоненте (info - значение по умолчанию)
@props(['type' => 'info', 'message'])
&lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;
    {{ $message }}
&lt;/div&gt;

- в шаблоне
&lt;x-alert type="error" :message="$message" class="mb-4"/&gt;</code></pre><p>задать свой путь к анонимному компоненту</p><pre><code>- для panel.blade.php
App\Providers\AppServiceProvider
public function boot(): void
{
    Blade::anonymousComponentPath(__DIR__.'/../components');
}
- в шаблоне
&lt;x-panel /&gt;

либо с пространством имен
Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');
- в шаблоне
&lt;x-dashboard::panel /&gt;
</code></pre></details><details><summary>Slots</summary><p>слоты - это области в шаблоне компонента для заполнения другими компонентами или шаблонами, могут быть именованными или анонимными<br>
и содержать:<br>
- другие слоты<br>
- атрибуты и данные, которые могут быть переданы в шаблон<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- свойства, которые могут быть доступны из шаблона<br></p><pre><code>- компонент
&lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;

&lt;div class="alert alert-danger"&gt;
    {{ $slot }}
&lt;/div&gt;

- шаблон
&lt;x-alert&gt;
    &lt;x-slot:title&gt;
        Ошибка сервера
    &lt;/x-slot&gt;

    &lt;strong&gt;Упс!&lt;/strong&gt; Что-то пошло не так!
&lt;/x-alert&gt;</code></pre><p>существует ли контент</p><pre><code>- комментарий считается контентом
&lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;

&lt;div class="alert alert-danger"&gt;
    @if ($slot->isEmpty())
        Это содержимое по умолчанию, если слот пуст.
    @else
        {{ $slot }}
    @endif
&lt;/div&gt;

- без комментария
@if ($slot->hasActualContent())
    В области нет комментариев.
@endif</code></pre><p>доступ к данным и методам класса компонента из слота</p><pre><code>&lt;x-alert&gt;
    &lt;x-slot:title&gt;
        {{ $component->formatAlert('Ошибка сервера') }}
    &lt;/x-slot&gt;

    &lt;strong>Упс!&lt;/strong> Что-то пошло не так!
&lt;/x-alert&gt;</code></pre><p>доступ к атрибутам слота из компонента</p><pre><code>@props([
    'heading',
    'footer',
])

&lt;div {{ $attributes->class(['border']) }}&gt;
    &lt;h1 {{ $heading->attributes->class(['text-lg']) }}&gt;
        {{ $heading }}
    &lt;/h1&gt;

    {{ $slot }}

    &lt;footer {{ $footer->attributes->class(['text-gray-700']) }}&gt;
        {{ $footer }}
    &lt;/footer&gt;
&lt;/div&gt;</code></pre><p>разметка в классе компонента</p><pre><code>public function render(): string
{
    return &lt;&lt;&lt;blade
        &lt;div class="alert alert-danger"&gt;
            {{ $slot }}
        &lt;/div&gt;
    blade;
}
</code></pre></details></details><details><summary>Layouts</summary><p>- макеты - это шаблоны, которые могут содержать другие шаблоны и компоненты, могут быть созданы с помощью команды artisan или вручную<br>
и могут содержать:<br>
- другие макеты, шаблоны и компоненты<br>
- атрибуты, которые могут быть переданы в шаблон<br>
- методы и события, которые могут быть вызваны из шаблона<br>
- свойства, которые могут быть доступны из шаблона<br>
- слоты, которые могут быть заполнены другими компонентами или шаблонами<br></p><pre><code>- resources/views/components/layout.blade.php
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;{{ $title ?? 'Менеджер задач' }}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1>Задачи&lt;/h1&gt;
        &lt;hr/&gt;
        {{ $slot }}
    &lt;/body&gt;
&lt;/html&gt;

- resources/views/tasks.blade.php
&lt;x-layout&gt;
    &lt;x-slot:title&gt;
        Пользовательский заголовок
    &lt;/x-slot&gt;

    @foreach ($tasks as $task)
        &lt;div&gt;{{ $task }}&lt;/div&gt;
    @endforeach
&lt;/x-layout&gt;

- app/routes/web.php
use App\Models\Task;

Route::get('/tasks', function () {
    return view('tasks', ['tasks' => Task::all()]);
});</code></pre><p>наследование</p><pre><code>resources/views/layouts/app.blade.php
&lt;html&gt;
    &lt;head&gt;
        &lt;title>Имя приложения - @yield('title')&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        @section('sidebar')
            Это главная боковая панель.
        @show   // определяет и дополняет секцию

        &lt;div class="container"&gt;
            @yield('content')   // @yield('content', 'Содержимое по умолчанию')
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;

resources/views/child.blade.php
@extends('layouts.app')

@section('title', 'Название страницы')

@section('sidebar')
    @@parent    // для добавления (а не перезаписи) содержимого к боковой панели макета

    &lt;p&gt;Это добавляется к главной боковой панели.&lt;/p&gt;
@endsection

@section('content')
    &lt;p&gt;Это содержимое моей страницы.&lt;/p&gt;
@endsection
</code></pre></details><details><summary>URL creation</summary><p>url используется для генерации URL-адресов приложения</p><code>url("/posts/{$post->id}");  // http://example.com/posts/1</code><p>URL-адрес с запросом</p><pre><code>echo url()->query('/posts', ['search' => 'Laravel']);   // https://example.com/posts?search=Laravel
echo url()->query('/posts?sort=latest', ['search' => 'Laravel']);   // http://example.com/posts?sort=latest&search=Laravel
echo url()->query('/posts?sort=latest', ['sort' => 'oldest']);  // http://example.com/posts?sort=oldest
echo $url = url()->query('/posts', ['columns' => ['title', 'body']]);   // http://example.com/posts?columns%5B0%5D=title&columns%5B1%5D=body
echo urldecode($url);   // http://example.com/posts?columns[0]=title&columns[1]=body</code></pre><p>получить URL</p><pre><code>- получить текущий URL без строки запроса...
echo url()->current();

- получить текущий URL, включая строку запроса...
echo url()->full();

- получить полный URL-адрес предыдущего запроса...
echo url()->previous();

либо через фасад: use Illuminate\Support\Facades\URL;
echo URL::current();</code></pre><p>route помощник генерации URL-адресов для именованных маршрутов</p><pre><code>Route::get('/post/{post}', function (Post $post) {})->name('post.show');
echo route('post.show', ['post' => 1]); // http://example.com/post/1

Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {})->name('comment.show');
echo route('comment.show', ['post' => 1, 'comment' => 3]);  // http://example.com/post/1/comment/3

- что не является параметром машрута - является запросом
echo route('post.show', ['post' => 1, 'search' => 'rocket']);   // http://example.com/post/1?search=rocket

- автоматически извлечь ключ маршрута из модели
route('post.show', ['post' => $post]);</code></pre><p>подписанные URL: URL-адрес с хешом «подписи», добавленный к строке запроса, чтобы защититься от манипуляций с URL-адресами</p><pre><code>- отказаться от подписки
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);

- исключить домен из хеша подписанного URL
return URL::signedRoute('unsubscribe', ['user' => 1], absolute: false);

- временный подписанный URL-адрес
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);

- проверка подлиности подписанного URL
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
    if (! $request->hasValidSignature()) {
        abort(401);
    }
})->name('unsubscribe');

- игнорировать page и order при проверке подлиности подписанного URL
if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {
    abort(401);
}</code></pre><p>signed из Illuminate\Routing\Middleware\ValidateSignature - middleware для проверки подлиности подписанного URL</p><pre><code>Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed');

- без включения домена в хеш подписи
Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed:relative');</code></pre><p>настроить в bootstrap/app.php свой ответ на недействительную подпись URL</p><pre><code>use Illuminate\Routing\Exceptions\InvalidSignatureException;

->withExceptions(function (Exceptions $exceptions) {
    $exceptions->render(function (InvalidSignatureException $e) {
        return response()->view('errors.link-expired', status: 403);
    });
})</code></pre><p>URL для действий контроллера</p><pre><code>use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);

- с параметрами для метода контроллера
$url = action([UserController::class, 'profile'], ['id' => 1]);</code></pre><p>URL::defaults определяет значение по умолчанию для параметра запроса</p><pre><code>- создать middleware
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\URL;
use Symfony\Component\HttpFoundation\Response;

class SetDefaultLocaleForUrls
{
    /**
    * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
    */
    public function handle(Request $request, Closure $next): Response
    {
        URL::defaults(['locale' => $request->user()->locale]);

        return $next($request);
    }
}

- дать вbootstrap/app.php приоритет выполнения middleware
->withMiddleware(function (Middleware $middleware) {
    $middleware->prependToPriorityList(
        before: \Illuminate\Routing\Middleware\SubstituteBindings::class,
        prepend: \App\Http\Middleware\SetDefaultLocaleForUrls::class,
    );
})

Route::get('/{locale}/posts', function () {})->name('post.index');
}
</code></pre></details><details> <summary>Vite</summary><p>- Vite - это инструмент сборки на JavaScript и CSS, использует ES-модули и поддерживает:<br>
- HMR (горячая перезагрузка модулей) для быстрой разработки<br>
- TypeScript, JSX, CSS и другие языки<br>
- плагины для расширения функциональности<br>
- SSR (серверный рендеринг) для создания приложений с серверным рендерингом<br>
- предварительную выборку, предзагрузку и кеширование ресурсов для оптимизации загрузки<br></p><pre><code>- vite.config.js
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';

export default defineConfig({
    plugins: [
        laravel({
            input: [
                'resources/css/app.css',
                'resources/js/app.js',
            ],
            refresh: true,
        }),
    ],
});</code></pre><p>vite.config.ts: resources/js/app.tsx - точка входа в приложение</p><pre><code>- Blade
laravel([
    'resources/css/app.css',
    'resources/js/app.js',
]),

- SPA
laravel({
    input: 'resources/js/app.tsx',  // точка входа vite в приложение
    ssr: 'resources/js/ssr.tsx',    // точка входа ssr в приложение
    refresh: true,  // обновит браузер при сохранении файла
}),</code></pre><p>в SPA-приложении импорт CSS через resources/js/app.tsx</p><code>import '../css/app.css';</code><p>в корневом шаблоне</p><pre><code>- Blade
&lt;head&gt;
    @vite(['resources/css/app.css', 'resources/js/app.js'])
&lt;/head&gt;

- SPA
&lt;head&gt;
    @viteReactRefresh
    @vite(['resources/js/app.jsx'])
&lt;/head&gt;</code></pre><p>подключить ресурсы в точку входа vite для обработки</p><pre><code>- в resources/js/app.js
import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

- в Blade-шаблоне
&lt;img src="{{ Vite::asset('resources/images/logo.png') }}"&gt;</code></pre><p>создать макрос</p><pre><code>- в App\Providers\AppServiceProvider
public function boot(): void
{
    Vite::macro('image', fn (string $asset) => $this->asset("resources/images/{$asset}"));
}

- в шаблоне
&lt;img src="{{ Vite::image('logo.png') }}" alt="Laravel Logo"&gt;</code></pre><p>предварительная выборка рессурсов при загрузке приложения в App\Providers\AppServiceProvider</p><pre><code>public function boot(): void
{
    Vite::prefetch(concurrency: 3); // максимум три параллельные загрузки вместе с загрузкой страницы
}

public function boot(): void
{
    Vite::prefetch(); // загрузить всё параллельно с загрузкой страницы
}</code></pre><p>предзагрузка в ручную по событию</p><pre><code>- в App\Providers\AppServiceProvider
public function boot(): void
{
    Vite::prefetch(event: 'vite:prefetch');
}

- в шаблоне отправить событие для загрузки русурсов через три секунды после загрузки страницы
&lt;script&gt;
    addEventListener('load', () => setTimeout(() => {
        dispatchEvent(new Event('vite:prefetch'))
    }, 3000))
&lt;/script&gt;</code></pre><p>отключить vite в тестах</p><pre><code>- в тесте
test('without vite example', function () {
    $this->withoutVite();
});

- для всех тестов в базовом классе TestCase
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;

abstract class TestCase extends BaseTestCase
{
    protected function setUp(): void
    {
        parent::setUp();
</code></pre></details><details> <summary>Livewire</summary><details><summary>Routes</summary><p>просмотреть список роутов</p><code>php artisan route:list --except-vendor</code><p>просто выдать страницу без дополнительных действий</p><code>Route::view('/', 'home');</code><pre><code>code Route::view('/', 'welcome')->name('home');

<span>welcome.blade.php</span>
&lt;nav&gt;
  &lt;a href="{{ route('home') }}"&gt;Home&lt;/a&gt;
&lt;/nav&gt;
</code></pre><pre><code>Route::get('test', function () {
  $job = Job::first();
  TranslateJob::dispatch($job);
  return 'Done';
});
</code></pre><p>wildcard {job} and parametr of function $job<br>
type of parametr function (Job $job)<br>
ларавель понимает, что нужен объект модели Job c данными из таблицы<br>
этот объект он отбирает из БД по значению {job}<br>
по умолчанию {job} - это id, но можно задать своё значение {job:name}</p><pre><code>Route::get('/jobs/{job}', function (Job $job) {
  return view('jobs.show', ['job' => $job]);
});
</code></pre><p>вызываю метод index из класса контроллера JobController при переходе на /jobs</p><code>Route::get('/jobs', [JobController::class, 'index']);</code><p>В livewire можно укзавыть роут на класс компонента</p><pre><code>Route::get('/posts', ShowPosts::class);
Route::get('/posts/create', CreatePost::class);</code></pre><p>для этого необходимо создать шаблон для всех компонентов<br>
(components.layouts.app.blade.php)</p><code>./sail artisan livewire:layout</code><p>объединяю роуты c одним и тем же контроллером</p><pre><code>Route::controller(JobController::class)->group( function()
{
  Route::get('/jobs', 'index');
  Route::get('/jobs/create', 'create');
  Route::get('/jobs/{job}', 'show');
  Route::get('/jobs/{job}/edit', 'edit');
  Route::post('/jobs', 'store');
  Route::patch('/jobs/{job}', 'update');
  Route::delete('/jobs/{job}', 'destroy');
});
</code></pre><p>сформирует для методов класса контроллера роуты:
jobs.index <span>- показать всё списком</span>
jobs.show <span>- показать один</span>
jobs.create <span>- создать</span>
jobs.edit <span>- редактировать</span>
jobs.store <span>- сохранить</span>
jobs.update <span>- обновить</span>
jobs.destroy <span>- уничтожить</span>
названия методов контроллера - это дефолтные названия ларавел.</p><pre><code>Route::resource('uri', controller);
Route::resource('jobs', JobController::class);</code></pre><p>можно форимровать роуты выборочно</p><pre><code>Route::resource('jobs', JobController::class, [
  'only' => ['index', 'show']
]);
Route::resource('jobs', JobController::class, [
  'except' => ['edit']
]);
</code></pre></details><details><summary>View</summary><p>vite компелирует, кеширует и отслеживает изменения в папке resources<br>
resources/views/components/layout.blade.php создаю компонент layout<br>
вставляю компонент на страницу</p><code>&lt;x-layout&gt;&lt;/x-layout&gt;</code><p>подключил лого</p><code>&lt;img src="{{ Vite::asset('resources/images/logo.svg') }}" alt=""&gt;</code><p>подключить стили и скрипты</p><code>@vite(['resources/css/app.css', 'resources/js/app.js'])</code><p>в SPA-приложении css поключаем в js-файле, поэтому подключаем только js</p><code>@vite('resources/js/app.js')</code><p>resources/js/app.js запихиваю картинки глобально, чтобы их учесть при npm run build</p><pre><code>import.meta.glob([
  '../images/**',
  '../fonts/**',
]);</code></pre><p>в файле .env указать место хранения загружаемых файлов<br>
варианты значений в файле config/filesystems.php</p><code>FILESYSTEM_DISK=public</code><p>при загрузке изображения оно будет сохранено в storage/app/public<br>
чтобы оно отображалось сделать ссылку:</p><code>php artisan storage:link</code><p>Встроенные шаблоны для писем</p><code>./sail artisan vendor:publish --tag=laravel-mail</code><details><summary>Localization</summary><p>Создать папку для переводов</p><code>php artisan lang:publish</code><p>Скопировать папку en, переименовать в ru и вставить переводы в файлах</p></details><details><summary>Component</summary><details><summary>Component styles</summary><p>разбить макет на компоненты<br>
в компоненте задать класс по умолчанию c общими настройками компонента</p><pre><code>@php
  $classes = 'className1 className2';
@endphp

&lt;div {{ $attributes(['class' => $classes]) }}&gt;
  {{ $slot }}
&lt;/div&gt;
</code></pre></details><details><summary>Component properties</summary><p>задаю свойства компонента, которые можно указывать в вёрстке и менять вид компонента</p><pre><code>@props(['size' => 'base'])

@php
  $classes = "className1 className2";
  if ($size === 'base') {
    $classes .= " className3";
  }
  if ($size === 'small') {
    $classes .= " className4";
  }
@endphp

&lt;a href="#" class="{{ $classes }}"&gt;{{ $slot }}&lt;/a&gt;
</code></pre></details><details><summary>Create component Livewire</summary><p>Компонент имеет доступ к публичным свойствам и методам своего класса</p><pre><code>php artisan make:livewire ComponentName
<span>or</span>
php artisan make:livewire component-name
</code></pre><p>Создать компонент в папке</p><pre><code>php artisan make:livewire FolderName\\ComponentName
<span>or</span>
php artisan make:livewire folder-name.component-name
</code></pre><p>Создать компонент с тестом</p><code>code ./sail artisan make:livewire create-post --pest</code><p>Создать шаблон для компонентов livewire</p><code>./sail artisan livewire:layout</code><p>Выбирать разные шаблоны на весь класс</p><pre><code><Layout layouts.app></Layout> 
class CreatePost extends Component
{
    // ...
}</code></pre><p>Выбирать разные шаблоны на методе</p><pre><code><Layout layouts.app></Layout> 
public function render()
{
  return view('livewire.create-post');
}</code></pre><p>Выбирать разные шаблоны динамически</p><pre><code>public function render()
{
  return view('livewire.create-post')
    ->layout('layouts.app'); 
}</code></pre><p>Через @yield('content') указываю файл шаблона</p><pre><code>&lt;body&gt;
  @yield('content')
&lt;/body&gt;</code></pre><p>Метод render() можно не указывать<br>
Livewire будет автоматически выводить view с названием как у класса
</p><p>В класс User.php добавить подстановку title в шаблон</p><code>use Livewire\Attributes\Title;
<Title title></Title></code><p>Подстановка title динамически</p><pre><code>public function render()
{
  return view('livewire.create-post')
    ->title('Create Post'); 
}
</code></pre><p>задаю свойства livewire компонента в классе</p><code>public $title = 'Post title...';</code><p>задаю свойства livewire компонента в виде</p><code><h1>Title: "{{ $title }}"</h1></code><p>Дополнительные свойства при рендере в классе</p><code>return view('livewire.create-post')->with([
  'author' => Auth::user()->name,
]);
</code><p>Дополнительные свойства при рендере в виде</p><code>Author: {{ $author }}</code><p>При выводе в любом цикле всегда указывать ключ</p><pre><code>@foreach ($posts as $post)
  &lt;livewire:post-item :$post :key="$post->id"&gt;
  @livewire(PostItem::class, ['post' => $post], key($post->id))
@endforeach
</code></pre><p>Привязка ввода к свойству класса</p><code>&lt;input type="text" id="title" wire:model="title"&gt;</code><p>Привязка ввода к методу класса</p><pre><code>&lt;form wire:submit="save"&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;
</code></pre><p>Получить значения и очистить поля ввода</p><pre><code>class ManageTodos extends Component
{
  public $todos = [];
  public $todo = '';
  public function addTodo()
  {
    $this->todos[] = $this->todo;
    $this->reset('todo'); 
  }
}</code></pre><p>Получить значения и очистить поля ввода</p><pre><code>class ManageTodos extends Component
{
  public $todos = [];

  public $todo = '';

  public function addTodo()
  {
    $this->todos[] = $this->pull('todo');
  }
}
// The same as $this->all() and $this->reset();
$this->pull();

// The same as $this->only(...) and $this->reset(...);
$this->pull(['title', 'content']);
</code></pre><p>Только авторизированный пользователь может изменить данные</p><pre><code>public function update()
{
  $post = Post::findOrFail($this->id);
  $this->authorize('update', $post); 
  $post->update(...);
}</code></pre><p>Изменение свойства возможно только внутри класса</p><pre><code>class UpdatePost extends Component
{
  <Locked></Locked> 
  public $id;
}</code></pre><p>Свойства Eloquent моделей по умолчанию изменять возможно только внутри класса</p><pre><code>class UpdatePost extends Component
{
  public Post $post; 
  public $title;
  public $content;
  
  public function update()
  {
    $this->post->update([
      'title' => $this->title,
      'content' => $this->content,
    ]);
    session()->flash('message', 'Post updated successfully!');
  }
}
</code></pre><p>Свойство <Computed></Computed> кеширует запрошенные данные,<br>
чтобы отправлять каждый раз новый запрос.<br>
Обращаться к свойству через объект $this->todos</p><pre><code>use Livewire\Attributes\Computed;

<Computed></Computed>
public function todos()
{
  return Auth::user()
    ->todos()
    ->select(['title', 'content'])
    ->get();
}

public function markAllComplete() 
{
  $this->todos->each->complete();
}
</code></pre><p>Вывод компонента в Blade view</p><code>&lt;livewire:create-post /&gt;</code><p>Вывод компонента в Blade view со значением</p><code>&lt;livewire:create-post title="Initial Title" /&gt;</code><p>Вывод компонента в Blade view с динамическим значением переменной</p><code>&lt;livewire:create-post :title="$initialTitle" /&gt;</code><p>Инициализация переменной в классе при подключении компонента</p><pre><code>class CreatePost extends Component
{
  public $title;
  public function mount($title = null)
  {
    $this->title = $title;
  }
}
</code></pre><p>livewire инициализирует переменную автоматически</p><pre><code>class CreatePost extends Component
{
  public $title;
}
</code></pre><p>Инлайн компонент - это один файл где разметка внутри метода render()</p><code>./sail artisan make:livewire CreatePost --inline</code><p>В routes/web.php добавить</p><pre><code>use App\Livewire\User\User;
Route::get('user', User::class);</code></pre><p>В классе UserCreate.php добавить переход на страницу uri без перезагрузки страницы с сервера</p><code>$this->redirect('/user', navigate: true);</code><p>Свойства и методы формы вынесены в отдельный класс UserForm<br>
В компоненте User объект класса UserForm определён как form<br>
Обращения к свойствам класса UserForm через form<br></p><p>Подключить assets в layout/app.blade.php</p><pre><code>@assets
  &lt;script src="https://cdn.jsdelivr.net/npm/pikaday/pikaday.js" defer&gt;&lt;/script&gt;
  &lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css"&gt;
@endassets

@vite(['resources/css/app.css', 'resources/js/app.js'])
</code></pre><!-- Actions--><p>$refresh - проверяет БД и отображает на странице</p><code>&lt;button type="button" wire:click="$refresh"&gt;...&lt;/button&gt;</code><p>$commit - отслеживает изменения компонета на сервере</p><code>&lt;button type="button" wire:click="$commit"&gt;...&lt;/button&gt;</code><!-- Event listeners--><p>wire:click<br>
wire:submit<br>
wire:keydown<br>
wire:keyup<br>
wire:mouseenter<br>
wire:* - любой текст после wire: может быть названием события<br>
Livewire поддерживает любые событыя браузера, например wire:transitionend<br></p><a href="https://livewire.laravel.com/docs/actions">слушатели событий<br></a><br><p>wire:loading - загрузчик<br>
wire:click="delete({{ $post->id }})" - передать в класс параметр<br>
wire:click="$parent.removePost({{ $post->id }})" - обращаюсь к методу родительского компонента<br>
wire:click="$set('query', '')" - заменил значение свойства query на пустую строку<br>
wire:click="$toggle('sortAsc')" - при каждом нажатии меняет true/false</p><pre><code>&lt;button wire:click="$toggle('sortAsc')"&gt;
  Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}
&lt;/button&gt;</code></pre><p>wire:click="$dispatch('post-deleted')" - срабатывает событие<br>
$event - даёт доступ к событиям JS, например при нажатии enter<br>
передать значение ввода в search() - метод класса компонента</p><code>&lt;input type="text" wire:keydown.enter="search($event.target.value)"&gt;</code><p>При выполнении метода с <Renderless></Renderless> метод render() этого же класса не выполняется,<br>
либо skipRender() внутри метода<br></p><pre><code><Renderless></Renderless> 
public function incrementViewCount()
{
  $this->post->incrementViewCount();
}

public function incrementViewCount()
{
  $this->post->incrementViewCount();
  $this->skipRender(); 
}</code></pre><p>wire:dirty.class="border-yellow" - позволяет менять класс<br>
если значение поля отличается от значения этого поля в БД</p><code>&lt;input type="text" wire:model.blur="title" wire:dirty.class="border-yellow"&gt;</code><p>Пока поле ввода title будет в фокусе, будет Unsaved...<br>
когда фокус уйдёт, значение будет записано в БД и Unsaved... исчезнет</p><pre><code>&lt;input type="text" wire:model.blur="title"&gt;
&lt;div wire:dirty wire:target="title"&gt;Unsaved...&lt;/div&gt;</code></pre><p>Можно выносить части Livewire компонентов в Blade компоненты</p><pre><code>&lt;form wire:submit="save"&gt;
  &lt;x-input-text name="title" wire:model="title" /&gt;
  &lt;x-input-text name="content" wire:model="content" /&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre><p>Blade компонент</p><pre><code>@props(['name'])
&lt;input type="text" name="{{ $name }}" {{ $attributes }}&gt;
&lt;div&gt;
    @error($name) &lt;span class="error"&gt;{{ $message }}&lt;/span&gt; @enderror
&lt;/div&gt;
</code></pre><p>породить событие post-created</p><code>$this->dispatch('post-created', title: $post->title);</code><p>по событию выполнить метод</p><pre><code><On post-created></On> 
public function updatePostList($title) { }</code></pre><p>породить событие post-created с динамическим аттрибутом</p><pre><code>$this->dispatch("post-updated.{$post->id}");

<On post-updated.{post.id}></On></code></pre><p>презагрузить родительский компонент,<br>
если в дочернем компоненте будет событие saved</p><code>&lt;livewire:edit-post @saved="$refresh"&gt;</code><p>вызвать метод close() родительского компонента<br>
если в дочернем компоненте будет saved конткретного postId</p><code>&lt;livewire:edit-post @saved="close($event.detail.postId)"&gt;</code></details></details><details><summary>Validation</summary><p>В основном такая же как в ларавел, но метод validate() применяется на объекте компонента<br>
Метод validate() возвращает массив отвалидированных данных либо массив ошибок</p><pre><code>public function save()
{
  $validated = $this->validate([ 
    'title' => 'required|min:3',
    'content' => 'required|min:3',
  ]);
  Post::create($validated);
  return redirect()->to('/posts');
}</code></pre><p>В форме ввода не фронте отобразить ошибку валидации с помощью<br>
директивы @error(), по ключу title выводиться значение $message</p><pre><code>&lt;input type="text" wire:model="title"&gt;
&lt;div&gt;@error('title') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Задать правила валидации можно разными способами</p><pre><code><span>методом validate()</span>
$validated = $this->validate([
  <span>массивом</span>
  'name' => ['required', 'min:2', 'max:30'],
  <span>строкой через разделитель</span>
  'email' => 'required|email|max:30',
  'password' => 'required|min:6',
]);

<span>параметром <Validate></Validate></span>
<span>отслеживает изменение значений</span>
<span>использует стандартные валидаторы ларавел</span>
<span>свой текст сообщения</span>
<Validate required message: Имя обязательно></Validate>
<span>своё имя поля в сообщении</span>
<Validate min:2 as: Name></Validate>
<Validate max:30></Validate>
public string $name;

<span>написать свои правила валидации</span>
protected function rules(): array
{
  return [
    'name' => ['required', 'min:2', 'max:30'],
    'email' => 'required|email|max:30',
    'password' => 'required|min:6',
  ];
}

<span>написать свои тексты сообщений об ошибке</span>
protected function messages(): array
{
  return [
    <span>название поля.валидатор => текст ошибки</span>
    'name.required' => 'Имя обязательно!',
    'name.min' => 'Имя должно быть длиннее!',
    'email.required' => 'Введите почту!',
    'password.required' => 'Пароль обязателен!',
  ];
}</code></pre><p>Если правила валидации заданы параметром <Validate></Validate><br>
или методом rules(),<br>
то метод validate() вызываем без параметров</p><code>$validated = $this->validate();</code><p>Создаю пользователя в БД</p><code>User::create($validated);</code><p>wire:model.blur="name" - real-time validation<br>
срабатывает по событию либо <dfn>.live</dfn> либо <dfn>.blur</dfn><br>
работает при использовании параметра валидирования <Validate></Validate><br>
wire:model.live="name" - отправляет на сервер введенный знак сразу<br>
wire:model.live.debounce="name" - отправляет на сервер введенное значение через 200мс после последнего нажатия<br>
wire:model.live.debounce.5ms="name" - отправляет на сервер введенное значение через 5мс после нажатия<br>
</p></details><details><summary>Form</summary><p>B компоненте создаю форму и меняю действие по умолчанию на вызов метода save из класса<br>
Форма вызывает метод обработки при надатии на enter или на кнопку Save<br>
B полях ввода данных привязываю данные к свойствам компонента<br>
Свойство компонента wire:model привязывает к полю ввода свойство класса wire:model="name"<br></p><pre><code>&lt;form wire:submit.prevent="save"&gt;
  &lt;input type="text" wire:model="name"&gt;
  &lt;input type="email" wire:model="email"&gt;
  &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</code></pre><p>B методе сохранения данных вызываю метод валидации данных<br>
Если данные валидны, то сохраняю данные в БД<br>
Если данные не валидны, то вывожу ошибку</p><pre><code>public function save()
{
  $validated = $this->validate([
    'name' => 'required|min:3',
    'email' => 'required|email',
  ]);
  User::create($validated);
}</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;
&lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;
&lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;</code></pre><p>Вывести ошибку валидации можно c помощью директивы @error()<br>
По ключу name выводится значение $message</p><pre><code>&lt;input type="text" wire:model="name"&gt;</code></pre><p>Получить все данные формы</p><code>$this->all();</code><p>Получить данные выборочных полей</p><code>$this->only(['name', 'email'])</code><p>Метод pull() - это метод only() + reset()<br>
Заберёт из формы данные полей name и email<br>
и очистит поля формы name и email</p><code>$this->pull(['name', 'email'])</code><p>заберёт из формы все данные и очистит форму</p><code>$this->pull();</code><p>Создать класс формы
Создаст app/Livewire/Forms/FormName.php</p><code>php artisan livewire:form FormName</code><p>При создании компонентов CreatePost, UpdatePost и т.д.
в классах компонентов будут вызываться методы и свойства класса FormName.php.
T.e. все свойства и методы формы в одном классе и исспользуются разными компонентами.
Для доступа к свойствам и методам калсса формы в классе компонента создаётся её объект form
и обращение к свойствам и методам через объект.
B классе компонента:</p><pre><code>public UserForm $form;
public function save()
{
    $this->form->saveUser();
}</code></pre><p>B шаблоне компонента:</p><code>wire:model="form.name"</code></details><details><summary>Events</summary><p>События позволяю прослушивать события в другом компоненте.
Сгенерировать событие: метод dispatch()</p><code>$this->dispatch('eventname');
<span>or</span>
$this->dispatch('eventname', title: $post->title);</code><p>В другом (других) компоненте добавить слушателя события</p><code>use Livewire\Attributes\On;
<On eventname></On>
public function updatePost($title) {}
</code></details></details></details></details><details><summary>Data</summary><details><summary>Encryption</summary><p>- шифрование - это процесс преобразования данных в неразборчивый вид с помощью алгоритма шифрования<br>
- дешифрование - это процесс преобразования зашифрованных данных в исходный вид с помощью алгоритма дешифрования<br>
- Laravel использует библиотеку OpenSSL и Sodium для шифрования и дешифрования данных<br>
- ключ шифрования хранится в переменной окружения APP_KEY в .env файле<br>
- параметр key в config/app.php устанавливается через APP_KEY в .env<br>
- ключ шифрования должен быть уникальным для каждого приложения случайным набором символов длинной 32 байта или 256 бит и защищёным от доступа посторонних лиц<br>
- драйверы шифрования: bcrypt, argon, argon2id, scrypt, md5, sha1, sha256, sha512, whirlpool, ripemd160, tiger1600, haval1600, gost, gost-crypto<br> </p><pre><code>- сгенерировать ключ
php artisan key:generate</code></pre><p>- при изменении ключа все сеансы аутентификации пользователей будут завершены.
- для плавной смены ключа есть предыдущие ключи шифрования указать в переменной окружения APP_PREVIOUS_KEYS</p><pre><code>APP_KEY="base64:J63qRTDLub5NuZvP+kb8YIorGS6qFYHKVo6u7179stY="
APP_PREVIOUS_KEYS="base64:2nLsGFGzyoae2ax3EF2Lyq/hH6QghBGLIq5uL+Gp8/w="</code></pre><p>зашифровать значение</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
class DigitalOceanTokenController extends Controller
{
  public function store(Request $request): RedirectResponse
  {
    $request->user()->fill([
      'token' => Crypt::encryptString($request->token),
    ])->save();
    return redirect('/secrets');
  }
}</code></pre><p>расшифровать значения</p><pre><code>use Illuminate\Contracts\Encryption\DecryptException;
use Illuminate\Support\Facades\Crypt;
try {
    $decrypted = Crypt::decryptString($encryptedValue);
} catch (DecryptException $e) { }
</code></pre></details><details><summary>Hashing</summary><p>хеширование - это необратимый процесс преобразования данных в неразборчивый вид с помощью алгоритма хеширования,<br>
используется для хранения паролей и проверки целостности, подлинности, идентичности, уникальности, безопасности, доступности, конфиденциальности данных<br>
- Laravel использует библиотеку Hash, Argon2, Bcrypt, Argon2id для хеширования данных<br>
- драйвер хеширования bcrypt, argon и argon2id указан в переменной HASH_DRIVER в .env<br>
- HASH_VERIFY в .env: true - сверять алгоритм хеширования пароля с установленным, false - любой алгоритм хеширования<br>
- чтобы настроить все параметры драйвера хеширования нужно опубликовать полный файл конфигурации хеширования<br></p><code>php artisan config:publish hashing</code><p>хеширование паролей</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;

class PasswordController extends Controller
{
    /**
    * Обновить пароль пользователя.
    */
    public function update(Request $request): RedirectResponse
    {
        // Проверить длину нового пароля...
        $request->user()->fill([
            'password' => Hash::make($request->newPassword)
        ])->save();

        return redirect('/profile');
    }
}</code></pre><p>коэффициент работы Bcrypt</p><pre><code>$hashed = Hash::make('password', [
    'rounds' => 12,
]);</code></pre><p>коэффициент работы Argon2</p><pre><code>$hashed = Hash::make('password', [
    'memory' => 1024,
    'time' => 2,
    'threads' => 2,
]);</code></pre><p>сверить хеш</p><pre><code>if (Hash::check('plain-text', $hashedPassword)) {
    // Пароли совпадают...
}</code></pre><p>проверить нужно ли повторно хешировать</p><pre><code>if (Hash::needsRehash($hashed)) {
    $hashed = Hash::make('plain-text');
}
</code></pre></details><details> <summary>Password Reset</summary><p>в App\Models\User использовать</p><pre><code>Illuminate\Notifications\Notifiable
Illuminate\Contracts\Auth\CanResetPassword</code></pre><p>- токен сброса пароля в 0001_01_01_000000_create_users_table.php<br>
- указать в bootstrap/app.php trustHosts - отвечать только на запросы указанных хостов<br>
- форма запроса ссылки сброса пароля с полем для email<br></p><pre><code>Route::get('/forgot-password', function () {
    return view('auth.forgot-password');
})->middleware('guest')->name('password.request');</code></pre><p>сверить почту и отправить на неё ссылку</p><pre><code>use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;

Route::post('/forgot-password', function (Request $request) {
    $request->validate(['email' => 'required|email']);
    $status = Password::sendResetLink(
        $request->only('email')
    );
    return $status === Password::ResetLinkSent
                ? back()->with(['status' => __($status)])
                : back()->withErrors(['email' => __($status)]);
})->middleware('guest')->name('password.email');</code></pre><p>форма ввода нового пароля, после перехода по ссылке сброса пароля</p><pre><code>Route::get('/reset-password/{token}', function (string $token) {
    return view('auth.reset-password', ['token' => $token]);
})->middleware('guest')->name('password.reset');

- проверка входящего запроса и обновление пароля пользователя в базе данных
use App\Models\User;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;

Route::post('/reset-password', function (Request $request) {
    $request->validate([
        'token' => 'required',
        'email' => 'required|email',
        'password' => 'required|min:8|confirmed',
    ]);
    $status = Password::reset(
        $request->only('email', 'password', 'password_confirmation', 'token'),
        function (User $user, string $password) {
            $user->forceFill([
                'password' => Hash::make($password)
            ])->setRememberToken(Str::random(60));

            $user->save();

            event(new PasswordReset($user));
        }
    );
    return $status === Password::PasswordReset
                ? redirect()->route('login')->with('status', __($status))
                : back()->withErrors(['email' => [__($status)]]);
})->middleware('guest')->name('password.update');</code></pre><p>удалить просроченные токены</p><pre><code>php artisan auth:clear-resets

- для автоматизации добавить в планировщик
use Illuminate\Support\Facades\Schedule;
Schedule::command('auth:clear-resets')->everyFifteenMinutes();</code></pre><p>изменить URL-адрес ссылки для сброса пароля</p><pre><code>- в App\Providers\AppServiceProvider
use App\Models\User;
use Illuminate\Auth\Notifications\ResetPassword;

public function boot(): void
{
    ResetPassword::createUrlUsing(function (User $user, string $token) {
        return 'https://example.com/reset-password?token='.$token;
    });
}</code></pre><p>свой вариант уведомления для отправки пользователю ссылки для сброса пароля</p><pre><code>use App\Notifications\ResetPasswordNotification;

/**
* Отправить пользователю уведомление о сбросе пароля.
*
* @param  string  $token
*/
public function sendPasswordResetNotification($token): void
{
    $url = 'https://example.com/reset-password?token='.$token;

    $this->notify(new ResetPasswordNotification($url));
}
</code></pre></details><details><summary>Request creation</summary><p>- Конфигурация баз данных в config/database.php
- Параметры конфигурации определяются значениями переменных окружения в .env
- Фасад DB содержит методы для каждого типа запроса: select, update, insert, delete, и statement.</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;

class UserController extends Controller
{
    /**
    * Показать список всех пользователей приложения.
    */
    public function index(): View
    {
        $users = DB::select('select * from users where active = ?', [1]);

        return view('user.index', ['users' => $users]);
    }
}</code></pre><p>select всегда возвращает массив</p><pre><code>use Illuminate\Support\Facades\DB;

$users = DB::select('select * from users');
foreach ($users as $user) {
    echo $user->name;
}</code></pre><p>чтобы получить значение в виде числа</p><pre><code>$burgers = DB::scalar(
    "select count(case when food = 'burger' then 1 end) as burgers from menu"
);</code></pre><p>получить все наборы результатов, возвращенных хранимой процедурой</p><pre><code>[$options, $notifications] = DB::selectResultSets(
    "CALL get_user_options_and_notifications(?)", $request->user()->id
);</code></pre><p>связывания параметров, используя именованные привязки</p><code>$results = DB::select('select * from users where id = :id', ['id' => 1]);</code><p>insert</p><pre><code>use Illuminate\Support\Facades\DB;
DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);</code></pre><p>update</p><pre><code>use Illuminate\Support\Facades\DB;
$affected = DB::update(
    'update users set votes = 100 where name = ?',
    ['Anita']
);</code></pre><p>delete</p><pre><code>use Illuminate\Support\Facades\DB;
$deleted = DB::delete('delete from users');</code></pre><p>запрос общего типа</p><code>DB::statement('drop table users');</code><p>запрос SQL без привязки каких-либо значений</p><code>DB::unprepared('update users set votes = 100 where name = "Dries"');</code><p>Если в config/database.php несколько соединений, то получить доступ к соединению с помощью метода connection</p><pre><code>use Illuminate\Support\Facades\DB;
$users = DB::connection('sqlite')->select(/* ... */);</code></pre><p>получить доступ к базовому экземпляру PDO текущего соединения</p><code>$pdo = DB::connection()->getPdo();</code><p>слушатель SQL-запроса</p><pre><code>- в App\Providers\AppServiceProvider.php
namespace App\Providers;
use Illuminate\Database\Events\QueryExecuted;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
    * Регистрация любых служб приложения.
    */
    public function register(): void
    {
        // ...
    }

    /**
    * Загрузка любых служб приложения.
    */
    public function boot(): void
    {
        DB::listen(function (QueryExecuted $query) {
            // $query->sql;
            // $query->bindings;
            // $query->time;
            // $query->toRawSql();
        });
    }
}</code></pre><p>вызвать функцию когда время выполнения запроса дольше указанного</p><pre><code>- в App\Providers\AppServiceProvider.php
namespace App\Providers;
use Illuminate\Database\Connection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
use Illuminate\Database\Events\QueryExecuted;

class AppServiceProvider extends ServiceProvider
{
    /**
    * Регистрация любых служб приложения.
    */
    public function register(): void
    {
        // ...
    }

    /**
    * Загрузка любых сервисов приложения.
    */
    public function boot(): void
    {
        DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) {
            // Уведомить команду разработчиков...
        });
    }
}</code></pre><p>выполнение набора операций в транзакции</p><pre><code>use Illuminate\Support\Facades\DB;
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
});

- либо с количеством попыток при взаимоблокировке
use Illuminate\Support\Facades\DB;
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
}, 5);</code></pre><p>транзакция вручную</p><pre><code>use Illuminate\Support\Facades\DB;

- начать транзакцию
DB::beginTransaction();

- откатить транзакцию
DB::rollBack();

- зафиксировать транзакцию
DB::commit();</code></pre><p>подключиться к базе данных</p><pre><code>php artisan db

либо указать имя соединения
php artisan db mysql</code></pre><p>просмотр базы данных</p><pre><code>php artisan db:show

либо с именем соединения
php artisan db:show --database=pgsql</code></pre><p>указать количество строк и представления для просмотра</p><code>php artisan db:show --counts --views</code><p>проверка базы данных</p><pre><code>use Illuminate\Support\Facades\Schema;

$tables = Schema::getTables();
$views = Schema::getViews();
$columns = Schema::getColumns('users');
$indexes = Schema::getIndexes('users');
$foreignKeys = Schema::getForeignKeys('users');</code></pre><p>проверить соединение с базой данных</p><code>$columns = Schema::connection('sqlite')->getColumns('users');</code><p>обзор отдельной таблицы</p><code>php artisan db:table users</code><p>мониторинг баз данных</p><pre><code>- мониторить соединения mysql и pgsql каждую минуту и отправить событие Illuminate\Database\Events\DatabaseBusy при количестве открытых соединений больше 100
php artisan db:monitor --databases=mysql,pgsql --max=100

- слушать событие Illuminate\Database\Events\DatabaseBusy в App\Providers\AppServiceProvider
use App\Notifications\DatabaseApproachingMaxConnections;
use Illuminate\Database\Events\DatabaseBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;

/**
* Запуск любых служб приложения.
*/
public function boot(): void
{
    Event::listen(function (DatabaseBusy $event) {
        Notification::route('mail', 'dev@example.com')
                ->notify(new DatabaseApproachingMaxConnections(
                    $event->connectionName,
                    $event->connections
                ));
    });
}</code></pre><p>получить все строки таблицы</p><pre><code>namespace App\Http\Controllers;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;

class UserController extends Controller
{
    /**
    * Показать список всех пользователей приложения.
    */
    public function index(): View
    {
        $users = DB::table('users')->get();

        return view('user.index', ['users' => $users]);
    }
}</code></pre><p>получить доступ к значению каждого столбца</p><pre><code>use Illuminate\Support\Facades\DB;
$users = DB::table('users')->get();
foreach ($users as $user) {
    echo $user->name;
}</code></pre><p>получить одну строку или один столбец</p><pre><code>$user = DB::table('users')->where('name', 'John')->first();
return $user->email;

либо если строки может не быть
$user = DB::table('users')->where('name', 'John')->firstOrFail();</code></pre><p>получить одно значение из строки</p><code>$email = DB::table('users')->where('name', 'John')->value('email');</code><p>получить одну строку по значению столбца id</p><code>$user = DB::table('users')->find(3);</code><p>получить значения одного столбца в виде коллекции</p><pre><code>use Illuminate\Support\Facades\DB;
$titles = DB::table('users')->pluck('title');
foreach ($titles as $title) {
    echo $title;
}</code></pre><p>получить значения одного столбца в виде коллекции с ключами из столбца name</p><pre><code>$titles = DB::table('users')->pluck('title', 'name');
foreach ($titles as $name => $title) {
    echo $title;
}</code></pre><p>извлекать данные частями</p><pre><code>use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    foreach ($users as $user) { }
});</code></pre><p>остановить обработку после получения части данных</p><pre><code>DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    return false;
});</code></pre><p>при изменении данных одновременно с получением по частям</p><pre><code>DB::table('users')->where('active', false)
    ->chunkById(100, function (Collection $users) {
        foreach ($users as $user) {
            DB::table('users')
                ->where('id', $user->id)
                ->update(['active' => true]);
        }
    });</code></pre><p>сгруппировать логически условия запроса</p><pre><code>DB::table('users')->where(function ($query) {
    $query->where('credits', 1)->orWhere('credits', 2);
})->chunkById(100, function (Collection $users) {
    foreach ($users as $user) {
        DB::table('users')
          ->where('id', $user->id)
          ->update(['credits' => 3]);
    }
});</code></pre><p>метод lazy() возвращает данные по частям в виде экземпляра LazyCollection</p><pre><code>use Illuminate\Support\Facades\DB;
DB::table('users')->orderBy('id')->lazy()->each(function (object $user) { });</code></pre><p>при изменении данных одновременно с получением по частям использовать методы lazyById или lazyByIdDesc</p><pre><code>DB::table('users')->where('active', false)
    ->lazyById()->each(function (object $user) {
        DB::table('users')
            ->where('id', $user->id)
            ->update(['active' => true]);
    });</code></pre><p>построитель запросов также содержит методы count, max, min, avg, и sum</p><pre><code>use Illuminate\Support\Facades\DB;
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');

либо
$price = DB::table('orders')
                ->where('finalized', 1)
                ->avg('price');</code></pre><p>проверить существование записей</p><pre><code>if (DB::table('orders')->where('finalized', 1)->exists()) { }

if (DB::table('orders')->where('finalized', 1)->doesntExist()) { }</code></pre><p>указать собственное выражение SELECT для запроса</p><pre><code>use Illuminate\Support\Facades\DB;
$users = DB::table('users')
            ->select('name', 'email as user_email')
            ->get();</code></pre><p>вернуть уникальные результаты</p><code>$users = DB::table('users')->distinct()->get();</code><p>добавить столбец к существующему выражению SELECT</p><pre><code>$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();</code></pre><p>cырые sql-выражения</p><pre><code>use Illuminate\Support\Facades\DB;

$users = DB::table('users')
            ->select(DB::raw('count(*) as user_count, status'))
            ->where('status', '<>', 1)
            ->groupBy('status')
            ->get();

$orders = DB::table('orders')
                ->selectRaw('price * ? as price_with_tax', [1.0825])
                ->get();

$orders = DB::table('orders')
                ->whereRaw('price > IF(state = "TX", ?, 100)', [200])
                ->get();

$orders = DB::table('orders')
                ->select('department', DB::raw('SUM(price) as total_sales'))
                ->groupBy('department')
                ->havingRaw('SUM(price) > ?', [2500])
                ->get();

$orders = DB::table('orders')
                ->orderByRaw('updated_at - created_at DESC')
                ->get();

$orders = DB::table('orders')
                ->select('city', 'state')
                ->groupByRaw('city, state')
                ->get();$orders = DB::table('orders')
                ->select('city', 'state')
                ->groupByRaw('city, state')
                ->get();

$users = DB::table('users')
            ->join('contacts', 'users.id', '=', 'contacts.user_id')
            ->join('orders', 'users.id', '=', 'orders.user_id')
            ->select('users.*', 'contacts.phone', 'orders.price')
            ->get();

$users = DB::table('users')
            ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();

$users = DB::table('users')
            ->rightJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();

$sizes = DB::table('sizes')
            ->crossJoin('colors')
            ->get();

DB::table('users')
        ->join('contacts', function (JoinClause $join) {
            $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
        })
        ->get();

DB::table('users')
        ->join('contacts', function (JoinClause $join) {
            $join->on('users.id', '=', 'contacts.user_id')
                ->where('contacts.user_id', '>', 5);
        })
        ->get();

- присоединить запрос к подзапросу
$latestPosts = DB::table('posts')
                  ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
                  ->where('is_published', true)
                  ->groupBy('user_id');
$users = DB::table('users')
        ->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {
            $join->on('users.id', '=', 'latest_posts.user_id');
        })->get();

- боковые соединения с подзапросом
- получить коллекцию пользователей, а также три последних блог-поста пользователя
$latestPosts = DB::table('posts')
                  ->select('id as post_id', 'title as post_title', 'created_at as post_created_at')
                  ->whereColumn('user_id', 'users.id')
                  ->orderBy('created_at', 'desc')
                  ->limit(3);

$users = DB::table('users')
            ->joinLateral($latestPosts, 'latest_posts')
            ->get();</code></pre><p>объединения» двух или более запросов Unions</p><pre><code>use Illuminate\Support\Facades\DB;

$first = DB::table('users')
            ->whereNull('first_name');

$users = DB::table('users')
            ->whereNull('last_name')
            ->union($first)
            ->get();
- запросы, объединенные с использованием метода unionAll, не будут удалять повторяющиеся результаты</code></pre><p>метод where, чтобы добавить в запрос WHERE</p><pre><code>$users = DB::table('users')
                ->where('votes', '=', 100)
                ->where('age', '>', 35)
                ->get();

либо
$users = DB::table('users')->where('votes', 100)->get();

либо
$users = DB::table('users')
                ->where('votes', '>=', 100)
                ->get();

$users = DB::table('users')
                ->where('votes', '<>', 100)
                ->get();

$users = DB::table('users')
                ->where('name', 'like', 'T%')
                ->get();

либо
$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
])->get();</code></pre><p>метод orWhere для добавления к запросу с помощью оператора OR</p><pre><code>$users = DB::table('users')
                    ->where('votes', '>', 100)
                    ->orWhere('name', 'John')
                    ->get();

либо
$users = DB::table('users')
            ->where('votes', '>', 100)
            ->orWhere(function (Builder $query) {
                $query->where('name', 'Abigail')
                      ->where('votes', '>', 50);
            })
            ->get();
сформирует запрос: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)</code></pre><p>методы whereNot и orWhereNot могут использоваться для отрицания заданной группы ограничений запроса</p><pre><code>$products = DB::table('products')
                ->whereNot(function (Builder $query) {
                    $query->where('clearance', true)
                          ->orWhere('price', '<', 10);
                })
                ->get();</code></pre><p>выбрать все записи, где хотя бы один столбец из списка соответствует определенному значению</p><pre><code>$users = DB::table('users')
            ->where('active', true)
            ->whereAny([
                'name',
                'email',
                'phone',
            ], 'like', 'Example%')
            ->get();

- сформирует запрос: 
SELECT *
FROM users
WHERE active = true AND (
    name LIKE 'Example%' OR
    email LIKE 'Example%' OR
    phone LIKE 'Example%'
)</code></pre><p>извлечение записей, где все указанные столбцы соответствуют заданному условию</p><pre><code>$posts = DB::table('posts')
            ->where('published', true)
            ->whereAll([
                'title',
                'content',
            ], 'like', '%Laravel%')
            ->get();

сформирует запрос:
SELECT *
FROM posts
WHERE published = true AND (
    title LIKE '%Laravel%' AND
    content LIKE '%Laravel%'
)</code></pre><p>извлечения записей, в которых ни один из заданных столбцов не соответствует заданному ограничению</p><pre><code>$posts = DB::table('albums')
            ->where('published', true)
            ->whereNone([
                'title',
                'lyrics',
                'tags',
            ], 'like', '%explicit%')
            ->get();

сформирует запрос:
SELECT *
FROM albums
WHERE published = true AND NOT (
    title LIKE '%explicit%' OR
    lyrics LIKE '%explicit%' OR
    tags LIKE '%explicit%'
)</code></pre><p>запрос к столбцу типа JSON</p><pre><code>$users = DB::table('users')
                ->where('preferences->dining->meal', 'salad')
                ->get();</code></pre><p>запрос массивов JSON</p><pre><code>$users = DB::table('users')
                ->whereJsonContains('options->languages', 'en')
                ->get();

либо
$users = DB::table('users')
                ->whereJsonContains('options->languages', ['en', 'de'])
                ->get();

- длина массива JSON
$users = DB::table('users')
                ->whereJsonLength('options->languages', 0)
                ->get();

$users = DB::table('users')
                ->whereJsonLength('options->languages', '>', 1)
                ->get();</code></pre><p>сопоставления с образцом</p><pre><code>$users = DB::table('users')
          ->whereLike('name', '%John%')
          ->get();</code></pre><p>включить поиск с учетом регистра</p><pre><code>$users = DB::table('users')
          ->whereLike('name', '%John%', caseSensitive: true)
          ->get();</code></pre><p>or с условием LIKE</p><pre><code>$users = DB::table('users')
          ->where('votes', '>', 100)
          ->orWhereLike('name', '%John%')
          ->get();</code></pre><p>не такой как образец</p><pre><code>$users = DB::table('users')
          ->whereNotLike('name', '%John%')
          ->get();</code></pre><p>or с условием NOT LIKE</p><pre><code>$users = DB::table('users')
          ->where('votes', '>', 100)
          ->orWhereNotLike('name', '%John%')
          ->get();</code></pre><p>значение переданного столбца содержится в указанном массиве</p><pre><code>$users = DB::table('users')
                    ->whereIn('id', [1, 2, 3])
                    ->get();</code></pre><p>значение переданного столбца не содержится в указанном массиве</p><pre><code>$users = DB::table('users')
                    ->whereNotIn('id', [1, 2, 3])
                    ->get();</code></pre><p>объект запроса как аргумент</p><pre><code>$activeUsers = DB::table('users')->select('id')->where('is_active', 1);
$users = DB::table('comments')
                    ->whereIn('user_id', $activeUsers)
                    ->get();

сформирует запрос
select * from comments where user_id in (
    select id
    from users
    where is_active = 1
)</code></pre><p>проверяет, что значение столбца находится между двумя значениями</p><pre><code>$users = DB::table('users')
          ->whereBetween('votes', [1, 100])
          ->get();</code></pre><p>проверяет, что значение столбца находится за пределами двух значений</p><pre><code>$users = DB::table('users')
                    ->whereNotBetween('votes', [1, 100])
                    ->get();</code></pre><p>проверяет, что значение столбца находится между двумя значениями двух столбцов в одной строке таблицы</p><pre><code>$patients = DB::table('patients')
                      ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])
                      ->get();</code></pre><p>проверяет, что значение столбца находится за пределами двух значений двух столбцов в одной строке таблицы</p><pre><code>$patients = DB::table('patients')
                      ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])
                      ->get();</code></pre><p>проверяет, что значение переданного столбца равно NULL</p><pre><code>$users = DB::table('users')
                ->whereNull('updated_at')
                ->get();</code></pre><p>проверяет, что значение переданного столбца не равно NULL</p><pre><code>$users = DB::table('users')
                ->whereNotNull('updated_at')
                ->get();</code></pre><p>сравнение значения столбца с датой</p><pre><code>$users = DB::table('users')
                ->whereDate('created_at', '2016-12-31')
                ->get();</code></pre><p>сравнение значения столбца с конкретным месяцем</p><pre><code>$users = DB::table('users')
                ->whereMonth('created_at', '12')
                ->get();</code></pre><p>сравнение значения столбца с определенным днем месяца</p><pre><code>$users = DB::table('users')
                ->whereDay('created_at', '31')
                ->get();</code></pre><p>сравнение значения столбца с конкретным годом</p><pre><code>$users = DB::table('users')
                ->whereYear('created_at', '2016')
                ->get();</code></pre><p>сравнение значения столбца с определенным временем</p><pre><code>$users = DB::table('users')
                ->whereTime('created_at', '=', '11:20:45')
                ->get();</code></pre><p>проверка равенства двух столбцов</p><pre><code>$users = DB::table('users')
                ->whereColumn('first_name', 'last_name')
                ->get();

либо
$users = DB::table('users')
                ->whereColumn('updated_at', '>', 'created_at')
                ->get();

либо
$users = DB::table('users')
                ->whereColumn([
                    ['first_name', '=', 'last_name'],
                    ['updated_at', '>', 'created_at'],
                ])->get();</code></pre><p>всегда группировать вызовы метода orWhere в круглых скобках</p><pre><code>$users = DB::table('users')
          ->where('name', '=', 'John')
          ->where(function (Builder $query) {
              $query->where('votes', '>', 100)
                    ->orWhere('title', '=', 'Admin');
          })
          ->get();

сформирует запрос
select * from users where name = 'John' and (votes > 100 or title = 'Admin')</code></pre><p>WHERE EXISTS</p><pre><code>$users = DB::table('users')
          ->whereExists(function (Builder $query) {
              $query->select(DB::raw(1))
                    ->from('orders')
                    ->whereColumn('orders.user_id', 'users.id');
          })
          ->get();

либо
$orders = DB::table('orders')
                ->select(DB::raw(1))
                ->whereColumn('orders.user_id', 'users.id');

$users = DB::table('users')
                    ->whereExists($orders)
                    ->get();

в обоих случаях получим
select * from users
where exists (
    select 1
    from orders
    where orders.user_id = users.id
)</code></pre><p>сравнивает результаты подзапроса с переданным значением</p><pre><code>use App\Models\User;
use Illuminate\Database\Query\Builder;

$users = User::where(function (Builder $query) {
    $query->select('type')
        ->from('membership')
        ->whereColumn('membership.user_id', 'users.id')
        ->orderByDesc('membership.start_date')
        ->limit(1);
}, 'Pro')->get();</code></pre><p>сравнивает столбец с результатами подзапроса</p><pre><code>use App\Models\Income;
use Illuminate\Database\Query\Builder;

$incomes = Income::where('amount', '<', function (Builder $query) {
    $query->selectRaw('avg(i.amount)')->from('incomes as i');
})->get();</code></pre><p>whereFullText и orWhereFullText добавят полнотекстовые “условия” в запрос для столбцов, имеющих полнотекстовые индексы</p><pre><code>$users = DB::table('users')
          ->whereFullText('bio', 'web developer')
          ->get();</code></pre><p>сортировать результаты запроса по конкретному столбцу</p><pre><code>$users = DB::table('users')
                ->orderBy('name', 'desc')
                ->get();

либо
$users = DB::table('users')
                ->orderBy('name', 'desc')
                ->orderBy('email', 'asc')
                ->get();</code></pre><p>latest и oldest: упорядочить результаты по дате, по умолчанию по столбцу created_at, либо указать столбец сортировки</p><pre><code>$user = DB::table('users')
                ->latest()
                ->first();</code></pre><p>сортировка результатов запроса в случайном порядке</p><pre><code>$randomUser = DB::table('users')
                ->inRandomOrder()
                ->first();</code></pre><p>Метод reorder удаляет все примененые выражения ORDER BY</p><pre><code>$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();</code></pre><p>удалить все существующие выражения ORDER BY и применить к запросу совершенно новый порядок</p><pre><code>$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();</code></pre><p>группировка результатов запроса</p><pre><code>$users = DB::table('users')
                ->groupBy('account_id')
                ->having('account_id', '>', 100)
                ->get();</code></pre><p>фильтрация результатов в заданном диапазоне</p><pre><code>$report = DB::table('orders')
                ->selectRaw('count(id) as number_of_orders, customer_id')
                ->groupBy('customer_id')
                ->havingBetween('number_of_orders', [5, 15])
                ->get();</code></pre><p>группировка по нескольким столбцам</p><pre><code>$users = DB::table('users')
                ->groupBy('first_name', 'status')
                ->having('account_id', '>', 100)
                ->get();</code></pre><p>- take: ограничить количество результатов, возвращаемых запросом
- skip: пропустить указанное количество результатов из запроса</p><pre><code>$users = DB::table('users')->skip(10)->take(5)->get();

либо limit и offset
$users = DB::table('users')
                ->offset(10)
                ->limit(5)
                ->get();</code></pre><p>применить выражение при условии: when выполняет переданную функцию если первый аргумент равен true</p><pre><code>$role = $request->input('role');
$users = DB::table('users')
                ->when($role, function (Builder $query, string $role) {
                    $query->where('role_id', $role);
                })
                ->get();</code></pre><p>второя переданная when функция будет выполнена если первый аргумент равен false</p><pre><code>$sortByVotes = $request->boolean('sort_by_votes');
$users = DB::table('users')
                ->when($sortByVotes, function (Builder $query, bool $sortByVotes) {
                    $query->orderBy('votes');
                }, function (Builder $query) {
                    $query->orderBy('name');
                })
                ->get();</code></pre><p>вставка записей в таблицу базы данных</p><pre><code>DB::table('users')->insert([
    'email' => 'kayla@example.com',
    'votes' => 0
]);

- каждый из массивов это запись, которую нужно вставить в таблицу
DB::table('users')->insert([
    ['email' => 'picard@example.com', 'votes' => 0],
    ['email' => 'janeway@example.com', 'votes' => 0],
]);</code></pre><p>игнорировать ошибки при вставке записей в базу данных</p><pre><code>DB::table('users')->insertOrIgnore([
    ['id' => 1, 'email' => 'sisko@example.com'],
    ['id' => 2, 'email' => 'archer@example.com'],
]);</code></pre><p>вставляет новые записи в таблицу, используя подзапрос</p><pre><code>DB::table('pruned_users')->insertUsing([
    'id', 'name', 'email', 'email_verified_at'
], DB::table('users')->select(
    'id', 'name', 'email', 'email_verified_at'
)->where('updated_at', '<=', now()->subMonth()));</code></pre><p>вставить запись и затем получить идентификатор этой записи</p><pre><code>$id = DB::table('users')->insertGetId(
    ['email' => 'john@example.com', 'votes' => 0]
);</code></pre><p>- вставляет записи, которые не существуют, и обновляет записи, которые уже существуют, новыми значениями<br>
- попытается вставить две записи. Если запись уже существует с такими же значениями столбцов departure и destination, то обновит столбец price этой записи<br></p><pre><code>DB::table('flights')->upsert(
    [
        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
    ],
    ['departure', 'destination'],
    ['price']
);</code></pre><p>обновить существующие записи</p><pre><code>$affected = DB::table('users')
              ->where('id', 1)
              ->update(['votes' => 1]);</code></pre><p>- Если запись существует, она будет обновлена значениями второго аргумента.<br>
- Если запись не может быть найдена, будет вставлена новая запись с объединенными атрибутами обоих аргументов<br></p><pre><code>DB::table('users')
    ->updateOrInsert(
        ['email' => 'john@example.com', 'name' => 'John'],
        ['votes' => '2']
    );

либо через условие
DB::table('users')->updateOrInsert(
    ['user_id' => $user_id],
    fn ($exists) => $exists ? [
        'name' => $data['name'],
        'email' => $data['email'],
    ] : [
        'name' => $data['name'],
        'email' => $data['email'],
        'marketable' => true,
    ],
);</code></pre><p>обновление столбца JSON</p><pre><code>$affected = DB::table('users')
              ->where('id', 1)
              ->update(['options->enabled' => true]);</code></pre><p>методы увеличения или уменьшения значения конкретного столбца</p><pre><code>DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes', 5);

либо
DB::table('users')->increment('votes', 1, ['name' => 'John']);</code></pre><p>увеличивать или уменьшать значения нескольких столбцов с помощью методов incrementEach и decrementEach</p><pre><code>DB::table('users')->incrementEach([
    'votes' => 5,
    'balance' => 100,
]);</code></pre><p>удалить записи из таблицы</p><pre><code>$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();</code></pre><p>удаление всех записей из таблицы и сброс автоинкрементного идентификатора на ноль</p><code>DB::table('users')->truncate();</code><p>предотвратить изменение выбранных строк до тех пор, пока транзакция не будет зафиксирована</p><pre><code>DB::table('users')
        ->where('votes', '>', 100)
        ->sharedLock()
        ->get();</code></pre><p>предотвращает изменение выбранных записей</p><pre><code>DB::table('users')
        ->where('votes', '>', 100)
        ->lockForUpdate()
        ->get();</code></pre><p>отобразить связанные параметры запроса и сам SQL-запрос</p><pre><code>DB::table('users')->where('votes', '>', 100)->dd();
DB::table('users')->where('votes', '>', 100)->dump();

либо
DB::table('users')->where('votes', '>', 100)->dumpRawSql();
DB::table('users')->where('votes', '>', 100)->ddRawSql();
</code></pre></details><details> <summary>Eloquent ORM</summary><p>Eloquent ORM - это реализация Active Record для работы с базой данных с помощью PHP-кода, SQL-запросов, миграций, сидов, фабрик и отношений<br></p><details><summary>Модели</summary><p>models - классы моделей Eloquent для взаимодействия с таблицами базы данных методами построителя запросов<br></p><pre><code>// Создать новый класс модели в app/Models<br>
php artisan make:model Flight</code></pre><p>сгенерировать классы при создании модели</p><pre><code>// Создать модель и миграцию
php artisan make:model Flight --migration
php artisan make:model Flight -m

// Создать модель и класс FlightFactory...
php artisan make:model Flight --factory
php artisan make:model Flight -f

// Создать модель и класс FlightSeeder...
php artisan make:model Flight --seed
php artisan make:model Flight -s

// Создать модель и класс FlightController...
php artisan make:model Flight --controller
php artisan make:model Flight -c

// Создать модель, класс ресурса FlightController и класс запроса формы...
php artisan make:model Flight --controller --resource --requests
php artisan make:model Flight -crR

// Создать модель и класс FlightPolicy class...
php artisan make:model Flight --policy

// Создать модель, миграцию, фабрику, наполнитель и контроллер ...
php artisan make:model Flight -mfsc

// Создать модель, миграцию, фабрику, наполнитель, политику, контроллер и запрос формы ...
php artisan make:model Flight --all
php artisan make:model Flight -a

// Создать сводную модель...
php artisan make:model Member --pivot
php artisan make:model Member -p</code></pre><p>помощь по созданию модели</p><code>php artisan help make:model</code><p>создаю модель в полном комплекте (Model, Migration, Factory, Seeder, Request, Controller, Policy)</p><code>php artisan make:model Employer -a</code><p>создать модель без миграции</p><code>php artisan make:model Employer -cfs --policy</code><p>то что не будет использовано можно будет удалить.<br>
в моделях app/Models/ указать связи</p><pre><code>class Employer extends Model
{
  use HasFactory;
  public function user(): BelongsTo
  {
    return $this->belongsTo(User::class);
  }
  public function jobs(): HasMany
  {
    return $this->hasMany(Job::class);
  }
}</code></pre><p>в файле Providers/AppServiceProvider.php, чтобы не указывать fillable</p><pre><code>public function boot(): void
{
  Model::unguard();
}</code></pre><p>Показать содажимое БД</p><pre><code>./sail artisan db:show
./sail artisan db:table users</code></pre><p>Показать содажимое таблицы БД</p><pre><code>php artisan tinker
User::all();</code></pre><p>при типе связи $this->belongsToMany() создать pivot table</p><p>обзор всех атрибутов и отношений модели</p><code>php artisan model:show Flight</code><p>- Eloquent будет предполагать, что модель Flight хранит записи в таблице flights
- а модель AirTrafficController – в таблице air_traffic_controllers
- указать имя таблицы модели вручную</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Таблица БД, ассоциированная с моделью.
    *
    * @var string
    */
    protected $table = 'my_flights';
}</code></pre><p>определить, какие атрибуты модели массово-заполняемые</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Атрибуты, для которых разрешено массовое присвоение значений.
    *
    * @var array<int, string>
    */
    protected $fillable = ['name'];
}

// вернёт новую запись
$flight = Flight::create(['name' => 'London to Paris']);

// заполнить запись атрибутами
$flight->fill(['name' => 'Amsterdam to Frankfurt']);</code></pre><p>для JSON-столбцов необходимо указать массово назначаемый ключ для каждого столбца</p><pre><code>/**
* Атрибуты, для которых разрешено массовое присвоение значений.
*
* @var array<int, string>
*/
protected $fillable = [
    'options->enabled',
];</code></pre><p>все атрибуты массово-заполняемые, модель без защиты</p><pre><code>/**
* @var array<string>|bool
*/
protected $guarded = [];</code></pre><p>генерировать исключение при попытке заполнения значением неподлежащего заполнению атрибута</p><pre><code>в App\Providers\AppServiceProvider.php
use Illuminate\Database\Eloquent\Model;

public function boot(): void
{
    Model::preventSilentlyDiscardingAttributes($this->app->isLocal());
}</code></pre><p>вставить новую запись</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Flight;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class FlightController extends Controller
{
    /**
    * Сохранить новый рейс в базе данных.
    */
    public function store(Request $request): RedirectResponse
    {
        // Валидация запроса...

        // создать экземпляр модели
        $flight = new Flight;

        // установить атрибуты модели
        $flight->name = $request->name;

        // сохранить запись (экземпляр модели)
        $flight->save();

        return redirect('/flights');
    }
}

либо
// указать свойство fillable или guarded в классе модели
use App\Models\Flight;

$flight = Flight::create([
    'name' => 'London to Paris',
]);</code></pre><p>- в каждой модели есть столбец первичного ключа с именем id
- указать другой столбец первичным ключом</p><pre><code>namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * @var string
    */
    protected $primaryKey = 'flight_id';
}</code></pre><p>- первичный ключ является автоинкрементным целочисленным значением
- использовать неинкрементный или нечисловой первичный ключ</p><pre><code>class Flight extends Model
{
    /**
    * @var bool
    */
    public $incrementing = false;
}</code></pre><p>первичный ключ модели не целочисленный</p><pre><code>class Flight extends Model
{
    /**
    * @var string
    */
    protected $keyType = 'string';
}</code></pre><p>- «Составные» первичные ключи не поддерживаются, можно добавить дополнительные многоколоночные уникальные индексы вместе с первичным ключем таблицы
- UUID – уникальные буквенно-цифровые идентификаторы длиной 36 символов
- использовать ключ UUID вместо автоинкрементного целочисленного ключа
(у таблицы должен быть столбец UUID,т.е. $table->uuid('id'); в миграции)</p><pre><code>use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    use HasUuids;
}

$article = Article::create(['title' => 'Traveling to Europe']);
$article->id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"</code></pre><p>переопределить процесс генерации UUID</p><pre><code>use Ramsey\Uuid\Uuid;

/**
* Generate a new UUID for the model.
*/
public function newUniqueId(): string
{
    return (string) Uuid::uuid4();
}

/**
* Get the columns that should receive a unique identifier.
*
* @return array<int, string>
*/
public function uniqueIds(): array
{
    return ['id', 'discount_code'];
}</code></pre><p>ULID имеют длину 26 символов (у таблицы должен быть столбец ULID,т.е. $table->ulid('id'); в миграции)</p><pre><code>use Illuminate\Database\Eloquent\Concerns\HasUlids;
use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    use HasUlids;
}

$article = Article::create(['title' => 'Traveling to Asia']);
$article->id; // "01gd4d3tgrrfqeda94gdbtdk5c"</code></pre><p>устанавливать значения столбцов created_at и updated_at вручную</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Следует ли обрабатывать временные метки модели.
    *
    * @var bool
    */
    public $timestamps = false;
}</code></pre><p>задать формат хранения даты в БД и сериализации модели в массив или JSON</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Формат хранения столбцов даты модели.
    *
    * @var string
    */
    protected $dateFormat = 'U';
}</code></pre><p>указать имена столбцов хранения временных меток</p><pre><code>class Flight extends Model
{
    const CREATED_AT = 'creation_date';
    const UPDATED_AT = 'updated_date';
}</code></pre><p>выполнять операцию с моделью, не изменяя ее метку времени в updated_at</p><code>Model::withoutTimestamps(fn () => $post->increment('reads'));</code><p>указать соединение с БД не по умолчанию для отдельной модели</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Соединение с БД, которое должна использовать модель.
    *
    * @var string
    */
    protected $connection = 'mysql';
}</code></pre><p>указать значения атрибутов по умолчанию</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class Flight extends Model
{
    /**
    * Значения по умолчанию для атрибутов модели.
    *
    * @var array
    */
    protected $attributes = [
        'options' => '[]',
        'delayed' => false,
    ];
}</code></pre><p>запретить ли отложенную загрузку</p><pre><code>в App\Providers\AppServiceProvider
use Illuminate\Database\Eloquent\Model;

/**
* Запустите любые службы приложения.
*/
public function boot(): void
{
    Model::preventLazyLoading(! $this->app->isProduction());
}</code></pre><p>генерировать исключение при попытке назначить значение неподлежащего назначению атрибута</p><code>Model::preventSilentlyDiscardingAttributes(! $this->app->isProduction());</code><p>получить все записи из связанной с моделью таблицы БД</p><pre><code>use App\Models\Flight;
foreach (Flight::all() as $flight) {
    echo $flight->name;
}</code></pre><p>построить запрос с дополнительными условиями</p><pre><code>$flights = Flight::where('active', 1)
              ->orderBy('name')
              ->take(10)
              ->get();</code></pre><p>повторно извлечь модель из БД</p><pre><code>$flight = Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh();</code></pre><p>повторно обновить существующую модель</p><pre><code>$flight = Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"</code></pre><p>получить одину запись</p><pre><code>use App\Models\Flight;

// Получить модель по ее первичному ключу...
$flight = Flight::find(1);

// Получить первую модель, соответствующую условиям запроса...
$flight = Flight::where('active', 1)->first();

// Альтернатива извлечению первой модели, соответствующей условиям запроса...
$flight = Flight::firstWhere('active', 1);</code></pre><p>если запись не найдена, то вернуть функцию</p><pre><code>$flight = Flight::findOr(1, function () {});
$flight = Flight::where('legs', '>', 3)->firstOr(function () {});</code></pre><p>если запись не найдена, то вернуть исключение</p><pre><code>$flight = Flight::findOrFail(1);
$flight = Flight::where('legs', '>', 3)->firstOrFail();

либо
use App\Models\Flight;

Route::get('/api/flights/{id}', function (string $id) {
    return Flight::findOrFail($id);
});</code></pre><p>если запись не найдена, то создать новую</p><pre><code>// Автосохранение созданной записи
use App\Models\Flight;

// Получить рейс по `name` или создать его, если его не существует...
$flight = Flight::firstOrCreate([
    'name' => 'London to Paris'
]);

// Получить рейс по `name` или создать его с атрибутами `name`,` delayed` и `arrival_time` ...
$flight = Flight::firstOrCreate(
    ['name' => 'London to Paris'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);

// Сохранение вручную $flight->save()
// Получить рейс по `name` или создать новый экземпляр Flight ...
$flight = Flight::firstOrNew([
    'name' => 'London to Paris'
]);

// Получить рейс по `name` или создать экземпляр с атрибутами `name`, `delayed` и `arrival_time` ...
$flight = Flight::firstOrNew(
    ['name' => 'Tokyo to Sydney'],
    ['delayed' => 1, 'arrival_time' => '11:30']
);</code></pre><p>возвращают соответствующее скалярное значение вместо экземпляра модели</p><pre><code>$count = Flight::where('active', 1)->count();
$max = Flight::where('active', 1)->max('price');</code></pre><p>обновить запись</p><pre><code>use App\Models\Flight;
$flight = Flight::find(1);
$flight->name = 'Paris to London';
$flight->save();</code></pre><p>обновить или создать новую запись</p><pre><code>$flight = Flight::updateOrCreate(

    // если существует запись
    ['departure' => 'Oakland', 'destination' => 'San Diego'],

    // то обновить значения стобцов price и discounted
    ['price' => 99, 'discounted' => 1]

    // если не существует, то создать новую запись с такими значениями
);</code></pre><p>все рейсы с пунктом назначения в Сан-Диего, будут помечены как задержанные</p><pre><code>Flight::where('active', 1)
      ->where('destination', 'San Diego')
      ->update(['delayed' => 1]);  // update возвращает количество затронутых строк</code></pre><p>обновление или создание записей за одну операцию</p><pre><code>Flight::upsert([
    ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
    ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
], uniqueBy: ['departure', 'destination'], update: ['price']);

// столбцы второго аргумента должны иметь “primary” или “unique” индекс</code></pre><p>изменения атрибутов</p><pre><code>use App\Models\User;
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';

// было ли изменение с момента получения модели
$user->isDirty(); // true
$user->isDirty('title'); // true
$user->isDirty('first_name'); // false
$user->isDirty(['first_name', 'title']); // true

// остался ли атрибут неизменным с момента получения модели
$user->isClean(); // false
$user->isClean('title'); // false
$user->isClean('first_name'); // true
$user->isClean(['first_name', 'title']); // false

$user->save();

$user->isDirty(); // false
$user->isClean(); // true

// были ли изменены какие-либо атрибуты при последнем сохранении модели в текущем цикле запроса
$user = User::create([
    'first_name' => 'Taylor',
    'last_name' => 'Otwell',
    'title' => 'Developer',
]);

$user->title = 'Painter';

$user->save();

$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged(['title', 'slug']); // true
$user->wasChanged('first_name'); // false
$user->wasChanged(['first_name', 'title']); // true

// возвращает массив, содержащий исходные атрибуты модели
$user = User::find(1);

$user->name; // John
$user->email; // john@example.com

$user->name = "Jack";
$user->name; // Jack

$user->getOriginal('name'); // John
$user->getOriginal(); // Массив исходных атрибутов...</code></pre><p>удалить запись</p><pre><code>use App\Models\Flight;
$flight = Flight::find(1);
$flight->delete();</code></pre><p>удалить все записи таблицы</p><code>Flight::truncate();</code><p>удаление записи по ключу</p><pre><code>Flight::destroy(1);
Flight::destroy(1, 2, 3);
Flight::destroy([1, 2, 3]);
Flight::destroy(collect([1, 2, 3]));</code></pre><p>удаление записи через запрос с условием</p><code>$deleted = Flight::where('active', 0)->delete();</code><p>программное удаление: фактически не удаляются из БД, а устанавливается атрибут deleted_at</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Flight extends Model
{
    use SoftDeletes;
}

// добавить столбец deleted_at в таблицу БД
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('flights', function (Blueprint $table) {
    $table->softDeletes();
});

Schema::table('flights', function (Blueprint $table) {
    $table->dropSoftDeletes();
});</code></pre><p>определить, была ли данная запись программно удалена</p><code>if ($flight->trashed()) {}</code><p>восстановить программно удаленную запись</p><pre><code>$flight->restore();

либо
Flight::withTrashed()
        ->where('airline_id', 1)
        ->restore();

либо
$flight->history()->restore();  </code></pre><p>окончательно удалить запись</p><pre><code>Flight::forceDestroy(1);

либо
$flight->forceDelete();

либо
$flight->history()->forceDelete();</code></pre><p>- программно удаленные записи будут автоматически исключены из результатов запроса
- отобразить программно удаленные записи в результате запроса</p><pre><code>use App\Models\Flight;
$flights = Flight::withTrashed()
                ->where('account_id', 1)
                ->get();

либо
$flight->history()->withTrashed()->get();</code></pre><p>отобразить только программно удаленные записи</p><pre><code>$flights = Flight::onlyTrashed()
                ->where('airline_id', 1)
                ->get();</code></pre><p>удалять данные, которые больше не нужны</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Prunable;

class Flight extends Model
{
    use Prunable;

    /**
    * Получите запрос для удаления устаревших записей модели.
    */
    public function prunable(): Builder
    {
        return static::where('created_at', '<=', now()->subMonth());
    }
}</code></pre><p>определить метод pruning для модели для удаления любых дополнительных ресурсов, связанных с записью</p><pre><code>/**
* Prepare the model for pruning.
*/
protected function pruning(): void { }</code></pre><p>добавить в планировщик Artisan-команду model:prune в файле routes/console.php</p><pre><code>// будет автоматически проверять и чистить модели от старых записей в каталоге app/Models
use Illuminate\Support\Facades\Schedule;
Schedule::command('model:prune')->daily();</code></pre><p>если модели находятся в другом месте</p><pre><code>Schedule::command('model:prune', [
    '--model' => [Address::class, Flight::class],
])->daily();</code></pre><p>чистить модели кроме указанных</p><pre><code>Schedule::command('model:prune', [
    '--except' => [Address::class, Flight::class],
])->daily();</code></pre><p>сколько записей будет удаоено при выполнении чистки</p><code>php artisan model:prune --pretend</code><p>удаление записей с помощью запросов массового удаления</p><pre><code>// метод pruning и события deleting и deleted вызваны не будут, т.к. модели не извлекаются перед удалением
namespace App\Models;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\MassPrunable;

class Flight extends Model
{
    use MassPrunable;

    /**
    * Get the prunable model query.
    */
    public function prunable(): Builder
    {
        return static::where('created_at', '<=', now()->subMonth());
    }
}</code></pre><p>создать копию записи</p><pre><code>use App\Models\Address;
$shipping = Address::create([
    'type' => 'shipping',
    'line_1' => '123 Example Street',
    'city' => 'Victorville',
    'state' => 'CA',
    'postcode' => '90001',
]);

$billing = $shipping->replicate()->fill([
    'type' => 'billing'
]);

$billing->save();</code></pre><p>создать копию записи без указанных атрибутов</p><pre><code>$flight = Flight::create([
    'destination' => 'LAX',
    'origin' => 'LHR',
    'last_flown' => '2020-03-04 11:00:00',
    'last_pilot_id' => 747,
]);

$flight = $flight->replicate([
    'last_flown',
    'last_pilot_id'
]);</code></pre><p>- глобальные диапазоны позволяют добавлять ограничения ко всем запросам для конкретной модели
- сгенерировать новый глобальный диапазон в app/Models/Scopes</p><code>php artisan make:scope AncientScope</code><p>в методе apply можно добавлять условия where или другие типы ограничений к запросу</p><pre><code>namespace App\Models\Scopes;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;

class AncientScope implements Scope
{
    /**
    * Применить диапазон к переданному построителю запросов.
    */
    public function apply(Builder $builder, Model $model): void
    {
        $builder->where('created_at', '<', now()->subYears(2000));
    }
} // Если диапазон добавляет столбцы в конструкцию Select-запроса - использовать метод addSelect вместо select</code></pre><p>применить глобальный диапазон к модели</p><pre><code>namespace App\Models;
use App\Models\Scopes\AncientScope;
use Illuminate\Database\Eloquent\Attributes\ScopedBy;

<ScopedBy [AncientScope::class]></ScopedBy>
class User extends Model { }

либо
namespace App\Models;
use App\Models\Scopes\AncientScope;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Метод «booted» модели.
    */
    protected static function booted(): void
    {
        static::addGlobalScope(new AncientScope);
    }
}

// User::all() вернёт
select * from `users` where `created_at` < 0021-02-18 00:00:00</code></pre><p>создать глобальный диапозон без класса через функцию</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Метод «booted» модели.
    */
    protected static function booted(): void
    {
        static::addGlobalScope('ancient', function (Builder $builder) {
            $builder->where('created_at', '<', now()->subYears(2000));
        });
    }
}</code></pre><p>исключения глобального диапазона в текущем запросе</p><pre><code>User::withoutGlobalScope(AncientScope::class)->get();

либо
User::withoutGlobalScope('ancient')->get();

либо
// Игнорировать все глобальные диапазоны...
User::withoutGlobalScopes()->get();

// Игнорировать некоторые глобальные диапазоны...
User::withoutGlobalScopes([
    FirstScope::class, SecondScope::class
])->get();</code></pre><p>чтобы определить локальный диапазон - добавить к методу префикс scope</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Диапазон запроса, включающий только популярных пользователей.
    */
    public function scopePopular(Builder $query): void
    {
        $query->where('votes', '>', 100);
    }

    /**
    * Диапазон запроса, включающий только активных пользователей.
    */
    public function scopeActive(Builder $query): void
    {
        $query->where('active', 1);
    }

    /**
    * Диапазон запроса, включающий пользователей только определенного типа.
    */
    public function scopeOfType(Builder $query, string $type): void
    {
        $query->where('type', $type);
    }
}

// вызвать метод при выполнении запроса
use App\Models\User;

$users = User::popular()->active()->orderBy('created_at')->get();

либо
$users = User::popular()->orWhere(function (Builder $query) {
    $query->active();
})->get();

либо
$users = User::popular()->orWhere->active()->get();

либо
$users = User::ofType('admin')->get();</code></pre><p>сравнение моделей</p><pre><code>if ($post->is($anotherPost)) {}
if ($post->isNot($anotherPost)) {}

// сравнить связанную модель без запроса на получение этой модели
if ($post->author()->is($user)) {}
</code></pre></details><details><summary>Events</summary><p>- события позволяют использовать хуки жизненного цикла модели: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleting, forceDeleted, restoring, restored и replicating.<br>
- события, заканчивающиеся на -ing, инициируются до сохранения изменений в модели, а события, заканчивающиеся на -ed, инициируются после сохранения изменений в модели.<br>
- события saved, updated, deleting, и deleted при массовом обновлении или удалении не будут инициированы<br></p><pre><code>- прослушивание событий модели
namespace App\Models;
use App\Events\UserDeleted;
use App\Events\UserSaved;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable
{
    use Notifiable;
    /**
    * Карта событий для модели.
    *
    * @var array<string, string>
    */
    protected $dispatchesEvents = [
        'saved' => UserSaved::class,
        'deleted' => UserDeleted::class,
    ];
}

либо через функции
namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Метод «booted» модели.
    */
    protected static function booted(): void
    {
        static::created(function (User $user) {});
    }
}</code></pre><p>выполнить слушателя событий модели в фоновом режиме, используя очередь</p><pre><code>use function Illuminate\Events\queueable;
static::created(queueable(function (User $user) {}));</code></pre><p>- использовать наблюдателей, чтобы сгруппировать слушателей в одном классе<br>
- создать наблюдателя в app/Observers<br></p><pre><code>php artisan make:observer UserObserver --model=User

получим
namespace App\Observers;
use App\Models\User;

class UserObserver
{
    /**
    * Обработать событие «created» модели User.
    */
    public function created(User $user): void {}

    /**
    * Обработать событие «updated» модели User.
    */
    public function updated(User $user): void {}

    /**
    * Обработать событие «deleted» модели User.
    */
    public function deleted(User $user): void {}

    /**
    * Обработать событие «restored» модели User.
    */
    public function restored(User $user): void {}

    /**
    * Обработать событие «forceDeleted» модели User.
    */
    public function forceDeleted(User $user): void {}
}</code></pre><p>регистрации наблюдателя</p><pre><code>use App\Observers\UserObserver;
use Illuminate\Database\Eloquent\Attributes\ObservedBy;

<ObservedBy [UserObserver::class]></ObservedBy>
class User extends Authenticatable {}

либо в App\Providers\AppServiceProvider
use App\Models\User;
use App\Observers\UserObserver;
/**
* Запуск любых служб приложения.
*/
public function boot(): void
{
    User::observe(UserObserver::class);
}</code></pre><p>наблюдатель выполнит свои обработчики событий только после фиксирования транзакции базы данных</p><pre><code>namespace App\Observers;

use App\Models\User;
use Illuminate\Contracts\Events\ShouldHandleEventsAfterCommit;

class UserObserver implements ShouldHandleEventsAfterCommit
{
    /**
    * Обработать событие «created» модели User.
    */
    public function created(User $user): void {}
}</code></pre><p>заглушить все события, запускаемые моделью</p><pre><code>use App\Models\User;

$user = User::withoutEvents(function () {
    User::findOrFail(1)->delete();
    return User::find(2);
});</code></pre><p>операции с моделью, не вызывая никаких событий</p><pre><code>$user = User::findOrFail(1);
$user->name = 'Victoria Faith';
$user->saveQuietly();
$user->deleteQuietly();
$user->forceDeleteQuietly();
$user->restoreQuietly();
</code></pre></details><details> <summary>Collections</summary><a href="http://github.com/Mezuno/laravel-collections-doc">Collections</a><p>коллекции - это итераторы, которые можно перебирать как массив</p><pre><code>use App\Models\User;

$users = User::where('active', 1)->get();
foreach ($users as $user) {
    echo $user->name;
}</code></pre><p>коллекции поддерживают map и reduce</p><pre><code>$names = User::all()->reject(function (User $user) {
    return $user->active === false;
})->map(function (User $user) {
    return $user->name;
});</code></pre><p>- все коллекции Eloquent расширяют базовый класс коллекций Laravel<br>
- методы collapse, flatten, flip, keys, pluck, и zip возвращают экземпляр базовой коллекции<br>
- коллекции Eloquent наследуют все методы класса базовой коллекции и содержит расширенный набор методов<br></p><pre><code>// указать, что атрибут должен быть добавлен к каждой записи в коллекции
$users->append('team');
$users->append(['team', 'is_admin']);

// содержится ли запись в коллекции
$users->contains(1);
$users->contains(User::find(1));

// возвращает все записи, которых нет в переданной коллекции
$users = $users->diff(User::whereIn('id', [1, 2, 3])->get());

// озвращает все записи, у которых нет указанных первичных ключей
$users = $users->except([1, 2, 3]);

// возвращает запись по указанному ключу
$users = User::all();
$user = $users->find(1);

// возвращает запись по указанному ключу или исключение
$users = User::all();
$user = $users->findOrFail(1);

// возвращает обновлённые записи
$users = $users->fresh();

// возвращает обновлённые записи с отношением
$users = $users->fresh('comments');

// возвращает записи, которые присутствуют в указанной коллекции
$users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());

// загружает указанные отношения для всех записей в коллекции
$users->load(['comments', 'posts']);
$users->load('comments.author');
$users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);

// загружает ещё незагруженные отношения для всех записей в коллекции
$users->loadMissing(['comments', 'posts']);
$users->loadMissing('comments.author');
$users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);

// возвращает первичные ключи для всех записей в коллекции
$users->modelKeys();             // [1, 2, 3, 4, 5]

// делает видимыми скрытые атрибуты записей из коллекции
$users = $users->makeVisible(['address', 'phone_number']);

// делает скрытыми атрибуты записей из коллекции
$users = $users->makeHidden(['address', 'phone_number']);

// возвращает все записи с указанными первичными ключами
$users = $users->only([1, 2, 3]);

// временно переопределяет видимые атрибуты для каждой записи в коллекции
$users = $users->setVisible(['id', 'name']);

// временно переопределяет скрытые атрибуты для каждой записи в коллекции
$users = $users->setHidden(['email', 'password', 'remember_token']);

// возвращает экземпляр построителя запросов
use App\Models\User;

$users = User::where('status', 'VIP')->get();
$users->toQuery()->update([
    'status' => 'Administrator',
]);

// возвращает уникальные записи в коллекции
$users = $users->unique();</code></pre><p>удаления записей из полученной коллекции</p><pre><code>$flights = Flight::where('destination', 'Paris')->get();
$flights = $flights->reject(function (Flight $flight) {
    return $flight->cancelled;
});</code></pre><p>перебирать коллекции</p><pre><code>foreach ($flights as $flight) {
    echo $flight->name;
}</code></pre><p>получать коллекцию записей частями</p><pre><code>use App\Models\Flight;
use Illuminate\Database\Eloquent\Collection;

Flight::chunk(200, function (Collection $flights) {
    foreach ($flights as $flight) { }
});

// 200 - количество записей за «порцию»
// к каждой порции применяется function (Collection $flights) {}</code></pre><p>извлекать записи со столбцом id, большим, чем у последней записи в предыдущей «порции»</p><pre><code>Flight::where('departed', true)
    ->chunkById(200, function (Collection $flights) {
        $flights->each->update(['departed' => false]);
    }, column: 'id');</code></pre><p>логическая группировка в запросе</p><pre><code>Flight::where(function ($query) {
    $query->where('delayed', true)->orWhere('cancelled', true);
})->chunkById(200, function (Collection $flights) {
    $flights->each->update([
        'departed' => false,
        'cancelled' => true
    ]);
}, column: 'id');</code></pre><p>lazy() возвращает каждую порцию записей как отдельную коллекцию</p><pre><code>use App\Models\Flight;
foreach (Flight::lazy() as $flight) { }</code></pre><p>lazyById извлекает записи со столбцом id, большим, чем у последней записи в предыдущей «порции»</p><pre><code>Flight::where('departed', true)
    ->lazyById(200, column: 'id')
    ->each->update(['departed' => false]);

// lazyByIdDesc - отфильтровать результаты по убыванию id</code></pre><p>при использовании cursor будет только один запрос к БД и только одна модель хранится в памяти в любой момент времени при итерации</p><pre><code>use App\Models\Flight;
foreach (Flight::where('destination', 'Zurich')->cursor() as $flight) { }

либо
use App\Models\User;
$users = User::cursor()->filter(function (User $user) {
    return $user->id > 500;
});
foreach ($users as $user) {
    echo $user->id;
}</code></pre><p>извлечь информацию из связанных таблиц в одном запросе</p><pre><code>// выбрал все пункты назначения и рейсы, которые прибыли последними в этот пункт назначения
use App\Models\Destination;
use App\Models\Flight;

return Destination::addSelect(['last_flight' => Flight::select('name')
    ->whereColumn('destination_id', 'destinations.id')
    ->orderByDesc('arrived_at')
    ->limit(1)
])->get();

// отсортировал пункты назначения по последнему рейсу
return Destination::orderByDesc(
    Flight::select('arrived_at')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderByDesc('arrived_at')
        ->limit(1)
)->get();</code></pre><p>использовать собственный объект Collection</p><pre><code>namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Attributes\CollectedBy;
use Illuminate\Database\Eloquent\Model;

<CollectedBy UserCollection::class></CollectedBy>
class User extends Model { }

// либо
namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Создать новый экземпляр коллекции Eloquent.
    *
    * @param  array<int, \Illuminate\Database\Eloquent\Model>  $models
    * @return \Illuminate\Database\Eloquent\Collection<int, \Illuminate\Database\Eloquent\Model>
    */
    public function newCollection(array $models = []): Collection
    {
        return new UserCollection($models);
    }
}
```
</code></pre></details><details> <summary>Accessors, mutators and typing</summary><p>Стобцы таблицы - это атрибуты модели.<br>
Аксессор преобразует значение атрибута экземпляра Eloquent при обращении к нему.<br></p><pre><code>// аксессор для атрибута first_name
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Получить имя пользователя.
    */
    protected function firstName(): Attribute
    {
        // конструктор класса Attribute
        return Attribute::make(

            // способ доступа к атрибуту
            get: fn (string $value) => ucfirst($value),
        );
    }
}

// получить доступ к значению аксессора
use App\Models\User;
$user = User::find(1);
$firstName = $user->first_name;

// преобразовать несколько атрибутов модели в один “объект-значение” (value object)
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;

/**
* Взаимодействуйте с адресом пользователя.
*/
protected function address(): Attribute
{
    return Attribute::make(
        get: fn (mixed $value, array $attributes) => new Address(
            $attributes['address_line_one'],
            $attributes['address_line_two'],
        ),
    );
}

// При возвращении объектов-значений из аксессоров любые изменения, внесенные в объект-значение, автоматически синхронизируются с моделью перед ее сохранением.
use App\Models\User;
$user = User::find(1);
$user->address->lineOne = 'Updated Address Line 1 Value';
$user->address->lineTwo = 'Updated Address Line 2 Value';
$user->save();

// включить кэширование для примитивных значений
protected function hash(): Attribute
{
    return Attribute::make(
        get: fn (string $value) => bcrypt(gzuncompress($value)),
    )->shouldCache();
}

// отключить кэширование для атрибутов
/**
* Взаимодействуйте с адресом пользователя.
*/
protected function address(): Attribute
{
    return Attribute::make(
        get: fn (mixed $value, array $attributes) => new Address(
            $attributes['address_line_one'],
            $attributes['address_line_two'],
        ),
    )->withoutObjectCaching();
}
</code></pre></details><details> <summary>Mutators</summary><p>Мутатор преобразует значение атрибута в момент его присвоения экземпляру Eloquent.</p><pre><code>// мутатор для атрибута first_name
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Манипуляции с именем пользователя
    */
    protected function firstName(): Attribute
    {
        return Attribute::make(
            get: fn (string $value) => ucfirst($value),
            set: fn (string $value) => strtolower($value),
        );
    }
}

// использовать мутатор
use App\Models\User;
$user = User::find(1);
$user->first_name = 'Sally';
// мутатор применит к 'Sally' функцию strtolower и установит полученное значение во внутреннем массиве $attributes

// установить несколько атрибутов в модели
use App\Support\Address;
use Illuminate\Database\Eloquent\Casts\Attribute;

/**
* Манипуляции с адресом пользователя.
*/
protected function address(): Attribute
{
    return Attribute::make(
        get: fn (mixed $value, array $attributes) => new Address(
            $attributes['address_line_one'],
            $attributes['address_line_two'],
        ),
        set: fn (Address $value) => [
            'address_line_one' => $value->lineOne,
            'address_line_two' => $value->lineTwo,
        ],
    );
}</code></pre><p>- Приведение атрибутов к типам обеспечивает функциональность, аналогичную аксессорам и мутаторам, но без необходимости определения каких-либо дополнительных методов модели.<br>
- Метод casts должен возвращать массив, где ключом является имя приводимого атрибута, а значением — тип, к которому нужно привести столбец.<br></p><a href="http://laravel.su/docs/12.x/eloquent-mutators#privedenie-atributov-k-tipam">Поддерживаемые типы преобразования</a><pre><code>// привести атрибут is_admin из значения 0 или 1 к логическому типу
namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Получение атрибутов, которые должны быть типизированы.
    *
    * @return array&lt;string, string&gt;
    */
    protected function casts(): array
    {
        return [
            'is_admin' => 'boolean',
        ];
    }
}

// применение атрибута (базовое значение хранится в базе данных как целое число)
$user = App\Models\User::find(1);
if ($user->is_admin) { }

// добавить новое временное приведение во время выполнения
$user->mergeCasts([
    'is_admin' => 'integer',
    'options' => 'object',
]);

// преобразование в строку
namespace App\Models;
use Illuminate\Database\Eloquent\Casts\AsStringable;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Получение атрибутов, которые должны быть типизированы.
    *
    * @return array&lt;string, string&gt;
    */
    protected function casts(): array
    {
        return [
            'directory' => AsStringable::class,
        ];
    }
}

// столбцы типа JSON или TEXT (содержащее сериализованный JSON) при типизации к array, автоматически десериализует атрибут модели Eloquent в массив PHP
namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Получение атрибутов, которые должны быть типизированы.
    *
    * @return array&lt;string, string&gt;
    */
    protected function casts(): array
    {
        return [
            'options' => 'array',
        ];
    }
}

// при назначении атрибута options, массив будет автоматически сериализован обратно в JSON для сохранения
use App\Models\User;

$user = User::find(1);
$options = $user->options;
$options['key'] = 'value';
$user->options = $options;
$user->save();

// обновить одно поле JSON-атрибута (разрешить массовое назначение)
$user = User::find(1);
$user->update(['options->key' => 'value']);

// преобразовать атрибут JSON в класс ArrayObject
use Illuminate\Database\Eloquent\Casts\AsArrayObject;

/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'options' => AsArrayObject::class,
    ];
}

// преобразовать атрибут JSON в экземпляр Laravel Collection
use Illuminate\Database\Eloquent\Casts\AsCollection;

/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'options' => AsCollection::class,
    ];
}

// создавало экземпляр пользовательского класса коллекции вместо базового
use App\Collections\OptionCollection;
use Illuminate\Database\Eloquent\Casts\AsCollection;

/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'options' => AsCollection::using(OptionCollection::class),
    ];
}
</code></pre></details><details> <summary>Typing</summary><p>типизация даты</p><pre><code>/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'created_at' => 'datetime:Y-m-d',
    ];
}

// настроить формат сериализации по умолчанию
/**
* Подготовить дату для сериализации массива / JSON.
*/
protected function serializeDate(DateTimeInterface $date): string
{
    return $date->format('Y-m-d');
}

// указать формат сохранения дат модели в базе данных
/**
* Формат хранения столбцов даты модели.
*
* @var string
*/
protected $dateFormat = 'U';

// столбцы created_at и updated_at всегда форматируются в формате UTC, независимо от настроек часового пояса приложения</code></pre><p>Типизация "Enum"</p><pre><code>// преобразовать значение атрибута в перечисление PHP
use App\Enums\ServerStatus;

/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'status' => ServerStatus::class,
    ];
}

// атрибут будет автоматически преобразован в перечисление и обратно
if ($server->status == ServerStatus::Provisioned) {
    $server->status = ServerStatus::Ready;

    $server->save();
}

// массив значений перечисления в одном столбце
use App\Enums\ServerStatus;
use Illuminate\Database\Eloquent\Casts\AsEnumCollection;

/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'statuses' => AsEnumCollection::of(ServerStatus::class),
    ];
}

// приведение encrypted зашифрует значение атрибута модели
// при изменении ключа в переменной окружения APP_KEY придется вручную повторно зашифровать зашифрованные атрибуты

// типизация во время запроса
use App\Models\Post;
use App\Models\User;

$users = User::select([
    'users.*',
    'last_posted_at' => Post::selectRaw('MAX(created_at)')
            ->whereColumn('user_id', 'users.id')
])->get();

// применить типизацию datetime к last_posted_at при выполнении запроса
$users = User::select([
    'users.*',
    'last_posted_at' => Post::selectRaw('MAX(created_at)')
            ->whereColumn('user_id', 'users.id')
])->withCasts([
    'last_posted_at' => 'datetime'
])->get();

// создать свой преобразователь типов в app/Casts
php artisan make:cast Json

// get - преобразует “сырое” значения из базы данных к типизированному значению
// set – преобразует типизированное значение в “сырое” значение, которое можно сохранить в базе данных
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
use Illuminate\Database\Eloquent\Model;

class Json implements CastsAttributes
{
    /**
    * Привести значение к пользовательскому типу.
    *
    * @param  array&lt;string, mixed&gt;  $attributes
    * @return array&lt;string, mixed&gt;
    */
    public function get(Model $model, string $key, mixed $value, array $attributes): array
    {
        return json_decode($value, true);
    }

    /**
    * Подготовить переданное значение к сохранению.
    *
    * @param  array&lt;string, mixed&gt;  $attributes
    */
    public function set(Model $model, string $key, mixed $value, array $attributes): string
    {
        return json_encode($value);
    }
}

// применение
namespace App\Models;
use App\Casts\Json;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Получение атрибутов, которые должны быть типизированы.
    *
    * @return array&lt;string, string&gt;
    */
    protected function casts(): array
    {
        return [
            'options' => Json::class,
        ];
    }
}

// преобразовать значения к объектам - set возвращает массив пар ключ / значение
namespace App\Casts;
use App\ValueObjects\Address as AddressValueObject;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
use Illuminate\Database\Eloquent\Model;
use InvalidArgumentException;

class Address implements CastsAttributes
{
    /**
    * Преобразовать значение к пользовательскому типу.
    *
    * @param  array&lt;string, mixed&gt;  $attributes
    */
    public function get(Model $model, string $key, mixed $value, array $attributes): AddressValueObject
    {
        return new AddressValueObject(
            $attributes['address_line_one'],
            $attributes['address_line_two']
        );
    }

    /**
    * Подготовить переданное значение к сохранению.
    *
    * @param  array&lt;string, mixed&gt;  $attributes
    * @return array&lt;string, string&gt;
    */
    public function set(Model $model, string $key, mixed $value, array $attributes): array
    {
        if (! $value instanceof AddressValueObject) {
            throw new InvalidArgumentException('The given value is not an Address instance.');
        }

        return [
            'address_line_one' => $value->lineOne,
            'address_line_two' => $value->lineTwo,
        ];
    }
}

// применение
use App\Models\User;
$user = User::find(1);
$user->address->lineOne = 'Updated Address Value';
$user->save();

// атрибуты приведеные к объектам значений кэшируются автоматически
// отключить кэширование объектов в пользовательском классе приведения
class Address implements CastsAttributes
{
    public bool $withoutObjectCaching = true;
}

// при преобразовании таблицы в массив или JSON с использованием методов toArray и toJson, объекты-значения будут сериализованы автоматически, если типизаторы реализуют интерфейсы Illuminate\Contracts\Support\Arrayable и JsonSerializable
// сериализовать вручную в пользовательском типизаторе
/**
* Получить сериализованное представление значения.
*
* @param  array&lt;string, mixed&gt;  $attributes
*/
public function serialize(Model $model, string $key, mixed $value, array $attributes): string
{
    return (string) $value;
}

// сгенерировать класс приведения только для входящих значений (только преобразует указанные значения атрибутов модели)
php artisan make:cast Hash --inbound

// типизатор хеширует входящие значения с использованием указанного алгоритма
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsInboundAttributes;
use Illuminate\Database\Eloquent\Model;

class Hash implements CastsInboundAttributes
{
    /**
    * Создать новый экземпляр класса типизации.
    */
    public function __construct(
        protected string|null $algorithm = null,
    ) {}

    /**
    * Подготовить переданное значение к сохранению.
    *
    * @param  array&lt;string, mixed&gt;  $attributes
    */
    public function set(Model $model, string $key, mixed $value, array $attributes): string
    {
        return is_null($this->algorithm)
                    ? bcrypt($value)
                    : hash($this->algorithm, $value);
    }
}

// параметры типизатора задаются с помощью символа : через запятую
/**
* Получение атрибутов, которые должны быть типизированы.
*
* @return array&lt;string, string&gt;
*/
protected function casts(): array
{
    return [
        'secret' => Hash::class.':sha256',
    ];
}

// определить класс типизатора в объекте-значения
// возвращает имя пользовательского класса типизатора
namespace App\ValueObjects;
use Illuminate\Contracts\Database\Eloquent\Castable;
use App\Casts\Address as AddressCast;

class Address implements Castable
{
    /**
    * Получить имя класса типизатора для использования двустороннего преобразования.
    *
    * @param  array&lt;string, mixed&gt;  $arguments
    */
    public static function castUsing(array $arguments): string
    {
        return AddressCast::class;
    }
}

// применение
use App\ValueObjects\Address;
protected function casts(): array
{
    return [
        'address' => Address::class.':argument',
    ];
}

// либо
namespace App\ValueObjects;
use Illuminate\Contracts\Database\Eloquent\Castable;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;

class Address implements Castable
{
    /**
    * Получить имя класса типизатора для использования двустороннего преобразования.
    *
    * @param  array&lt;string, mixed&gt;  $arguments
    */
    public static function castUsing(array $arguments): CastsAttributes
    {
        return new class implements CastsAttributes
        {
            public function get(Model $model, string $key, mixed $value, array $attributes): Address
            {
                return new Address(
                    $attributes['address_line_one'],
                    $attributes['address_line_two']
                );
            }

            public function set(Model $model, string $key, mixed $value, array $attributes): array
            {
                return [
                    'address_line_one' => $value->lineOne,
                    'address_line_two' => $value->lineTwo,
                ];
            }
        };
    }
}
</code></pre></details><details> <summary>Api resources</summary><details> <summary>Resource classes</summary><p>классы ресурсов Eloquent преобразуют модель в массив</p><pre><code>- сгенерировать новый ресурс модели
php artisan make:resource UserResource

- класс ресурса
namespace App\Http\Resources;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class UserResource extends JsonResource
{
    /**
    * Преобразовать ресурс в массив.
    *
    * @return array&lt;string, mixed&lt;
    */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'email' => $this->email,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}

- вернуть ресурс из маршрута или контроллера (массив ресурса будет преобразован в JSON)
use App\Http\Resources\UserResource;
use App\Models\User;

Route::get('/user/{id}', function (string $id) {
    return new UserResource(User::findOrFail($id));
});

- для возврата коллекции ресурса или ответа с постраничной разбивкой
- экземпляр пагинатора можно передать методу collection ресурса или коллекции ресурса
use App\Http\Resources\UserResource;
use App\Models\User;

Route::get('/users', function () {
    return UserResource::collection(User::all());
});</code></pre><p>включить связанные ресурсы в ответ: добавить посты пользователя в ответ ресурса</p><pre><code>use App\Http\Resources\PostResource;
use Illuminate\Http\Request;

/**
* Преобразовать ресурс в массив.
*
* @return array&lt;string, mixed&gt;
*/
public function toArray(Request $request): array
{
    return [
        'id' => $this->id,
        'name' => $this->name,
        'email' => $this->email,
        'posts' => PostResource::collection($this->posts),
        'created_at' => $this->created_at,
        'updated_at' => $this->updated_at,
    ];
}</code></pre><p>ответ ресурса после возврата из маршрута или контроллера (преобразован в JSON)</p><pre><code>- верхний ресурс обёрнут в ключ data
 {
   "data": [
     {
         "id": 1,
         "name": "Eladio Schroeder Sr.",
         "email": "therese28@example.com"
     },
     {
         "id": 2,
         "name": "Liliana Mayert",
         "email": "evandervort@example.com"
     }
   ]
 }

 - отключить обертывание верхнего ресурса
 namespace App\Providers;
 use Illuminate\Http\Resources\Json\JsonResource;
 use Illuminate\Support\ServiceProvider;

 class AppServiceProvider extends ServiceProvider
 {
     /**
     * Регистрация любых служб приложения.
     */
     public function register(): void { }

     /**
     * Загрузка любых служб приложения.
     */
     public function boot(): void
     {
         JsonResource::withoutWrapping();
     }
 }</code></pre><p>- разбитые на страницы ответы всегда содержат ключи meta и links с информацией о состоянии постраничной разбивки,<br>
поэтому Laravel обернет данные ресурса в ключ data, даже если был вызван метод withoutWrapping<br></p><pre><code>{
  "data": [
      {
        "id": 1,
        "name": "Eladio Schroeder Sr.",
        "email": "therese28@example.com"
      },
      {
        "id": 2,
        "name": "Liliana Mayert",
        "email": "evandervort@example.com"
      }
  ],
  "links":{
    "first": "http://example.com/users?page=1",
    "last": "http://example.com/users?page=1",
    "prev": null,
    "next": null
  },
  "meta":{
    "current_page": 1,
    "from": 1,
    "last_page": 1,
    "path": "http://example.com/users",
    "per_page": 15,
    "to": 10,
    "total": 10
  }
}</code></pre><p>настроить информацию, включаемую в ключи links или meta ответа пагинации</p><pre><code>/**
* Настроика информации о постраничной навигации для ресурса.
*
* @param  \Illuminate\Http\Request  $request
* @param  array $paginated
* @param  array $default
* @return array
*/
public function paginationInformation($request, $paginated, $default)
{
    $default['links']['custom'] = 'https://example.com';

    return $default;
}</code></pre><p>включить атрибут в ответ ресурса, по условию</p><pre><code>- включить в ответ значение 'secret-value', только если текущий пользователь администратор
public function toArray(Request $request): array
{
    return [
        'id' => $this->id,
        'name' => $this->name,
        'email' => $this->email,
        'secret' => $this->when($request->user()->isAdmin(), 'secret-value'),
        'created_at' => $this->created_at,
        'updated_at' => $this->updated_at,
    ];
}

либо вычислить результирующее значение, только если переданное условие истинно
'secret' => $this->when($request->user()->isAdmin(), function () {
    return 'secret-value';
}),

- включение атрибута, если он присутствует в модели
'name' => $this->whenHas('name')

- включения атрибута в ответ ресурса, если атрибут не равен null
'name' => $this->whenNotNull($this->name)

- несколько атрибутов при одном и том же условии (ключи должны быть одного типа (string, int), цифровые ключи должны быть упорядочены)
public function toArray(Request $request): array
{
    return [
        'id' => $this->id,
        'name' => $this->name,
        'email' => $this->email,
        $this->mergeWhen($request->user()->isAdmin(), [
            'first-secret' => 'value',
            'second-secret' => 'value',
        ]),
        'created_at' => $this->created_at,
        'updated_at' => $this->updated_at,
    ];
}</code></pre><p>включать отношения в ответ ресурса если отношение уже загружено в модель (позволяет избежать проблем «N+1» с запросами в ресурсах)</p><pre><code>- ключ posts будет удален из ответа ресурса, если отношение не было загружено
use App\Http\Resources\PostResource;
public function toArray(Request $request): array
{
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'posts' => PostResource::collection($this->whenLoaded('posts')),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];
}

- включить счетчик отношений в ответ ресурса, если счетчик отношений был загружен в модели
new UserResource($user->loadCount('posts'));

public function toArray(Request $request): array
{
  return [
    'id' => $this->id,
    'name' => $this->name,
    'email' => $this->email,
    'posts_count' => $this->whenCounted('posts'),
    'created_at' => $this->created_at,
    'updated_at' => $this->updated_at,
  ];
}
- условная загрузка агрегатов avg, sum, min и max
'words_avg' => $this->whenAggregated('posts', 'words', 'avg'),
'words_sum' => $this->whenAggregated('posts', 'words', 'sum'),
'words_min' => $this->whenAggregated('posts', 'words', 'min'),
'words_max' => $this->whenAggregated('posts', 'words', 'max'),</code></pre><p>включать данные из сводных таблиц отношений «многие ко многим» по условию</p><pre><code>// 'role_user' - имя сводной таблицы
public function toArray(Request $request): array
{
  return [
    'id' => $this->id,
    'name' => $this->name,
    'expires_at' => $this->whenPivotLoaded('role_user', function () {
      return $this->pivot->expires_at;
    }),
  ];
}

либо экземпляр модели сводной таблицы в качестве первого аргумента
'expires_at' => $this->whenPivotLoaded(new Membership, function () {
  return $this->pivot->expires_at;
}),

- если сводная таблица использует аксессор
public function toArray(Request $request): array
{
  return [
    'id' => $this->id,
    'name' => $this->name,
    'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {
      return $this->subscription->expires_at;
    }),
  ];
}</code></pre><p>включить в ответ самого верхнего русурса массив метаданных</p><pre><code>namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;

class UserCollection extends ResourceCollection
{
    public function toArray(Request $request): array
    {
        return parent::toArray($request);
    }

    /**
    * Получить дополнительные данные, возвращаемые с массивом ресурса.
    *
    * @return array&lt;string, mixed&gt;
    */
    public function with(Request $request): array
    {
        return [
            'meta' => [
                'key' => 'value',
            ],
        ];
    }
}</code></pre><p>добавить данные верхнего уровня при создании экземпляров ресурсов в маршруте или контроллере</p><pre><code>return (new UserCollection(User::all()->load('roles')))
        ->additional(['meta' => [
            'key' => 'value',
        ]]);</code></pre><p>связать метод response связанный с ресурсом, вернет экземпляр Illuminate\Http\JsonResponse, что даст полный контроль над заголовками HTTP-ответа</p><pre><code>use App\Http\Resources\UserResource;
use App\Models\User;

Route::get('/user', function () {
    return (new UserResource(User::find(1)))
                ->response()
                ->header('X-Value', 'True');
});

либо определить метод withResponse внутри самого ресурса, если ресурс самый верхний в ответе
namespace App\Http\Resources;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class UserResource extends JsonResource
{
    /**
    * Преобразовать ресурс в массив.
    *
    * @return array<string, mixed>
    */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
        ];
    }

    /**
    * Настроить исходящий ответ для ресурса.
    */
    public function withResponse(Request $request, JsonResponse $response): void
    {
        $response->header('X-Value', 'True');
    }
}
</code></pre></details><details> <summary>Resource collections</summary><p>- коллекции ресурса, позволяет определить любые метаданные, которые должны быть включены в ответ<br>
- коллекции ресурса преобразуют коллекцию моделей в массив<br></p><pre><code>- сгенерировать новую коллекцию ресурса
php artisan make:resource User --collection

либо
php artisan make:resource UserCollection

- класс коллекции ресурса
namespace App\Http\Resources;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\ResourceCollection;

class UserCollection extends ResourceCollection
{
    /**
    * Преобразовать коллекцию ресурса в массив.
    *
    * @return array&lt;int|string, mixed&gt;
    */
    public function toArray(Request $request): array
    {
        return [
            'data' => $this->collection,
            'links' => [
                'self' => 'link-value',
            ],
        ];
    }
}

- вернуть из маршрута или контроллера (массив коллекции будет преобразован в JSON)
use App\Http\Resources\UserCollection;
use App\Models\User;

Route::get('/users', function () {
    return new UserCollection(User::all());
});</code></pre><p>сохранять исходные ключи коллекции при возврате из маршрута (по умолчанию меняет на числовые)</p><pre><code>namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\JsonResource;

class UserResource extends JsonResource
{
    /**
    * Указывает, следует ли сохранить ключи коллекции ресурса.
    *
    * @var bool
    */
    public $preserveKeys = true;
}

- вернуть коллекцию ресурса
use App\Http\Resources\UserResource;
use App\Models\User;

Route::get('/users', function () {
    return UserResource::collection(User::all()->keyBy->id);
});</code></pre><p>- каждый элемент коллекции сопостовляется с его единственным классом ресурсов<br>
- единственным классом ресурса является коллекции UserCollection может быть либо класс User либо класс UserResource<br>
- изменить класс ресурса для коллекции</p><pre><code>namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;

class UserCollection extends ResourceCollection
{
    /**
    * Ресурс, используемый при формировании коллекции.
    *
    * @var string
    */
    public $collects = Member::class;
}</code></pre><p>- чтобы обернуть все коллекции ресурсов ключом data, независимо от их вложенности<br>
нужно определить класс коллекции для каждого ресурса и вернуть коллекцию с ключом data<br></p><pre><code>namespace App\Http\Resources;
use Illuminate\Http\Resources\Json\ResourceCollection;

class CommentsCollection extends ResourceCollection
{
    /**
    * Преобразовать коллекцию ресурса в массив.
    *
    * @return array&lt;string, mixed&gt;
    */
    public function toArray(Request $request): array
    {
        return ['data' => $this->collection];
    }
}</code></pre><p>- oтветы с постраничной разбивкой всегда содержат ключи meta и links с информацией о состоянии пагинатора</p><pre><code>{
  "data": [
      {
        "id": 1,
        "name": "Eladio Schroeder Sr.",
        "email": "therese28@example.com"
      },
      {
        "id": 2,
        "name": "Liliana Mayert",
        "email": "evandervort@example.com"
      }
  ],
  "links":{
    "first": "http://example.com/users?page=1",
    "last": "http://example.com/users?page=1",
    "prev": null,
    "next": null
  },
  "meta":{
    "current_page": 1,
    "from": 1,
    "last_page": 1,
    "path": "http://example.com/users",
    "per_page": 15,
    "to": 10,
    "total": 10
  }
}
</code></pre></details><details> <summary>Serialization</summary><p>сериализация в массив</p><pre><code>- преобразовать модель и ее загруженные отношения в массив
use App\Models\User;
$user = User::with('roles')->first();
return $user->toArray();

- преобразованиe атрибутов модели в массив
$user = User::first();
return $user->attributesToArray();

- преобразовать коллекции моделей в массивы
$users = User::all();
return $users->toArray();</code></pre><p>сериализация в JSON</p><pre><code>- преобразовать модель и ее загруженные отношения в JSON
use App\Models\User;
$user = User::find(1);
return $user->toJson();
return $user->toJson(JSON_PRETTY_PRINT);

- преобразование модели или коллекции в строку, автоматически вызовет метод toJson
return (string) User::find(1);

- Laravel автоматически сериализует модели и коллекции Eloquent в JSON, когда они возвращаются из маршрутов или контроллеров
Route::get('/users', function () {
  return User::all();
});</code></pre><p>cкрытие атрибутов из JSON</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Атрибуты, которые должны быть скрыты для сериализации.
    *
    * @var array&lt;string&gt;
    */
    protected $hidden = ['password'];
}

либо только те, которые видны
protected $visible = ['first_name', 'last_name'];

- сделать некоторые обычно скрытые атрибуты видимыми на конкретном экземпляре модели
return $user->makeVisible('attribute')->toArray();

- скрыть некоторые атрибуты, которые обычно видны
return $user->makeHidden('attribute')->toArray();

- временно переопределить все видимые или скрытые атрибуты
return $user->setVisible(['id', 'name'])->toArray();
return $user->setHidden(['email', 'password', 'remember_token'])->toArray();</code></pre><p>добавить атрибуты, которым нет соответствующего столбца в базе данных, при преобразовании моделей в массивы или JSON</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
    * Определить, является ли пользователь администратором.
    */
    protected function isAdmin(): Attribute
    {
        return new Attribute(
            get: fn () => 'yes',
        );
    }
}</code></pre><p>чтобы аксессор всегда добавлялся к массиву и JSON-представлению вашей модели</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
  /**
  * Аксессоры, добавляемые к массиву модели.
  *
  * @var array
  */
  protected $appends = ['is_admin'];
}</code></pre><p>добавить дополнительные атрибуты во время выполнения скрипта</p><code>return $user->append('is_admin')->toArray();</code><p>чтобы переопределить весь массив добавленных свойств для конкретного экземпляра модели</p><code>return $user->setAppends(['is_admin'])->toArray();</code><p>сериализация даты</p><pre><code>- формат сериализации массива/JSON для всех дат модели по умолчанию
protected function serializeDate(DateTimeInterface $date): string
{
  return $date->format('Y-m-d');
}
- настроить формат сериализации отдельных атрибутов даты
protected function casts(): array
{
  return [
    'birthday' => 'date:Y-m-d',
    'joined_at' => 'datetime:Y-m-d H:00',
  ];
}
</code></pre></details></details><details><summary>Migrations</summary><p>- миграции позволяют создавать и изменять таблицы базы данных<br>
- фасад Schema используется для создания и изменения таблиц / столбцов базы данных во время миграции<br>
- создать миграцию<br></p><code>php artisan make:migration create_flights_table  // поместит в database/migrations</code><p>«сжать» миграции в один файл SQL</p><pre><code>php artisan schema:dump

- выгрузить текущую схему БД и удалить все существующие миграции ...
php artisan schema:dump --prune  // поместит в database/schema</code></pre><p>- сначала выполняются SQL-операторы дампа, потом все оставшиеся миграции, которые не были включены в дамп схемы БД<br>
- создать файл схемы базы данных с поключением тестов к базе данных<br></p><pre><code>php artisan schema:dump
php artisan schema:dump --database=testing --prune</code></pre><p>- Класс миграции содержит два метода: up и down.
- up для добавления новых таблиц, столбцов или индексов
- down отменить операции, выполняемые методом up.
- создать таблицу flights:</p><pre><code>use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
    * Запустить миграцию.
    */
    public function up(): void
    {
        Schema::create('flights', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('airline');
            $table->timestamps();
        });
    }

    /**
    * Обратить миграции.
    */
    public function down(): void
    {
        Schema::drop('flights');
    }
};</code></pre><p>указать соединение с базой данных, отличное от соединения с базой данных по умолчанию</p><pre><code>/**
* Соединение с БД, которое должно использоваться миграцией.
*
* @var string
*/
protected $connection = 'pgsql';

/**
* Запустить миграцию.
*/
public function up(): void { }</code></pre><p>запустить все незавершенные миграции</p><code>php artisan migrate</code><p>узнать какие миграции выполнены</p><code>php artisan migrate:status</code><p>посмотреть SQL-запросы, которые будут выполнены миграциями без запуска миграций</p><code>php artisan migrate --pretend</code><p>блокировать другие попытки выполнить команду migrate, пока выполняется текущая миграция</p><code>php artisan migrate --isolated</code><p>запуск команды без подтверждения</p><code>php artisan migrate --force</code><p>откатить последнюю миграцию</p><code>php artisan migrate:rollback</code><p>откатить ограниченное количество миграций</p><code>php artisan migrate:rollback --step=5</code><p>откатить все миграции в третьей партии (партии в таблице migrations)</p><code>php artisan migrate:rollback --batch=3</code><p>посмотреть SQL-запросы миграций без их выполнения</p><code>php artisan migrate:rollback --pretend</code><p>откатить все миграции</p><code>php artisan migrate:reset</code><p>откат и миграция одной командой</p><pre><code>php artisan migrate:refresh

- откатить базу данных и запустить все наполнители базы данных...
php artisan migrate:refresh --seed

- откатить и повторно запустить последние пять миграций
php artisan migrate:refresh --step=5</code></pre><p>удалить все таблицы из базы данных и выполнить миграцию</p><pre><code>php artisan migrate:fresh

php artisan migrate:fresh --seed

- указать имя соединения с базой данных, которое следует использовать (имя соединения из конфига)
php artisan migrate:fresh --database=admin</code></pre><p>создать таблицу</p><pre><code>use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::create('users', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('email');
    $table->timestamps();
});</code></pre><p>определить наличие таблицы, столбца или индекса</p><pre><code>if (Schema::hasTable('users')) {
    // Таблица `users` существует...
}

if (Schema::hasColumn('users', 'email')) {
    // Таблица `users` существует и содержит столбец `email`...
}

if (Schema::hasIndex('users', ['email'], 'unique')) {
    // Таблица `users` существует и имеет уникальный индекс в столбце `email`...
}</code></pre><p>выполнить операцию схемы с подключением подключением к базе данных не по умолчанию</p><pre><code>Schema::connection('sqlite')->create('users', function (Blueprint $table) {
    $table->id();
});</code></pre><p>указать механизм хранения таблицы в MariaDB или MySQL</p><pre><code>Schema::create('users', function (Blueprint $table) {
    $table->engine('InnoDB');
});</code></pre><p>указать набор символов и сопоставления для создаваемой таблицы в MariaDB или MySQL</p><pre><code>Schema::create('users', function (Blueprint $table) {
    $table->charset('utf8mb4');
    $table->collation('utf8mb4_unicode_ci');
});</code></pre><p>указать, что таблица «временная»: видна только текущему соединению и удаляется при закрытии соединения</p><pre><code>Schema::create('calculations', function (Blueprint $table) {
    $table->temporary();
});</code></pre><p>комментарий к таблице базы данных, только в MariaDB, MySQL и PostgreSQL</p><pre><code>Schema::create('calculations', function (Blueprint $table) {
    $table->comment('Business calculations');
});</code></pre><p>обновление существующих таблиц</p><pre><code>use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('users', function (Blueprint $table) {
    $table->integer('votes');
});</code></pre><p>переименовать существующую таблицу базы данных</p><pre><code>use Illuminate\Support\Facades\Schema;
Schema::rename($from, $to);</code></pre><p>удалить существующую таблицу (внешний ключ в таблице должен иметь явное имя в файлах миграции)</p><pre><code>Schema::drop('users');
Schema::dropIfExists('users');</code></pre><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-stolbcov">типы столбцов</a><p>столбец допускающий значение NULL</p><pre><code>use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('users', function (Blueprint $table) {
    $table->string('email')->nullable();
});</code></pre><a href="http://laravel.su/docs/12.x/migrations#modifikatory-stolbca">модификаторы столбцов</a><p>назначить значения по умолчанию</p><pre><code>use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Query\Expression;
use Illuminate\Database\Migrations\Migration;

return new class extends Migration
{
    /**
    * Запустить миграцию.
    */
    public function up(): void
    {
        Schema::create('flights', function (Blueprint $table) {
            $table->id();
            $table->json('movies')->default(new Expression('(JSON_ARRAY())'));
            $table->timestamps();
        });
    }
};</code></pre><p>добавляет набор столбцов после существующего в MariaDB или MySQL</p><pre><code>$table->after('password', function (Blueprint $table) {
    $table->string('address_line1');
    $table->string('address_line2');
    $table->string('city');
});</code></pre><p>изменить тип и атрибуты существующих колонок</p><pre><code>Schema::table('users', function (Blueprint $table) {
    $table->string('name', 50)->change();
});

- добавить атрибуты unsigned, default и comment
Schema::table('users', function (Blueprint $table) {
    $table->integer('votes')->unsigned()->default(1)->comment('мой комментарий')->change();
});</code></pre><p>модификаторы индекса</p><pre><code>- добавляем индекс...
$table->bigIncrements('id')->primary()->change();

- удаляем индекс...
$table->char('postal_code', 10)->unique(false)->change();</code></pre><p>переименование столбца</p><pre><code>Schema::table('users', function (Blueprint $table) {
    $table->renameColumn('from', 'to');
});</code></pre><p>удалениe столбца</p><pre><code>Schema::table('users', function (Blueprint $table) {
    $table->dropColumn('votes');
});

либо
Schema::table('users', function (Blueprint $table) {
    $table->dropColumn(['votes', 'avatar', 'location']);
});</code></pre><a href="http://laravel.su/docs/12.x/migrations#dostupnye-psevdonimy-komand">псевдонимы команд</a><p>создать индекс</p><pre><code>- при создании столбца
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('users', function (Blueprint $table) {
    $table->string('email')->unique();
});

- на существующем столбце
$table->unique('email');</code></pre><p>созданиe составного индекса</p><code>$table->index(['account_id', 'created_at']);</code><p>указать имя индекса вручную (второй аргумент)</p><code>$table->unique('email', 'unique_email');</code><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-indeksov">типы индексов</a><p>переименовать индекс</p><code>$table->renameIndex('from', 'to')</code><a href="http://laravel.su/docs/12.x/migrations#udalenie-indeksov">удалить индекс</a><pre><code>Schema::table('geo', function (Blueprint $table) {
    $table->dropIndex(['state']);    // Удалить простой индекс `geo_state_index`.
});</code></pre><p>создание внешнего ключа</p><pre><code>use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('posts', function (Blueprint $table) {
    $table->unsignedBigInteger('user_id');

    $table->foreign('user_id')->references('id')->on('users');
});

либо
Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained();
});</code></pre><p>указать имя таблицы и созданного индекса</p><pre><code>Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained(
        table: 'users', indexName: 'posts_user_id'
    );
});</code></pre><p>указать действие при удалении и при обновлении</p><pre><code>$table->foreignId('user_id')
      ->constrained()
      ->onUpdate('cascade')
      ->onDelete('cascade');</code></pre><p>любые модификаторы столбца должны быть вызваны перед constrained</p><pre><code>$table->foreignId('user_id')
      ->nullable()
      ->constrained();</code></pre><p>- удалить внешний ключ<br>
- имя внешнего ключа основано на имени таблицы и столбцов и суффикса _foreign<br></p><pre><code>$table->dropForeign('posts_user_id_foreign');

либо
$table->dropForeign(['user_id']);</code></pre><p>включить или отключить внешний ключ в миграциях</p><pre><code>Schema::enableForeignKeyConstraints();

Schema::disableForeignKeyConstraints();

Schema::withoutForeignKeyConstraints(function () {
    // Ограничения отключены внутри этого замыкания...
});</code></pre><p>SQLite по умолчанию отключает внешние ключи</p><a href="http://laravel.su/docs/12.x/migrations#sobytiia">каждая операция миграции отправляет событие</a><details><summary>Rename table</summary><p>в файле config/queue.php меняю название таблиц по умолчанию<br>
к названию таблицы добавляю слово queue</p><pre><code>'database' => [
  'driver' => 'database',
  'connection' => env('DB_QUEUE_CONNECTION'),
  'table' => env('DB_QUEUE_TABLE', 'queued_jobs'),
  'queue' => env('DB_QUEUE', 'default'),
  'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
  'after_commit' => false,
],

'batching' => [
  'database' => env('DB_CONNECTION', 'sqlite'),
  'table' => 'queued_job_batches',
],
'failed' => [
    'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
    'database' => env('DB_CONNECTION', 'sqlite'),
    'table' => 'queued_failed_jobs',
], </code></pre><p>в папке database/migrations/<br>
к названию файла по умолчанию добавляю слово queue</p><code>0001_01_01_000002_create_queued_jobs_table.php</code><p>в нутри файлa к названиям таблиц добавляю слово queue</p><pre><code>Schema::create('queued_jobs', function (Blueprint $table) {
  ...
Schema::create('queued_job_batches', function (Blueprint $table) {
  ...
Schema::create('queued_failed_jobs', function (Blueprint $table) {</code></pre><p>удаляю старые файлы и создаю новые c учётом изменений</p><code>php artisan migrate:fresh</code><p>чтобы внести изменения в базу данных:</p><code>php artisan migrate</code></details></details><details><summary>Seeders</summary><p>классы наполнителей хранятся в database/seeders<br></p><pre><code>- сгенерировать новый наполнитель
php artisan make:seeder UserSeeder</code></pre><p>вставлять данные в базу данных</p><pre><code>namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

class DatabaseSeeder extends Seeder
{
    /**
    * Запустить наполнение базы данных.
    */
    public function run(): void
    {
        DB::table('users')->insert([
            'name' => Str::random(10),
            'email' => Str::random(10).'@example.com',
            'password' => Hash::make('password'),
        ]);
    }
}</code></pre><p>метод call для запуска других наполнителей</p><pre><code>public function run(): void
{
    $this->call([
        UserSeeder::class,
        PostSeeder::class,
        CommentSeeder::class,
    ]);
}</code></pre><p>отправку событий модели во время выполнения сидов (seeds)</p><pre><code>namespace Database\Seeders;
use Illuminate\Database\Seeder;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;

class DatabaseSeeder extends Seeder
{
    use WithoutModelEvents;

    /**
    * Запуск сидеров базы данных.
    */
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
        ]);
    }
}</code></pre><p>Sequence меняет значения полей для каждой итерации цикла создания данных</p><pre><code>public function run(): void
{
  $tags = Tag::factory(3)->create();
  Job::factory(20)->hasAttached($tags)->create(new Sequence([
    'featured' => false,
    'schedule' => 'Full Time',
  ], [
    'featured' => true,
    'schedule' => 'Part Time',
  ]));
}</code></pre><p>наполнить БД</p><pre><code>php artisan db:seed

- указать конкретный класс наполнителя
php artisan db:seed --class=UserSeeder</code></pre><p>полная перестройка базы данных с наполнением</p><pre><code>php artisan migrate:fresh --seed

- указать конкретный класс наполнителя
php artisan migrate:fresh --seed --seeder=UserSeeder</code></pre><p>запустить наполнители без подтверждений</p><code>php artisan db:seed --force</code></details><details> <summary>Factories</summary><p>- фабрики моделей для удобного создания большого количества записей в БД
- языковой стандарт Faker - параметр faker_locale в config/app.php</p><pre><code>- сгенерировать фабрику для модели User в database/factories с именем UserFactory
php artisan make:factory UserFactory

// в модели User
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory;
}</code></pre><p>создать фабрику вручную</p><pre><code>// в модели
use Database\Factories\Administration\FlightFactory;

/**
* Создать новый экземпляр фабрики для модели.
*/
protected static function newFactory()
{
    return FlightFactory::new();
}

// в фабрике
use App\Administration\Flight;
use Illuminate\Database\Eloquent\Factories\Factory;

class FlightFactory extends Factory
{
    /**
    * Название модели, соответствующей фабрике.
    *
    * @var class-string<\Illuminate\Database\Eloquent\Model>
    */
    protected $model = Flight::class;
}</code></pre><p>состояние фабрик</p><pre><code>// изменить значение атрибута в фабрике \Database\Factories\UserFactory
use Illuminate\Database\Eloquent\Factories\Factory;

/**
* Указать, что аккаунт пользователя временно приостановлен.
*/
public function suspended(): Factory
{
    return $this->state(function (array $attributes) {
        return [
            'account_status' => 'suspended',
        ];
    });
}

// создать модель без сохранения в базе данных
use App\Models\User;

$user = User::factory()->make();

// создать коллекцию из множества моделей
$users = User::factory()->count(3)->make();

// применить состояние к модели
$users = User::factory()->count(5)->suspended()->make();

// переопределить значения по умолчанию для моделей
$user = User::factory()->make([
    'name' => 'Abigail Otwell',
]);

// либо
$user = User::factory()->state([
    'name' => 'Abigail Otwell',
])->make();

// создать модель
use App\Models\User;

// Создаем один экземпляр `App\Models\User` ...
$user = User::factory()->create();

// Создаем три экземпляра `App\Models\User` .
$users = User::factory()->count(3)->create();

// переопределить атрибуты модели по умолчанию
$user = User::factory()->create([
    'name' => 'Abigail',
]);

// чередовать значение атрибута для каждой создаваемой модели
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Sequence;
$users = User::factory()
                ->count(10)
                ->state(new Sequence(
                    ['admin' => 'Y'],
                    ['admin' => 'N'],
                ))
                ->create();

// либо
use Illuminate\Database\Eloquent\Factories\Sequence;
$users = User::factory()
                ->count(10)
                ->state(new Sequence(
                    fn (Sequence $sequence) => ['role' => UserRoles::all()->random()],
                ))
                ->create();

// либо
$users = User::factory()
                ->count(10)
                ->sequence(fn (Sequence $sequence) => ['name' => 'Name '.$sequence->index])
                ->create();

// либо
$users = User::factory()
                ->count(2)
                ->sequence(
                    ['name' => 'First User'],
                    ['name' => 'Second User'],
                )
                ->create();</code></pre><p>отношения фабрик</p><pre><code>// создать пользователя с тремя постами, модель User должна иметь метод posts, который определяет отношения
use App\Models\Post;
use App\Models\User;
$user = User::factory()
            ->has(Post::factory()->count(3))
            ->create();

// либо указать метод отношений модели User вручную
$user = User::factory()
            ->has(Post::factory()->count(3), 'posts')
            ->create();

// манипуляции с состоянием связанных моделей
$user = User::factory()
            ->has(
                Post::factory()
                        ->count(3)
                        ->state(function (array $attributes, User $user) {
                            return ['user_type' => $user->type];
                        })
            )
            ->create();

// либо при наличии метода отношений posts модели User использовать магический метод отношений фабрики hasPosts()
$user = User::factory()
            ->hasPosts(3)
            ->create();

// создадим 50 пользователей, по одному посту у каждого
use App\Models\User;
public function run(): void
{
    User::factory()
            ->count(50)
            ->hasPosts(1)
            ->create();
}

// переопределение атрибутов в связанных моделях
$user = User::factory()
            ->hasPosts(3, [
                'published' => false,
            ])
            ->create();

// либо
$user = User::factory()
            ->hasPosts(3, function (array $attributes, User $user) {
                return ['user_type' => $user->type];
            })
            ->create();

// обратное отношение for, для определения родительской модели
use App\Models\Post;
use App\Models\User;
$posts = Post::factory()
            ->count(3)
            ->for(User::factory()->state([
                'name' => 'Jessica Archer',
            ]))
            ->create();

// либо
$user = User::factory()->create();
$posts = Post::factory()
            ->count(3)
            ->for($user)
            ->create();

// магический метод отношений фабрики при наличии отношения user в модели Post
$posts = Post::factory()
            ->count(3)
            ->forUser([
                'name' => 'Jessica Archer',
            ])
            ->create();

// отношения Many To Many
use App\Models\Role;
use App\Models\User;
$user = User::factory()
            ->has(Role::factory()->count(3))
            ->create();

// установить атрибуты в связующей таблице
use App\Models\Role;
use App\Models\User;
$user = User::factory()
            ->hasAttached(
                Role::factory()->count(3),
                ['active' => true]
            )
            ->create();

// преобразовать состояние связанной модели через доступ к родительской модели
$user = User::factory()
            ->hasAttached(
                Role::factory()
                    ->count(3)
                    ->state(function (array $attributes, User $user) {
                        return ['name' => $user->name.' Role'];
                    }),
                ['active' => true]
            )
            ->create();

// прикрепить существующие записи к создаваемым моделям
// трем пользователям будут назначены одни и те же три роли
$roles = Role::factory()->count(3)->create();
$user = User::factory()
            ->count(3)
            ->hasAttached($roles, ['active' => true])
            ->create();

// магический метод отношений фабрики при наличии метода отношений roles модели User
$user = User::factory()
            ->hasRoles(1, [
                'name' => 'Editor'
            ])
            ->create();

// Полиморфные отношения Morph Many создаются так же, как типичные отношения Has Many
// модель App\Models\Post имеет отношение morphMany с моделью App\Models\Comment
use App\Models\Post;
$post = Post::factory()->hasComments(3)->create();

// создать три комментария, относящиеся к одному посту, используя напрямую метод for
$comments = Comment::factory()->count(3)->for(
    Post::factory(), 'commentable'
)->create();

// полиморфные отношения Many To Many 
use App\Models\Tag;
use App\Models\Video;
$videos = Video::factory()
            ->hasAttached(
                Tag::factory()->count(3),
                ['public' => true]
            )
            ->create();

// либо
$videos = Video::factory()
            ->hasTags(3, ['public' => true])
            ->create();

// определить отношение в рамках фабрики
// создать нового пользователя при создании публикации
use App\Models\User;
/**
* Определить состояние модели по умолчанию.
*
* @return array<string, mixed>
*/
public function definition(): array
{
    return [
        'user_id' => User::factory(),
        'title' => fake()->title(),
        'content' => fake()->paragraph(),
    ];
}

/**
* Определить состояние модели по умолчанию.
*
* @return array&lt;string, mixed&gt;
*/
public function definition(): array
{
    return [
        'user_id' => User::factory(),
        'user_type' => function (array $attributes) {
            return User::find($attributes['user_id'])->type;
        },
        'title' => fake()->title(),
        'content' => fake()->paragraph(),
    ];
}

// использовать одну и ту же авиакомпанию как для билета, так и для рейса
Ticket::factory()
    ->recycle(Airline::factory()->create())
    ->create();

// recycle принимает коллекцию существующих моделей - будет выбрана случайная модель из коллекции
Ticket::factory()
    ->recycle($airlines)
    ->create();
</code></pre></details><details> <summary>Relations</summary><p>Отношения определяются как методы в классах модели.<br>
Отношения реализованы поверх построителей запросов.<br>
Внешний ключ в дочерней модели Eloquent ищет по имени родидельской модели с суффиксом _id,<br>
например: родительская модель User, дочерняя модель Phone должна иметь столбец user_id<br></p><pre><code>не ->posts, а ->posts()
$user->posts()->where('active', 1)->get();</code></pre><p>один к одному (имеет одного)</p><pre><code>// запись модели User связана с одной записью модели Phone
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOne;

class User extends Model
{
    /**
    * Получить телефон, связанный с пользователем.
    */
    public function phone(): HasOne
    {
        // если модель Phone имеет внешний ключ user_id
        // Eloquent будет искать id пользователя из модели User в столбце user_id модели Phone
        return $this->hasOne(Phone::class);

        // задать внешний ключ вручную
        return $this->hasOne(Phone::class, 'foreign_key');

        // задать искомое значение в user_id вручную
        return $this->hasOne(Phone::class, 'foreign_key', 'local_key');
    }
}

// получить связанную запись
$phone = User::find(1)->phone;


// определить инверсию отношения hasOne
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Phone extends Model
{
    /**
    * Получить пользователя, владеющего телефоном.
    */
    public function user(): BelongsTo
    {
        // если модель Phone имеет внешний ключ user_id
        // Eloquent будет искать значение user_id модели Phone в столбце id модели User  
        return $this->belongsTo(User::class);

        // задать внешний ключ вручную
        return $this->belongsTo(User::class, 'foreign_key');

        // задать вручную искомое в id модели User значение
        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');
    }
}</code></pre><p>один ко многим (имеет много)</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Post extends Model
{
    /**
    * Получить комментарии к посту блога.
    */
    public function comments(): HasMany
    {
        // получим коллекцию связанных комментариев
        return $this->hasMany(Comment::class);

        // задать внешний ключ вручную
        return $this->hasMany(Comment::class, 'foreign_key');

        // задать искомое значение в post_id вручную
        return $this->hasMany(Comment::class, 'foreign_key', 'local_key');
    }
}

// получить комментарии
use App\Models\Post;
$comments = Post::find(1)->comments;
foreach ($comments as $comment) { }

// дополнительные ограничения
$comment = Post::find(1)->comments()
                    ->where('title', 'foo')
                    ->first();

// определить инверсию отношения hasMany
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Comment extends Model
{
    /**
    * Получить пост, которому принадлежит комментарий.
    */
    public function post(): BelongsTo
    {
        // если модель Comment имеет внешний ключ post_id
        return $this->belongsTo(Post::class);

        // задать внешний ключ вручную
        return $this->belongsTo(Post::class, 'foreign_key');

        // задать вручную искомое в id модели Post значение
        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');
    }
}

// получить родительский пост комментария
use App\Models\Comment;

$comment = Comment::find(1);

return $comment->post->title;

// получить последний заказ пользователя
public function latestOrder(): HasOne
{
    return $this->hasOne(Order::class)->latestOfMany();
}

// получить первый заказ пользователя
public function oldestOrder(): HasOne
{
    return $this->hasOne(Order::class)->oldestOfMany();
}

// первый аргумент ofMany - столбец по которому ищем
/**
* Получить самый дорогой заказ пользователя
*/
public function largestOrder(): HasOne
{
    return $this->hasOne(Order::class)->ofMany('price', 'max');
}

// преобразовать отношение "Many" в отношение "Has One"
/**
* Получить заказы пользователя
*/
public function orders(): HasMany
{
    return $this->hasMany(Order::class);
}

/**
* Получить самый дорогой заказ пользователя
*/
public function largestOrder(): HasOne
{
    return $this->orders()->one()->ofMany('price', 'max');
}

// с подзапросом
/**
* Получить актуальную цену на продукт
*/
public function currentPricing(): HasOne
{
    return $this->hasOne(Price::class)->ofMany([
        'published_at' => 'max',
        'id' => 'max',
    ], function (Builder $query) {
        $query->where('published_at', '<', now());
    });
}</code></pre><p>один через отношение</p><pre><code>// сопоставить модель с экземпляром другой модели, связавшись через третью модель
// механик связан с машиной, а машина связана с владельцем
mechanics
    id - integer
    name - string

cars
    id - integer
    model - string
    mechanic_id - integer

owners
    id - integer
    name - string
    car_id - integer

// механик получит доступ к владельцу через машину
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOneThrough;

class Mechanic extends Model
{
    /**
    * Получить владельца машины.
    */
    public function carOwner(): HasOneThrough
    {
        return $this->hasOneThrough(Owner::class, Car::class);
    }
}

// либо через ключи
class Mechanic extends Model
{
    /**
    * Получить владельца машины.
    */
    public function carOwner(): HasOneThrough
    {
        return $this->hasOneThrough(
            Owner::class,
            Car::class,
            'mechanic_id', // Внешний ключ в таблице `cars` ...
            'car_id', // Внешний ключ в таблице `owners` ...
            'id', // Локальный ключ в таблице `mechanics` ...
            'id' // Локальный ключ в таблице `cars` ...
        );
    }
}

// получить владельца
// String based syntax...
return $this->through('cars')->has('owner');

// Dynamic syntax...
return $this->throughCars()->hasOwner();</code></pre><p>многие через отношение</p><pre><code>projects
    id - integer
    name - string

environments
    id - integer
    project_id - integer
    name - string

deployments
    id - integer
    environment_id - integer
    commit_hash - string

// Проект получит все развёртывания через среду окружения
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;

class Project extends Model
{
    /**
    * Получить все развертывания для проекта.
    */
    public function deployments(): HasManyThrough
    {
        return $this->hasManyThrough(Deployment::class, Environment::class);
    }
}

// через ключи
class Project extends Model
{
    public function deployments(): HasManyThrough
    {
        return $this->hasManyThrough(
            Deployment::class,
            Environment::class,
            'project_id', // Внешний ключ в таблице `environments` ...
            'environment_id', // Внешний ключ в таблице `deployments` ...
            'id', // Локальный ключ в таблице `projects` ...
            'id' // Локальный ключ в таблице `environments` ...
        );
    }
}

// получить развёртывания
// String based syntax...
return $this->through('environments')->has('deployments');

// Dynamic syntax...
return $this->throughEnvironments()->hasDeployments();</code></pre><p>получение доступа к родительской модели из дочерней при циклическом переборе записей дочерней модели может вызвать проблему «N + 1», Eloquent автоматически не прикрепит запись из родительской модели к её записям из дочерней модели.</p><pre><code>// проблема «N + 1»
$posts = Post::with('comments')->get();
foreach ($posts as $post) {
    foreach ($post->comments as $comment) {
        echo $comment->post->title;
    }
}

// автоматически прикрепить запись из родительской модели к её дочерним записям из дочерней модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Post extends Model
{
    /**
    * Get the comments for the blog post.
    */
    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class)->chaperone();
    }
}

либо
use App\Models\Post;

$posts = Post::with([
    'comments' => fn ($comments) => $comments->chaperone(),
])->get();</code></pre><p>- модель по умолчанию
- oтношения belongsTo, hasOne, hasOneThrough и morphOne позволяют определить модель по умолчанию при получении null</p><pre><code>// вернёт пустую модель
public function user(): BelongsTo
{
    return $this->belongsTo(User::class)->withDefault();
}

либо
/**
* Получить автора поста.
*/
public function user(): BelongsTo
{
    return $this->belongsTo(User::class)->withDefault([
        'name' => 'Guest Author',
    ]);
}

либо
/**
* Получить автора поста.
*/
public function user(): BelongsTo
{
    return $this->belongsTo(User::class)->withDefault(function ($user, $post) {
        $user->name = 'Guest Author';
    });
}</code></pre><p>определить в запросе к кому принадлежит</p><pre><code>use App\Models\Post;
$posts = Post::where('user_id', $user->id)->get();

либо
$posts = Post::whereBelongsTo($user)->get();

либо
$users = User::where('vip', true)->get();
$posts = Post::whereBelongsTo($users)->get();

либо
$posts = Post::whereBelongsTo($user, 'author')->get();</code></pre><p>многие ко многим</p><pre><code>// таблицы пользователей и ролей
users
    id - integer
    name - string

roles
    id - integer
    name - string

role_user
    user_id - integer
    role_id - integer

// в модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class User extends Model
{
    /**
    * Роли, принадлежащие пользователю.
    */
    public function roles(): BelongsToMany
    {
        return $this->belongsToMany(Role::class);
    }
}

// получить доступ к ролям пользователя
use App\Models\User;
$user = User::find(1);

foreach ($user->roles as $role) { }

// с ограничениями и условиями
$roles = User::find(1)->roles()->orderBy('name')->get();

// обратное отношение многие-ко-многим
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Role extends Model
{
    /**
    * Пользователи, принадлежащие к роли.
    */
    public function users(): BelongsToMany
    {
        return $this->belongsToMany(User::class);
    }
}

// Eloquent автоматически соединит имена таблиц User и Role в алфавитном порядке role_user для поиска связующей таблицы
// задать имя связующей таблицы вручную
return $this->belongsToMany(Role::class, 'role_user');

// изменить имена столбцов ключей
return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');

// доступ к связующей таблице
use App\Models\User;
$user = User::find(1);
foreach ($user->roles as $role) {
    echo $role->pivot->created_at;
}

// дополнительные атрибуты связующей модели (столбцы связующей таблицы)
return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');

// чтобы связующая таблица имела временные метки created_at и updated_at, нужно вызвать withTimestamps
return $this->belongsToMany(Role::class)->withTimestamps();

// дугое имя для связующей таблицы
return $this->belongsToMany(Podcast::class)
                ->as('subscription')
                ->withTimestamps();

// получить столбец связующей таблицы
$users = User::with('podcasts')->get();

foreach ($users->flatMap->podcasts as $podcast) {
    echo $podcast->subscription->created_at;
}</code></pre><p>фильтрация запросов по столбцам связующей таблицы</p><pre><code>return $this->belongsToMany(Role::class)
                ->wherePivot('approved', 1);

return $this->belongsToMany(Role::class)
                ->wherePivotIn('priority', [1, 2]);

return $this->belongsToMany(Role::class)
                ->wherePivotNotIn('priority', [1, 2]);

return $this->belongsToMany(Podcast::class)
                ->as('subscriptions')
                ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

return $this->belongsToMany(Podcast::class)
                ->as('subscriptions')
                ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

return $this->belongsToMany(Podcast::class)
                ->as('subscriptions')
                ->wherePivotNull('expired_at');

return $this->belongsToMany(Podcast::class)
                ->as('subscriptions')
                ->wherePivotNotNull('expired_at');

return $this->belongsToMany(Badge::class)
                ->where('rank', 'gold')
                ->orderByPivot('created_at', 'desc');</code></pre><p>определить свою модель связующей таблицы RoleUser</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Role extends Model
{
    /**
    * Пользователи, принадлежащие к роли.
    */
    public function users(): BelongsToMany
    {
        return $this->belongsToMany(User::class)->using(RoleUser::class);
    }
}

// модель связующей модели RoleUser
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;

class RoleUser extends Pivot { }

// автоинкремент для связующей таблицы
/**
* Указывает, что идентификаторы модели являются автоинкрементными.
*
* @var bool
*/
public $incrementing = true;</code></pre><p>- полиморфные отношения<br>
- один к одному полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации<br></p><pre><code>// таблицы
posts
    id - integer
    name - string

users
    id - integer
    name - string

images
    id - integer
    url - string
    imageable_id - integer
    imageable_type - string

// модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class Image extends Model
{
    /**
    * Получить родительскую модель (пользователя или поста), к которой относится изображение.
    */
    public function imageable(): MorphTo
    {
        return $this->morphTo();
    }
}

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphOne;

class Post extends Model
{
    /**
    * Получить изображение поста.
    */
    public function image(): MorphOne
    {
        return $this->morphOne(Image::class, 'imageable');
    }
}

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphOne;

class User extends Model
{
    /**
    * Получить изображение пользователя.
    */
    public function image(): MorphOne
    {
        return $this->morphOne(Image::class, 'imageable');
    }
}

// получить доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
$image = $post->image;

// получить родительский объект полиморфной модели, вернёт Post или User
use App\Models\Image;
$image = Image::find(1);
$imageable = $image->imageable;

// задать имена столбцов-ключей вручную
/**
* Получить родительскую модель, к которой относится изображение.
*/
public function imageable(): MorphTo
{
    return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');
}</code></pre><p>один ко многим полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации</p><pre><code>// таблицы
posts
    id - integer
    title - string
    body - text

videos
    id - integer
    title - string
    url - string

comments
    id - integer
    body - text
    commentable_id - integer
    commentable_type - string

// модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class Comment extends Model
{
    /**
    * Получить родительскую модель (поста или видео), к которой относится комментарий.
    */
    public function commentable(): MorphTo
    {
        return $this->morphTo();
    }
}

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphMany;

class Post extends Model
{
    /**
    * Получить все комментарии поста.
    */
    public function comments(): MorphMany
    {
        return $this->morphMany(Comment::class, 'commentable');
    }
}

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphMany;

class Video extends Model
{
    /**
    * Получить все комментарии видео.
    */
    public function comments(): MorphMany
    {
        return $this->morphMany(Comment::class, 'commentable');
    }
}

// доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
foreach ($post->comments as $comment) { }

// доступ к родительской модели, вернет либо экземпляр Post, либо Video
use App\Models\Comment;
$comment = Comment::find(1);
$commentable = $comment->commentable;</code></pre><p>доступ к родительской модели из дочерней модели при циклическом переборе дочерних записей может возникнуть проблемы с запросами «N + 1»</p><pre><code>// проблема «N + 1»
$posts = Post::with('comments')->get();
foreach ($posts as $post) {
    foreach ($post->comments as $comment) {
        echo $comment->commentable->title;
    }
}

// автоматически связывать записи родительской модели с дочерними
class Post extends Model
{
    /**
    * Get all of the post's comments.
    */
    public function comments(): MorphMany
    {
        return $this->morphMany(Comment::class, 'commentable')->chaperone();
    }
}

// либо
use App\Models\Post;
$posts = Post::with([
    'comments' => fn ($comments) => $comments->chaperone(),
])->get();</code></pre><p>один из многих полиморф</p><pre><code>/**
* Get the user's most recent image.
*/
public function latestImage(): MorphOne
{
    return $this->morphOne(Image::class, 'imageable')->latestOfMany();
}

// либо
/**
* Get the user's oldest image.
*/
public function oldestImage(): MorphOne
{
    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();
}

// задать столбец сортировки и способ сортировки вручную: ofMany('likes', 'max')
/**
* Получаем изображение, у которого больше всего лайков.
*/
public function bestImage()
{
    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');
}
</code></pre><p>многие ко многим полиморф</p><pre><code>// таблицы
posts
    id - integer
    name - string

videos
    id - integer
    name - string

tags
    id - integer
    name - string

taggables
    tag_id - integer
    taggable_id - integer
    taggable_type - string

// модель
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Post extends Model
{
    /**
    * Получить все теги поста.
    */
    public function tags(): MorphToMany
    {
        return $this->morphToMany(Tag::class, 'taggable');
    }
// taggable - связующая таблица
}

// получить записи родительской модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphToMany;

class Tag extends Model
{
    /**
    * Получить все посты, которым присвоен этот тег.
    */
    public function posts(): MorphToMany
    {
        return $this->morphedByMany(Post::class, 'taggable');
    }

    /**
    * Получить все видео, которым присвоен этот тег.
    */
    public function videos(): MorphToMany
    {
        return $this->morphedByMany(Video::class, 'taggable');
    }
}

// получить доступ к дочерней модели
use App\Models\Post;
$post = Post::find(1);
foreach ($post->tags as $tag) { }

// получить доступ к родительской модели
use App\Models\Tag;
$tag = Tag::find(1);
foreach ($tag->posts as $post) { }

foreach ($tag->videos as $video) { }</code></pre><p>задать псевдоним полиморфного типа модели вручную</p><pre><code>use Illuminate\Database\Eloquent\Relations\Relation;

Relation::enforceMorphMap([
    'post' => 'App\Models\Post',
    'video' => 'App\Models\Video',
]);

// либо
use Illuminate\Database\Eloquent\Relations\Relation;

// определить псевдоним полиморфного типа конкретной модели
$alias = $post->getMorphClass();

// определить полное имя класса, связанное с псевдонимом полиморфного типа
$class = Relation::getMorphedModel($alias);</code></pre><p>динамические отношения</p><pre><code>// настроить динамические отношения в App\Providers\AppServiceProvider метод boot
use App\Models\Order;
use App\Models\Customer;

Order::resolveRelationUsing('customer', function (Order $orderModel) {
    return $orderModel->belongsTo(Customer::class, 'customer_id');
});</code></pre><p>- запросы отношений
- можно вызвать метод для получения экземпляра отношения, не выполняя запроса для загрузки связанных моделей</p><pre><code>namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class User extends Model
{
    /**
    * Получить все посты пользователя.
    */
    public function posts(): HasMany
    {
        return $this->hasMany(Post::class);
    }
}

// запросить отношение posts
use App\Models\User;
$user = User::find(1);
$user->posts()->where('active', 1)->get();

// либо
$user->posts()
        ->where('active', 1)
        ->orWhere('votes', '>=', 100)
        ->get();
// вернёт
select *
from posts
where user_id = ? and active = 1 or votes >= 100

// либо
use Illuminate\Database\Eloquent\Builder;
$user->posts()
        ->where(function (Builder $query) {
            return $query->where('active', 1)
                        ->orWhere('votes', '>=', 100);
        })
        ->get();
// вернёт
select *
from posts
where user_id = ? and (active = 1 or votes >= 100)

// получить доступ к отношению, как к свойству
use App\Models\User;
$user = User::find(1);
foreach ($user->posts as $post) { }</code></pre><p>получить записи таблицы, у которых есть отношения с другими таблицами</p><pre><code>use App\Models\Post;

// Получить все посты, в которых есть хотя бы один комментарий ...
$posts = Post::has('comments')->get();

// Получить посты, в которых есть 3 или более комментариев ...
$posts = Post::has('comments', '>=', 3)->get();

// Получить посты, в которых есть хотя бы один комментарий с изображениями ...
$posts = Post::has('comments.images')->get();

// либо
use Illuminate\Database\Eloquent\Builder;

// Получить посты с хотя бы одним комментарием, содержащим `code%` ...
$posts = Post::whereHas('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');
})->get();

// Получить посты с как минимум десятью комментариями, содержащими `code%` ...
$posts = Post::whereHas('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');
}, '>=', 10)->get();

// запросить все посты с не одобренными комментариями
use App\Models\Post;
$posts = Post::whereRelation('comments', 'is_approved', false)->get();

// запросить посты в зависимости от момента создания комментария
$posts = Post::whereRelation(
    'comments', 'created_at', '>=', now()->subHour()
)->get();</code></pre><p>получить записи таблицы, у которых нет отношения с другими таблицами</p><pre><code>// получить все посты блога, которые не имеют комментариев
use App\Models\Post;
$posts = Post::doesntHave('comments')->get();

// проверить содержимое комментария
use Illuminate\Database\Eloquent\Builder;
$posts = Post::whereDoesntHave('comments', function (Builder $query) {
    $query->where('content', 'like', 'code%');
})->get();

// получить посты без комментариев и с комментариями от незабаненных авторов
use Illuminate\Database\Eloquent\Builder;
$posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
    $query->where('banned', 0);
})->get();</code></pre><p>узнать о существовании полиморфных «один-к» отношений</p><pre><code>use App\Models\Comment;
use App\Models\Post;
use App\Models\Video;
use Illuminate\Database\Eloquent\Builder;

// Получить комментарии, связанные с постами или видео с заголовком, содержащими `code%` ...
$comments = Comment::whereHasMorph(
    'commentable',
    [Post::class, Video::class],
    function (Builder $query) {
        $query->where('title', 'like', 'code%');
    }
)->get();

// Получить комментарии, связанные с постами с заголовком, не содержащим `code%` ...
$comments = Comment::whereDoesntHaveMorph(
    'commentable',
    Post::class,
    function (Builder $query) {
        $query->where('title', 'like', 'code%');
    }
)->get();

// с указанием типа
use Illuminate\Database\Eloquent\Builder;
$comments = Comment::whereHasMorph(
    'commentable',
    [Post::class, Video::class],
    function (Builder $query, string $type) {
        $column = $type === Post::class ? 'content' : 'title';

        $query->where($column, 'like', 'code%');
    }
)->get();

// запросить дочерние элементы
$comments = Comment::whereMorphedTo('commentable', $post)
                      ->orWhereMorphedTo('commentable', $video)
                      ->get();</code></pre><p>извлечь все возможные полиморфные типы из базы данных</p><pre><code>use Illuminate\Database\Eloquent\Builder;
$comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
    $query->where('title', 'like', 'foo%');
})->get();</code></pre><p>- агрегирование связанных моделей
- подсчитать количество связанных моделей для отношения, не загружая модели</p><pre><code>use App\Models\Post;
$posts = Post::withCount('comments')->get();
foreach ($posts as $post) {
    echo $post->comments_count;
}

// добавить «счетчики» для нескольких отношений, а также добавить дополнительные ограничения к запросам
use Illuminate\Database\Eloquent\Builder;
$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
    $query->where('content', 'like', 'code%');
}])->get();
echo $posts[0]->votes_count;
echo $posts[0]->comments_count;

// использовать псевдоним результата подсчета отношений
use Illuminate\Database\Eloquent\Builder;
$posts = Post::withCount([
    'comments',
    'comments as pending_comments_count' => function (Builder $query) {
        $query->where('approved', false);
    },
])->get();
echo $posts[0]->comments_count;
echo $posts[0]->pending_comments_count;

// загрузить счетчик отношений после того, как родительская модель уже была получена
$book = Book::first();
$book->loadCount('genres');

// установить дополнительные ограничения запроса
$book->loadCount(['reviews' => function (Builder $query) {
    $query->where('rating', 5);
}])

// withCount вызывать после метода select
$posts = Post::select(['title', 'body'])
                ->withCount('comments')
                ->get();

// сумма комментариев
use App\Models\Post;
$posts = Post::withSum('comments', 'votes')->get();
foreach ($posts as $post) {
    echo $post->comments_sum_votes;
}

// с псевдонимом
$posts = Post::withSum('comments as total_comments', 'votes')->get();
foreach ($posts as $post) {
    echo $post->total_comments;
}

// отложенное выполнение на уже полученных моделях
$post = Post::first();
$post->loadSum('comments', 'votes');

// все методы вызывать после select
$posts = Post::select(['title', 'body'])
                ->withExists('comments')
                ->get();

// посчитать количество отношений у родителей
Photo родитель Tag, Post родитель Comment, Photo и Post полиморфные родители ActivityFeed
use Illuminate\Database\Eloquent\Relations\MorphTo;

// отложенное выполнение на уже загруженный записях ActivityFeed
$activities = ActivityFeed::with([
    'parentable' => function (MorphTo $morphTo) {
        $morphTo->morphWithCount([
            Photo::class => ['tags'],
            Post::class => ['comments'],
        ]);
    }])->get();</code></pre><p>проблема «N+1»</p><pre><code>// модель Book «принадлежит» модели Author
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Book extends Model
{
    /**
    * Получить автора книги.
    */
    public function author(): BelongsTo
    {
        return $this->belongsTo(Author::class);
    }
}

// получим все книги и их авторов
// если в таблице 25 книг, то будет 26 запросов:
// один для получения всех книг
// 25 дополнительных запросов для получения автора каждой книги
use App\Models\Book;
$books = Book::all();
foreach ($books as $book) {
    echo $book->author->name;
}

// при жадной загрузке будут выполнены только два запроса:
// один запрос для получения всех книг
// второй запрос – для получения всех авторов для всех книг
$books = Book::with('author')->get();
foreach ($books as $book) {
    echo $book->author->name;
}

// вернёт
select * from books
select * from authors where id in (1, 2, 3, 4, 5, ...)</code></pre><p>- жадная (eager) загрузка<br>
- При доступе к отношениям как к свойствам, связанные модели загружаются «отложенно», т.е. не загружаются, пока вы впервые не затребуете доступ к свойству.<br>
- Можно «жадно» загрузить отношения во время запроса родительской модели.<br>
- Жадная загрузка позволяет избежать проблем «N+1» с запросами. <br>
- Жадная загрузка обеспечивает значительное сокращение количества SQL-запросов, которые необходимо выполнить для загрузки отношений модели.<br>
- всегда предотвращать ленивую загрузку<br></p><pre><code>// в App\Providers\AppServiceProvider в boot
use Illuminate\Database\Eloquent\Model;

/**
* Bootstrap any application services.
*/
public function boot(): void
{
    Model::preventLazyLoading(! $this->app->isProduction());
}

// когда приложение попытается лениво загрузить отношение, будет исключение<br>
// регистрировать, а не выбрасывать исключение<br>
Model::handleLazyLoadingViolationUsing(function (Model $model, string $relation) {
    $class = $model::class;

    info("Attempted to lazy load [{$relation}] on model [{$class}].");
});

// загрузить несколько разных отношений
$books = Book::with(['author', 'publisher'])->get();

// вложенная жадная загрузка контактов всех авторов книг
$books = Book::with('author.contacts')->get();

// одновременная загрузка нескольких вложенных отношений
$books = Book::with([
    'author' => [
        'contacts',
        'publisher',
    ],
])->get();

// загрузить полиморфное отношение «один-к»
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class ActivityFeed extends Model
{
    /**
    * Получить родительский элемент записи ленты активности.
    */
    public function parentable(): MorphTo
    {
        return $this->morphTo();
    }
}

// Event, Photo и Post могут создавать модели ActivityFeed
// Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
// получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
use Illuminate\Database\Eloquent\Relations\MorphTo;

$activities = ActivityFeed::query()
    ->with(['parentable' => function (MorphTo $morphTo) {
        $morphTo->morphWith([
            Event::class => ['calendar'],
            Photo::class => ['tags'],
            Post::class => ['author'],
        ]);
    }])->get();

// жадная загрузка указанных столбцов
$books = Book::with('author:id,name,book_id')->get();

// постоянная загрузка отношений при извлечении модели
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Book extends Model
{
    /**
    * Отношения, которые всегда должны быть загружены.
    *
    * @var array
    */
    protected $with = ['author'];

    /**
    * Получить автора книги.
    */
    public function author(): BelongsTo
    {
        return $this->belongsTo(Author::class);
    }

    /**
    * Получить жанр книги
    */
    public function genre(): BelongsTo
    {
        return $this->belongsTo(Genre::class);
    }
}

// удалить элемент из свойства $with для одного запроса
$books = Book::without('author')->get();

// для одного запроса
$books = Book::withOnly('genre')->get();

// ключ массива – имя отношения
// значение массива – ограничение к запросу жадной загрузки
// загружать только те посты, столбец title которых содержит слово code
use App\Models\User;
use Illuminate\Contracts\Database\Eloquent\Builder;

$users = User::with(['posts' => function (Builder $query) {
    $query->where('title', 'like', '%code%');
}])->get();

// сортировка по времени создания
$users = User::with(['posts' => function (Builder $query) {
    $query->orderBy('created_at', 'desc');
}])->get();

// ограничения к жадной загрузке полиморфного отношения «один-к»
// загружать только скрытые посты, а видео только с типом как образовательное
use Illuminate\Database\Eloquent\Relations\MorphTo;

$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
    $morphTo->constrain([
        Post::class => function ($query) {
            $query->whereNull('hidden_at');
        },
        Video::class => function ($query) {
            $query->where('type', 'educational');
        },
    ]);
}])->get();

// проверить наличие отношения при жадной загрузке
use App\Models\User;

$users = User::withWhereHas('posts', function ($query) {
    $query->where('featured', true);
})->get();

// жадно загрузить отношение только после получения родительской модели
use App\Models\Book;

$books = Book::all();

if ($someCondition) {
    $books->load('author', 'publisher');
}

// с ограничением
$author->load(['books' => function (Builder $query) {
    $query->orderBy('published_date', 'asc');
}]);

// загрузить если еще не было загружено
$book->loadMissing('author');

// вложенная жадная пост-загрузка с полиморфными отношениями «один-к»
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class ActivityFeed extends Model
{
    /**
    * Получить родительский элемент записи ленты активности.
    */
    public function parentable(): MorphTo
    {
        return $this->morphTo();
    }
}

// Event, Photo и Post могут создавать модели ActivityFeed
// Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
// получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
$activities = ActivityFeed::with('parentable')
    ->get()
    ->loadMorph('parentable', [
        Event::class => ['calendar'],
        Photo::class => ['tags'],
        Post::class => ['author'],
    ]);</code></pre><p>вставка и обновление связанных моделей</p><pre><code>// добавить новый комментарий к посту
use App\Models\Comment;
use App\Models\Post;

$comment = new Comment(['message' => 'A new comment.']);
$post = Post::find(1);
$post->comments()->save($comment);

// сохранить несколько связанных записей
$post = Post::find(1);
$post->comments()->saveMany([
    new Comment(['message' => 'A new comment.']),
    new Comment(['message' => 'Another new comment.']),
]);

// получить доступ к отношениям после использования методов save или saveMany
$post->comments()->save($comment);
$post->refresh();

// все комментарии, включая только что сохраненный комментарий ...
$post->comments;

// сохранить пост, его комментарии и авторы этих комментариев
$post = Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();

// сохранения поста и его связанных отношений без вызова каких-либо событий
$post->pushQuietly();

// метод save принимает экземпляр модели Eloquent, а create принимает простой массив PHP
use App\Models\Post;

$post = Post::find(1);
$comment = $post->comments()->create([
    'message' => 'A new comment.',
]);

// создание нескольких связанных записей
$post = Post::find(1);
$post->comments()->createMany([
    ['message' => 'A new comment.'],
    ['message' => 'Another new comment.'],
]);

// создания постов без отправки каких-либо событий
$user = User::find(1);
$user->posts()->createQuietly([
    'title' => 'Post title.',
]);

$user->posts()->createManyQuietly([
    ['title' => 'First post.'],
    ['title' => 'Second post.'],
]);

// создание и обновление записей
методы findOrNew, firstOrNew, firstOrCreate, и updateOrCreate

// назначить дочернюю модель новой родительской модели
use App\Models\Account;

$account = Account::find(10);
$user->account()->associate($account);
$user->save();

удалить родительскую модель из дочерней модели
$user->account()->dissociate();
$user->save();

// присоединить «многие-ко-многим», вставив запись в связующую таблицу
use App\Models\User;

$user = User::find(1);
$user->roles()->attach($roleId);


// передать массив дополнительных данных для вставки в связующую таблицу
$user->roles()->attach($roleId, ['expires' => $expires]);

// удалить запись отношения «многие-ко-многим» - удалит запись из связующей таблицы
// Отсоединяем одну роль от пользователя
$user->roles()->detach($roleId);

// Отсоединяем от пользователя все роли
$user->roles()->detach();

// либо
$user = User::find(1);
$user->roles()->detach([1, 2, 3]);
$user->roles()->attach([
    1 => ['expires' => $expires],
    2 => ['expires' => $expires],
]);

// создать ассоциации «многие-ко-многим», добавив массив идентификаторов в связующую таблицу
$user->roles()->sync([1, 2, 3]);

// либо
$user->roles()->sync([1 => ['expires' => true], 2, 3]);

вставить одинаковые значения в связующую таблицу для каждого ID
$user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);

// не удалять существующие связи, идентификаторы которых отсутствуют в переданном массиве
$user->roles()->syncWithoutDetaching([1, 2, 3]);

// если переданный идентификатор в настоящее время присоединен, он будет отсоединен и наоборот
$user->roles()->toggle([1, 2, 3]);

// передать дополнительные значения для связующей таблицы вместе с идентификаторами
$user->roles()->toggle([
    1 => ['expires' => true],
    2 => ['expires' => true],
]);

// обновить существующую строку в связующей таблице
$user = User::find(1);

$user->roles()->updateExistingPivot($roleId, [
    'active' => false,
]);</code></pre><p>временные метки родителя</p><pre><code>// обновить временную метку родителя при обновлении дочерней модели
// свойство $touches дочерней модели, содержит имена отношений, которые должны обновляться с дочерней моделью
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Comment extends Model
{
    /**
    * Все отношения, временные метки которых должны быть затронуты.
    *
    * @var array
    */
    protected $touches = ['post'];

    /**
    * Получить пост, к которому принадлежит комментарий.
    */
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class);
    }
}
</code></pre></details></details><details> <summary>Pagination</summary><p>в tailwind.config.js</p><pre><code>content: [
    './resources/**/*.blade.php',
    './resources/**/*.js',
    './resources/**/*.vue',
    './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',
],</code></pre><p>- paginate автоматически устанавливает «предел» и «смещение» в запросе на основе текущей страницы
- отобразить 15 элементов на странице</p><pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;

class UserController extends Controller
{
    /**
    * Показать всех пользователей приложения.
    */
    public function index(): View
    {
        return view('user.index', [
            'users' => DB::table('users')->paginate(15)
        ]);
    }
}</code></pre><p>если вам нужно отображать только простые ссылки «Далее» и «Назад» без общего количества страниц</p><pre><code>$users = DB::table('users')->simplePaginate(15);</code></pre><p>разбить запросы Eloquent на страницы</p><pre><code>use App\Models\User;
$users = User::paginate(15);

либо
$users = User::where('votes', '>', 100)->paginate(15);

либо
$users = User::where('votes', '>', 100)->simplePaginate(15);

либо
$users = User::where('votes', '>', 100)->cursorPaginate(15);</code></pre><p>отобразить два отдельных модуля пагинации на одном экране: в третьем параметре указать имя страницы отдельно для каждого модуля пагинации</p><pre><code>use App\Models\User;
$users = User::where('votes', '>', 100)->paginate(
    $perPage = 15, $columns = ['*'], $pageName = 'users'
);</code></pre><p>- paginate и simplePaginate создают запросы с использованием SQL-оператора “offset”<br>
- Cursor-пагинация работает путем создания конструкции “where”<br>
- пагинация на основе смещения включает номер страницы в строке запроса URL-адресов<br>
- Курсор представляет собой закодированную строку, содержащую место, с которого следующий запрос с пагинацией должен начать постраничную навигацию, и направление, в котором он должен разбиваться на страницы<br></p><code>$users = DB::table('users')->orderBy('id')->cursorPaginate(15);</code><p>отобразить “вторую страницу” результатов для таблицы users, упорядоченных по id</p><pre><code>- offset пагинация...
select * from users order by id asc limit 15 offset 15;

- cursor пагинация...
select * from users where id > 15 order by id asc limit 15;</code></pre><p>Преимущества Cursor-пагинация перед Offset-пагинацией:<br>
- Для больших наборов данных Cursor-пагинация обеспечивать лучшую производительность, если столбцы “order by” проиндексированы. Это связано с тем, что предложение “offset” сканирует все ранее сопоставленные данные.<br>
- Для наборов данных с частыми записями Offset-пагинация может пропускать записи или отображать дубликаты, если результаты были недавно добавлены или удалены со страницы, которую пользователь просматривает в данный момент.<br>
<br>
Ограничения Cursor-пагинации:<br>
- Как и simplePaginate, Cursor-пагинация может использоваться только для отображения ссылок “Далее” и “Назад” и не поддерживает создание ссылок с номерами страниц.<br>
- Требуется, чтобы порядок был основан как минимум на одном уникальном столбце или на комбинации уникальных столбцов. - Столбцы с null – значениями не поддерживаются.<br>
- Выражения запросов c “order by” поддерживаются только в том случае, если они имеют псевдоним и также добавлены в “select”.<br>
- Выражения запросов с параметрами не поддерживаются.<br>
- чтобы пагинатор генерировал ссылки типа http://example.com/admin/users?page=N</p><pre><code>use App\Models\User;

Route::get('/users', function () {
    $users = User::paginate(15);

    $users->withPath('/admin/users');

    // ...
});</code></pre><p>добавить sort=votes к каждой ссылке пагинации</p><pre><code>use App\Models\User;

Route::get('/users', function () {
    $users = User::paginate(15);

    $users->appends(['sort' => 'votes']);

    // ...
});</code></pre><p>хотите добавить все значения строки текущего запроса к ссылкам постраничной навигации</p><code>$users = User::paginate(15)->withQueryString();</code><p>добавить «хеш-фрагмент» к URL-адресам</p><code>$users = User::paginate(15)->fragment('users');</code><p>- вызов метода paginate возвращает экземпляр Illuminate\Pagination\LengthAwarePaginator<br>
- вызов метода simplePaginate возвращает экземпляр Illuminate\Pagination\Paginator<br>
- вызов метода cursorPaginate возвращает экземпляр Illuminate\Pagination\CursorPaginator<br>
- экземпляры являются итераторами и могут быть перебраны как массив<br></p><a href="http://laravel.su/docs/12.x/pagination#metody-ekzempliara-paginator-i-lengthawarepaginator">экземпляры содержат методы, описывающие результирующий набор</a><pre><code>&lt;div class="container"&gt;
    @foreach ($users as $user)
        {{ $user->name }}
    @endforeach
&lt;/div&gt;

// links отрисует ссылки с переменной запроса page на остальные страницы
{{ $users->links() }}</code></pre><p>- HTML, сгенерированный методом links, совместим с фреймворком Tailwind CSS<br>
- пагинатор отображает навигационные ссылки, включающие номер текущей страницы, а также ссылки для трех страниц до и после текущей<br>
- контролировать, сколько дополнительных ссылок отображается с каждой стороны от текущей страницы<br></p><code>{{ $users->onEachSide(5)->links() }}</code><p>преобразовать экземпляр пагинатора в JSON, вернув его из маршрута или действия контроллера</p><pre><code>use App\Models\User;

Route::get('/users', function () {
    return User::paginate();
});</code></pre><p>передать свой шаблон отображения навигационных ссылок пагинации</p><pre><code>{{ $paginator->links('view.name') }}

- передача дополнительных данных в шаблон ...
{{ $paginator->links('view.name', ['foo' => 'bar']) }}</code></pre><p>отредактировать встроенные шаблоны постраничной навигации</p><code>php artisan vendor:publish --tag=laravel-pagination</code><p>- файл tailwind.blade.php в resources/views/vendor/pagination - шаблон постраничной навигации по умолчанию<br>
- назначить другой файл шаблоном постраничной навигации по умолчанию<br></p><pre><code>в App\Providers\AppServiceProvider.php
namespace App\Providers;

use Illuminate\Pagination\Paginator;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
    * Загрузка любых служб приложения.
    */
    public function boot(): void
    {
        Paginator::defaultView('view-name');

        Paginator::defaultSimpleView('view-name');
    }
}
</code></pre></details><details><summary>Redis</summary><p>- Redis используется в качестве кэша и драйвера очереди<br>
- драйвер Redis по умолчанию использует расширение phpredis<br>
- расширение predis не поддерживается<br>
- расширение phpredis поддерживает Redis 3.0 и выше<br></p><pre><code>php artisan config:cache
php artisan route:cache
php artisan view:cache</code></pre><a href="http://laravel.su/docs/12.x/redis">redis</a><p>- кеширование данных в Redis<br>
- кеширование представлений в Redis<br>
- кеширование маршрутов в Redis<br>
- кеширование конфигурации в Redis<br></p><pre><code>use Illuminate\Support\Facades\Redis;

Redis::set('key', 'value');
Redis::get('key');
Redis::del('key');
Redis::exists('key');
Redis::expire('key', 60);
Redis::ttl('key');
Redis::keys('*');
Redis::flushAll();
</code></pre></details><details><summary>MongoDB</summary><p>- MongoDB используется в качестве драйвера кэша, очереди, сессий, базы данных<br></p><pre><code>php artisan vendor:publish --provider="Jenssegers\Mongodb\MongodbServiceProvider"</code></pre><a href="http://laravel.su/docs/12.x/mongodb">mongodb</a><p>- драйвер MongoDB по умолчанию использует расширение mongodb<br>
- расширение mongodb поддерживает MongoDB 2.6 и выше<br>
</p></details></details><details><summary>How to</summary><details> <summary>Api</summary><p>Установить пакет Sanctum, создать роут, миграцию personal_access_tokens_table и токен аутентификацию для api</p><code>./sail artisan install:api</code><p>Создать модель с миграцией</p><code>./sail artisan make:model Category -m</code><p>Обновить таблицы</p><code>./sail artisan migrate</code><p>создать контроллер в отдельной структуре папок (v1 - версия)
--model=Category - привязка к модели
--api - методы апи контроллера
--requests - вынос валидации в отдельные классы</p><code>./sail artisan make:controller Api/V1/CategoryController --model=Category --api --requests</code><p>сгруппировать роуты по версиям и создать рессурсный роут</p><code>use App\Http\Controllers\Api\V1\CategoryController;
Route::prefix('v1')->group(function()
{
    Route::apiResource('categories', CategoryController::class);
});</code><p>просмотреть список роутов</p><code>./sail artisan route:list --except-vendor</code><p>В файле bootstrap/app.php можно добавить свой обработчик ошибок</p><code>use Illuminate\Foundation\Configuration\Exceptions;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (NotFoundHttpException $e, Request $request) {
    if ($request->is('api/*')) {
      return response()->json([
        'message' => 'Record not found.'
      ], 404);
    }
  });
})</code><p>Чтобы задать формат api ответа создать Resources</p><code>./sail artisan make:resource Api/V1/CategoryResource</code><p>в контроллере возврат данных таблицы через рессурс-коллекцию для массива данных</p><code>return CategoryResource::collection(Category::all());</code><p>для возврата одной записи из таблицы данных</p><code>new CategoryResource(Category::findOrFail($id));</code><p>либо</p><code>public function show(Category $category)
{
  return new CategoryResource($category);
}</code><p>в Api/V1/PostResource задаю условие: поле "content" показывать если роут posts.show</p><code>"content"=> $this->when(Route::currentRouteName() == 'posts.show', $this->content),</code><p>в Api/V1/PostResource по связи метода category из модели получаю свойство категории</p><code>"categoryName" => $this->category->title,</code><p>в Models/Post задаю связь с таблицей category методом category</p><code>public function category()
{
  return $this->belongsTo(Category::class);
}</code><p>в Models/Post задаю список полей, которые не участвуют в работе методов</p><code>protected $hidden = [
  "created_at",
];</code><p>в PostController по связи метода category из модели Models/Post получаю всё одним запросом
и вывожу частями по 5 постов</p><code>return PostResource::collection(Post::with('category')->paginate(5));</code><p>для ограничения количества запросов в App\Providers\AppServiceProvider добавить в метод boot()</p><code>use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
RateLimiter::for('api', function (Request $request) {
  return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});</code><p>ключить ограничение middleware(['throttle:api', 'auth:sanctum']) в роуты</p><code>Route::prefix('v1')->middleware(['throttle:api'])->group(function()</code><p>для доступа к данным апи через токен добавить в модель User</p><code>use Laravel\Sanctum\HasApiTokens;
use HasApiTokens</code><p>установить срок жизни токена в минутах в config/sanctum.php          </p><code>'expiration' = 10,</code><p>просроченные токены удалять командой sanctum:prune-expired</p><code>use Illuminate\Support\Facades\Schedule;
Schedule::command('sanctum:prune-expired --hours=24')->daily();
</code></details><details></details><summary>CRUD</summary><p>Create model</p><code>php artisan make:model Post -mfcr</code><p>Add columns in migration<br>
Define fillable columns and relation in Post model and relation in User model<br>
Fill database/factories/PostFactory.php and database/seeders/DatabaseSeeder.php<br>
Fill database fake data<br></p><code>php artisan migrate:fresh --seed</code><p>In resources/js/types/index.d.ts create interface Post<br>
Create link for images</p><code>php artisan storage:link</code><p>Add navItem in resources/js/components/app-sidebar.tsx to posts.index<br>
Copy resources/js/pages/dashboard.tsx to resources/js/pages/posts/index.tsx<br>
In resources/js/pages/posts/index.tsx import table from shadcn and create inertia link for post creating<br>
Copy resources/js/pages/auth/login.tsx to resources/js/pages/posts/create.tsx<br>
In resources/js/types/index.d.ts create type PostForm<br>
Import and past textarea from shadcn into resources/js/pages/posts/create.tsx<br>
Copy resources/js/pages/posts/create.tsx to resources/js/pages/posts/edit.tsx<br>
Create resource for posts<br></p><code>php artisan make:resource PostResource</code><p>Add to boot function AppServiceProvider</p><code>JsonResource::withoutWrapping();</code><p>Register route for posts/ in routes/web.php<br>
Fill methods in PostController<br>
Clear and optimazing data<br></p><pre><code>php artisan optimize
php artisan optimize:clear</code></pre><p>Add flash messages to app/Http/Middleware/HandleInertia/Requests<br>
In resources/js/types/index.d.ts create interface Flash<br>
Import sonner toaster from shadcn component into resources/js/layouts/app-layout.tsx<br>
Display toaster into resources/js/pages/posts/index.tsx<br>
</p><p>Access by SSH to VPS by password<br>
Authenticated like user for installed Laravel on VPS<br></p><code>su - user</code><p>To see domain folder with installed project</p><code>cd htdocs </code><p>Come into Laravel files</p><code>cd domainfolder</code><p>In domainfolder generate ssh key for VPS</p><code>ssh-keygen -t ed25519 -C "my@email.com"   // leave passphrase empty</code><p>Read VPS ssh public key</p><code>cat ~/.ssh/id_ed25519.pub   // copy the key</code><p>In github repository open settings>Deploy keys>Add deploy key, paste VPS ssh public key (Allow write server)<br>
Move installed Laravel files into tmp folder<br></p><code> mv domainfolder/ tmp</code><p>Clone Laravel files from private repository github by ssh into domainfolder<br></p><code>git clone githubUrl domainfolder</code><p>In domainfolder copy .env file</p><code>cp .env.exemple .env</code><p>In domainfolder</p><code>composer install</code><p>Create sqlite database</p><code>php artisan migrate</code><p>Create mysql database on VPS server panel and change database setting into .env for mysql<br>
Apply data into mysql database</p><code>php artisan migrate</code><p>Generate app key</p><code>php artisan key:generate --ansi</code><p>Install as root nodejs on VPS</p><a href="https://nodejs.org/en/download">Nodejs</a><p>In htdocs/domainfolder run as user</p><pre><code>npm install
npm run build</code></pre><p>Fill database fake data</p><code>php artisan migrate:fresh --seed</code><p>Test app in browser</p><a href="http://laravel.com/docs/12.x/queues#supervisor-configuration">automaticaly ssr on VPS install as root</a><a href="https://youtu.be/lqKbDEBa2B0">youtube tutorial at 5:20:00</a><p>In conf file change command to </p><code>artisan inertia:start-ssr</code><p>In .env file</p><pre><code>APP-NAME=Appname
APP_ENV=prod
APP_DEBUG=false
APP_URL=Appurl</code></pre><p>change mail settings</p><p>Create localy .github/workflows/deploy.yml with action for github<br>
Github repository>settings>Secrets and variables>Actions
Create new secret - see youtube tutorial 5:41:30</p></details></details></div></nav></main><footer> </footer></div></body></html>