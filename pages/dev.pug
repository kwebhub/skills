extends templates/layout

block menu
  .menu__inner

    //- Platform
    details
      summary.menu__submenu Platform
      p Design: react - tailwind | pug - scss - alpinejs
      a(href="https://github.com") Github
      a(href="http://www.figma.com") Figma
      a(href="https://dbdiagram.io") DB Diagram
      a(href="https://nodejs.org/en/download/") Node.js
      a(href="https://code.visualstudio.com") VSCode (Theme: Catppuccin Mocha, Font: Cascadia Code)
      a(href="http://www.contentful.com/blog/react-app-tailwind-css") React App Tailwind CSS
      a(href="http://www.github.com/gitname/react-gh-pages/") React GitHub Pages
      br
      p Development:
      a(href="https://refactoring.guru/ru") Паттерны, рефакторинг, SOLID
      a(href="http://docs.docker.com/engine") Docker
      a(href="https://aws.amazon.com/ru/?nc2=h_lg") AWS
      a(href="https://laravel.com") laravel
      a(href="https://laravel.su/") laravel(ru)<br>
      br
      p Security: bash, linux, rust, net, crypto

    //- Languages
    details 
      summary.menu__submenu Languages

      //- Symbols
      details
        summary.menu__submenu_lv1 Symbols
        p.
          Symbols<br>
          <b>0b11111111</b> - бинарная (двоичная) форма записи числа 255<br>
          <b>0о377</b> - восьмиричная форма записи числа 255<br>
          <b>0xff</b> - шестнадцатиричная форма записи числа 255<br>
          <br>
          Регулярные выражения<br>
          <b>^</b> - циркумфлекс, значение начинается с указанной подстроки<br>
          <b>$</b> - доллар, значение заканчивается указанной подстрокой<br>
          <b>~</b> - тильда, значение содержит указанное слово<br>
          <b>*</b> - звезда, значение содержит указанную подстроку<br>
          <b>!</b> - восклецательный знак, значение без указанной подстроки<br>
          <b>|</b> - вертикальная черта, значение содержит указанное слово или после этого слова знак дефиса<br>

      //- API
      details
        summary.menu__submenu_lv1 API
        p.
          <dfn>API</dfn> (Application programming interface) - это контракт, который предоставляется программою “Ко мне можно обращаться так и так, я обязуюсь делать то и это”.<br>
          <dfn>API</dfn> -  это набор функций. <br>
          Наборы группируются разработчиком по функционалу, по заказчику, по смыслу операций и т.д.<br>
          <br>
          <em>HTML, XML - языки:</em> <br>
            HTML - закрепленные теги, прощает некоторые синтаксические ошибки. <br>
            XML - теги создает пользователь, проверка синтаксиса и валидация документа по WDSL. <br>
          <br>
          <em>RPC, REST - архитектура API:</em> <br>
            RPC - запрос на выполнение функции на сервере по имени функции с входными параметрами. <br>
            REST - запрос с помощью установленных методов к ресурсу (сущности) на сервере. <br>
          <br>
          <em>XML, JSON - формат передачи данных:</em> <br>
            XML - наличие тегов, корневого элемента и пространства имен. Не может содержать массивы. <br>
            JSON - более компактный, не имеет тегов, может содержать в значениях массивы. <br>
          <br>
          <em>HTTP, SOAP - протоколы передачи данных:</em> <br>
            HTTP - протокол прикладного уровня передачи данных. <br>
            SOAP - формальный корпоративный подход, работает поверх любого протокола связи, даже асинхронно. <br>
          <br>
          <em>Наиболее распространенные связки:</em> <br>
            JSON + REST + HTTP <br>
            XML + RPC + SOAP <br>
          <br>
          <dfn>Интерфейс программирования приложений</dfn> (API) - это интерфейс или правила связи между клиентом и сервером, предназначенный для упрощения создания программного обеспечения на стороне клиента. <br>
          API является важной абстракцией, описывающей функциональность «в чистом виде», безотносительно того, как реализована эта функциональность.<br>
          <br>
          <dfn>RPC</dfn> (Remote Procedure Call) <br>
          <dfn>Удаленный вызов процедур</dfn> — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). <br>
        img(src="./img/web/rpc.png" alt="")
        img(src="./img/web/rpc1.png" alt="")
        br
        p.
          <dfn>REST</dfn> (Representational State Transfer) <br>
          <dfn>Передача состояния представления</dfn> — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.<br>
          REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой системы по модели клиент-сервер.<br>
          Особенности архитектурного стиля:<br>
          - Каждая сущность должна иметь уникальный идентификатор – URI<br>
          - Сущности должны быть связаны между собой<br>
          - Для чтения и изменения данных должны использоваться стандартные методы<br>
          - Должна быть поддержка нескольких типов ресурсов<br>
          - Взаимодействие должно осуществляться без состояния<br>
          <br>
          Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.<br>
          Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35 страница в этой книге — /book/3/page/35.<br>
          CRUD в REST:<br>
          - GET /book/ — получить список всех книг<br>
          - GET /book/3/ — получить книгу номер 3<br>
          - POST /book/ — добавить книгу (данные в теле запроса)<br>
          - PUT /book/3 – изменить книгу (данные в теле запроса)<br>
          - DELETE /book/3 – удалить книгу<br>
          <br>
          Или:<br>
          - GET /book/ — получить список всех книг<br>
          - GET /book/3/ — получить книгу номер 3<br>
          - POST /book/ — добавить книгу (данные в теле запроса)<br>
          - POST /book/3 — изменить книгу (данные в теле запроса)<br>
          - POST /book/3 — удалить книгу (тело запроса пустое)<br>
          <br>
        img(src="./img/web/MicroService.png" alt="")
        p.
          RPC: Мы отправляем сообщение, и это может привести к тому, что что-то сохранится в базе данных для сохранения истории, что может быть другим вызовом RPC, возможно, с теми же именами полей. <br>
          REST: Мы создаем ресурс сообщений в коллекции сообщений пользователя.<br>
          Мы можем легко увидеть историю этого, выполнив GET для того же URL.<br>
        img(src="./img/web/rpcrest.png" alt="")
        img(src="./img/web/rpcrest1.png" alt="")
        p.
          API основанные на RPC прекрасно работают для действий (выполнения процедур или команд).<br>
          API основанные на REST хороши для моделирования сущностей и применения CRUD (create, read, update, delete) для данных.<br>
          <br>
          <dfn>JSON</dfn> - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером.<br>
          Он основан на подмножестве языка программирования JavaScript.<br>
          Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. <br>
          <br>
          Ключи в JSON находятся с левой стороны от двоеточия.<br>
          Их нужно оборачивать в двойные кавычки (например, "key ") и это может быть любая строка.<br>
          В каждом объекте, ключи должны быть уникальными.<br>
          Пробелы допускаются, но лучше их заменять знаком подчеркивания.<br>
          Значения находятся с правой стороны от двоеточия.<br>
          Значения могут быть одним из шести типов данных:<br>
          Строкой<br>
          Числом<br>
          Объектом<br>
          Массивом<br>
          Булевым значением<br>
          null<br>
        img(src="./img/web/json1.png" alt="")
        img(src="./img/web/json2.png" alt="")
        p.
          JSON более компактный и не требует тегов закрытия как в XML.<br>
          Более того, XML не может использовать массивы, как в примере с JSON.

      //- Markdown
      details
        summary.menu__submenu_lv1 Markdown
        pre
          code.
            <span>Heading:</span>
            # H1
            ## H2
            ### H3
            #### H4
            ##### H5
            ###### H6

            <span>Bold:</span>
            **bold text**

            <span>Italic:</span>
            *italicized text*

            <span>Strikethrough:</span>
            ~~The world is flat.~~

            <span>Blockquote:</span>
            > blockquote

            <span>Ordered List:</span>
            1. First item
            2. Second item
            3. Third item

            <span>Unordered List:</span>
            - First item
            - Second item
            - Third item

            <span>Code:</span>
            `code`

            <span>Link:</span>
            [title](https://www.example.com)

            <span>Image:</span>
            ![alt text](image.jpg)

            <span>Table:</span>
            | Item         | Price | # In stock |
            |--------------|:-----:|-----------:|
            | Juicy Apples |  1.99 |        739 |
            | Bananas      |  1.89 |          6 |

            <span>Fenced Code Block:</span>
              {
                "firstName": "John",
                "lastName": "Smith",
                "age": 25
              }

            <span>Footnote:</span>
            Here's a sentence with a footnote. [^1]
            [^1]: This is the footnote. 

            <span>Heading ID:</span>
            My Great Heading {#custom-id}

            <span>Definition List:</span>
            term
            : definition

            <span>Task List:</span>
            - [x] Write the press release
            - [ ] Update the website
            - [ ] Contact the media 

            <span>Emoji:</span>
            That is so funny! :joy:

            <span>Highlight:</span>
            I need to highlight these ==very important words==. 

            <span>Subscript:</span>
            H~2~O

            <span>Superscript:</span>
            X^2^

      //- XML
      details
        summary.menu__submenu_lv1 XML
        p.
          <dfn>XML</dfn> - это язык разметки подобный HTML. <br>
          Расшифровывается как (англ. <i>Extensible Markup Language</i> - Расширяемый Язык Разметки). <br>
          В отличии от остальных языков разметки, XML сам по себе не определён (это означает, что вы должны сами определять используемые теги). <br>
          Основной целью XML является передача данных между разными системами (даже концептуально разными), такими как интернет.<br>
          Cвое название получил по той причине, что в нем нет фиксированного формата, как в HTML. <br>В то время как язык HTML ограничивается набором твердо закрепленных тегов, пользователи XML могут создавать свои собственные тэги, которые бы отвечали тематике документа. <br>Таким образом, XML - это метаязык. <br>Этот язык используется в качестве средства для описания грамматики других языков и контроля за правильностью составления документов.<br>
          Для корректного XML документа должны исполняться следующие условия: <br>
          Правильное оформление документа. <br>
          Соблюдаться все синтаксические правила XML. <br>
          Документ должен соответствовать семантическим правилам языка (которые обычно заданны в схеме XML или DTD (англ. Document Type Definition (en-US))).<br>
          <br>
          Сходство с HTML:<br>
          - В XML существуют открывающие, закрывающие и пустые тэги.<br>
          - Теги в документе могут быть вложены друг в друга.<br>
          - Теги начала и конца элемента являются основными используемыми в XML разметками.<br>
          - Тэги могут иметь атрибуты, причем количество атрибутов зависит от фантазии автора.<br>
          - Документы XML могут содержать ссылки на другие объекты.<br>
          <br>
          Основные отличия от HTML: <br>
          Большое внимание уделяется контролю документа. <br>
          Проверка действительности документа предполагает выполнение следующих действий: <br>
          - Синтаксическая проверка, <br>
          - Проверка валидности документа.<br>
          <br>
          XML обычно используют для описания чего-то. <br>
          Существуют методы отображения XML данных, но если вы не определили способ визуализации XML документа, то в браузере он отобразится построчно, как обычный текстовый файл. <br>
          Один из методов отображения XML - указать CSS (чтобы использовать в документе нужно прописать инструкцию xml-stylesheet). <br>
        code xml-stylesheet type="text/css" href="stylesheet.css"
        br
        p.
          Есть также много других мощных методов отображения XML, например, <dfn>XSLT</dfn>(англ. <i>Extensible Stylesheet Language Transformations</i>), который может использоваться для преобразование XML в другие языки такие, как HTML. <br>
          Это делает XML очень универсальным. <br>
        code xml-stylesheet type="text/xsl" href="transform.xsl"
        br
        img(src="./img/web/XML_.png" alt="")
        img(src="./img/web/XMLDTD.png" alt="")
        img(src="./img/web/XMLEntities.png" alt="")

      //- HTML
      details
        summary.menu__submenu_lv1 HTML
        pre
          code.
            &lt;div&gt;
              &lt;p&gt;Привет, мир!&lt;/p&gt;
            &lt;/div&gt;
        p.
          <dfn>Структура</dfn><br>
          <b>!DOCTYPE</b> - Тип документа<br>
          <b>html</b> - Корень HTML-документа<br>
          <b>head</b> - Содержит метаданные/информацию для документа, блочный<br>
          <b>title</b> - Название сайта, которое отображается во вкладке<br>
          <b>body</b> - Тело документа, блочный<br>
          <b>header</b> - Заголовок документа или раздела, блочный, семантика<br>
          <b>nav</b> - Навигационные ссылки, блочный, семантика<br>
          <b>main</b> - Основное содержимое документа, блочный, семантика<br>
          <b>section</b> - Раздел в документе, семантика<br>
          <b>aside</b> - Боковая панель сайта, второстепенный контент, семантика<br>
          <b>div</b> - Контейнер, блочный<br>
          <b>footer</b> - Нижний колонтитул документа или раздела, блочный, семантика<br>
          <br>
          <dfn>Вставка</dfn><br>
          <b>script</b> - JS вставка<br>
          <b>style</b> - CSS вставка<br>
          <b>embed</b> - Контейнер для внешнего приложения, блочный<br>
          <b>object</b> - Контейнер для внешнего приложения, блочный<br>
          <b>template</b> - Контейнер для контента, который должен быть скрыт при загрузке страницы<br>
          <b>iframe</b> - Встроенный фрейм (страница в странице)<br>
          <b>noscript</b> - Альтернативный контент при не поддержании JS<br>
          <br>
          <dfn>Списки</dfn><br>
          <b>details</b> - Спойлер, блочный<br>
          <b>summary</b> - название спойлера<br>
          <b>dl</b> - Список определений, блочный<br>
          <b>dt</b> - Термин<br>
          <b>dd</b> - Значение термина<br>
          <b>ol</b> - Упорядоченный список, блочный<br>
          <b>ul</b> - Неупорядоченный список, блочный<br>
          <b>menu</b> - Неупорядоченный список, блочный<br>
          <b>li</b> - Элемент списка, блочный<br>
          <b>optgroup</b> label="" - Группу связанных параметров в раскрывающемся списке<br>
          <b>option</b> value="" - параметр в раскрывающемся списке<br>
          <b>label</b> for="cars" - Имя раскрывающегося списка<br>
          <b>select</b> name="cars" id="cars"- Раскрывающийся список<br>
          <b>option</b> value="" - Значение раскрывающегося списка<br>
          <br>
          <dfn>Текст</dfn><br>
          <b>article</b> - Группировка связанных элементов в независимый объект, семантика<br>
          <b>hgroup</b> - Заголовок и связанный контент, блочный<br>
          <b>abbr</b> title="Расшифровка" - Аббревиатура или акроним, строчный<br>
          <b>address</b> - Вывод контактной информации, строчный<br>
          <b>b</b> - Жирный текст, строчный<br>
          <b>small</b> - Меньший текст, строчный<br>
          <b>span</b> - Часть текста в строке, строчный<br>
          <b>strong</b> - Текст большой важности, строчный, семантика<br>
          <b>u</b> - Подчеркнутый текст, строчный<br>
          <b>sub</b> - Подстрочный текст<br>
          <b>sup</b> - Надстрочный текст<br>
          <b>bdi</b> - Изолирует часть текста, строчный<br>
          <b>bdo</b> dir="rtl" - Переопределяет направление текста, строчный<br>
          <b>blockquote</b> cite="ссылка на источник" - Раздел, цитируемый из другого источника, блочный, семантика<br>
          <b>q</b> - Короткая цитата, семантика<br>
          <b>time</b> - Вывод даты и времени, семантика<br>
          <b>br</b> - Разрыв строки, строчный<br>
          <b>cite</b> - Название произведения, вывод автора цитаты, строчный, семантика<br>
          <b>code</b> - Часть компьютерного кода, строчный<br>
          <b>data</b> value="номер продукта" - Ассоциирует название продукта с номером продукта, строчный<br>
          <b>del</b> - Перечеркнутый текст, строчный<br>
          <b>dfn</b> - Термин, который будет определен, строчный<br>
          <b>em</b> - Выделенный текст, текст с ударением (более громко), отдельная мысль или перефразировка, строчный, семантика<br>
          <b>h1</b> - h1 - h6, Заголовок, блочный, семантика<br>
          <b>i</b> - Текст курсивом. Текст, который отличается (иностранное слово, мысли и т.д.), строчный<br>
          <b>ins</b> - Текст, который был вставлен, строчный<br>
          <b>kbd</b> - Текст, как ввод с клавиатуры, строчный<br>
          <b>mark</b> - Отмеченный/выделенный текст особого внимания, строчный<br>
          <b>s</b> - Неправильныйт текст<br>
          <b>samp</b> - Текст как вывод компьютерной программы<br>
          <b>var</b> - Текст как переменная<br>
          <b>wbr</b> - Возможный разрыв строки<br>
          <b>p</b> - Параграф, блочный<br>
          <b>pre</b> - Предварительно отформатированный текст, блочный<br>
          <b>ruby</b> - Аннотация Ruby (для восточноазиатской типографики)<br>
          <b>hr</b> - Тематическое изменение содержания (линия), блочный<br>
          <br>
          <dfn>Ссылки</dfn><br>
          <b>link</b> - Связывает с документом другой документ, блочный<br>
          <b>a</b> href="ссылка" - Гиперссылка<br>
          <b>a</b> href="#" target="_blank" title="Подсказка" class="" id="" style=""<br>
          <b>a</b> href="tel: phone"<br>
          <b>a</b> href="email: address"<br>
          <b>base</b> href="..." - Базовый URL-адрес для всех относительных URL-адресов в документе, строчный<br>
          <br>
          <dfn>Формы</dfn><br>
          <b>dialog</b> - Диалоговое окно, блочный<br>
          <b>textarea</b> rows="" cols="" - Поле многострочного ввода (текстовая область)<br>
          <b>button</b> - Кликабельная кнопка, блочный<br>
          <br>
          <b>table</b> - Таблица, блочный<br>
          <b>caption</b> - Название таблицы, блочный<br>
          <b>thead</b> - Шапка таблицы, блочный<br>
          <b>tbody</b> - Тело таблицы, блочный<br>
          <b>tr</b> - Строка таблицы, блочный<br>
          <b>th</b> - Ячейка шапки таблицы, блочный<br>
          <b>td</b> - Ячейка тела таблицы, блочный<br>
          <b>tfoot</b> - Подвал таблицы, блочный<br>
          <b>colgroup</b> - Группа столбцов в таблице<br>
          <b>colspan</b> ="2" - Объединение столбцов в таблице<br>
          <b>rowspan</b> ="2" - Объединение строк в таблице<br>
        pre
          code.
            form action="" method=""
              label for="" /label
              input type="" id="" name="" value="" tabindex=""
              textarea name="" placeholder="" /textarea
              select
                option /option
              /select
              input type="submit" id="" name="" value="Надпись на кнопке"
              button /button
            /form
        p.
          <b>form</b> action="/action_page.php" - HTML-форма для ввода пользователя. Отвечает за отправку введенных данных, адрес передачи - атрибут action, метод передачи - атрибут method<br>
          <b>fieldset</b> - Групперует элементы формы<br>
          <b>legend</b> - Заголовок формы<br>
          <b>label</b> for="fname" - Заголовок поля<br>
          <b>input</b> type="text" id="fname" name="fname" - Поле ввода<br>
          <b>input</b> type="submit" value="Submit" - Кнопка отправить<br>
          <br>
          <b>form</b> action="/action_page.php" method="get" - Форма с предопределённым списком вариантов для поля ввода<br>
          <b>label</b> for="browser" - Заголовок поля<br>
          <b>input</b> list="browsers" name="browser" id="browser" - Поле ввода<br>
          <b>datalist</b> id="browsers" - Список вариантов<br>
          <b>option</b> value="Edge" - Вариант ввода<br>
          <b>input</b> type="submit" - Кнопка отправить<br>
          <br>
          <b>search</b> - Раздел поиска<br>
          <b>form</b> - Форма поиска<br>
          <b>input</b> name="" id="" placeholder="" - Поле ввода поиска<br>
          <br>
          <b>form</b> oninput="x.value=parseInt(a.value)+parseInt(b.value)" - Результат расчета<br>
          <b>input</b> type="range" id="a" value="50" - ввод первого слагаемого<br>
          + <b>input</b> type="number" id="b" value="25" - ввод второго слагаемого<br>
          = <b>output</b> name="x" for="a b" - вывод суммы<br>
          <br>
          <b>label</b> for="idname" - Заголовок манометра<br>
          <b>meter</b> id="idname" value="" - Скалярное измерение в известном диапазоне (манометр)<br>
          <br>          
          <b>label</b> for="file" - Заголовок прогресса<br>
          <b>progress</b> id="file" value="32" max="100" - Представляет ход выполнения задачи, блочный<br>
          <br>
          <dfn>Медиа</dfn><br>
          <b>canvas</b> id="myCanvas" - Рисование графики на лету, блочный<br>
          <b>svg</b> width="" height="" - Контейнер для графики SVG, блочный<br>
          <b>img</b> src="" alt="" - Изображение, строчный<br>
          <br>
          <b>img</b> src="" alt="" usemap="#workmap" - Карта-изображения<br>
          <b>map</b> name="workmap" - Карта-изображения<br>
          <b>area</b> shape="" coords="" alt="" href="" - Карта-изображения<br>
          <br>
          <b>picture</b> - контейнер для нескольких вариантов ресурсов изображений, блочный<br>
            source media="(min-width: 650px)" srcset="img_food.jpg" - Адаптив без css, ускоряет загрузку верстки.<br>
            source media="(min-width: 465px)" srcset="img_car.jpg" <br>
            img src="img_girl.jpg" - Если браузер не поддерживает picture, то выведет img.<br>
          /picture<br>
          <br>
          <b>figure</b> - Групировка медиа-элементов, блочный, изображение с доп.тегами<br>
            img src="" - медиа-элемент<br>
            figcaption  - Заголовок медиа-элемента<br>
          <b>audio</b> controls - Встроенный аудио контент<br>
          <b>source</b> src="horse.ogg" type="audio/ogg" - аудио контент<br>
          <b>source</b> src="horse.mp3" type="audio/mpeg" - аудио контент<br>
          <b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
          <br>          
          <b>video</b> width="" height="" controls - Встроенный видио контент, блочный<br>
          <b>source</b> src="" type="" - видио контент<br>
          <b>track</b> src="" kind="" srclang="" label="" - текстовые дорожки<br>
          <br>
          <dfn>Мета</dfn>
          <b>meta charset="UTF-8"</b> - Кодировка<br>
          <b>meta name="viewport" content="width=1170"</b> - фиксированная ширина вся помещается в экран<br>
          <b>meta name="viewport" content="width=device-width"</b> - адаптивный<br>
          <b>meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</b> - параметры адаптивности<br>
          <b>meta name="format-detection" content="telephone=no"</b> - отключает ссылку у номера телефона на iOS<br>
          <b>meta name="description" content="<i>описание до 140 символов</i>"</b> - для SEO<br>
          <b>meta name="keywords" content="<i>ключевые слова через запятую до 20</i>"</b> - ключевые слова для SEO<br>
          <b>meta name="robots" content="noindex, nofollow"</b> - недопуск поисковых роботов к страице<br>
          <b>meta name="robots" content="none"</b>
          <b>meta name="robots" content="noimageindex, nofollow"</b> - запрет индексации картинок и ссылок<br>
          <b>meta name="Author" content="<i>Дарт Вейдер</i>"</b> - Автор страницы<br>
          <b>meta name="Copyright" content="<i>Люк Скайвокер</i>"</b> - Авторские права<br>
          <b>meta name="Address" content="<i>Татуин, кратер № 97</i>"</b> - Адрес автора<br>
          <b>meta http-equiv="refresh" content="0"; url=""</b> - обновляет страницу либо перенаправляет пользователя, указать количество секунд до перенаправления и адрес страницы<br>
          <b>meta property="og:locale" content="<i>ru_RU</i>"</b> - локализация для русcкоязычного сайта<br>
          <b>meta property="og:type" content="<i>article</i>"</b> - тип контента статья<br>
          <b>meta property="og:title" content="<i>META теги</i>"</b> - заголовок записи в социальной сети<br>
          <b>meta property="og:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
          <b>meta property="og:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
          <b>meta property="og:url" content="http://fls.guru/meta/ "</b> - ссылка на текущую страницу<br>
          <b>meta property="og:site_name" content="<i>Название сайта</i>"</b> - Название сайта<br>
          <b>meta name="twitter:card" content="<i>summary</i>"</b> - тип карты твитер<br>
          <b>meta name="twitter:site" content="<i>Автор</i>"</b> - имя/логин автора<br>
          <b>meta name="twitter:title" content="<i>META теги</i>"</b> - название страницы<br>
          <b>meta name="twitter:description" content="<i>описание страницы</i>"</b> - описание страницы<br>
          <b>meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg"</b> - изображение для записи в соцсети<br>
          <br>
          p Валидаторы HTML:<br>
        a(href="https://caninclude.glitch.me/") glitch<br>
        a(href="https://validator.w3.org/") w3<br>
        a(href="https://developers.facebook.com/tools/debug/sharing/")  Facebook<br>
        a(href="https://ruogp.me/") ogp<br>
        a(href="https://cards-dev.twitter.com/validator") twitter<br>
        a(href="https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started") twitter<br>
        a(href="https://www.w3schools.com/html/default.asp") W3schools<br>

      //- Pug
      details
        summary.menu__submenu_lv1 Pug
        a(href="https://pugjs.org/language/attributes.html") Официальная документация по Pug
        p.
          Pug - это препроцессор HTML и шаблонизатор, который был написан на JavaScript для Node.js.<br>
          <br>
          В терминале:<br>
        code pug -w . -o ./ -P -E php
        p.
          <b>pug</b> - компилировать файлы с расширением .pug<br>
          <b>-w</b> - watcher - следить за изменениями в файлах<br>
          <b>.</b> - текущий каталог (каталог слежения)<br>
          <b>-o</b> - output - вывод скомпилированных файлов<br>
          <b>./</b> - каталог вывода<br>
          <b>-P</b> - pretty - удобочитаемый вид<br>
          <b>-E php</b> - компилировать с расширением php<br>
          <br>
          В Pug нет закрывающих тегов, вместо этого он использует строгую табуляцию (отступы) для определения вложености тегов.<br>
          Для закрытия тегов в конце необходимо добавить символ `/`: `foo(bar='baz')/`<br>
        pre
          code.
            ul            
              li Item A
              li Item B
              li Item C
        p Теги внутри строки<br>
        code This is plain old <em>text</em> content.
        br
        p.
          <dfn>Комментарии</dfn>
          Существуют различные комментариев: те, которые будут отображаться после компиляции, и те, которые пропадут.
        pre
          code.
            //-
              Comments for your template writers.
              Use as much text as you want.
            //
              Comments for your HTML readers.
              Use as much text as you want.
        p Перенос текста на несколько строк
        pre
          code.
            | The
            | mulyiline
            | text
        p или так
        pre
          code.
            The
            mulyiline
            text
        br
        p Синтаксис
        pre
          code.
            a(class='button' href='google.com') Google
            
            input(type='checkbox' name='agreement' checked)

            - var url = 'pug-test.html';
            a(href='/' + url) Link

            - url = 'https://example.com/'
            a(href=url) Another link

            - var classes = ['foo', 'bar', 'baz']
            a(class=classes)

            //- the class attribute may also be repeated to merge arrays
            a.bang(class=classes class=['bing'])
        br
        p Многострочный ассоциативный массив
        pre
          code.
            -
              var priceItem = [
                {include: filterInc, parameter : "Розовый фильтр"},
                {include: smileInc, parameter : "Смайлики"},
                {include: commentInc, parameter : "Комментарии"}
              ]
        br
        p <dfn>Условия</dfn>
        pre
          code.
            - var user = { description: 'foo bar baz' }
            - var authorised = false
            
            // user
            if user.description
              h2.green Description
              p.description= user.description
            else if authorised
              h2.blue Description
              p.description.
                User has no description,
                why not add one...
            else
              h2.red Description
              p.description User has no description

            - var authenticated = true
            body(class=authenticated ? 'authed' : 'anon')
        br
        p.
          <dfn>Конструкция Switch Case</dfn><br>
          Pug поддерживает switch case, которая представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
        pre
          code.
            - var friends = 10
            case friends
              when 0
                p you have no friends
              when 1
                p you have a friend
              default
                p you have #{friends} friends
        br
        p <dfn>Циклы</dfn>
        pre
          code.
            ul                                            
              each val, index in ['zero', 'one', 'two']
                li= index + ': ' + val

            - var values = [];
            ul
              each val in values
                li= val
              else
                li There are no values

            - var n = 0;
            ul
              while n < 4
                li= n++
        br
        p.
          <dfn>Вставка JavaScript кода</dfn><br>
          Pug поддерживает вставку частей JavaScript кода в шаблоны.<br>
          Не буфферизированный код начинается с символа `-`  
        pre
          code.
            - for (var x = 0; x < 3; x++)                 
              li item
        br                                                                          
        p Буфферизированный код начинается с символа `=`
        pre
          code.
            - let firstName = "Bob"
            p= firstName
            - let lastName = "Joe"
            .full-name= firstName + " " + lastName
            .full-name= `First name: ${firstName} Last name: ${lastName}`

            - const names = ['Bob Joe', 'John Doe', 'Billy Bob', 'John Week']
            ol
              each name in names
                li= name

            -
              const friendsList = [
                {
                  "firstName":"Bob",
                  "lastName":"Joe",
                  "mobile":"123456789"
                },
                {
                  "firstName":"John",
                  "lastName":"Doe",
                  "mobile":"123456789"
                },
                {
                  "firstName":"Billy",
                  "lastName":"Bob",
                  "mobile":"123456789"
                }
              ]

            // friendsList
              each friend in friendsList
                .friend
                  .first-name= friend.firstName
                  .last-name= friend.lastName
                  .mobile= friend.mobile

            -
              const friendsList2 = []

            // friendsList2
              each friend in friendsList
                .friend
                  .first-name # {friend.firstName}
                  .last-name # {friend.lastName}
                  .mobile # {friend.mobile}
              else
                .oh-no You have no friends!

            mixin friendCard(friend)
              .friend
                .first-name # {friend.firstName}
                .last-name # {friend.lastName}
                .mobile # {friend.mobile}

            // friends
              each friend in friendsList
                +friendCard(friend)
        br
        p.
          <dfn>PHP</dfn><br>
          вывод данных полученных из формы, код вместе с html в php файле.
        pre
          code.
            .friend.
              <?php
                echo $_POST['username'];
                echo "br";
                echo $_POST['username'];
                echo "br";
                echo $_POST['username'];
              ?>
        p <b>.friend.</b> - точка вначале обозначает класс (friend), точка в конце означает, что далее многостраничный текст<br>
        br
        p.
          <dfn>Интерполяция переменных</dfn>
          Pug предоставляет различные способы вывода переменных.
        pre
          code.
            - var title = "On Dogs: Man's Best Friend";
            - var author = "enlore";
            - var theGreat = "<span>escape!</span>";
            h1= title
            p Written with love by # {author}
            p This will be safe: ! {theGreat}
        br
        p.
          doctype html - Тип документа<br>
          <br>
          <dfn>Инклюды</dfn> (Includes)<br>
          Pug имеет возможность вставки содержимого одного файла в другой файл Pug.
        pre
          code.
            doctype html
            html
              head
                style
                include style.css
              body
                h1 My Site
                p Welcome to my super lame site.
                script
                  include script.js
        p.
          <dfn>Наследование шаблонов</dfn><br>
          Pug поддерживает наследование шаблонов.<br>
          Наследование шаблонов работает через ключевые слова <b>block</b> и <b>extend</b>.<br>
          В шаблоне block - обычный блок Pug, который может заменить дочерний шаблон.<br>
          Этот процесс является рекурсивным.
        pre
          code.
            // layout.pug
            html
              head
                title My Site
                block scripts
                  script(src='/jquery.js')
              body
                block content
                block foot
                  #footer
                    p some footer content

            // home.pug
            extends templates/layout
            - var title = 'Animals'
            - var pets = ['cat', 'dog']
            block content
              h1= title // or h1 # {title}
              each petName in pets
                p= petName // or p # {petName}
        p.
          <dfn>Миксины</dfn><br>
          Поддержка миксинов позволяет создавать переиспользуемые блоки.
        pre
          code.
            // Declaration
            mixin pet(name)
              li.pet= name
            // use
            ul                                              
              +pet('cat')
              +pet('dog')
              +pet('pig') 

            mixin article(title)
              .article
                .article-wrapper
                  h1= title
                  if block
                    block
                  else
                    p No content provided
            +article('Hello world')
            +article('Hello world')
              p This is my
              p Amazing article

            mixin link(href, name)
            // attributes == {class: "btn"}
              a(class!=attributes.class href=href)= name

            +link('/foo', 'foo')(class="btn")

      //- CSS
      details
        summary.menu__submenu_lv1 CSS
        p.
          <em>Стилем или CSS</em> (<i>Cascading Style Sheets, каскадные таблицы стилей</i>) <br>
            называется набор параметров форматирования,
            который применяется к элементам документа,
            чтобы изменить их внешний вид.<br>
            <em>Достоинства</em>:<br>
            - Разграничение кода и оформления<br>
            - Разное оформление для разных устройств<br>
            - Расширенные по сравнению с HTML способы оформления элементов<br>
            - Ускорение загрузки сайта<br>
            - Единое стилевое оформление множества документов<br>
          <br>
          <b>h1</b> <em>style</em> ="color: red;" - Внутренние стили. Приоритет максимальный.<br>
          <br>
          <b>style</b> - Глобальные стили<br>
            h1 {<br>
              color: red;<br>
            }<br>
          <b>style</b><br>
          <br>
          <b>link</b> rel="stylesheet" href="<i>путь/к файлу/CSS</i>" - Связанные стили<br>
          <br>
        a(href="https://www.w3schools.com/css/default.asp") W3schools
          
        //- Селекторы
        details
          summary Селекторы
          pre
            code.
              селектор {
                свойство: значение;
              }
          p.
            - Базовые ( #id,.class, tag)<br>
            - Иерархические (+, >, ~)<br>
            - Атрибутные ([atribute])<br>
            - :псевдоклассы (:hover, :visited и т.д.) - при действии<br>
            - ::псевдоэлементы (::after, ::before) - добавляем элемент до или после выбранного<br>
            <br>
            <b>"tag</b> - имя тэга<br>
            <b>".class</b> - CSS-класс<br>
            <b>"#id</b> - ID тэга<br>
            <b>"name = value</b> - Атрибут тэга<br>
            <b>":filter</b> - фильтр<br>
            <br>
            <b>"*</b> - все элементы на странице<br>
            <b>"sel, sel, sel</b> - выбор элементов по множетву селекторов<br>
            <b>"sel sel</b> - всех потомков<br>
            <b>"sel > sel</b> - только прямых потомков<br>
            <b>"sel + sel</b> - следующий сосед этого же уровня<br>
            <b>"sel ~ sel</b> - всех следующих соседей этого же уровня<br>
            <br>
            <b>[title="first"]</b> - атрибут title равен first<br>
            <b>[title~="first"]</b> - атрибут title содержит слово first<br>
            <b>sel:first-child {}</b> - первый ребенок<br>
            <b>sel:last-child {}</b> - последний ребенок<br>
            <b>sel:nth-child(2) {}</b> - второй ребенок<br>
            <b>sel:nth-child(2n) {}</b> - каждый второй ребенок<br>
            <b>sel:nth-child(even) {}</b> - чётные<br>
            <b>sel:nth-child(add) {}</b> - нечётные<br>
            <b>div.text {}</b>  применяем css-свойство к тегу div с классом text<br>
            <b>.block.text {}</b>  применяем к тегам, содержащим оба класса<br>
            <b>.block,.text {}</b>  применяем к тегам, содержащим один из классов<br>
            <b>.block .text {}</b>  применяем к тегам, содержащим класс text и находящийся внутри элемента с классом block<br>
            <b>.text > div {}</b>  применяем к первому div верхнего уровня внутри элемента с классом text<br>
            <b>.block + .text</b> sibling<br>
            <b>.block : hover</b> <br>
            псевдоклассы состояния: hover, active, target, focus<br>
            псевдоклассы навигации: first child, last child, first off type, last off type, not<br>
            <b>.block :: after</b> псевдоэлементы: before, after<br>
            @import "имя файла"; - импорт файлов<br>
            <br>
            <em>Параметр в качестве селектора</em>:<br>
            [class*="__container"] {}  применяем css-свойство ко всем элементам с атрибутом class, значение которого содержит __container<br>
            <br>
            <em>Псевдокласс</em> - это модификатор селектора<br>
            <b>.link:hover{}</b><br>
            <b>:hover</b> - срабатывает при наведении<br>
            <b>:visited</b> - срабатывает для посещенных ссылок<br>
            <b>:active</b> - срабатывает при нажатии на элемент<br>
            <b>:focus</b> - срабатывает при получении элементом фокуса<br>
            <b>:first-child</b> - обращение к первому элементу в блоке<br>
            <b>:last-child</b> - обращение к последнему элементу в блоке<br>
            <b>:nth-child(номер элемента по порядку, odd, even)</b> - обращение к конкретному элементу в блоке<br>
            <br>
            <em>Псевдоэлемент</em><br>
            строчный, модификатор содержимого элемента, синтаксис<br>
            <b>.text:hover::befor{}</b> либо <b>.text::first-line{}</b><br>
            <b>::first-line{}</b> - задает стиль первой строки текста<br>
            <b>::first-letter{}</b> - задает стиль первого символа<br>
            <b>::before</b> - для отображения контента до содержимого элемента, к которому применяется.<br>
              Обязательное свойство <b>content</b>: '';<br>
            <b>::after</b> - для отображения контента после содержимого элемента, к которому применяется.<br>
              Обязательное свойство <b>content</b>: '';<br>
            <br>
            <em>БЭМ</em><br>
            - блок - часть кода, которая повторяется или может повторяться самостоятельно<br>
            - элемент - это часть блока. имя класса блока__имя класса элемента<br>
            - модификатор - дополняет или уточняет стиль блока или элемента<br>
            <br>
            класс_модификатор<br>
            класс__элемент_модификатор<br>
            микс - позволяет использовать блоки и элементы в одном объекте<br>
            <br>
            <em>Абсолютные единицы измерения</em><br>
            <b>px</b> (пиксель)  Все остальные еденицы измерения пересчитываются браузером в пиксели<br>
            <br>
            <em>Относительные единицы измерения</em><br>
            <b>em</b> - равен текущему размеру объекта.<br> Лучше использовать для медиа-запросов и в случае когда нужно привязаться к текущему размеру шрифта.<br>
            <b>rem</b> - равен размеру шрифта в теге html, а если там нет, то браузера по умолчанию (16px).<br> Т.е. не зависит от резмаера шрифта родителя.<br> Лучше использовать для размеров шрифтов, отступов, не указывая размер для тега html.<br>
            <b>%</b> - разные свойства css вычисляют % от разных оснований.<br> Лучше использовать для отзывчивых резиновых конструкций, для позиционирования объектов и для скрола.<br>
            <b>vw, vh, vmin, vmax</b> - работают относительно окна браузера (viewport).<br> Лучше использовать для полноэкранных блоков и scss вычислений.<br>
            <b>fr</b> - единица измерения в модуле grid.<br>
            <b>ex</b> - единица измерения относительно размера прописной "е".<br>
            <b>ch</b> - единица измерения относительно размера 0.<br>

        //- Свойства
        details
            summary Свойства
            p.
              <em>Текст</em><br>
              <b>font-family</b> - семейство шрифта.<br>
              <b>font-size</b> - размер шрифта елемента.<br>
              <b>font-style</b> - начертание шрифта (курсив, наклон и нормальный)<br>
              <b>font-weight</b> - насыщенность (вес) шрифта<br>
              <b>color</b> - цвет текста<br>
              <b>text-align</b> - горизонтальное выравнивание текста<br>
              <b>text-decoration</b> - оформление текста (подчеркивание, перечеркивание и т.д.)<br>
              <b>text-shadow</b> - добавляет тень к тексту<br>
              <b>text-transform</b> - преобразование заглавных и прописных символов<br>
              <b>text-ident</b> - отступ первой строки от края блока<br>
              <b>letter-spacing</b> - определяет интервал между символами<br>
              <b>word-spacing</b> - определяет интервал между словами<br>
              <b>white-space</b> - управляет свойствами пробелов между словами<br>
              <b>line-height</b> - устанавливает межстрочный интервал текста<br>
              <br>
              <em>Геометрия</em><br>
              <b>padding</b> - внутренний отступ блочных тегов<br>
              <b>margin</b> - внешний отступ блочных тегов<br>
              <b>width</b> - ширина блочных тегов<br>
              <b>max-width</b> - устанавливает макимальную ширину блочных тегов<br>
              <b>min-width</b> - устанавливает минимальную ширину блочных тегов<br>
              <b>height</b> - устанавливает высоту блочных тегов<br>
              <b>max-height</b> - устанавливает максимальную высоту блочных тегов<br>
              <b>min-height</b> - устанавливает минимальную высоту блочных тегов<br>
              <br>
              <em>Отоброжение</em><br>
              <b>overflow</b> - управляет отображением содержания блочного елемента<br>
              <b>display</b> - определяет как елемент должен быть показан в документе<br>
              <b>border</b> - граница блока<br>
              <b>border-radius</b> - устанавливает радиус скругления уголков блока<br>
              <b>outline</b> - внешняя граница блока<br>
              <b>box-shadow</b> - добавляет тень к блоку<br>
              <b>opacity</b> - определяет уровень прозрачности элемента<br>
              <b>visibility</b> - отображение или скрытие блока<br>
              <b>background</b> - управляет фоном элемента<br>
              <b>background-color</b> - цвет фона элемента<br>
              <b>background-image</b> - фоновое изображение или градиентная заливка<br>
              <b>background-repeat</b> - повторение фонового изображения<br>
              <b>background-position</b> - положение фонового изображения<br>
              <b>background-attachment</b> - прокручивание фона вместе с содержимым элемента<br>
              <b>background-size</b> - размеры фонового изображения<br>
              <b>background</b> - позволяет задать несколько фоновых изображений одному блоку<br>
              <b>background-origin и background-clip</b> - отвечают за показ фона вместе с границей border.<br>
              <br>
              <em>Позиционирование</em><br>
              <b>position</b> - совйство позиционирования устанавливает тип позиционирования элемента относительно других элементов или окна браузера<br>
              <b>position: static</b>; - по умолчанию у всех блоков<br>
              <b>position: relative</b>; - положение относительно изначального места в коде, обязательно с:<br>
              <b>left, top, right, bottom</b> - управляют позицией элемента<br>
              <b>z-index</b> - управляет наложением элементов<br>
              Для взаиморасположения относительно друг друга у одного элемента должно быть absolute у другого relative<br>
              <b>position: absolute</b>; - утрачивает связь с местом в коде и свойствами тега, обязательно с:<br>
              <b>position: fixed</b>; - фиксирует элемент относительно окна браузера не завися от элементов с relative и прокрутки обязательно с: left, top, right, bottom - управляют позицией элемента<br>
              <b>position: sticky</b>; - переводит элемент из static в fixed при достижении элементом указаной позиции обязательно с: left, top, right, bottom - управляют позицией элемента<br>
              <br>
              <em>Трансформ</em><br>
              <b>transform</b> - применяется только к блочным объектам<br>
              <b>transform: translate(0px, 0px</b>); - translate сдвигает элемент на новое место<br>
              <b>transform: scale(1, 1)</b>; - scale масштабирует изображения, т.е. zoom. При отрицательном значении - зеркалит.<br>
              <b>transform: rotate(0deg)</b>; - поворачивает элемент. Положительное значение по часовой, отрицетельное - против.<br>
              <b>transform: skew(0deg, 0deg)</b>; - деформирует стороны объекта по вертикали и горизонтали.<br>
              <b>transform: matrix(a, b, c, d, e)</b>; - позволяет объединить трансформации. Значения без едениц измерения.<br>
              <b>transform: translate(0px, 0px) scale(1, 1) rotate(0deg)</b>;
              <b>transform-origin: center</b>; - смещает центр трансформации<br>
              <b>perspective: 0px</b>; - установка глубины перспективы<br>
              <b>perspective-origin: center</b>; - смена точки начала координат<br>
              <b>transform: translate3d(0px, 0px, 0px)</b>;<br>
              <b>transform: scale3d(1, 1, 1)</b>;<br>
              <b>transform: rotate3d(x, y, z, deg)</b>;<br>
              <b>transform: matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n)</b>; - 16 значений<br>
              <b>transform: translate3d(0px, 0px, 0px) rotate3d(1, 1, 1, 0deg)</b>;
              <b>transform-style: flat</b>; - задает стиль трансформации<br>
              <b>backface-visibility: visible</b>; - показывает обратную сторону объекта<br>
              <br>
              <em>Шрифты</em> подключаем любо в html тегом <b>link</b> либо в scss через <b>@import</b><br>
              fonts.google.com<br>
              nomail.com.ua<br>
              font2web.com<br>
              <br>
              БЭМ: ru.bem.info<br>

        //- Flex
        details
          summary Flex
          p.
            <b>display</b>: flex; - включает флекс разметку<br>
            <b>display</b>: inline-flex; - строчный флекс-контейнер<br>
            <br>
            <b>justify-content</b> - определяет выравнивание вдоль основной оси<br>
            <b>justify-content</b>: flex-start; - елементы слева<br>
            <b>justify-content</b>: flx-end; - елементы справа<br>
            <b>justify-content</b>: cnter; - елементы в центре<br>
            <b>justify-content</b>: space-between; - пространство между елементами<br>
            <b>justify-content</b>: space-around; - пространство вокруг елементов<br>
            <br>
            <em>для флекс-контейнера:</em>
            <b>align-items</b> - определяет поведение вдоль перекрёсной оси<br>
            <b>align-items</b>: stretch; - елементы подстраиваются под самый высокий<br>
            <b>align-items</b>: flex-start; - высота флекс-елемента от верха на высоту контента<br>
            <b>align-items</b>: flex-end; - высота флекс-елемента от низа на высоту контента<br>
            <b>align-items</b>: center; - флекс-елементы выстроятся по горизонтальному центру самого высокого елемента<br>
            <b>align-items</b>: baseline; - выстраивает флекс-елементы по базовой линии<br>
            <b>flex-wrap</b>: nowrap; - флекс-елементы не адаптируются<br>
            <b>flex-wrap</b>: wrap; - флекс-елементы адаптируются<br>
            <b>flex-wrap</b>: wrap-reverse; - флекс-елементы адаптируются в обратном порядке<br>
            <br>
            <em>для флекс-елемента:</em>
            <b>align-self</b> - переопределяет выравнивание<br>
            <b>align-self</b>: stretch;<br>
            <b>align-self</b>: center;<br>
            <b>align-self</b>: flex-start;<br>
            <b>align-self</b>: flex-end;<br>
            <br>
            <b>order</b> - порядок вывода елементов<br>
            <b>order</b>: 1; - выводим первым<br>
            <b>flex-basis</b> - базовый размер элемента<br>
            <b>flex-basis</b>: auto; - по размеру контента<br>
            <br>
            <b>flex-grow</b> - возможность увеличиваться в размере<br>
            <b>flex-grow</b>: 0; - не больше чем flex-basis<br>
            <b>flex-shrink</b> - возможность уменьшаться в размере<br>
            <b>flex-shrink</b>: 1; - разрешено становиться меньше<br>
            <b>flex</b>: 0 1 auto; - короткая запись flex-grow flex-shrink flex-basis<br>
            <br>
            <b>flex-direction</b> - устанавливает основную ось<br>
            <b>flex-direction</b>: row; - в ряд<br>
            <b>flex-direction</b>: row-reverse; - в обратную сторону в обратном порядке<br>
            <b>flex-direction</b>: column; - основная ось вертикально<br>
            <b>flex-direction</b>: column-revers; - вертикально снизу вверх<br>

        //- GRID
        details
          summary GRID
          p.
            <b>display</b>: grid; - определяет блочный грид-контейнер<br>
            <b>display</b>: inline-grid; - определяет строчный грид-контейнер<br>
            <b>grid-template-columns</b>: ; - управление колонками<br>
            <b>grid-template-rows</b>: ; - управление рядами<br>
            <b>grid-template-columns</b>: 200px minmax(150px, 1fr) 200px; - первая колонка шириной 200рх, вторая - минимум 150рх и максимум на всю ширину грид-контейнера, третья - шириной 200рх<br>
            <b>grid-template-rows</b>: 1fr 1fr; - два ряда делят высоту грид-контейнера поровну<br>
            <b>grid-template-columns</b>: fit-content(400px) 1fr auto; - ширина первой колонки по контенту, но не шире 400рх, вторая колонка - вся свободная ширина блока, третья колонка по ширине контента<br>
            <b>grid-template-columns</b>: repeat(3, 1fr); - 3 колонки размером 1fr<br>
            <b>grid-template-areas</b>: ; - управляет областями<br>
            <b>grid-area</b>: ; - применяется к елементам<br>
            <b>grid-template</b>: repeat(2, 1fr) / repeat(3, 1fr); - две равные строки и три равные колонки<br>
            <b>grid-template</b>:<br>
            [start] "header header" 100px [row2]<br>
            [row2]  "side content" 1fr [row-end] / 150px 1fr; - управление областями, через свойство grid-area присваиваем имена элементам, в первом ряду header занимает две колонки, второй ряд содержит колонки side и content, высота рядов 1fr, ширина колонок 150px 1fr.<br>
            <b>grid-auto-rows</b>: ; - управляет рядом неявной сетки, т.е. ряд, который не обозначен в grid-template-rows<br>
            <b>grid-auto-columns</b>: ; - если не задан grid-template-columns<br>
            <b>grid-auto-flow</b>: row; - выстраивает грид-элементы поочередно в ряд<br>
            <b>grid-auto-flow</b>: column; - выстраивает грид-элементы поочередно в колонку<br>
            <b>grid-auto-flow</b>: dense; - выстраивает грид-элементы в произвольном порядке<br>
            <br>
            <em>Размещение элементов с помощью линий сетки</em>:<br>  
            <b>grid-row-start</b>: auto;<br>
            <b>grid-row-end</b>: auto;<br>
            <b>grid-column-start</b>: auto;<br>
            <b>grid-column-end</b>: auto;<br>
            <b>grid-row-start</b>: span 2; объект занимает 2 строчки<br>
            <b>grid-template-rows</b>: [start] 1fr [row2] 1fr [row-end]; - две строки одинаковой высоты и [имена линий] между строк сверху вниз<br>
            <b>grid-template-columns</b>: [start] 1fr [col2] 1fr [col3] 1fr [col-end]; - три столбца одинаковой ширины и [имена линий] меду столбцами слева направо<br>
            <b>grid-row</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
            <b>grid-column</b>: 1 / 2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
            или<br>
            <b>grid-row</b>: start / row2; - применяется к элементу, указывает начало и конец элемента по линиям рядов<br>
            <b>grid-column</b>: start / col2; - применяется к элементу, указывает начало и конец элемента по линиям столбцов<br>
            <b>order</b>: 1; - задается каждому елементу сетки и определяет порядок вывода елемента<br>
            <b>justify-items</b>: stretch; - растягивает/прижимает елементы в ячейках вправо/влево<br>
            <b>align-items</b>: stretch; - растягивает/прижимает елементы в ячейках вверх/вниз<br>
            <b>row-gap</b>: 20px; - расстояние между строками<br>
            <b>column-gap</b>: 20px; - расстояние между колонками<br>
            или<br>
            <b>gap</b>: 20px; - и для строк и для колонок одновременно<br>

        //- Адаптивная верстка
        details
          summary Адаптивная верстка
          p.
            <em>отзывчивая</em> - всё в <b>%</b>, указываем только максимальную ширину для body, весь контент на своём месте, отзывается на изменение ширины экрана.<br>
            <em>адаптивная</em> - <b>брейкпоинты</b>, медиа-запросы, контент перестраивается на брейкпоинтах при изменении ширины экрана.<br>
            <em>отзывчиво-адаптивная</em> - делаем отзывчиую пока читается контент при уменьшении ширины экрана. При ширине плохо читабельного контента далем брейкпоинт - адаптив.<br>
            <b>meta</b> name="viewport" content="width=device-width"<br>
            <em>Брейкпоинт</em>:
          pre
            code.
              @media (max-width:1200px){
                .container{
                  max-width: 970px;
                }
              }

              @media (max-width:992px){
                .container{
                  max-width: 750px;
                }
              }

              @media (max-width:767px){
                .container{
                  max-width: none;
                }
              }
          <b>@import</b> url(color.css) screen and (color); - медиа-запрос в css,<br>
          <b>link</b> rel="stylesheet" media="screen and (color)" href="example.css" - медиа-запрос в html: файл стилей подключится в только при выполнении условия медиа-запроса<br>

        //- Animation
        details
          summary Animation
          pre
            code.
              <b>@keyframes</b> <i>grow</i> {
                <b>from</b> {
                  font-size: 20px;
                }
                <b>to</b> {
                  font-size: 100px;
                }
              }

              <b>h1</b> {
                <b>animation-name</b>: <i>grow</i>;
                <b>animation-direction</b>: 2s;
                <b>animation-fill-mode</b>: forwards;
              }
              
              <span>или</span>

              <b>@keyframes</b> <i>grow</i> {
                <b>from</b> {
                  left: 0%;
                }
                <b>to</b> {
                  left: 50%;
                }
              }

              <b>h1</b> {
                <b>position: relative</b>
                <b>animation-name</b>: <i>grow</i>;
                <b>animation-direction</b>: 2s;
                <b>animation-fill-mode</b>: forwards;
              }
          p.
            <b>animation-name</b>: имя ключевых кадров, имя ключевых кадров № 2; - список применяемых к элементу анимаций (кадров)<br>
            <b>animation-duration</b> - продолжительность анимации<br>
            <b>animation-timing-function</b> - сценарий анимации<br>
            <b>animation-iteration-count</b> - количество повторов ключевых кадров<br>
            <b>animation-direction</b> - тип и направление проигрования ключевых кадров<br>
            <b>animation-play-state</b> - запускает либо приостанавливает анимацию по событию<br>
            <b>animation-name</b>: none; - возвращает анимацию на исходную<br>
            <b>animation-delay</b> - задержка перед началом анимации<br>
            <b>animation-fill-mode</b> - определяет какие свойства применятся после завершения анимации<br>
            <b>animation</b>: name duration function count direction delay mode;<br>
            <b>animation</b>: firstname 2s linear infinite alternate 0s forwards, secondname 5s ease infinite alternate 0s forwards;<br>
            <br>
            Сколько свойств - столько и значений transition-duration через запятую<br>
            <b>transition-duration</b> - время перехода<br>
            <b>transition-property</b> - содержит css свойства к которым будет применен переход<br>
            <b>transition-delay</b> - время задержки перехода<br>
            <b>transition-timing-function</b> - сценарий анимации<br>
            <b>общая запись</b>: transition: all 1s ease 0s; - transition: property duration function delay;<br>
            <b>transition</b>: padding 1s ease 0s, color 2s ease-in 0.5s;<br>

        //- Графика
        details
          summary Графика
          p.
            <b>JPEG/JPG</b> - растровый, оптимизируется хорошо, лучше для контента<br>
            <b>PNG</b> - растровый, оптимизируется плохо, может быть прозрачным, лучше для фона и элементов дизайна<br>
            <b>GIF</b> - растровый, до 256 цветов, видеоролик в формате изображения, оптимизируется хорошо<br>
            <b>SVG</b> - векторный, хорошо подходит для иконок и при масштабировании изображения<br>
            <b>WebP</b> - замена всех растровых форматов (прозрачность, анимация, хорошо оптимизируется)<br>
            <b>ico</b> - растровый, оптимизируется хорошо, может быть прозрачным, 16х16рх, для иконок<br>
            <b>link</b> rel="shortcut icon" href="favicon.ico"<br>
            <b>object</b> - работа с изображениями в контейнере как background в фоне<br>
            <b>object-fit</b>: fill; - управляет изображением внутри контейнера<br>
            <b>object-position</b>: center; - позиционирование изображения относительно родителя<br>

        a(href="https://www.youtube.com/@OnlineTutorialsYT") OnlineTutorialsYT
        a(href="https://www.youtube.com/@codeonly") Code Only
        a(href="https://www.youtube.com/playlist?list=PLM6XATa8CAG6IJvQBkrTTNZmpIcyS2Avk") Как сделать
        a(href="https://www.youtube.com/watch?v=kfOe-F64C_A&list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr&index=9") Уроки HTML CSS JS
        a(href="https://www.youtube.com/playlist?list=PLN2KCaMlZNdCBrVcXJXEO1iaTkZIMEA7R") Верстка сайта от 0 до 1
        a(href="https://www.w3.org/TR/cssom-1/") CSSOM
        
      //- Sass
      details
        summary.menu__submenu_lv1 Sass
        p.
          <em>Sass</em> - препроцессор, добавляет функционала в css<br>
          <em>SCSS</em> - синтаксис Sass похожий на синтаксис css<br>
          <em>Вложенность</em> - писать правила css внутрь других правил<br>
          <em>&</em> - подставляет вместо себя класс, внутри которого указан. Удобно для указания псевдоклассов и псевдо элементов<br> 
          <em>$var:80px;</em> - переменная var со значением 80 пикселей<br>
          <br>
          <em>Шаблоны</em>:<br>
          <b>%tpl</b> {параметры css} - задаём шаблон tpl<br>
          <b>@extend</b> %tpl; - вставляем в нужный блок правил css<br>
          либо<br>
          <b>.tpl</b> {параметры css} - задаём шаблон tpl<br>
          <b>@extend</b> .tpl; - вставляем в нужный блок правил css<br>
        pre
          code. 
            %message {
              <b>font-family</b>: sans-serif;
              <b>font-size</b>: 18px;
              <b>font-weight</b>: bold;
              <b>border</b>: 1px solid black;
              <b>padding</b>: 20px;
              <b>maigin</b>: 20px;
            }
            
            .success {
              <b>@extend %message</b>;
              <b>background-color</b>: green;
            }
            
            .warning {
              <b>@extend %message</b>;
              <b>background-color</b>: orange;
            }
            
            .error {
              <b>@extend %message</b>;
              <b>background-color</b>: red;
            }
        br
        p.
          <em>Миксины</em>:<br>
          @<b>mixin</b> exempl($var) {font-size: $var;} - объявляем миксин с переменной<br>
          @<b>include</b> exempl(100px); - вставляем в нужный блок правил css со значением поддерживает математические рассчеты<br>
          <br>
          <em>Комментарии</em>:<br>
          <b>/* */</b> - отображается и в файле scss и в css<br>
          <b>//</b> - отображается только в файле scss<br>
        br
        a(href="https://sass-scss.ru/") Manual

      //- JS
      details
        summary.menu__submenu_lv1 JS
        //- Синтаксис
        details
          summary Синтаксис
          p.
            &lt;<b>script</b>&gt;alert('Привет мир!') &lt;/<b>script</b>&gt; - вставить скрипт в html, либо<br>
            &lt;<b>script</b> src="/path/to/script.js"&gt; &lt;/<b>script</b>&gt; - подключить в html файл со скриптом.<br>
            <b>"use strict"</b> или <b>'use strict'</b> - строгий режим. Отключить невозможно.<br>
            Классы и модули строгий режим включают автоматически.<br>
            <br>
            Имена должны быть легко читаемые, camelCase, описательные и лаконичные.<br>
            <b>" "</b> или <b>' '</b> - это строка<br>
            <b>`${...} `</b> - вставить выражение в строку<br>
            <b>//</b> - однострочный комментарий<br>
            <b>/*...*/</b> - многострочный комментарий<br>
            <br>
            <dfn>Блок инструкций</dfn>:
          pre
            code.
              {
                console.log('Учим');
                console.log('JS');
              }
          br
          p.
            <dfn>Область видимости {}</dfn><br>
            <b>const KNOW_VAL = I know the value</b>; - константа с известным заранее значением пишем в верхнем регистре<br>
            <b>const donotKnow = I don't know the value</b>; - константа с неизвестным заранее значением<br>
            <b>var</b> - ключевое слово переменной, можно использовать до объявления.<br>
            область видимости в пределах модуля, <br>
            исключение: если объявлена в теле функции, то видна только в теле функции.<br>
            <br>
            <dfn>Комментируй</dfn>:<br>
              - общую архитектуру<br>
              - использование функций<br>
              - неочевидные решения<br>
              - важные детали<br>
            <em>Не комментируй что делает код.</em><br>
            <br>
          table
            caption <dfn>Значения</dfn>:
            thead
              th фиксированные значения
              th литералы
            tbody
              tr
                td литерал целого числа
                td 25
              tr
                td литерал дробного числа
                td 23.8
              tr
                td литерал строки
                td 'Javascript', "Javascript"
              tr
                td литерал массива
                td [], [15,7,89]
              tr
                td литерал объекта
                td {}, {name: 'Javascript', surname: 'Javascript'}
              tr
                td литерал регулярного выражения
                td (ab|bc)
              tr
                td значения констант
                td const MAX_VALUE = 17;
              tr
                td значения переменных
                td var section = 'JS';
          code let arr = ['HTML','CSS','JS'];
          br
          p.
            <dfn>Выражения</dfn> - комбинация значений переменных и операторов<br>
            <dfn>Ключевые слова</dfn> - определяет какое действие нужно выполнить<br>
            <br>
            <dfn>Автоматическое тестирование</dfn> - тесты пишуться отдельно:<br>
            по-разному запускают функции и сравнивают результат с ожидаемым.<br>
            <br>
            <dfn>спецификация состоит из</dfn>:
          pre
            code.
              <span>описываем функцию pow</span>
              describe ("pow", function(){
                <span>рабочий блок - описывает что делает</span>
                it ("возводит в степень n", function() {
                  <span>функция assert проверяет работу функции pow</span>
                  assert.equal(pow(2, 3), 8);
                });
              });
          br
          p.
            <dfn>Опциональная цепочка</dfn>:<br>
            Если перед <em>?.</em> undefined или null, то останавливает вычисление и возвращает undefined (без ошибки).<br>
            <em>?.</em> работает:<br>
              - с существующими переменными<br>
              - с функциями user1.admin?.(...)<br>
              - с квадратными скобками ?.[...]<br>
            <b>let user = {}</b>; - пользователь без адреса<br>
            <b>alert(user?.adress?.street)</b>; - undefined (без ошибки)<br>
            <b>delete user?.name</b> - удалит user.name если user существует<br>
            <b>obj?.prop</b> - вернёт obj.prop если obj есть, иначе undefined<br>
            <b>obj?.[prop]</b> - вернёт obj[prop] если obj есть, иначе undefined<br>
            <b>obj.method?.()</b> - вызовет obj.method если он есть, иначе undefined<br>
                  
        //- Types
        details
          summary Types
          p.
            <dfn>Тип</dfn>:<br>
            - набор характеристик значения,<br>
            - не у переменной, а у значения,<br>
            - присваиваится переменной вместе со значением.

          //- Object
          details
            summary Object
            pre
              code.
                Object {
                        property1: value1,
                        property2: value2
                      }

                let someObj = new Object();
                let someObj = {
                  key1: value1,
                };
                console.log(someObj.key);
                либо 
                console.log(someObj['key']);
            p.
              <b>someObj.key2 = value2</b>; - добавил в объект свойство (ключ: значение)<br>
              <b>delete someObj.key2</b>; - удалил из объекта свойство (ключ: значение)<br>
              <b>let obj = someObj</b>; - скопировал ссылку на объект в другую переменную<br>
              <b>let obj = Object.assign({}, someObj)</b>; - сделал дубликат объекта
            pre
              code.
                <span>проверка на наличие свойства</span>
                if ("key1" in someObj) {}
                <span>перебирает все свойства объекта</span>
                for (let key in object) {}
                let someObj = {
                  key1: value1,
                  <span>метод объекта</span>
                  someFunc: function () {},
                  <span>либо</span>
                  someFunc() {},
                };
            p.
              <dfn>Function</dfn> - это Object, но выведен отдельно для простоты определения функций<br>
              <dfn>Object.getOwnPropertySymbols(obj)</dfn> - получить все свойства объекта с ключами-символами<br>
              <dfn>Reflect.ownKeys(obj)</dfn> - возвращает все ключи объекта включая символьные<br>
          
          //- Примитивы
          details
            summary Примитивы
            p.
              <dfn>Примитивы</dfn> - это конкретные значения.<br>
              С помощью объектов-оберток (Number, String, ...) все примитивы кроме null и undefined
              имеют методы работы с ними.<br>
              <dfn>undefined</dfn> - неопределен, нет значения<br>
              <dfn>null</dfn> - переменная определена, значение - ничего<br>
              <dfn>boolean</dfn> - true/false<br>
              <dfn>number</dfn> - числа целые и с точкой<br>
              <dfn>infinity</dfn> (безконечность)<br>
              <dfn>NaN</dfn> (Not a Number)<br>
              <br>
              <dfn>Обычные числа в JS</dfn> - это числа с плавающей точкой двойной точности 
              (double precision floating point numbers), 64-битный формат IEEE-754.<br>
              <br>
              <dfn>BigInt</dfn> - числа позволяют работать с числами произвольной длины.<br>
              123e6 = 123 000 000 (e6 - это 6 нулей) 123e-6 = 0,000123<br>
              let someNum = 1000000; лучше так: let someNum = 1e6;<br>
              let num = 0.000001; - let num = 1e-6;<br>
              <br>
              <dfn>string</dfn> - строка ' ', " ", `${}`<br>
              "Какое-то \n предложение \n\t тут": \n - перевод строки, \t - табуляция (отступ), \ - экранирование<br>
              let someText = "text";<br>
            pre
              code.
                <span>длина строки</span>
                console.log(someText.length);

                <span>получаем символ строки</span>
                let firstSymbol = someText[0];

                <span>последний символ строки</span>
                let lastSymbol = someText[someText.length-1];

                <span>перебирает символы строки</span>
                for (const char of someText) {
                  console.log(char);
                }
            p.
              <dfn>someText.toUpperCase()</dfn> - все буквы большие<br>
              <dfn>someText.toLowerCase()</dfn> - все буквы маленькие<br>
              <dfn>someText.indexOf(substr, pos)</dfn> - ищет подстроку substr в строке someText,<br>
                pos - необязательный, символ с которого искать<br>
              <dfn>includes(substr, pos), startsWith(substr), endsWith(substr)</dfn> - проверяет на наличие, возвращает true или false<br>
              <dfn>slice(start, end)</dfn> - возвращает часть строки без end<br>
              <br>
              <dfn>Symbol</dfn> - идентификатор объекта<br>
              Два <b>Symbol("id")</b> с одинаковым "<b>id</b>" - это разные символы.<br>
              let id = Symbol.for("id") - читает символ "id" из глобального реестра,
              если символа нет, то создаст новый глобальный символ.<br>
              В глобальном реестре под одним именем один символ.<br>
              Используется как "скрытые" свойства объектов, т.к. символьное свойство не появится в for..in,
              например:<br>
              - Symbol.iterator - для итераторов,<br>
              - Symbol.toPrimitive - для преобразования объектов в примитивы<br>
            pre
              code.
                <span>создание символа</span>
                let id = Symbol("id");
                let user = {
                <span>не преобразуются в строку автоматически</span>
                  name: "Вася",
                <span>просто id:123 не работает,</span>
                <span>т.к. нужно значение переменной id,</span>
                <span>а не срока id.</span>
                  [id]: 123
                };

          //- typeof
          details
            summary typeof
            p.
              <em>typeof</em> - возвращает тип аргумента<br>
              <em>typeof 0</em> - number<br>
              <em>typeof true</em> - boolean<br>
              <em>typeof 'JS'</em> - string<br>
              <em>typeof undefined</em> - undefined<br>
              <em>typeof Math</em> - object<br>
              <em>typeof Symbol ('JS')</em> - symbol<br>
              <em>typeof null</em> - object - баг, это null<br>
              <em>typeof function() {}</em> - function - баг, это object<br>
              <em>typeof NaN</em> - number - Not a Number возвращает number<br>
          
          //- Приведение типов
          details
            summary Приведение типов
            p.
              Основные приведения: <dfn>строковое, численное и логическое.</dfn><br>
              <em>' ', 0, null, undefined, Nan, false</em> - приводятся Boolean() к false.<br>
              <em>Boolean('Hello')</em> - true<br>
              <em>Boolean(' ')</em> - true, пробел - это символ<br>
              <em>Boolean('0')</em> - true, '0' приводится к строке<br>
              <em>Boolean(0)</em> - false<br>
              <em>Boolean([])</em> - true<br>
              <em>Boolean({})</em> - true<br>
              <br>
              Операторы приводят значения null к 0, а undefined к NaN:<br>
              <em>null > 0</em> - false<br>
              <em>null >= 0</em> - true<br>
              <em>null == 0</em> - false<br>
              <em>undefined > 0</em> - false<br>
              <em>undefined == 0</em> - false<br>
              <br>
              <b>NaN</b> возвращает <b>false</b> при любых сравнениях.<br>
              При нестрогом равенстве null/undefined ни к чему не приводятся и равны только друг другу.<br>
              <br>
              <dfn>Строки и числа</dfn><br>
              <em>String(value);</em> - приведение к строке<br>
              <em>Number(value);</em> - приведение к числу<br>
              <em>Number("123");</em> - 123<br>
              <em>Number("123z");</em> - NaN<br>
              <em>Number(true);</em> - 1<br>
              <em>Number(false);</em> - 0<br>
              <em>+true</em> - 1<br>
              <em>+''</em> - 0<br>
              <em>null + 2</em> - number 2, null приводится к 0<br>
              <em>1 + '2'</em> - string 12<br>
              <em>'' + 1 + 0</em> - string 10<br>
              <em>'' - 1 + 0</em> - number -1, у строки есть только оператор сложения (конкатенация), поэтому -1 это число + 0<br>
              <em>'3' + '8'</em> - number 24<br>
              <em>4 + 10 + 'px'</em> - string 14px<br>
              <em>'px' + 4 + 10</em> - string px410<br>
              <em>'42' - 40</em> - number 2<br>
              <em>'42px' - 40</em> - NaN, px к числу не приводится<br>
              <em>undefined + 2</em> - NaN, undefined приводится к NaN<br>
              <em>parseInt()</em> - возвращает целое число, которое смогло получить из параметра<br>
              <em>parseFloat()</em>- возвращает число с точкой, которое смогло получить из параметра<br>
              <em>parseInt(str, base)</em> - преобразует строку в число,<br>
              base - система исчисления 2 =&lt;base =&lt;36, по умолчанию 10<br>
              <em>parseInt('0xff', 16)</em> - 255, дополнительное свойство - читает кодировки чисел<br>
              <em>parseInt('100px')</em> - 100<br>
              <em>parseFloat('12.5dfn')</em> - 12.5<br>
              <em>parseInt('a123')</em> - NaN, не смог прочитать ни одной цифры<br>
              <em>num.toString(base)</em> - преобразует число num в строку в виде системы исчисления base (от 2 до 32, по умолчанию 10)<br>
              Если вызывать метод на числе, то <b>123..toString(36)</b> или <b>(123).toString(36)</b><br>
              <em>num.toFixed(n)</em> - округляет до n знаков после запятой и возвращает результат в виде строки<br>
              <em>isNaN(value)</em> - преобразует в число и проверяет является ли оно NaN. NaN никогда не будет равно NaN.<br>
              <em>NaN === NaN</em> - false<br>
              <em>isFinite(value)</em> - преобразует в число и возвращает true если обычное число<br>
              <em>Object.is(a, b)</em> - идентично a === b<br>
              <em>Object.is(NaN, NaN)</em> === true<br>
              <em>Object.is(0, -0)</em> === false, технически 0 и -0 это разные значения<br>
              встроенный объект <em>Math</em> - математические операции над числами<br>
              <br>
              <dfn>Преобразование объектов в примитивы:</dfn><br>
              <b>obj[Symbol.toPrimitive](hint)</b> - вызывается метод объекта если он существует<br>
              Если <b>hint = string</b>, то вызывается <b>obj.toString()</b>,<br>если такого нет, то <b>obj.valueOf()</b><br>
              Если <b>hint = number или default</b>, то вызывается <b>obj.valueOf()</b>,<br>если такого нет, то <b>obj.toString()</b>.
            img(src="../img/js/Прототип.png" alt="")
        
        //- Регулярные выражения
        details
          summary Регулярные выражения
      
        //- Операторы
        details
          summary Операторы
          p.
            <em>операнд</em> - это то, к чему применяется оператор<br>
            <em>-х;</em> - унарный оператор - применяется к одному операнду<br>
            <em>у - х;</em> - бинарный оператор - применяется к двум операндам<br>
            <em>+операнд</em> - приведение к числу<br>
            <em>=</em> - оператор присваивания<br>
            <br>
            <dfn>все операторы возвращают значение</dfn><br>
            <em>+</em> сложения, если одно из слагаемых строка, то сумма - строка.<br>
            Остальные операторы дают число.<br>
            <em>-</em> вычитания<br>
            <em>*</em> умножения<br>
            <em>/</em> деления<br>
            <em>%</em> взятие остатка от деления (5%2 = 1)<br>
            <em>**</em> возведения в степень<br>
            <br>
            <dfn>Инкремент/декремент можно применять только к переменной.</dfn><br>
            <em>++</em> инкремент увеличивает на 1<br>
            <em>--</em> декремент уменьшает на 1<br>
            <em>counter++</em> постфиксная форма возвращает старое значение (до увеличения/уменьшения числа)<br>
            <em>++counter</em> префиксная форма возвращает новое значение<br>
            <br>
            <dfn>операторы == vs === (нестрогое vs строгое)</dfn><br>
            <em>==</em> сравнивает с приведением типов<br>
            <em>===</em> сравнивает без приведения типов<br>
          pre
            code.
              2 == '2' <span>true</span>
              2 === '2' <span>false</span>
              undefined == null <span>true</span>
              undefined === null <span>false</span>
              '0' == false    <span>true</span>
              '0' == 0        <span>true</span>
              0 == 0          <span>true</span>
              false == ''     <span>true</span>
              false == []     <span>true</span>
              false == {}     <span>false</span>
              '' == 0         <span>true</span>
              '' == []        <span>true</span>
              '' == {}        <span>false</span>
              '' == null      <span>false</span>
              {} == {}        <span>false</span>
              {} === {}       <span>false</span>
          p.
            == и === для объектов работают одинаково.<br>
            Два объекта равны если это один и тот же объект.
          pre
            code.
              2**2 = 4
              4**(1/2) = 2 <span>квадратный корень</span>
              8**(1/3) = 2 <span>кубический корень</span>
          br
          p.
            <dfn>Приоритет</dfn>:<br>
            <em>+</em> унарный плюс<br>
            <em>-</em> унарный минус<br>
            <em>**</em> возведение в степень<br>
            <em>*</em> умножение<br>
            <em>/</em> деление<br>
            <em>+</em> сложение<br>
            <em>-</em> вычитание<br>
            <em>=</em> присваивание<br>
            <br>
          p <dfn>Операторы сравнения</dfn>:<br>
          pre
            code.
              a&gt; b, a &lt;b    <span>больше/меньше</span>
              a&gt;= b, a <= b  <span>больше/меньше или равно</span>
              a == b          <span>равно</span>
              a === b         <span>строгое равно</span>
              a != b          <span>не равно</span>
              a !== b         <span>строгое не равно</span>
          p.
            Все операторы возвращают true или false.<br>
            Строки сравниваются посимвольно.<br>
            При сравнении разных типов - приведение к числу.<br>
          br
          p.
            <dfn>Оператор запятая</dfn> (,):<br>
            - позволяет вычислять несколько выражений, разделяя их запятой.<br>
            - каждое выражение выполняется, но возвращается результат только последнего.<br>
          pre
            code.
              let a = (1+2, 3+4);   <span>скобки важны, т.к. приоритет ниже чем =</span>
              alert(a);   <span>7-результат 3+4.</span>
          br
          p <dfn>Побитовые операторы</dfn>:
          pre
            code.
              &   <em>AND</em>                     <span>и</span>
              |   <em>OR</em>                      <span>или</span>
              ^   <em>XOR</em>                     <span>побитовое исключающие или</span>
              ~   <em>NOT</em>                     <span>не</span>
              <<  <em>LEFT SHIFT</em>              <span>левый сдвиг</span>
              >>  <em>RIGHT SHIFT</em>             <span>правый сдвиг</span>
              >>> <em>ZERO-FILL RIGHT SHIFT</em>   <span>правый сдвиг с заполнением нулями</span>
          p Побитовые операторы работают с 32-разрядными целыми числами (приводят к ним), на уровне их внутреннего двоичного представления.<br>
          br
          p.
            <dfn>Логические операторы</dfn>:<br>
            <em>||</em>  или - если любой из аргументов true, то вернет true, иначе false
          pre
            code.
              true  || true   <span>true</span>
              false || true   <span>true</span>
              true  || false  <span>true</span>
              false || false  <span>false</span>
          p.
            - цепочка или || возвращает первое истиное значение или последнее, если такое значение не найдено.<br>
            - цепочка вычисляется слева направо.<br>
          code undefined || null || 0  <span>результат 0</span>
          br
          p <em>&&</em>  и - если оба аргумента true, то вернет true, иначе false
          pre
            code.
              true  && true   <span>true</span>
              false && true   <span>false</span>
              true  && false  <span>false</span>
              false && false  <span>false</span>
          p.
            - цепочка или && возвращает первое ложное значение или или последнее, если такое значение не найдено.<br>
            - приоритет и && больше чем или ||.<br>
            <em>Или ||</em> спотыкается на правде, <em>и &&</em> спотыкается на лжи.<br>
          br
          p.
            <em>!</em> не  - принимает один аргумент, приводит к логическому типу и возвращает к противоположное значение.<br>
            <em>!true</em> - false<br>
            <em>!0</em> - true<br>
            <em>!"non-empty string"</em> - true<br>
            <em>!null</em> - false<br>
            <em>!операнд</em> - приведение к boolean<br>
            Приоритет <em>!</em> наивысший из всех логических операторов.<br>
          br
          p <em>??</em> - оператор объединения с null, возвращает первое определённое значение, если оно отличается от null или undefined.
          pre
            code.
              let height = 0;
              height || 100 <span>вернет 100</span> 
              height ?? 100 <span>вернет 0</span>
              a ?? b <span>результат a, если а определено, иначе b</span>
              let user;
              alert(user??"Аноним");  <span>Аноним</span>
          p Запрещено использовать оператор ?? вместе с && и || без явного указания приоритета скобками.
          br
          p.
            <em>...</em> - троеточие, обозначает оператор "остаточные параметры" если нахидотся в конце списка аргументов функции либо оператор "расширения".<br>
            - оператор "остаточные параметры" используется, чтобы создавать функции с неопределённым числом аргументов, собирает оставшиеся параметры в массив:
          code let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Repablic"];
          p.
            - оператор "расширения" позволяет вставить массив в функцию, расширяя перебираемый объект arr в список аргументов (f...arr);<br>
            оператор "расширения" работает только с итерируемыми объектами.

        //- Инструкции
        details
          summary Инструкции
          p <dfn>Условное ветвление</dfn>:
          pre
            code.
              if (...) {          
                ...             
              } else if (...) {    
                ...
              }
          p.
            - вычисляет условие в скобках<br>
            - приводит к логическому типу<br>
            - если условие true, то выполняет блок кода<br>
            Блоков else и else if может быть сколько угодно, а может и не быть.<br>
          pre
            code.
              if () {}
              if () {} else {}
              if () {} else if () {} else {}

              switch(x) {
                case 'value1':
                  ...
                  break
                case 'value2':
                  ...
                  break
                default:
                  ...
                break
              }
          p.
            - switch заменяет несколько if.<br>
            - switch имеет один или несколько блоков case.<br>
            - проверка равенства всегда строгая.<br>
            - если нет break, то выполнение пойдет по следующим case без проверки.<br>
          br
          p.
            ? - тернарный оператор (три аргумента)<br>
            let result = условие <b>?</b> значение1 <b>:</b> значение2;<br>
            если условие true, то значение1, иначе значение2<br>
            break/continue использовать нельзя<br>
            () <b>?</b> valueIfTrue <b>:</b> valueIfFalse; тоже самое <b>if () {} else {}</b><br>
          br
          p <dfn>Циклы</dfn>:
          pre
            code.
              while (...) {
                <span>тело цикла - выполняется пока условие true</span>
              }
              while () {} - <span>если процедура не одна, то {}.
              Если процедура одна: while () procedure;</span>

              do {
                <span>тело цикла</span>
              } while (...);
          p.
            - выполнить и проверить условие<br>
            - если условие true, то выполнить и проверить условие ещё раз<br>
          pre
            code.
              for (начало; условаие; шаг) {
                <span>тело цикла</span>
              }
          p.
            - выполнить начало<br>
            - посторять пока условие true:<br>
            если условие true, то выполнить тело<br>
            выполнить шаг и проверить условие<br>
            Любая часть может быть пропущена.<br>
          pre
            code.
              for (;;) {
                <span>будет выполняться вечно</span>
              }

              for (key in object) {
                <span>тело цикла выполняется для каждого свойства объекта</span>
              }
          p.
            <em>for..in</em> - для перебора свойств объекта<br>
            <em>for..of</em> - для перебора значений массива<br>
          pre
            code.
              let fruits = ["Яблоко", "Апельсин", "Слива"];
              for (let fruit of fruits) {
                alert(fruit);
              }
          p.
              - проходит по значениям каждого элемента массива<br>
              - не предоставляет доступа к номеру элемента, только к его значению<br>
          br
          p <dfn>Метка</dfn> - точка местоположения в коде:
          pre
            code.
              outer: for (...) {
                for (...) {
                  if (!input) break outer;
                }
              }
          p.
            outer: - метка-идентификатор с двоеточием<br>
            break/continue поддерживает метки

        //- Функция
        details
          summary Функция
          img(src="../img/js/Синтаксис.png" alt="")
          <br>
          p.
            <dfn>Функция</dfn> - это значение, представляющее действие.<br>
            Одна функция - одно действие.
          pre
            code.
              function sayHi(аргументы, через, запятую) {
                <span>тело функции, код</span>
              }
          p.
            <em>sayHi</em> - обращение к переменной, содержащей код функции.<br>
            <em>sayHi()</em> - вызываем код функции на выполнение.<br>
          br
          p.
            Можно передать внутрь функции любую информацию через аргументы функции.<br>
            Переданные через аргументы значения копируются в локальные переменные (параметры) и используются в теле функции.<br>
            Функция всегда получает только копию значения.<br>
            Если аргумент не указан, то его значением становится undefined.<br>
          pre
            code.
              function showMessage(from, text = "текст не добавлен") {
                alert(from + ": " + text);  <span>"текст не добавлен" - текст по умолчанию.</span>
              } 
          p.
            <dfn>return</dfn> - функция останавливается и возвращает значение.<br>
            Результат функции с пустым retutn или без него - undefined.<br>
            <br>
            Функция внутри другой функции называется <dfn>вложенной</dfn>.<br>
            <br>
            <dfn>Рекурсия</dfn> - функция вызывает саму себя. Глубина рекурсии - количество вызовов самой себя.<br>
            <br>
            <dfn>Колбэк функция</dfn> - функция передаваемая параметром в другую функцию и вызываемая внутри другой функции.<br>
          pre
            code.
              function func1(param1, param2) {}
              function func2(param3) {}
              function func3(param1, param2) {
                func2(func1(param1, param2));
              }
              func3(param1, param2); <span>- выдаст результат работы func1 и func2</span>
          p.
            Функция - это объект, его свойства:<br>
            - <b>name</b> - имя функции<br>
            - <b>length</b> - количество аргументов в объявлении функции, троеточие (остаточные аргументы) не считаються.<br>
            <br>
            Функция может содержать другие функции в своих свойствах.<br>
            <br>
            <em>Переменные</em> - это не свойства функции и не наоборот - это два параллельных мира.<br>
            <br>
            Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.<br>
            Arguments не поддерживает методы массивов и всегда содержит все аргументы функции - мы не можем получить их часть.<br>
            <br>
            <dfn>Function Declaration</dfn> (Объявление функций) считывается интерпритатором когда создаётся лексическое окуржение,
            в котором объявлена, hosting работает.<br>
            При запуске функций, для неё создаётся лексическое окружение для хранения локальных переменных и параметров вызова.<br>
          pre
            code.
              function sayHi(аргументы, через, запятую) {
                <span>тело, код функции</span>
              }
          <br>
          p <dfn>Function Expression</dfn> (Функциональное выражение) считывается когда выполнение доходит до него, hosting не работает.
          pre
            code.
              let sayHi = function() {
                alert("Привет");
              }
          p.
            <dfn>Named Function Expression NFE</dfn> (именованное функциональное выражение) - когда у функционального выражения есть имя.<br>
            Имя функционального выражения не доступно за пределами функции и позволяет функции ссылаться на себя (рекурсивные вызовы).
          pre
            code.
              let sayHi = function func(who) {
                alert(`Hello, ${who}`);
              }
          p.
            <dfn>IIFE</dfn> - Immediate Invoked Function Expression<br>
            Функциональное выражение моментального выполнения.<br>
            Позволяет оборачивать функции для моментального выполнения, передавая необходимые параметры.<br>
            Используются для создания локальной области видимости (scope) с замыканием на внешнюю переменную.<br>
            Пути создания IIFE:<br>
          pre
            code.
              (function() {
                alert("Скобки вокруг функции");
              })();

              (function() {
                alert("Скобки вокруг всего");
              }());

              !function() {
                alert("Выражение начинается с логического оператора NOT");
              }();

              +function() {
                alert("Выражение начинается с унарного плюса");
              }();
          br
          p.
            <dfn>=> Arrow functions</dfn> (Стрелочные функции):<br>
            - не имееют this. При обращении к this, его значение берётся снаружи.<br>
            - не имеют arguments. Arguments внешней функции.<br>
            - не могут быть вызваны с new. Не могут быть конструктором.<br>
            - нет super.<br>
            - предназначены для небольшого кода без контекста, выполняемого в контексте текущего кода.<br>
            - func.bind(this) создаёт связанную версию функции, а => ничего не привязывает, т.к. у неё нет this.<br>
          pre
            code.
              let sum = (a, b) => a + b;
              <span>или</span>
              let sum = (a, b) => {
                let result = a + b;
                return result;
              };        
          p при фигурных скобках для возврата значения нужно явно вызвать return.
          <br>
          p.
            <dfn>new Function</dfn><br>
            При создании функции через new Function в её [[Environment]] записывается ссылка не на внешнее лексическое окружение,
            в котором она была создана, а на глобальное.<br>
            Поэтому у неё доступ только к глобальным перменным.<br>
            Используют new Function когда код функции заранее не известен, а будет определен только в процессе выполнения.<br>
          pre
            code.
              let func = new Function([arg1, arg2, ...argN], functionBody);
              let sum = new Function('a', 'b', return a+b);
          p Можно получить код функции с сервера:
          pre
            code.
              let str = ...код полученный с сервера динамически...
              let func = new Function(str);
              func();
          p.
            Переданные явно глобальные аргументы не вызывают проблем у минификаторов.<br>
            <br>
            <dfn>Минификатор</dfn> - специальная программа, которая уменьшает размер кода, удаляя комментарии,
            лишние пробелы, а локальным переменным даются укороченные имена.<br>
            <br>
            <dfn>Функции-конструкторы</dfn> (Конструкторы):<br>
            - имя с заглавной буквы<br>
            - вызывается при помощи оператора new<br>
            - используется для повторного создания однотипных объектов<br>
            При вызове создаёт пустой this в начале и возвращает заполненный (свойства и их значения) в конце:<br>
            <em>this = {};</em> явно добавляет свойства к this<br>
            <em>return this;</em> неявно<br>
          pre
            code.
              function User(name) {             
                this.name = name;            
                this.isAdmin = false;
              }                                
              let user = new User("Вася");
          p выполняет роль класса, сама функция ничего не возвращает
          pre
            code.
              function Cat(color, name) {      
                this.color = color;
                this.name = name;
              }
              const cat = new Cat('black', 'Кот');
              console.log(cat);      <span>Cat {color:'black', name: 'Кот'}</span>
              const cat = Cat();     <span>присвоит cat undefined, т.к. Cat() ничего не возвращает</span>
              const cat = new Cat(); <span>присвоит cat - Cat{color: undefined, name: undefined}, т.к. нет входных аргументов</span>

              function myNew(constractor, ...args) {   <span>создаём своё ключевое слово new</span>
                const obj = {};                      <span>new всегда возвращает новый объект</span>
                Object.setPrototypeOf(obj.constractor.prototype)
                return constractor.apply(obj, args) || obj;
              }
          p.
            - устанавливаем в поле prototype объекта переданную во входных аргументах constructor-ссылку, теперь constructor прототип obj.<br>
            - теперь obj имеет доступ ко всем полям constructor, выполняет функцию-конструктор в контексте obj с входными аргументами args
            или в случае ошибки только сам obj.<br>
            const cat = myNew(Cat, 'black', 'Кот');
            console.log(cat);   <span>Cat {color:'black', name:'Кот'}</span>
          p выполняем своё ключевое слово myNew c constructor в контексте Cat и входными аргументами 'black' и 'Кот'.
          pre
            code.
              function SomeFuncCon(name, age) {
                this.name = name;
                this.age = age;
              }
              <span>создаю конструктором новый объект Вася и вывожу в консоль</span>
              console.log(new SomeFuncCon('Vasya', 30));
          p.
            Планирование вызова функции:<br>
            <em>setTimeout</em>(функция или код, задержка, параметр, параметр) - вызывает функцию один раз через какое-то время<br>
            <em>setInterval</em>(функция или код, задержка, параметр, параметр) - вызывает функцию много раз через интервал времени<br>
            <br>
          code let timeId = setTimeout(someFunc, param, param);
          p.
            <em>setInterval(timeId)</em>; - прерывание setTimeout.<br>
            Если setTimeout вызывать из setTimeout (рекурсия), то получим setInterval<br>
            clearInterval тоже самое что и setInterval<br>
            <br>
            <dfn>Контекст</dfn> - объект, который передают при вызове и который указывает с каким объектом работает вызываемая функция.<br>
            Ключевое слово function создаёт свой контекст, к которому нужно привязать объект (this), с которым работает функция.<br>
            <em>this</em> - обозначает текущий объект<br>
            <br>
            <dfn>Контекст выполнения</dfn> - специальная внутренняя структура данных, которая содержит информацию о вызове функции:<br>
            - место в коде, где находится итерпритатор<br>
            - локальные переменные функции<br>
            - значение this<br>
            - прочая служебная информация.<br>
            <br>
            <dfn>Привязка контекста: bind</dfn><br>
          code person.knows.bind(john, 'ничего не', 'Джон');
          p.
            в отличии от call и apply, bind не вызывает метод knows на выполнение, 
            а возвращает новый объект, который нужно вызвать как функцию (),
            чтобы передать вызов в knows и установить this = john.<br>
            Для выполнения пишем так:<br>
          code person.knows.bind(john, 'ничего не', 'Джон')();
          p либо так
          pre
            code.
              const bound = person.knows.bind(john, 'ничего не', 'Джон');
              bound();
          p.
            При передаче методов объекта в качестве колбэков,
            например в setTimeout, метод передаётся отдельно от объекта, происходит потеря this.<br>
            Встроенный в функции метод bind позволяет зафиксировать this.<br>
            Частичная или частично применённая функция - это функция с привязанными аргументами.<br>
          code let bound = func.bind(context, [arg1], [arg2], ...);
          br
          p <dfn>Явная привязка контекста</dfn>:
          pre
            code.
              function logThis() {
                console.log(this)
              }
              const obj = {num: 42};
              logThis.apply(obj); {num: 42}
              logThis.call(obj); {num: 42}
              logThis.bind(obj)(); {num: 42}
          br
          p <dfn>Неявная привязка контекста</dfn>:
          pre
            code.
              const animal = {
                legs: 4,
                  logThis: function() {
                    console.log(this);
                }
              }
              animal.logThis();  {legs: 4, logThis:[Function: logThis]}
          p.
            в контекст привязался тот объект, в котором была вызвана функция.<br>
            <br>
            <dfn>Методы</dfn> - это функции как свойства объекта.<br>
            Методы ссылаются на объект через this для доступа к информации внутри объекта.<br>
            Значение this вычисляется во время выполнения кода (когда функция вызвана) и зависит от контекста.<br>
            Функция может быть скопирована между объектами (из одного объекта в другой).<br>
            Значением this во время вызова синтаксисом "метода" (object.method()) является объект перед точкой.<br>
            У стрелочных функций нет this, его значение берётся из внешей функции.<br>
            Для работы вызовов типа user.hi(), точка возвращает не саму функцию, 
            а специальное значение "ссылочного типа" - Reference Type.<br>
            <br>
            <dfn>Значение ссылочного типа</dfn> - это "триплет", комбинация из трёх значений:<br>
            <em>base</em> - объект<br>
            <em>name</em> - имя свойства объекта<br>
            <em>strict</em> - режим исполнения (true если <b>'use strict</b>')<br>
            Когда скобки () применяются к значению ссылочного типа (вызов функции), 
            они получают полную информацию об объекте и его методе, и могут подставить правильный <b>this</b>.<br>
            Ссылочный тип - исключительно внутренний, промежуточный, используется чтобы передать информацию от точки до вызывающих скобок().<br>
            При любой другой операции, например присваении <b>hi = user.hi</b>;
            ссылочный тип заменяется на само значение <b>user.hi</b> (функцию), и дальше работа только с ней - без this.<br>
            <br>
            <dfn>Замыкание</dfn> - это функция, которая помнит лексическое окружение где она была создана (свои внешние переменные)
            и может получить к нему доступ с помощью скрытого свойства [[Environment]].<br>
            Все функции, кроме newFunction(), изначально являются замыканиями.<br>
          pre
            code.
              function sayHelloTo(name) {
                const message = 'Helo' + name;
                return function() {   <span>анонимная функция</span>
                  console.log(message);
                }
              }
              <span>helloToElena ссылается на анонимную функцию</span>
              const helloToElena = sayHelloTo('Elena');

              <span>helloToIgor ссылается на анонимную функцию</span>
              const helloToIgor = sayHelloTo('Igor');  

              helloToElena();      <span>Hello Elena</span>
              helloToIgor();       <span>Hello Igor</span>

              const fib = [1, 2, 3, 5, 8, 13];
              for (var i=0; i &lt;fib.length; i++) {
                setTimeout(function() {
                  console.log(`fib[${j}] = ${fib[j]}`)
                }, 1500)
              }
          p.
            через 1,5 секунды должен вывести индекс = значение, 
            но не работает т.к. цикл for за 1,5 секунды успевает пробежать по всей длине массива и var i уже имеет значение 6.<br>
            Только потом срабатывает setTimeout.<br>
            <br>
            <dfn>Исправление через область видимости</dfn>:<br>
            const fib = [1, 2, 3, 5, 8, 13];
            for (let i=0; i &lt;fib.length; i++) {
              setTimeout(function() {
                console.log(`fib[${j}] = ${fib[j]}`)
              }, 1500)
            }
          p.
            поменять var на let, т.к. let действует только в области видимости цикла.<br>
            <br>
            <dfn>Исправление через замыкание</dfn>:<br>
          pre
            code.
              const fib = [1, 2, 3, 5, 8, 13];
              for (var i=0; i &lt;fib.length; i++) {
              (function(j) {
                setTimeout(function() {
                    console.log(`fib[${j}] = ${fib[j]}`)
                  }, 1500)
                })(i)
              }
          p обернуть setTimeoutв функцию и через ()()(IIFE) замкнуть функцию на var i.
          pre
            code.
              let someObj = {
                key1: value1,

                someFunc() {
                  function anotherFunc() {console.log(`${this.key1}`)}

                  anotherFunc();
                }
              };
          p.
            <b>someObj.someFunc();</b> - ошибка, anotherFunc() создает свою область видимости и замыкается (использует)
            область видимости someFunc(), this ищет в области видимости someFunc() свойство key1.
          pre
            code.
              let someObj = {
                key1: value1,

                someFunc() {
                  let someVar = () => console.log(`${this.key1}`)

                  someVar();
                }
              };
          p.
            <b>someObj.someFunc();</b> - стрелочная функция не создает свою область видимости и пользуется всем что есть у
            someFunc(), т.е. области видимости someFunc() и someObj.<br>
            <b>this</b> находит свойство key1 в области видимости someObj<br>
            <br>
            <dfn>Перенапрвление вызова</dfn> (call forwarding) - передача всех аргументов вместе с контекстом другой функции:<br>
            <b>call и apply</b> - встроенные методы функции, позволяют вызывать функцию, явно устанавливая this.<br>
            Одна разница:<br>
            - оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.<br>
            - apply принимает только псевдомассив args.<br>
          pre
            code.
              const person = {
                surname: 'Старк',
                knows: function(what, name) {
                  console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
                }
              }    <span>функция работает в контексте (this) объекта person</span>

              const john = {surname: 'Сноу'}
              person.knows('всё', 'Бран')      <span>Ты всё знаешь Бран Старк</span>
          p.
            чтобы перенаправить вызов, функцию knows не вызываем (), а обращаемся к ней как к объекту
            и вызываем её метод call(), в который передаём объект (this), в контексте которого она
            должна отработать и аргументы самой функции knows:<br>
          pre
            code.
              <span>Ты ничего не знаешь, Джон Сноу.</span>
              person.knows.call(john, 'ничего не', 'Джон');

              <span>аргументы в виде массива.</span>
              person.knows.apply(john, ['ничего не', 'Джон']);

              <span>ES-6 синтаксис - оператор спред (...) разворачивает массив.</span>
              person.knows.call(john, ...['ничего не', 'Джон']);
          br
          p <dfn>Заимствование метода</dfn>:
          pre
            code.
              <span>функция делает ключ-строку из принимаемых аргументов</span>
              function hash (args) {
                return args[0] + ',' + args[1];
              }
              <span>позаимствовали join у массива</span>
              function hash (args) {
                alert([].join.call(args));
              }
        
        //- Event loop
        details
          summary Event loop
          <dfn>Event loop</dfn> - событийный цикл (бесконечный цикл):
          img(src="../img/js/EventLoop.png" alt="")
          p.
            1. Выполнить старейшую задачу из очереди макрозадач.<br>
            <b>setTimeout(f)</b> с нулевой задержкой добавляет в очередь новую макрозадачу.<br>
            2. Выполнить старейшую задачу из очереди микрозадач.<br>
            <b>queuemicrotask(f)</b> - добавляет в очередь новую микрозадачу.<br>
            Обработчики промисов в микрозадачах.<br>
            3. Отрисовать изменения страницы (если есть).<br>
            4. Если очередь макрозадач пуста - подождать, когда появится макрозадача.<br>
            Сразу после каждой макрозадачи: все микрозадачи -> события -> рендеринг -> макрозадача<br>
            <br>
            <dfn>Очередь</dfn> - (queue) добавляем в конец, извлекаем с начала.<br>
            <dfn>Стек</dfn> - (stack) новые элементы всегда добавляются или удаляются с конца.<br>
            <br>
            <dfn>Web workers</dfn>:<br>
            - способ исполнить код в параллельном потоке<br>
            - обмениваются сообщениями с основным процессом<br>
            - имеют свои переменные и свой событийный цикл<br>
            - позволяют задействовать несколько ядер процессора сразу<br>
            - не имеют доступа к DOM<br>
            - используются для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.<br>

        //- Environment
        details
          summary Environment
          p.
            <dfn>Переменная</dfn> - это именованное хранилище для данных, которое является свойством Environment Record.<br>
            <dfn>Переменные</dfn> - это ссылки на значения, объекты или на другие переменные.<br>
            Объекты храняться и копируются по ссылке.<br>
            Создание переменной происходит в два этапа:<br>
            - <dfn>declaration</dfn> (объявление)<br>
            - <dfn>definition</dfn> (определение), <dfn>initalization</dfn> (инициализация)<br>
            Имя переменной может содержать буквы, цифры, символы $ и _.<br>
            Первый символ в имени не цифра. Регистр имеет значение.<br>
            Переменная не объявлена - is not defined.<br>
            Переменная не определена - undefined.<br>
            <br>
            <dfn>hoisting</dfn> (всплытие, поднятие) - это механизм в JS, в котором объявления переменных и функций, 
            передвигаются вверх своей области видимости (локальной или глобальной) перед тем как код будет выполнен и мы
            можем обратиться к ним ещё до их определения.<br>
            hoisting передвигает только объявления функций и переменных, их определения остаются на своих местах.<br>
            <br>
            <dfn>LexicalEnvironment</dfn> - объект лексического окружения состоит из двух частей:<br>
            <dfn>Environment Record</dfn> - (лексическое окружение) объект, в котором как свойства храняться все локальные переменные, 
            значение this и т.д.<br>
            Это структура, состоящая из лексических областей видимости, 
            которая определяет связи между идентификаторами переменных и функций с их определениями 
            на основе вложенности лексических областей видимости.<br>
          pre
            code.
              function funcA() {
                let a = 1;
                function funcB() {
                  let b = 2;
                  function funcC() {
                    let c = 3;
                    console.log(a, b, c);
                  }
                }
              }
          p.
            Один вызов функции - одно лексическое окружение.<br>
            Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.<br>
            Для цикла у каждой итерации свой отдельное лексическое окружение.<br>
            Из-за того, что у блока есть собственное лексическое окружение, код снаружи не видит переменные этого блока.<br>
            При обращении к переменной - сначала ищем во внутреннем лексическом окружении, затем во внешнем, и так до глобального.<br>
            Функция получает последнее значение внешних переменных.<br>
            Объект лексического окружения существует пока есть хотя бы одна вложенная функция, которая ссылается на него.<br>
            <br>
            <dfn>Scope</dfn> - (лексическая область видимости) ссылка на внешнее лексическое окружение, 
            т.е. это область видимости, которая указывает на доступность переменных:<br>
            - глобальная область видимости - window или document в браузере<br>
            - локальная область видимости  - в рамках одной функции или блока кода<br>
            <br>
            Это область видимости, которая определена во время разбора кода на лексемы 
            и формируется исходя из того, где переменные, функции и инструкции размещены в коде.<br>
            <br>
            лексемы:<br>
            <b>var a = 2;</b><br>
            <em>var</em> - объявление переменной<br>
            <em>a</em> - идентификатор (имя) переменной<br>
            <em>=</em> - оператор присваивания<br>
            <em>2</em> - число<br>
            <em>;</em> - конец инструкции<br>
            <dfn>let</dfn> - изменяемая впеременная, область видимости блок, hoisting не работает.<br>
            <dfn>const</dfn> - неизеняемая переменная, область видимости блок, hoisting не работает.<br>
            Константы с заглавными буквами для заранее известных значений.<br>
            Константы маленькими буквами для значений вычисляемых и присваиваемых в процессе выполнения.<br>
            <dfn>var</dfn> - изменяемая переменная, область видимости функция или скрипт, hoisting работает.<br>
          pre
            code.
              let a = 'variable a'; <span>- global scope</span>
              let b = 'variable b';
              {
                a = 'New variable A'; <span>- a from global scope</span>
                let b = 'Local Variable B'; <span>- b from local scope</span>
                console.log('A:', a); <span>- New Variable A</span>
                console.log('B:', b); <span>- Local Variable B</span>
                console.log('C:', c); <span>- ReferenceError</span>
                let c = 'Something';
              }
              console.log('A:', a); <span>- New Variable A</span>
              console.log('B:', b); <span>- Local Variable B</span>

        //- Коллекции                           
        details
          summary Коллекции
          p.
            Объекты для хранения именованных коллекций.<br>
            <dfn>Массив</dfn> - (Array), подвид объектов для хранения упорядоченых коллекций,
            расширяют объекты методами для работы с упорядоченными коллекциями данных и свойством <b>length</b>.<br>
            Получить доступ к элементу <b>arr[0]</b> - это синтаксис доступа по ключу (<b>obj[key]</b>),
            где в роли obj у нас arr, а key - числовой индекс.<br>
            Создание пустого массива: <br>
          pre
            code.
              let arr = new Array();
              <span>либо</span>
              let arr = [];
              let arr = newArray(2); <span>- создать пустой массив на 2 пустых элемента.</span>
              
              let fruins = ["Яблоко", "Апельсин", "Слива"];
              fruits[0] <span>- получить элемент</span>
              fruins[2] = 'Груша'; <span>- заменить элемент с индеком 2</span>
              fruins[3] = 'Лимон'; <span>- добывить новый элемент</span>
              fruins.length <span>- общее число элементов массива</span>
              alert(fruins); <span>- вывести массив целиком</span>
          p.
            В массиве могут храниться элементы любого типа.<br>
            <br>
            <dfn>Массив</dfn> - это объект, который намного быстрее объекта если работать с массивом ни как с объектом, 
            а как с упорядоченной коллекцией:<br>
            - свойства именовать цифрами (индексы - числа, а не строки)<br>
            - не создавать дыр, т.е. не оставлять свойства без значений (0: "Вася", 1: , 2: "Петя")<br>
            - не заполнять массив значениями в обратном порядке (сконца)<br>
          pre
            code.
              let arr = new Array();
              let arr = [];
              let arr = [el1, el2, el3,]; <span>- элементом массива может быть что угодно.</span>
              arr[1] <span>- обращение к элементу, индексация с 0</span>
              arr.length <span>- длина массива</span>
              let arrNew = arr; <span>- скопировал ссылку на массив</span>
          br
          p.
            масcивы могут работать и как очередь и как стек:<br>
            <em>push()</em> - добавляет в конец массива - выполняется быстро<br>
            <em>pop()</em> - удаляет элемент вконце массива - выполняется быстро<br>
            <em>shift()</em> - удаляет элемент вначале массива - выполняется медленно<br>
            <em>unshift()</em> - добавляет элемент вначало массива - выполняется медленно<br>
            <em>delete arr[1]</em>; - удаление конкретного элемента<br>
            <em>arr.splice(pos, count)</em>; - начиная с позиции pos удалить count элементов<br>
            (pos - считаем сначала, -pos - считаем сконца)
          pre
            code.
              <span>начиная с позиции pos удалить count элементов и вернуть удаленные элементы в переменную</span>
              let rm = arr.splice(pos, count);

              <span>начиная с позиции pos заменить count элементов на elem</span>
              arr.splice(pos, count, elem);

              <span>начиная с позиции pos добавить elem1, elem2</span>
              arr.splice(pos, 0, eldfn1, eldfn2); -

              <span>копируем весь массив</span>
              let arrNew = arr.slice();

              <span>копируем массив с позиции 1 до позиции 2, не включая позицию 2</span>
              let arrNew = arr.slice(1, 2);

              <span>копирует весь массив и добавляет в конец нового массива elem</span>
              let arrNew = arr.concat(elem);

              <span>ищет elem с индекса from, возвращает индекс найденого item или -1</span>
              arr.indexOf(elem, from);

              <span>возвращает индекс найденого elem или -1, ищет справа налево</span>
              arr.lastIndexOf(elem);

              <span>ищет elem с индекса from, возвращает true  или false</span>
              arr.includes(elem, from);
          br
          p.
            Для массивов, элементы которых объекты:<br>
            <em>find()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
            если условие совпало, то прерывает поиск и возвращает соответствующее свойство либо undefined
          pre
            code.
              let res = arr.find(function(elem, index, array) {
                return elem.prop === 18;
              });
              <span>либо</span>
              let res = arr.find(elem => elem.prop === 18);
          p.
            <em>findIndex()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
            если условие совпало, то прерывает поиск и возвращает соответствующей индекс либо undefined
          code let res = arr.findIndex(elem => elem.prop === 18);
          p.
            <em>filter()</em> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,<br>
            если условие совпало, то продолжает поиск и возвращает массив совпавших свойств либо undefined
          code let res = arr.filter(elem => elem.prop&gt;= 18);
          p.
            <em>sort(fn)</em> - сортирует массив, меняя в нем порядок элементов по алгоритму функции fn,<br>
            если fn не указана, то по возрастанию
          pre
            code.
              function compareNum(a, b) {
                console.log(`Сравниваем ${a} и ${b}`);
                if (a&gt; b) return 1;
                if (a == b) return 0;
                if (a &lt;b) return -1;
              }
              console.log(arr.sort(compareNum));
              <span>либо</span>
              function compareNum(a, b) {
                console.log(`Сравниваем ${a} и ${b}`);
                return a - b;
              }
              console.log(arr.sort(compareNum));
              <span>либо</span>
              console.log(arr.sort((a, b) => a - b));
          p.
            <em>reverse()</em> - меняет порядок елементов в массиве на обратный <b>arr.reverse()</b>;
            <br>
            <em>map()</em> - перебирает элементы массива, применяет функцию к каждому элементу и возвращает 
            на его место в массиве результат работы функции.<br>
          code let res = arr.map(function(eldfn, index, array) {});
          p.
            <em>split()</em> - преобразовывает строку в массив по указанному разделителю
          pre
            code.
              let str = 'eldfn1,eldfn2,eldfn3';
              let arr = str.split(',', limit);
          p.
            limit ограничивает количество элементов, которые попадут в массив если не указывать, то все
            <br>
            <em>join()</em> - преобразовывает массив в строку с указанным разделителем
          pre
            code.
              let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
              let res =  arr.join(',');
              <span>либо</span>
              let arr = ['eldfn1', 'eldfn2', 'eldfn3'];
              let res =  String(arr); - разделитель всегда запятая
          p.
            <b>Array.isArray(arr)</b> - возвращает true если arr это массив, иначе false
            <br>  
            Циклы для перебора элементов массива:<br>
          code for (i=0; i &lt;arr.length; i++) и for (let var of arr) {}
          p <em>forEach()</em> - метод перебора массива, применяет функцию для каждого элемента массива
          pre
            code.
              arr.foreach(function(eldfn, index, array) {
                console.log(`${eldfn} находится на ${index} позиции в ${array}`);
              });
              <span>либо</span>
              arr.forEach((eldfn, index, array) => {
                console.log(`${eldfn} находится на ${index} позиции в ${array}`);
              });
              <span>либо</span>
              let func = function(eldfn, index, array) {
                console.log(`${eldfn} находится на ${index} позиции в ${array}`);
              };
              arr.forEach(func);
          p.
            <em>reduce()</em> - перебирает элементы массива и вычисляет значение на основе всего массива<br>
          pre
            code.
              let value = arr.reduce(
                function(
                  previousValue, eldfn, index, array
                ) {},
              [initial]);
          br
          p.
            <em>previousValue</em> - результат предыдущего вызова этой функции, равен initial при первом вызове функции (если initial передан),<br>
            <em>elem</em> - очередной элемент массива<br>
            <em>index</em> - его индекс<br>
            <em>array</em> - сам массив<br>
            <br>
            <dfn>reduceRight()</dfn> - так же как и reduce(), но справа на лево<br>
          br
          img(src="../img/js/Methods.jpg" alt="")
          br
          p.
            <dfn>Псевдомассив</dfn> - объекты, у которых есть индексы и свойство length,
            могут иметь другие свойства и методы, но у них нет встроенных методов массива.<br>
            <b>Array.from(obj[,mapFn, thisArg])</b> - создаёт Array из итерируемого объекта
            или псевдомассива obj, и затем к нему можно применить методы массивов.<br>
            Необязательные аргументы mapFn и thisArg позволяют применять функцию с 
            задаваемым контекстом к каждому элементу.<br>
            <br>
            <dfn>Итерируемые объекты</dfn> - объекты, которые реализуют метод <b>Symbol.iterator</b>,
            и их можно использовать в цикле for..of.<br>
            Результат вызова <b>obj[Symbol.iterator]</b> называется итератором. Он управляет итерацией.<br>
            Итератор должен иметь метод <b>next()</b>, который возвращает объект<br>
            <b>{done: Boolean, value: any}</b>,<br> где done: true - окончание итерации,
            иначе value - следующее значение.<br>
            Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его
            и напрямую. Строковый итератор знает про сурогатные пары.<br>
            <br>
            Свойство <dfn>length</dfn> - это наибольший цифровой индекс плюс один.
            Самый простой способ очистить массив - это <b>arr.length = 0</b>;<br>
            Метод <b>toString</b> возвращает список элементов, разделённых запятыми.<br>
            <br>
            <dfn>Добавление/удаление элементов</dfn>:<br>
            <em>push(...itdfns)</em> - добавляет элементы в конец<br>
            <em>pop()</em> - извлекает элемент с конца<br>
            <em>shift()</em> - извлекает элемент с начала<br>
            <em>unshift(...itdfns)</em> - добавляет элемент в начало<br>
            <em>splice(pos, deleteCount, ...itdfns)</em> - начиная с индекса pos, удаляет deleteCount элементов и вставляет itdfns.<br>
            <em>slice(start, end)</em> - создаёт новый массив, копируя в него элементы с позиции start до end, не включая end.<br>
            <em>concat(...itdfns)</em> - возвращает новый массив: копирует все элементы текущего массива и добавляет к нему itdfns.<br>
            Если какой-то из itdfns является массивом, то беруться его элементы.<br>
            Если объект имеет специальное свойство <b>Symbol.isConcatSpreadable</b>, то он обрабатывается concat как массив,
            т.е. вместо объекта добавляются его числовые свойства.<br>
            Методы push/pop выполняются быстро, а shift/unshift - медлено.<br>
            <br>
            <dfn>Поиск среди элементов</dfn>:<br>
            <em>indexOf/lastIndexOf(itdfn, pos)</em> - ищет itdfn, начиая с позиции pos, и возвращает его индекс или -1, если ничего не найдено.<br>
            <em>includes(value)</em> - возвращает true, если в массиве есть элемент value, иначе false.<br>
            <em>find/filter(func)</em> - фильтрует элементы через функцию и отдаёт первое/все значения, 
            у которых при прохождении через функцию возвращается true.<br>
            <em>findIndex</em> - похож на find, но возвращает индекс вместо значения.<br>
            <br>
            <dfn>Перебор элементов</dfn>:<br>
            <em>forEach(func)</em> - вызывает func для каждого элемента. Ничего не возвращает.<br>
          code ["Bilbo", "Gandalf", "Nazgul"].forEach(alert); - вызов alert для каждого элемента.<br>
          br
          p.
            <dfn>Преобразование массива</dfn>:<br>
            <em>map(func)</em> - создаёт новый массив из результатов вызова func для каждого элемента.<br>
            <em>sort(func)</em> - сортирует массив "на месте", а потом возвращает его.<br>
            <em>revers(func, initial)</em> - вычисляет одно значение на основе всего массива,
            вызывая func для каждого элемента и передавая промежуточный результат между вызовами.<br>
            <br>
            <dfn>Деструктуризация</dfn> позволяет разбивать объект или массив на переменные при присвоении.<br>
            Для объекта: (неупомянутые свойства копируются в объект rest.)<br>
          code let {prop: varName = default, ...rest} = object
          p Для массива: (первый элемент копируется в itdfn1, второй в itdfn2, остальные в массив rest.)<br>
          code let [itdfn1 = default, itdfn2, ...rest] = array
          p.
            Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и первая.
          br
          p.
            <dfn>Map</dfn> - коллекция пар: ключ-значение.<br>
            Отличия от обычного объекта Object:<br>
            - что угодно может быть ключом, в том числе и объекты.<br>
            - есть дополнительные методы, свойство size.<br>
            <br>
            <dfn>Методы и свойства</dfn>:<br>
            <em>newMap([iterable])</em> - создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ, значение] для инициализации.<br>
            <em>map.set(key.value)</em> - записывает по ключу key значение value.<br>
            <em>map.get(key)</em> - возвращает значение по ключу или undefined, если ключа нет.<br>
            <em>map.has(key)</em> - возвращает true, если ключ key присутствует в коллекции, иначе false.<br>
            <em>map.delete(key)</em> - удаляет элемент по ключу key.<br>
            <em>map.clear()</em> - очищает коллекцию от всех элементов.<br>
            <em>map.size</em> - возвращает текущее количество элементов.<br>
            <em>map.keys()</em> - возвращает итерируемый объект по ключам.<br>
            <em>map.values()</em> - возвращает итерируемый объект по значениям.<br>
            <em>map.entries()</em> - возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.<br>
            <em>Object.entries(obj)</em> - создаёт Map из обычного объекта.<br>
            <em>let obj = Object.fromEntries(map)</em>; - создаёт объект из Map.<br>
            <br>
            <dfn>Set</dfn> - коллекция значений без ключей, где каждое значение может появляться только один раз.<br>
            <br>
            <dfn>Методы и свойства</dfn>:<br>
            <em>newSet([iterable])</em> - создаёт Set, можно указать перебираемый объект со значениями без инициализации.<br>
            <em>set.add(value)</em> - добавляет значение если такого нет, возвращает тот же объект.<br>
            <em>set.delete(value)</em> - удаляет значение, возвращает true если value было, иначе false.<br>
            <em>set.has(value)</em> - возвращает true, если значение есть, иначе false.<br>
            <em>set.clear()</em> - удаляет все значения.<br>
            <em>set.size</em> - возвращает количество элементов в множестве.<br>
            <em>set.values()</em> - возвращает перебираемый объект для значений.<br>
            <em>set.keys()</em> - то же самое, что и <b>set.values()</b>, нужен для обратной совместимости с Map.<br>
            <br>
            Перебор Map и Set всегда осуществляется в порядке добавления элементов,
            поменять порядок элементов или получить элемент напрямую по номеру нельзя.<br>
            <br>
            <dfn>WeakMap & WeakSet</dfn>:<br>
            <em>WeakMap</em> - Map-подобная коллекция, где ключи только объекты, автоматически удаляемые вместе со значениями
            как только они становяться недостижимыми.<br>
            <em>WeakSet</em> - Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми.<br>
            <dfn>Methods</dfn>:<br>
          pre
            code.
              weakMap.get(key)          weakSet.get(key)
              weakMap.set(key, value)   weakSet.set(key, value)
              weakMap.delete(key)       weakSet.delete(key)
              weakMap.has(key)          weakSet.has(key)
          p WeakMap и WeakSet поддерживают операции только на отдельном элементе коллекции.

        //- Модуль
        details
          summary Модуль
          p.
            <dfn>Модуль</dfn> - это файл.<br>
            Чтобы работал import/export, нужно указать <b>&lt;script type="module"&gt;</b>.<br>
            <b>export</b> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.<br>
            <b>import</b> позволяет импортировать функциональность из других модулей.<br>
          pre
            code.
              &lt;!doctype html&gt;
              &lt;script type="module"&gt;
              import {sayHi} from './say.js';
              document.body.innerHTML = sayHi('John');
              &lt;/script&gt;
          p.
            <dfn>У модулей</dfn>:<br>
            - Отложенное (deferred) выполнение по умолчанию.<br>
            - Загрузка внешних модулей (&lt;script type="module" src="..."&gt;) не блокирует обработку HTML и выполняются только после загрузки HTML документа.<br>
            - Выполняются в порядке расположения в документе.<br>
            - Для загрузки внешнего модуля с другого источника, он должен ставить заголовки CORS.<br>
            - Дублирующиеся внешние скрипты игнорируются.<br>
            - У модулей своя область видимости, обмен через import/export.<br>
            - В модуле всегда включен "use strict".<br>
            - Код в модуле выполняется только один раз.<br>
            - Сборщик Webpack объединяет модули для производительности.<br>
            <br>
            <dfn>Синтаксис</dfn>:
          pre
            code.
              <span>перед объявлением</span>
              export default class/function/variable

              <span>отдельный экспорт</span>
              export {x as y, ...}

              <span>реэкспорт</span>
              export {x [as y], ...} from "module"

              <span>реэкспорт всего кроме export default</span>
              export * from "module"

              <span>реэкспорт только export default </span>
              export {default [as y], ...} from "module"

              <span>именованный импорт из модуля</span>
              import {x [as y], ...}

              <span>импорт по умолчанию</span>
              import x from "module"

              <span>импорт по умолчанию</span>
              import {default as x} from "module"

              <span>импорт всего сразу</span>
              import * as obj from "module"

              <span>подключить модуль без присваивания переменной</span>
              import "module"
          p import/export могут быть вначале или вконце скрипта, но не в {...}.
          pre
            code.
              <dfn>Именованный экспорт</dfn>                <dfn>Экпорт по умолчанию</dfn>
              export class User {...}           export default class User {...}
              import {User} from ...            import User from ...
          p.
            Выражение import (module) загружает модуль и возвращает промис,
            результатом которого становится объект модуля, содержащий все его экспорты.
          pre
            code.        
              say.js
              export function hi() {
                alert('Привет');
              }
              export function buy() {
                alert('Пока');
              }
              export default function() {
                alert('Модуль загружен');
              }

              &lt;!doctype html&gt;
              &lt;script&gt;                    
                async function load() {                             
                  let say = await import('./say.js');         
                  say.hi();       <span>Привет</span>
                  say.buy();      <span>Пока</span>
                  say.default();  <span>Модуль загружен</span>
                }                                               
              &lt;/script&gt;
              &lt;button onclick = "load"&gt;Нажми меня &lt;/button&gt;
          p.
            Динамический импорт работает в обычных скриптах и не требует указания <b>script type="module"</b>.<br>
            <em>import()</em> - это не функция, а спец.синтаксис, как <b>super()</b>.
          img(src="../img/js/promise.png" alt="")

        //- Browser
        details
          summary Browser
          img(src="../img/js/windowJS.png" alt="")

          //- Window
          details
            summary Window
            p.
              <dfn>Window</dfn> = <b>globalThis + DOM + BOM</b> - глобальный объект JS в браузере.<br>
              <em>Object <- EventTarget <- Window</em> - интерфейс Window наследует свойства интерфейса EventTarget
              и реализует свойства из WindowOrWorkerGlobalScope и миксин WindowEventHandlers.<br>
              Объект Window реализует интерфейс Window.<br>
              У каждого окна и у каждой вкладки свой объект Window.<br>
              глобальные функции доступны как методы глобального объекта
            pre
              code.
                functionsayHi() {       
                    alert('Hello');
                }
                window.sayHi();
            p.
              <dfn>Window.properties</dfn>:<br>
              <em>opener</em> - ссылка на открывающее окно,<br>
              <em>closed</em> - true (закрыто), false (открыто),<br>
              <em>frames</em> - коллекция объектов window вложенных ифреймов<br>
              <em>parent</em> - ссылка на родительское окно<br>
              <em>top</em> - ссылка на окно самого верхнего уровня<br>
              <br>
              <dfn>Window.methods</dfn>:<br>
              <em>open (url, name, params)</em> - открывает новое окно и возвращает ссылку на него.<br>
              <em>close()</em><br>
              <em>focus()</em><br>
              <em>blur()</em><br>
              <em>alert("Hello")</em> - показывает сообщение<br>
              <em>result = promt(title, [default])</em>; - показывает сообщение и запрашивает у пользователя
              ввод текста.<br> Возвращает напечатанный в поле ввода текст или null.<br>
              <em>result = confirm (question)</em>; - показывает сообщение и ждёт, пока пользователь 
              нажмёт ОК или Отмена.<br> Возвращает true если нажата ОК и fasle - если отмена.<br>
              <em>iframe.contentWindow</em> - объект Window внутри тега &lt;iframe&gt;<br>
          
          //- BOM
          details
            summary BOM
            p.
              <em>Browser Object Model</em> - объектная модель браузера.<br>
              <em>Window.navigator</em> - информация о браузере пользователя.<br>
              <em>Window.screen</em> - информация об экране пользователя.<br>
              <em>Window.location</em> - адресная строка: текущие компоненты.<br>
              <em>Window.frames</em> - фреймы и ифреймы.<br>
              <em>Window.history</em> - история посещений (url), движения вперед и назад в окне.<br>
              <em>Window.XMLHttp Request</em> - встроенный объект для Http запросов к серверу без перезагрузки страницы.<br>
              <em>Window.document</em> - DOM-документ загруженный в окно.<br>
              https://html.spec.whatwg.org
          
          //- DOM
          details
            summary DOM
            p.
              <dfn>Document Object Model</dfn> - объектная модель документа, представляет всё содержимое страницы в виде объектов.<br>
            code document.body.style.background = "red"
            p.
              Object <- EventTarget <- Node <- Document<br>
              html-документы представленны в браузере в виде дерева DOM.<br>
              <br>
              <dfn>Веб-воркер</dfn> — это JavaScript, который работает в фоновом режиме, 
              независимо от других скриптов, не влияя на производительность страницы. <br>
              Вы можете продолжать делать все, что захотите: щелкать, выбирать объекты и т. д.,
              пока веб-воркер работает в фоновом режиме.<br>
              https://dom.spec.whatwg.org<br>
              https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov
          
          //- Node
          details
            summary Node
            p.
              <dfn>Node</dfn> - абстрактный класс.<br>
              Обеспечивает базовую функциональность для всех узлов.<br>
              Объекты класса Node никогда не создаются, но от него наследуются.<br>
              <br>
              <dfn>Классы</dfn>:<br>
              <dfn>Text</dfn> - для текстовых узлов. Содержат текст.<br>
              <dfn>Comment</dfn> - для узлов-комментариев. Иногда в них можно включить информацию, которая 
              не будет поазана, но будет доступна в DOM для чтения JS.<br>
              <dfn>Element</dfn> - для узлов-элементов. HTML-тэги - строительные блоки документа.<br>
              Обеспечивает навигацию на уровне узлов-элементов и служит базой
              для классов SVGElement, XMLElement, HTMLElement.<br>
              <br>
              Текст, комментарий и тэг - это DOM-узел.<br>
              Каждый DOM-узел принадлежит своему классу.<br>
              Для наследования используют классы, основанные на прототипах.<br>
              Классы формируют иерархию.<br>
              Весь набор свойств и методов является результатом наследования.<br>
              <dfn>DOM-узлы</dfn> - это обычные JS объекты. Реализация соответствующего класса.<br>
              <dfn>DOM-элемент</dfn> - это JS объект тэга.<br>
              <br>
              <dfn>HTMLElement</dfn> - является базовым классом для всех остальных HTML-элементов.<br>
              От него наследуют элементы:<br>
              <dfn>HTMLInputElement</dfn> - класс для тега &lt;input&gt;<br>
              <dfn>HTMLBodyElement</dfn> - класс для тега &lt;body&gt;<br>
              <dfn>HTMLAnchorElement</dfn> - класс для тега &lt;a&gt;<br>
              и т.д., <br>
              каждому тегу соответствует свой класс, который представляет свойства и методы:<br>
              <dfn>value</dfn> - значение для &lt;input&gt;, &lt;select&gt; и &lt;textarea&gt; (HTMLInputElement, HTMLSelectElement, ...).<br>
              <dfn>href</dfn> - адрес ссылки "href" для &lt;a href="..."&gt; (HTMLAnchorElement).<br>
              <dfn>id</dfn> - значение атрибута "id" для всех элементов (HTMLElement).<br>
              <br>
              console.log(elem) выводит элемент в виде DOM-дерева.<br>
              console.dir(elem) выводит элемент в виде DOM-объекта, это удобно для анализа его свойств.<br>
              <br>
              Для изменения элементов или проверки DOM-дерева можем использовать инструменты разработчика в браузере.<br>
          
          //- DOM-navigation
          details
            summary DOM-navigation
            img(src="../img/js/Навигация DOM.png" alt="")
            p.
              <dfn>Дочерние узлы (дети)</dfn> - непосредственные дети-элементы узла.<br>
              <dfn>Потомки</dfn> - все элементы, внутри данного, ключая детей, их детей и т.д.<br>
              Коллекция childNodes содержит список всех детей, включая текст.<br>
            pre
              code.
                eldfn.childNodes[0] === eldfn.firstChild
                eldfn.childNodes[eldfn.childNodes.length-1] === eldfn.lastChild
            p.  
              <dfn>Соседи</dfn> - узлы, у которых один и тот же родитель.<br>
              &lt;<b>body</b>&gt; - следующий или правый сосоед &lt;<b>head</b>&gt;<br>
              &lt;<b>head</b>&gt; - предыдущий или левый сосед &lt;<b>body</b>&gt;<br>
            pre
              code.
                const bodyElement = document.body;
                const firstChildNode = bodyElement.firstChild; <span>- первый узел</span>
                const lastChildNode = bodyElement.lastChild; <span>- последний узел</span>
            br
            p список всех детей (узлов) объекта (в данном случае body) в виде коллекции
            code const childNodes = bodyElement.childNodes;
            br
            p проверяет есть ли дочерние узлы у объекта true or false
            code bodyElement.hasChildNodes()
            br
            p.
              <dfn>Коллекция</dfn> - это псевдомассив:<br>
              можно перебирать с помощью <b>for( of ) {}</b> и <b>forEach()</b>
              методы массива не работают<br>
              изменять элемент коллекции как в массиве не получится, только через специальные методы<br>
            pre
              code.
                bodyElement.previousSibling; <span>- предыдущий соседний узел</span>
                bodyElement.nextSibling; <span>- следующий соседний узел</span>
                bodyElement.parentNode; <span>- родительский узел</span>
            br
            p <dfn>Для элементов (тегов)</dfn>:
            pre
              code.
                bodyElement.childNodes; <span>- получаем коллекцию всех дочерних узлов</span>
                bodyElement.children; <span>- получаем коллекцию всех дочерних элементов (тегов)</span>
                bodyElement.firstElementChild; <span>- первый элемент</span>
                bodyElement.lastElementChild; <span>- последний элемент</span>
                bodyElement.previousElementSibling; <span>- предыдущий соседний элемент</span>
                bodyElement.nextElementSibling; <span>- следующий соседний элемент</span>
                bodyElement.parentElement; <span>- родительский элемент</span>
            br
            p.
              <dfn>Поиск произвольного элемента</dfn>:<br>
              возвращает статичную коллекцию со всеми элементами внутри elem, соответствующие указанному CSS-селектору (класс (с точкой впереди), тег, вложенные теги, атрибут, id и т.д.)
            code elem.querySelectorAll(CSS);
            br
            p проверяет только последний указанный в CSS-селекторе элемент без учета контекста используется чаще других, ищет и возвращает первый попавшийся объект по указанному CSS-селектору
            code querySelector(CSS);
            br
            p ищет и возвращает элемент по id, ищет только в document
            code document.getElementById(id без решетки);
            br
            p возвращает живую коллекцию, ищет где угодно
            code getElementsByTagName(тег);
            br
            p возвращает живую коллекцию, ищет где угодно
            code  getElementsByClassName(класс без точки впереди);
            br
            p возвращает живую коллекцию, ищет только в document
            code document.getElementsByName(атрибут name);
            br
            p живая коллекция - содержит в себе всегда актуальную информацию с учетом изменений в дереве DOM<br>
            img(src="../img/js/querySelector.png" alt="")
            br
            p ищет ближайшего предка, который соответствует указанному css-селектору
            code elem.closest(css)
            br
            p ничего не ищет, проверяет соответствует ли элемент css селектору, возвращает true or false
            code elem.matches(css)
            br
            p получил объект
            code const textElement = document.querySelector('.someClass__text');
            p получил содержимое объекта как есть
            code const textEldfnentContent = textElement.innerHTML;
            p заменил содержимое объекта
            code textElement.innerHTML = `Новое содержимое объекта`;
            br
            p получил объект
            code const textElement = document.querySelector('.someClass__text');
            p получил содержимое объекта и сам объект
            code const textEldfnentContent = textElement.outerHTML;
            p заменил сам объект
            code textElement.outerHTML = `&lt;p>Новое содержимое объекта&lt;/p>`;
            br
            p получил объект
            code const textElement = document.querySelector('.someClass__text');
            p получил содержимое объекта без тегов
            code const textEldfnentContent = textElement.textContent;
            p заменил содержимое объекта, но теги вставляються как текст позволяет записывать получаемый текст безопасно
            code textElement.textContent = `&lt;p>Новое содержимое объекта&lt;/p>`;
            br
            p получил объект с классом .someClass__text
            code const textElement = document.querySelector('.someClass__text');
            p получил следующий объект - комментарий
            code const getComment = textElement.nextSibling;
            p вывел текст комментария в консоль
            code console.log(getComment.data);
            p заменил текст комментария
            code getComment.data = `Новый текст`;
            br
            p.
              <dfn>Методы поиска элементов в DOM</dfn>:<br>
              <em>querySelector</em> - ищет внутри элемента по CSS-selector<br>
              <em>querySelectorAll</em> - <br>
              <em>getElementById</em> - ищет по id<br>
              <em>getElementsByName</em> - возвращает коллекцию, ищет по имени<br>
              <em>getElementsByTagName</em> - возвращает коллекцию, ищет внутри элемента по тегу или "*"<br>
              <em>getElementsByClassName</em> - возвращает коллекцию, ищет внутри элемента по class<br>
              <em>elem.matches(css)</em> - проверяет, удовлетворяет ли элемент CSS-селектору<br>
              <em>elem.closest(css)</em> - ищет ближайшего предка<br>
              <em>elemA.contains(eldfnB)</em> - вернет true если elemB находится внутри elemA или elemA == elemB<br>
              
          //- Document
          details
            summary Document
            p.
              <dfn>Document</dfn> - интерфейс доступа к узлам, его реализует объект document.<br>
              <dfn>document</dfn> - объект DOM, входная точка в DOM<br>
            br
            p получить объект html со всем его содержимым
            code const htmlEldfnent = document.documentEldfnent;
            p получить объект head со всем его содержимым
            code const headEldfnent = document.head;
            p получить объект body со всем его содержимым
            code const bodyEldfnent = document.body;
            br
            p.
              <dfn>DOMContentLoaded</dfn> генерируется на document, когда DOM готов и к нему можно применить JS.<br>
              Изображения и другие ресурсы (стили и т.п.) всё ещё могут продолжать загружаться.<br>
              <em>window.onload</em> - страница и все ресурсы загружены<br>
              <em>window.beforeunload</em> - пользователь покидает страницу.<br>
              Если отменить событие, то браузер спросит хочет ли пользователь уйти.<br>
              <em>window.unload</em> - пользователь окончательно уходит, можно сделать сетевой запрос.<br>
              <em>document.readyState</em> - текущее состояние загрузки документа.<br>
            br
            p.
              Изменения можно отследить с помощью события <dfn>readyStateChange</dfn>:<br>
              <b>loading</b> - документ грузится<br>
              <b>interactive</b> - документ прочитан, происходит перед DOMContentLoaded<br>
              <b>complete</b> - документ и ресурсы загружены, происходит перед window.onload<br>
            br
            p.
              Скрипт должен дождаться пока загрузятся стили.<br>
              Скрипты <b><&lt;script&gt;... &lt;/script&gt;</b> или <b><&lt;script src="..."&gt; &lt;/script&gt;</b> блокируют DOMContentLoaded.<br>
              Скрипты созданные через <b>document.createElement('script')</b>, добавленные на страницу и скрипты с атрибутами async или defer не блокируют DOMContentLoaded.<br>
              Динамически загружаемые скрипты по умолчанию ведут себя как async,
            pre
              code.
                script.async = false; <span>- отмена async-поведения</span>
                let script = document.createElement('script');
                script.src = "путь/к/скрипту";
                document.body.append(script);
            p.
              <em>async</em> - скрипты выполняются по загрузке, DOMContentLoaded не имеет значения.<br>
              <em>defer</em> - скрипты выполняются по расположению в докумете. Скрипт ждёт загружки документа выполняется перед DOMContentLoaded.<br>
              <em>defer</em> работает только у внешних скриптов - у которых есть <b>src="..."</b>, все элементы с src="..." дают события:<br>
              <b>load</b> - при успешной загрузке,<br>
              <b>error</b> - при ошибке<br>
              <em>&lt;iframe&gt;</em> - исключение: всегда даёт load, даже при ошибке.<br>
              Событие <em>readystatechange</em> также работает для ресурсов.<br>
              Обработчики onload/onerror отслеживают только сам процесс загрузки.<br>
              <em>Window.onerror</em> - позволяет "поймать" ошибки в скрипте.<br>
              Скрипт одного сайта не может получить детали ошибки скрипта с другого сайта, нужно поставить тегу  атрибут crossorigin 
              и специальные заголовки на удалённом сервере.<br>
              <em>MutationObserver</em> - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.<br>
            code let observer = newMutationObserver(callback); - создать наблюдатель
            p.
              <em>observer.observe(node, config)</em>; - прикрепить наблюдателя к DOM-узлу.<br>
              <em>observer.disconnect()</em>; - останавливает наблюдение.<br>
              <em>observer.takeRecords()</em>; - получает список необработанных записей измененений, которые произошли, 
              но колбэк для них ещё не выполнился.<br>
            br
            p.
              В основе выделения лежит <dfn>Range(диапозон)</dfn> - пара граничных точек: начало и конец диапозона.<br>
              <dfn>Range</dfn> - общий, объект для управления диапозоном.<br>
              Выделение в документе представлено объектом Selection, который можно получить как 
              <b>window.getSelection()</b> или <b>document.getSelection()</b>.<br>
              <dfn>Selection</dfn> (выделение) имеет начальную границу (якорь) и конечную (фокус).<br>
            br
            p.
              Основные свойства выделения:<br>
              <em>anchorNode</em> - узел начала выделения<br>
              <em>anchorOffset</em> - смещение в anchorNode, где начинается выделение<br>
              <em>focusNode</em> - узел окончания выделения<br>
              <em>focusOffset</em> - смещение в focusNode, где выделение заканчивается<br>
              <em>inCollapsed</em> - true, если диарозон выделения пуст или не существует<br>
              <em>rangeCount</em> - количество диапозонов в выделении<br>
            br
            p.
              <dfn>document.cookie</dfn> предоставляет доступ к куки:<br>
              - операция записи изменяет только те куки, которые было указано<br>
              - имя и значение куки должны быть закодированы<br>
              - одно уки вмещает до 4 kb данных, количество куки зависит от браузера.<br>
            br
            p.
              <dfn>Настройки куки</dfn>:<br>
              <em>path = /</em> - по умолчанию текущий путь, делает куки видимыми только по указанному пути и ниже<br>
              <em>domain = site.com</em> - по умолчанию куки видно только на текущем домене, если явно указан домен, 
              то куки видно и на поддоменах<br>
              <em>expires или max-age</em> - устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.<br>
              <em>secure</em> - делает куки доступными только при использовании HTTPS<br>
              <em>somesite</em> - запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки<br>
            br
            p.
              <dfn>Методы создания узлов</dfn>:
              <em>document.createElement(tag)</em> - создаёт элемент с заданным тегом<br>
              <em>document.createTextNode(value)</em> - создаёт текстовый узел<br>
              <em>document.write(html)</em> - добавляет html на страницу до завершения её загрузки.<br>
            br
            p.
              После загрузки затирает начальный документ.<br>
              <em>const newElement = document.createElement(`div`)</em>; - создал элемент: тег div<br>
              <em>const newText = document.createTextNode(`Новый текст`)</em>; - создал текстовый узел<br>
              <em>elem.cloneNode(deep)</em> - клонирует элемент, если deep == true, то со всеми дочерними элементами.<br>
            br
            p.
              Вставка и удаление узлов:<br>
              <em>node.append(...nodes or strings)</em> - вставляет в node в конец<br>
              <em>node.prepend(...nodes or strings)</em> - вставляет в node в начало<br>
              <em>node.before(...nodes or strings)</em> - вставляет прямо перед node<br>
              <em>node.after(...nodes or strings)</em> - вставляет сразу после node<br>
              <em>node.replaceWith(...nodes or strings)</em> - заменяет node<br>
              <em>node.remove()</em> - удаляет node<br>
              <em>elem.beforebegin</em> - вставляет html прямо перед elem<br>
              <em>elem.afterbegin</em> - вставляет html в elem в начало<br>
              <em>elem.beforeend</em> - вставляет html в elem в конец<br>
              <em>elem.afterend</em> - вставляет html сразу после elem<br>
              <em>elem.insertAdjacentText</em> - вставляет текстовые строки<br>
              <em>elem.insertAdjacentElement</em> - вставляет элементы<br>
              <em>textElement.before(newElement)</em>; - вставил newElement перед textElement<br>
              <em>textElement.after(newElement)</em>; - вставил newElement после textElement<br>
              <em>textElement.prepend(newElement)</em>; - вставил newElement в начало внутри объекта textElement<br>
              <em>textElement.append(newElement)</em>; - вставил newElement в конец внутри объекта textElement<br>
              либо<br>
              <em>textElement.append(newElement, `Новый текст`)</em>; - можно вставлять через запятую, но теги вставляються как текст<br>
              <em>textElement.insertAdjacentHTML('pos', `ins`)</em>; - позволяет вставить в DOM что угодно<br>
              <b>pos</b> - место вставки по отношению к textElement<br>
              <b>beforebegin</b> - вставить перед textElement<br>
              <b>afterbegin</b> - вставить в начало textElement<br>
              <b>beforeend</b> - вставить в конец textElement<br>
              <b>afterend</b> - вставить после textElement<br>
              <b>ins</b> - то что вставляем, позволяет вставить теги<br>
              <em>insertAdjacentText()</em>;<br>
              <em>insertAdjacentElement()</em>;<br>
              <em>textElement.append(oldElement)</em>; - перенес существующий oldElement в конец textElement<br>
              <em>let cloneOldElement = oldElement.cloneNode()</em>; - клонировал без дочерних элементов<br>
              <em>let cloneOldElement = oldElement.cloneNode(true)</em>; - клонировал с дочерними элементами<br>
              <em>textElement.remove()</em>; - удаление объекта<br>
              <em>const elementClassNames = element.className</em>; - получил все классы объекта element<br>
              <em>element.className = "red"</em>; - заменил все классы на класс red<br>
              <em>element.classList.add('active')</em>; - добавить класс<br>
              <em>element.classList.remove('active')</em>; - удалить класс<br>
              <em>element.classList.toggle('active')</em>; - добавить класс если его нет, а если есть, то удалить<br>
              <em>element.classList.contains('active')</em>; - проверяет наличие класса, возвращает true or false<br>
              <em>element.style.color = "red"</em>; - получаем доступ к атрибуту style HTML-тега и задаём цвет<br>
              <em>console.log(element.style.marginBottom)</em>; - вывод в консоль значения css-свойство атрибута style HTML-тега объекта element<br>
              <em>element.style.color = ""</em>; - удалил css-свойство из атрибута style HTML-тега<br>
              записываю сразу несколько css-свойств в атрибут style, перезаписывает style полностью<br>
            pre
              code.
                element.style.cssText = `
                margin-bottom: 30px;
                color: red;
                `;
            br
            p.
              <em>const elementStyle = getComputedStyle(eldfnent)</em>; - получил вычисленные стили элемента<br>
              <em>console.log(elementStyle.fontSize)</em>; - выводим вычисленое значение размера шрифта<br>
              <em>const elementBeforeStyle = getComputedStyle(element, "::before")</em>; - получил стили псевдоэлемента<br>
              <em>console.log(elementBeforeStyle.backgroundColor)</em>; - выводим цвет фона, который реализован с помощью ::before<br>
              <em>getComputedStyle()</em>; - работает только для чтения<br>
              <em>const paddingLeft = parseInt(elementStyle.paddingLeft)</em>; - сразу перевожу значение из строки в число<br>
              <em>element.style.marginLeft = "20px"</em>; - задавать значения всегда с единицами измерения<br>
              <br>
              Устаревшие методы (возвращают node):<br>
              <em>parent.appendChild(node)</em><br>
              <em>parent.insertBefore(node, nextSibling)</em><br>
              <em>parent.removeChild(node)</em><br>
              <em>parent.replaceChild(newEldfn, node)</em><br>
              <br>
              <em>document.forms</em> - живая коллекция всех форм на странице <b>document.forms[name/index]</b><br>
              Элементы <em>&lt;form&gt;</em> или <em>&lt;fieldset&gt;</em> доступны через <b>form.elements[name/index]</b> или <b>form[name/index]</b>.<br>
              Элементы хранят ссылку на свою форму в свойстве <b>element.form</b>.<br>
              Значения элементов формы доступны через <b>input.value</b>, <b>textarea.value</b>, <b>select.value</b> и т.д. либо <b>input.cheked</b> для чекбоксов и переключателей.<br>
              <br>
              Для <em>&lt;select&gt;</em> можно получить индекс выбранного пункта через: <b>select.selectedIndex</b> либо <b>select.options</b>.<br>
              Элемент получает фокус когда пользователь кликает по нему или использует Tab.<br>
              <br>
              HTML-атрибут <b>auto-focus</b> - устанавливает фокус при загрузке страницы.<br>
              HTML позволяет делать валидацию с помощью атрибутор required, pattern и т.д.<br>
              События <b>focus и blur</b> срабатывают на фокусировке/потере фокуса элемента и не всплывают, но можно использовать фазу перехвата или focusin/focusout.<br>
              <b>tabindex</b> делает фокусируемым любой элемент.<br>
              <br>
              <em>document.activeElement</em> - текущий элемент с фокусом.<br>
              <em>const form = document.forms[0]</em> - получить форму по индексу коллекции<br>
              <em>const form = document.forms.main</em> - по аттрибуту тега name (name="main")<br>
              <br>
              <em>document.querySelectorAll('form')</em> - неживая коллекция<br>
            pre
              code.
                const form = document.forms.main<br>
                console.log(form.elements) -  вывел элементы формы<br>
            <br>
            p.
              <em>focus, blur</em> - события не всплывают<br>
              <br>
              <em>focus(), blur()</em> - методы. Аттрибут taindex = -1 на клавишу tab не реагирует, но можно установить фокус на елемент методом<br>
              <em>document.activeElement</em> - получаем текущий элемент с фокусом<br>
              <em>focusin / focusout</em> - события всплывают<br>
              <br>
              <dfn>События изменения данных:</dfn><br>
              <em>change</em> - значение изменено. срабатывает в текстовом поле при потере фокуса, в остальных полях при выборе.<br>
              <em>input</em> - значение изменено. Срабатывает немедлено при каждом изменении текстового поля.<br>
              <em>cut/copy/paste</em> - свойство event.clipboardData даёт доступ на чтение/запись в буфер.<br>
              <em>cut</em> - событие, срабатывает при вырезании<br>
              <em>copy</em> - событие, срабатывает при копировании<br>
              <em>paste</em> - событие, срабатывает при вставке<br>
              <em>submit</em> - событие отправки данных формы, при <b>form.submit()</b> - форма отправится при потере фокуса<br>
              <em>event.preventDefault()</em> - запретит выполнение события<br>
              <br>
              <dfn>Отправка формы:</dfn><br>
              Нажать кнопку <b>&lt;input type="submit"&gt;</b> или <b>&lt;input type="image"&gt;</b><br>
              Нажать Enter на любом поле<br>
              При отправке формы по нажатию Enter в текстовом поле, генерируется событие <em>click</em> на кнопке <b>&lt;input type="submit"&gt;</b><br>
              При отправке формы срабатывает событие <em>submit</em>, оно используется для проверки формы перед её отправкой на сервер 
              или для отмены отправки и обработки её с помощью JS.<br>
              <b>form.submit()</b> позволяет отправить форму из JS. Используют для создания и отправки собственных форм на сервер, 
              при этом событие <em>submit</em> не генерируется.<br>
              <br>
              <dfn>scroll</dfn> - событие прокрутки позволяет реагировать на прокрутку страницы или элемента.<br>
            pre
              code.
                window.addEventListener('scroll', function() {
                  document.getEldfnentById('showScroll').innerHTML = pageYOffset + 'px';
                });

          //- EventTarget
          details
            summary EventTarget
            p.
              <dfn>EventTarget</dfn> - это абстрактный класс.<br>
              Обеспечивает поддержание DOM-узлами событий.<br>
              <br>
              <dfn>Event</dfn>(Событие) - сигнал от браузера о том, что что-то произошло.<br>
              Событию можно назначить обработчик - функцию, которая сработает, как только событие произошло.<br>
              Способы назначения обработчиков событий:<br>
              Атрибут HTML: <b>onclick="..."</b>.
              DOM-свойство: <b>elem.onclick = function</b>.
              Методы: <b>elem.addEventListener(event, handler[, phase])</b> для добавления<br>
              <b>event</b> - имя события, например "click".<br>
              <b>handler</b> - ссылка на функцию обработчик.<br>
              <b>options</b> - дополнительный объект со свойствами:<br>
              <b>once</b>: если true, тогда обработчик будет удалён после выполнения.<br>
              <b>capture</b>: фаза, на которой должен сработать обработчик (false/true)<br>
              <b>passive</b>: если true, то обработчик не вызовет preventDefault()<br>
              <br>
              Обработчик всегда хранится в свойстве DOM-объекта, а атрибут - лишь один из способов его инициализации.<br>
              В DOM-свойстве один обработчик на один тип события, так как одно имя - одно свойство.<br>
              Методы - самый гибкий и используемый способ.<br>
              <b>addEventListener</b> поддерживает объекты в качестве обработчиков событий, вызывая метод объекта object.handleEvent(event).<br>
              Убрать обработчик <b>elem.onclick = null</b>.<br>
              Не используй <b>setAttribute</b> для обработчиков.<br>
              Регистр DOM-свойства имеет значение, а HTML-атрибута - нет.<br>
              Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.<br>
              Любой обработчик получает объект события первым аргументом<br>
              <em>event.type</em> - тип события, например "click"<br>
              <em>event.clientX/event.clientY</em> - координаты курсора для событий мыши в момент клика относительно окна.<br>
              <br>
              <dfn>События</dfn>:<br>
              <em>onclick="JScode"</em> - обработчик события, аттрибут тега.<br>
            code const button = document.querySelector('.button');
            p.
              <em>button.onclick = function () {};</em> - нет возможности повесить на одно событие несколько обработчиков<br>
              либо<br>
            code function showClick() {}
            p.
              <em>button.onclick = showClick;</em> - нет возможности повесить на одно событие несколько обработчиков<br>
              <em>button.addEventListener("click", function (e) {});</em> - можно назначить обработчик несколько раз<br>
              либо<br>
            code.
              button.addEventListener("click", func);
              function func(e) {}
              <br>
            p.
              <em>button.removeEventListener(event, handler);</em> - отключает обработчик<br>
              <em>button.addEventListener(event, handler, options);</em> - можно добавить параметры<br>
            pre
              code.
                const options {
                  "capture: false", - фаза, на которой должен сработать обработчик (всплытие/погружение)
                  "once": false, - если true, тогда обработчик будет удален после выполнения
                  "passive": false - если true, то обработчик никогда не вызовет preventDefault()
                }
                либо
                button.addEventListener("click", func, {"once": true});
            <br>
            p.
              Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его
              в качестве аргумента (event) функции - обработчику:<br>
              <em>event.type</em> - тип события<br>
              <em>event.target</em> - объект, на котором сработал обработчик<br>
              <em>event.currentTarget</em> - объект, которому назначен обработчик<br>
              <em>event.clientX</em> - положение курсора по Х<br>
              <em>event.clientY</em> - положение курсора по Y<br>
              <em>console.log(evant)</em> - посмотреть все детали события<br>
              <em>event.stopPropagation()</em>; - остановка всплытия<br>
              <br>
              <dfn>Делегирование</dfn> - вешаем прослушку на родителя<br>
              Отмена действий браузера по умолчанию:<br>
            pre
              code.
                event.preventDefault(); - для addEventListener
                либо
                button.addEventListener("click", func, {"passive": true});

                link.onclick = function () { - для onclick
                  return false;
                }
              <br>
            p.
              <dfn>Всплытие и погружение:</dfn><br>
              целевой элемент <b>(event.target)</b> - самый глубоко вложенный элемент, над которым произошло событие.<br>
              Сначала событие двигается вниз (погружение) от корня документа к event.target, по пути вызывая обработчики, 
              поставленные через <b>addEventListener(..., true)</b>,<br>
              где true - сокращенно <b>{capture: true}</b><br>
              Далее обработчики на целевом элементе.<br>
              Потом событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
              поставленные через on&lt;event&gt; и addEventListener без третьего аргумента
              или с третьим аргументом равным fasle.<br>
              Каждый обработчик имеет доступ к свойствам события event:<br>
              <em>event.target</em> - самый глубокий элемент, на котором произошло событие<br>
              <em>event.currentTarget(=this)</em> - элемент, на котором в данный момент сработал обработчик 
              (тот, на котором "висит" конкретный обработчик)<br>
              <em>event.eventPhase</em> - не какой фазе он сработал: (погружение = 1, фаза цели = 2, всплытие = 3)<br>
              <br>
              Любой обработчик может остановить событие вызовом <b>event.stopPropagation()</b>.<br>
              Всплытие и погружение являются основой для делегирования событий.<br>
              Делегирование событий используется при схожей обработке многих элементов.<br>
              Вешаем обработчик на контейнер.<br>
              В обработчике проверяем целевой элемент <b>event.target</b>.<br>
              Если событие произошло на нужном элементе, то обрабатываем его.<br>
              <br>
              Использование:<br>
              Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.<br>
              Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.<br>
              Удобство изменений DOM: можно массово добавлять или удалятьэлементы путём изменения innerHTML и ему подобных.<br>
              <br>
              Событие должно всплывать. Низкоуровневые обработчики не должны вызывать event.stopPropagation().<br>
              Два способа отменить действие браузера по умолчанию:<br>
              - <em>event.preventDefault()</em> - основной способ<br>
              либо
              - &lt;a href="/" onclick = "event.preventDefault()"&gt;здесь&lt;/a&gt;<br>
              Опция <b>passive</b>: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено.<br>
              Это сообщит браузеру, что он не должен ждать выполнения всех обработчиков, 
              а ему следует сразу приступать к выполнению действия по умолчанию, например к прокрутке.<br>
              event.defaultPrevented равно true если событие по умолчанию отменено, иначе false.<br>
              Чтобы сгенерировать событие из кода, вначале нужно создать объект события<br>
            code let event = newEvent(name[, options]);
            p.
              Базовый конструктор <em>Event(name, options)</em> принимает обязательное имя события и options - объект с тремя свойствами:<br>
              - <em>bubbles: true</em> - чтобы событие всплывало<br>
              - <em>cancelable: true</em> - если нужно, чтобы работал event.preventDefault()<br>
              - <em>composed: true/false</em> - если true, то событие будет всплывать наружу за пределы Shadow DOM.<br>
              По умолчанию все три свойства - false:<br>
            code {bubbles: false, canselable: false, composed: false}.
            p.
              <em>elem.dispatchEvent(event)</em> - запускает объект события на элементе.<br>
              <em>event.isTrusted</em> - true для событий от пользователя и false для генерирующих.<br>
              <em>on&lt;event&gt;</em> - для встроенных событий.<br>
              <em>addEventListener</em> - для генерируемых.<br>
              При создании встроенных событий использовать конструкторы встроенных событий (newMouseEvent("click") и др.)<br>
              Для пользовательских событий применять конструктор CustomEvent.<br>
              event.detail позволяет передавать информацию в объекте события.<br>
              Генерировать встроенные события в случаях:<br>
              - явный грубый хак, чтобы заставить работать сторонние библиотеки, если нет другого способа.<br>
              - скриптом нажать на кнопку для автоматического тестирования.<br>
              <br>
              <dfn>События мыши:</dfn><br>
              <em>click</em> - кликнули на элемент левой кнопкой мыши (на устройсвах с сенсорными экранами - при касании).<br>
              contextmenu - происходит, когда кликнули на элемент правой кнопкой мыши<br>
              <em>mouseover/mouseout</em> - когда мышь наводится на/покидает элемент.<br>
              <em>mousedown/mouseup</em> - когда нажали/отжали кнопку мыши на элементе.<br>
              <em>mousemove</em> - при движении мыши.<br>
              Комплексные события состоят из простых, обработчики событий вызываются в следующем порядке:<br>
              <b>mousedown -> mouseup -> click</b><br>
              Свойство события мыши which - какая кнопка мыши нажата:<br>
              - <b>event.which == 1</b> - левая кнопка<br>
              - <b>event.which == 2</b> - средняя кнопка<br>
              - <b>event.which == 3</b> - правая кнопка<br>
              Клавиши - модификаторы (true если нажаты): <b>altKey, ctrKey и metaKey (Mac)</b>.<br>
              В Мас обычно Cmd вместо ctrl, поэтому лучше проверить: <b>if(e.metaKey || e.ctrlKey)</b>.<br>
              Координаты относительно окна: clientX, clientY.<br>
              Координаты относительно документа: pageX/pageY.<br>
              Запрет копирования:<b> &lt;div oncopy = "alert('Копрование запрещено!'); return false"&gt;</b><br>
              При быстром движении мыши события не будут возникать на промежуточных элементах.<br>
              Браузер периодически проверяет позицию курсора и при изменении генерирует событие mousemove.<br>
              Если был mouseover, то будет и mouseout.<br>
              События mouseover/out и mouseenter/leave имеют дополнительное свойство relatedTarget.<br>
              Для события mouseover:<br>
              <em>event.target</em> - это элемент, на который курсор пришёл.<br>
              <em>event.relatedTarget</em> - это элемент, с которого курсор пришёл (target -> relatedTarget)<br>
              <em>event.relatedTarget</em> равно null - указатель мыши пришёл из-за или ушёл за пределы окна.<br>
              В любой момент времени указатель может быть только над одним элементом - над самым глубоко вложенным.<br>
              События <b>mouseover/out</b> возникают, когда происходит переход с родительского элемента на потомка.<br>
              События <b>mouseenter/leave</b> не всплывают и генерируются, когда курсор переходит или уходит на элемент в целом (без учёта потомков).<br>
              <br>
              <dfn>Простые</dfn>:<br>
              <em>mousedown / mouseup</em> - кнопка мыши нажата / отпущена над элементом<br>
              <em>mouseover / mouseout</em> - курсор мыши появляется над элементом и уходит с него<br>
              <br>
              <dfn>mouseover</dfn>:<br>
              <em>event.target</em> - элемент откуда ушёл курсор<br>
              <em>event.relatedTarget</em> - элемент куда ушёл курсор<br><br>
              <br>
              <dfn>mouseout</dfn>:<br>
              <em>event.target</em> - элемент куда пришёл курсор<br>
              <em>event.relatedTarget</em> - элемент откуда пришёл курсор<br>
              <br>
              <em>mousemove</em> - каждое движение мыши над элементом генерирует это событие<br>
              <em>contextmenu</em> - вызывается при попытке открытия контекстного меню<br>
              <br>
              <dfn>Комплексные</dfn>
              <em>click - mousedown и mouseup</em> над одним и тем же элементом<br>
              <em>dblclick</em> - двойной клик на элементе<br>
              <br>
              <em>event.which = 1</em> - нажата основная кнопка мыши (левая)<br>
              <em>event.which = 2</em> - нажата средняя кнопка мыши (колесо)<br>
              <em>event.which = 3</em> - нажата не основная кнопка мыши (правая)<br>
              <br>
              <em>mouseover / mouseout</em> - всплывают, можно использовать делегирование,<br>
              <em>mouseenter / mouseleave</em> - нет<br>
              <br>
              <dfn>Базовый алгоритм Drag'n'Drop.</dfn><br>
              При mousedown - готовим элемент к перемещению (если нужно создаём его копию).<br>
              При mousemove передвигаем элемент на новые координаты путём смены left/top и position: absolute.<br>
              При mouseup - остановить перенос элемента и произвести окончание Drag'n'Drop.<br>
              Ключевые идеи:<br>
              <b>object.mousedown -> document.mousemove -> object.mouseup</b><br>
              (обязательно отменить браузерный ondragstart)<br>
              В начале перетаскивания запоминаем начальное смещение указателя относительно элемента(shiftX/shiftY) и сохраняем его при перетаскивании.<br>
              Выявляем потенциальные цели переноса под указателем с помощью <b>document.elementFromPoint</b>.<br>
              На mouseup завершить перенос: изменить данные, переместить элементы.<br>
              <br>
              <dfn>События указателя</dfn> (Pointer events) одновременно обрабатывают действия мыши, касания пера.<br>
              Содержат свойства мыши и дополнительно свои:<br>
              <em>pointerId</em> - идентификатор указателя, вызвавшего событие, генерируется браузером,
              позволяет обрабатывать несколько указателей (стилус и мультитач).<br>
              <em>pointerType</em> - тип указывающего устройства. Строка с одним из значений: "mouse", "pen" или "touch".<br>
              <em>isPrimary</em> - равно true для основного указателя (первый палец в мультитач).<br>
              При обработке переносов и сложных касаний нужно отменить действие браузера и ставить <b>touch-events: none</b> в CSS для элементов.<br>
              Можно перенаправить (захватить) все события указателя на определённый элемент до наступления события pointerup/pointercancel.<br>
              Два связанных с захватом события:<br>
              <b>getpointercapture</b> срабатывает, когда элемент использует <b>setPointerCapture</b> для включения захвата.<br>
              <b>lostpointercapture</b> срабатывает при освобождении от захвата:<br>
              - явно с помощью <b>releasePointerCapture</b> или<br>
              - автоматически при событии <b>pointerup/pointercancel</b>.<br>
              <br>
              <dfn>Сбытия указателя - мыши</dfn>:<br>
              <em>pointerdown - mousedown</em><br>
              <em>pointerup - mouseup</em><br>
              <em>pointermove - mousdfnove</em><br>
              <em>pointerover - mouseover</em><br>
              <em>pointerenter - mouseenter</em><br>
              <em>pointerleave - mouseleave</em><br>
              <em>pointercancel - </em><br>
              <em>getpointercapture - </em><br>
              <em>lostpointercapture - </em><br>
              <br>
              <dfn>События клавиатуры</dfn>:<br>
              <em>keydown</em> - происходит при нажатии клавиши<br>
              <em>keyup</em> - при отпускании клавиши<br>
              <em>event.code</em> - код нажатой клавиши ("KeyA", "ArrowLeft" и т.д.)<br>
              <em>event.key</em> - клавиша с учетом регистра и раскладки клавиатуры символ ("A", "a" и т.д.)<br>
              <em>event.repeat</em> - вернет true при срабатывании повтора на зажатой клавише<br>
              Нажатие клавиши всегда генерирует клавиатурное событие, кроме клавиши Fn.<br>
              <br>
              <dfn>Прокрутка</dfn>:<br>
              <em>scroll</em> - событие прокрутки<br>
              <em>scrollY</em> - количество прокрученных пикселей по вертикали<br>
              <em>scrollX</em> - количество прокрученных пикселей по горизонтали<br>
              <br>
              <dfn>Загрузка</dfn>:<br>
              <em>DOMContentLoaded</em> - браузер полностью загрузил HTML, построил DOM-дерево, 
              но внешние ресурсы могут быть ещё не загружены
              срабатывает на объекте document<br>
              <em>load</em> - браузер полностью загрузил HTML, и внешние ресурсы
              срабатывает на объекте window<br>
              <em>beforeunload / unload</em> - пользователь покидает сраницу<br>
              <em>beforeunload</em> - можем вывести пользователю предупреждение о несохраненных данных в форме<br>
              <em>unload</em> - пользователь уже ушёл состраницы, но можно поручить браузеру собрать статистику<br>
              <br>
              <em>document.readyState</em> - остояние загрузки:<br>
              <em>loading</em> - документ загружается<br>
              <em>interactive</em> - документ был полностью прочитан<br>
              <em>complete</em> - документ был полностью прочитан и все ресурсы загружены<br>
              <br>
              События, отправленные сервером (SSE), позволяют веб-странице получать обновления с сервера.<br>
              В случае событий, отправленных сервером, обновления приходят автоматически.<br>

          //- Properties
          details
            summary Properties
            p.
              Когда браузер загружает страницу, он читает (парсит) HTML и генерирует DOM-объекты.<br>
              Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся
              свойствами DOM-объектов.<br>
              У каждого тега свои атрибуты:<br>
              Атрибуты написаны в HTML, свойства - в DOM-объектах.<br>
              Можно изменять DOM-узлы добавляя своё свойство.<br>
              Методы для работы с атрибутами:<br>
              <em>elem.hasAttribute(name)</em> - проверить на наличие<br>
              <em>elem.getAttribute(name)</em> - получить значение<br>
              <em>elem.setAttribute(name, value)</em> - установить значение<br>
              <em>elem.removeAttribute(name)</em> - удалить атрибут<br>
              <em>elem.attributes</em> - коллекция всех аттрибутов<br>
              <br>
              <dfn>Свойства</dfn>:<br>
              <em>nodeType</em> - тип DOM-узла.<br>
              Только для чтения.<br>
              Его значение-числовое: 1- элементы, 3 - текстовые узлы и т.д.<br>
              <br>
              <em>nodeName/tagName</em> - возвращает название тега.<br>
              Только для чтения.<br>
              Для узлов - неэлементов описывает, что за узел.<br>
              <br>
              <em>innerHTML</em> - внутренее HTML-содержимое узла-элемента.<br>
              Изменяемый.
              С innerHTML вставка происходит "как HTML", со всеми HTML-тегами.<br>
              <br>
              <em>console.dir(element)</em>; - выведет список доступных свйоств DOM-объекта element<br>
              <em>element.hasAttribute('some-name')</em>; - проверить наличие аттрибута name<br>
              <em>element.getAttribute('some-name')</em>; - получить значение аттрибута name<br>
              <em>element.setAttribute('some-name', value)</em>; - создать аттрибут (some-name) и установить в него значение (value)<br>
              <em>element.removeAttribute('some-name')</em>; - удалить аттрибут name<br>
              <em>element.tagName</em> - показывает какой тег у объекта<br>
              <em>element.hidden = true</em>; - скрыть или показать объект<br>
            img(src="../img/js/JS58.png" alt="")
            br
            img(src="../img/js/JS59.png" alt="")
            br
            img(src="../img/js/JS60.png" alt="")
            br
            img(src="../img/js/JS61.png" alt="")
            br
            br
            p.
              <dfn>Размеры и координаты</dfn><br>
              <em>const mainElement = document.documentElement</em>; - получил объект html<br>
              <em>const mainElementWidth = mainElement.clientWidth</em>; - доступная ширина окна без прокрутки<br>
              <em>const mainElementHeight = mainElement.clientHeight</em>; - доступная высота окна без прокрутки<br>
              <em>const windowWidth = window.innerWidth</em>; - ширина окна с полосой прокрутки<br>
              <em>const windowHeight = window.innerHeight</em>; - высота окна с полосой прокрутки<br>
              <br>
              Ширину и высоту всего документа (включая прокрученную часть) можно найти:<br>
            pre
              code.
                let scrollWidth = Math.max(
                  document.body.scrollWidth, document.documentElement.scrollWidth,
                  document.body.offsetWidth, document.documentElement.offsetWidth,
                  document.body.clientWidth, document.documentElement.clientWidth,
                );

                let scrollHeight = Math.max(
                  document.body.scrollHeight, document.documentElement.scrollHeight,
                  document.body.offsetHeight, document.documentElement.offsetHeight,
                  document.body.clientHeight, document.documentElement.clientHeight,
                );
            br
            p <dfn>Метрики</dfn><br>
            img(src="../img/js/metrics.png" alt="")
            p.
              <em>element.offsetParent</em>; - получаем родительский элемент, относительно которого позиционирован eldfnent<br>
              <em>element.offsetLeft</em>; - отступ слева от родительского элемента element.offsetParent<br>
              <em>element.offsetTop</em>; - отступ сверху от родительского элемента element.offsetParent<br>
              <em>element.offsetWidth</em>; - общая ширина element<br>
              <em>element.offsetHeight</em>; - общая высота element<br>
              <em>element.clientTop</em>; element.clientLeft; - отступы внутренней части element от внешней<br>
              <em>element.clientWidth</em>; element.clientHeight; - размеры объекта без рамок и полосы прокрутки<br>
              <em>element.scrollWidth</em>; element.scrollHeight; - размеры объекта без рамок и полосы прокрутки, включая прокручиваемую часть внутри объекта<br>
              <em>element.scrollLeft</em>; element.scrollTop; - размеры прокрученной области внутри объекта, можно считывать и задавать значения к объекту можно применять scrollBy, scrollTo, scrollIntoView<br>
              <em>element.getBoundingClientRect()</em>; - получить координаты относительно окна браузера<br>
              <em>element.getBoundingClientRect().top + window.pageYOffset</em>; - получить координаты относительно документа<br>
              <em>const elem = document.eldfnentFromPoint(x, y)</em>; - узнать какой элемент находится по указанным координатам (координаты относительно окна браузера)<br>
              <br>
              <em>data-аттрибут</em> - для ввода нестандартных аттрибутов:<br>
              <em>element.dataset.size = "1024"</em>; - установил в аттрибут data-size значение 1024<br>
              <em>alert(document.body.innerHTML)</em>; - читаем текущее содержимое<br>
              <em>document.body.innerHTML = 'Новый BODY!'</em>; - заменяем содержимое<br>
              Если innerHTML вставляет в документ тег  - он становится частью HTML, но не запускается.<br>
              <br>
              <dfn>outerHTML</dfn> - полный HTML узла-элемента.<br>
              Запись в elem.outerHTML заменяет elem во внешнем контексте.<br>
            pre
              code.
                &lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;
                
                alert(elem.outerHTML); - &lt;div id = "elem"&gt;Привет Мир&lt;/div&gt;
            br
            p.
              <dfn>textContent</dfn> - текст внутри элемента: HTML за вычетом всех тегов.<br>
              Запись в него помещает текст в элемент, при этом все спецюсимволы и теги интерпретируются как текст.<br>
              Можно использовать для защиты от вставки произвольного HTML кода.<br>
              <dfn>hidden</dfn> - если true, то скрывает элемент.<br>
              <dfn>nodeValue и data</dfn> - содержимое узла-неэлемнта (текст, комментарий).<br>
              Обычно используют data. Изменяемый.<br>
            pre
              code.
                &lt;p&gt;Привет&lt;/p&gt;
                // Комментарий
                
                let comment = text.nextSibling;
                alert(comment.data); - Комментарий
                
                JS может прочитать if из свойства data и обработать инструкции:
                // if isAdmin
                Добро пожаловать, Админ!
                // /if 
            p.
              Лучше использовать DOM-свойства. Атрибуты используем тогда, когда нужны именно атрибуты.<br>
              Например нестандартный атрибут. Если он начинается с data-, то нужно использовать dataset.<br>
            pre
              code.
                &lt;body data-about = "Elephants"&gt;
                alert(document.body.dataset.about); - Elephants
            p.
              Атрибут из нескольких слов data-order-state это свойство dataset.orderState<br>
              Геометрические свойства (метрики) DOM-элементов<br>
              <dfn>offsetParent</dfn> - ближайший CSS-позиционированный родитель или td, th, table, body.<br>
              <dfn>offsetLeft/offsetTop</dfn> - позиция в пикселях верхнего левого угла offsetParent.<br>
              <dfn>offsetWidth/offsetHeight</dfn> - внешняя ширина/высота элемента, включая рамки.<br>
              <dfn>clientLeft/clientTop</dfn> - это border - отступ внутренней части элемента от внешней.<br>
              <dfn>clientWidth/clientHeight</dfn> - ширина/высота сожержимого вместе <br>
              с внутренними отступами padding, но без полосы прокрутки.<br>
              <dfn>scrollWidth/scrollHeight</dfn> - ширина/высота содержимого с учетом <br>
              прокрученной (невидимой) области элемента.<br>
              <dfn>scrollLeft/scrollTop</dfn> - ширина/высота прокрученной сверху части элемента,
              считается от верхнего левого угла.<br>
              <br>
              Все кроме scrollLeft/scrollTop доступны только для чтения.<br>
              Если элемент, или любой его родитель, имеет display:none или отсутствует в документе, 
              то все его метрики равны нулю (или null если это offsetParent).<br>
              Лучше использовать свойства-метрики т.к. CSS-свойства width/height зависят от другого свойства - box-sizing,
              которое определяет CSS-ширину/высоту.<br>
              Изменение box-sizing сломает код.<br>
              CSS-свойства width/height могут быть равны auto.<br>
              Ширина/высота видимой части документа:<br>
              document.documentElement.clientWidth/Height
              Ширина/высота всего документа с прокрученной частью:<br>
            pre
              code.
                let scrollHeight = Math.max(
                  document.body.scrollHeight, document.documentElement.scrollHeight,
                  document.body.offsetHeight, document.documentElement.offsetHeight,
                  document.body.clientHeight, document.documentElement.clientHeight,
                );
            p.
              <dfn>Прокрутка</dfn>:<br>
              <em>window.pageYOffset/pageXOffset</em> - прокрутка окна.<br>
              <em>window.scrollTo(pageX, pageY)</em> - абсолютные координаты.<br>
              <em>window.scrollTo(0, 0)</em> - прокрутка в самое начало.<br>
              <em>window.scrollBy(x, y)</em> - прокрутка относительно текущего места.<br>
              <em>window.scrollBy(0, 10)</em> - прокручивает страницу на 10рх вниз.<br>
              <em>window.scrollIntoView(top)</em> - прокрутить страницу, чтобы eldfn стал видимым
              (выровнять относительно верхней/нижней части окна).<br>
              <br>
              Количество прокрученных пикселей (только для чтения):<br>
              <em>const windowScrollTop = window.pageYOffset</em>; - количество пикселей прокрученных сверху<br>
              <em>const windowScrollLeft = window.pageXOffset</em>; - количество пикселей прокрученных слева<br>
              <em>window.scrollBy(x, y)</em>; - прокручивает страницу относительно текущего положения<br>
              <em>window.scroll(x, y)</em>; - прокручивает страницу на абсолютные координаты<br>
              <em>window.scrollTo(x, y)</em> - прокручивает страницу на абсолютные координаты<br>
              <em>element.scrollIntoView(top)</em>; - прокрутит страницу до элемента element.<br>
                        Если <b>top = true</b>, то элемент будет вверху страницы<br>
                        Если <b>top = false</b>, то элемент будет внизу страницы<br>
              Запретить или разрешить прокрутку:<br>
              <em>document.body.style.overflow = "hidden"</em>; - добавляет <b>overflow = "hidden"</b> в аттрибут style тега body<br>
              либо<br>
              <em>document.body.classList.toggle('scroll-lock')</em>; - добавляет класс в тег body,<br>
              потом нужно добавить в класс css-свойство <b>overflow = "hidden"</b><br>
              <br>
              Для прокрутки страницы из JS её DOM должен быть полностью построен.<br>
            code  document.body.style.overflow = "hidden"
            p.
              Все координаты в контексте окна считаются от верхнего левого угла.<br>
              <em>position: fixed</em>; - для координат относительно окна.<br>
              <em>position: absolute</em>; - для координат относительно документа.<br>
              Любая точка на странице имеет координаты:<br>
              - относительно окна браузера - <b>elem.getBoundingClientRect()</b><br>
              - относительно документа - <b>elem.getBoundingClientRect()</b> + прокрутка страницы.<br>
              <em>document.elementFromPoint(x, y)</em> - возвращает самый глубоко вложенный элемент по координатам (х, у). <br>
              Для координат вне окна возвращает null.<br>
              <br>
              <dfn>CSS</dfn>:<br>
              CSS-событие <em>transitioned</em> - CSS-анимация завершена.<br>
              Два способа задания стилей элементу:<br>
              &lt;div class=" "&gt; - создать класс в CSS и использовать его<br>
              &lt;div style="color:some"&gt; - писать стили в атрибуте style<br>
              JS может менять и классы CSS и свойство style.<br>
              Лучше использовать классы. Свойство style только если класс не подходит.<br>
              Для управления классами существует два DOM-свойства:<br>
              <em>className</em> - строковое значение, заменяет всю строку с классами.<br>
              <em>classList</em> - объект с методами для управления одним классом.<br>
              <br>
              <dfn>Методы classList</dfn>:<br>
              <em>elem.classList.add/remove("class")</em> - добавить/удалить класс.<br>
              <em>elem.classList.toggle("class")</em> - добавит класс если его нет, иначе удалит.<br>
              <em>elem.classList.contains("class")</em> - проверка наличия класса, возвращает true/false.<br>
              <br>
              Свойство style это объект со стилями в camelCase:<br>
            pre
              code.
                background-color - elem.style.backgroundColor
                z-index - elem.style.zIndex
                border-left-width - elem.style.borderLeftWidth
                style = "width: 100px" - elem.style.width = "100px"
              <br>
            p Чтобы удалить elem.style.display нужно присвоить пустую строку:<br>
            code elem.style.display = "".
            p Свойство <em>style.cssText</em> - вся строка стилей атрибута style:
            pre
              code.
                &lt;div id = "div"&gt;Button&lt;/div&gt;
                
                div.style.cssText = `
                color: red !important;
                background-color: yellow;
                width: 100px;
                text-align: center;`
                alert(div.style.cssText);
            p.
              <dfn>getComputedStyle(eldfn, [psevdo])</dfn> - возвращает объект для чтения окончательных стилей 
              с учетом всех классов, после применения CSS и вычисления окончательных значений.<br>
              eldfn - элемент, значения для которого нужно получить.<br>
              psevdo - если нужен псевдоэлемент ::before.<br>
              Без аргумента означает сам элемент.<br>

          //- Storage
          details
            summary Storage
            p.
              <dfn>localStorage и sessionStorage</dfn> - объекты вэб-хранилища, позволяют хранить пары ключ/значение в браузере.<br>
              <em>key и value</em> - строки<br>
              <em>Лимит 2 Mb</em> - зависит от браузера<br>
              Данные не имеют срока хранения<br>
              Данные привязаны к источнику (домен/протокол/порт)<br>
              <dfn>localStorage</dfn> - используется между всеми вкладками и окнами одного источника совместно. Переживает перезапуск браузера.<br>
              <dfn>sessionStorage</dfn> - разделяется в рамках вкладки браузера, среди ифреймов из того же источника.<br>
              Переживает перезагрузку страницы, но не закрытие вкладки.<br>
              <br>
              <dfn>API</dfn>:<br>
              <em>setItdfn(key, value)</em> - сохранить пару ключ/значение<br>
              <em>getItdfn(key)</em> - получить данные по ключу key<br>
              <em>rdfnoveItdfn(key)</em> - удалить значение по ключу key<br>
              <em>clear()</em> - удалить всё<br>
              <em>key(index)</em> - получить ключ по заданной позиции<br>
              <em>length</em> - количество элементов в хранилище<br>
              <em>Object.keys</em> - получить все ключи<br>
              Если обращаться к ключам как к обычным свойствам объекта, то событие storage не срабатывает.<br>
              <br>
              <dfn>Событие storage</dfn>:<br>
              Срабатывает при вызове <b>setItdfn, rdfnoveItdfn, clear</b><br>
              Содержит все данные о произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea<br>
              Срабатывает на всех объектах window, которые имеют доспут к хранилищу, кроме того где оно было сгенерировано 
              (внутри вкладкидля sessionStorage, глобально для localStorage)<br>
              <br>
              <dfn>IndexedDB</dfn> - встроенная база данных типа ключ-значение, мощнее localStorage.<br>
              Интерфейс для IndexedDB основан на событиях IndexedDB имеет встроенный механизм версионирования схемы, 
              который отсутствует в серверных базах данных.<br>
              IndexedDB работает на стороне клиента (в браузере) и у нас нет прямого доступа к данным.<br>
              При публикации новой версии приложения возможно обновлять базу данных.<br>
              <br>
              <dfn>Использование</dfn>:<br>
              Пoдключить обёртку над промисами (idb)<br>
              Открыть базу данных: <b>idb.openDb(name, version, onupgradeneeded)</b><br>
              Создание хранилищ объектов и индексов в обработчике onupgradeneeded<br>
              Обновление версии - либо сравнивая номера версий, либо проверить что есть, а что нет.<br>
              <br>
              <dfn>Для запросов</dfn>:<br>
              Создать транзакцию <b>db.transaction('books')</b> - можно указать readwrite.<br>
              Получить хранилище объектов <b>transaction.objectStore('books')</b>.<br>
              Для поиска по ключу вызвать метод непосредственно у хранилища объектов.<br>
              Для поиска по любому полю объекта нужно создать индекс.<br>
              Если данных не помещаются в памяти, то используй курсор.

      //- SQL
      details
        summary.menu__submenu_lv1 SQL
        a(href="https://dbdiagram.io/home") Diagram

        //- Definition
        details
          summary Определение (Definition)
          p.
            <dfn>SQL</dfn> — применяется для создания, модификации и управления данными в реляционной базе данных, 
            управляемой соответствующей системой управления базами данных.<br>
            В базовом варианте SQL является информационно-логическим языком, а не языком программирования. <br>
            <br>
            <dfn>Система управления базами данных (СУБД)</dfn> — совокупность программных и лингвистических средств
            общего или специального назначения, обеспечивающих управление созданием и использованием баз данных. <br>
            <br>
            <dfn>База данных (БД)</dfn> - под БД (БД) понимают хранилище структурированных данных, 
            при этом данные должны быть непротиворечивы, минимально избыточны и целостны. <br>
            <br>
            <dfn>Реляционная база данных</dfn> — база данных, основанная на реляционной модели данных. <br>
            Реляционные БД представляют связанную между собой совокупность таблиц-сущностей БД. <br>
            Каждая таблица БД представляется как совокупность строк и столбцов, где строки соответствуют
            экземпляру объекта, конкретному событию или явлению, а столбцы - атрибутам (признакам,
            характеристикам, параметрам) объекта, события, явления. <br>
            При практической разработке БД таблицы-сущности зовутся таблицами, строки-экземпляры - записями,
            столбцы-атрибуты - полями. <br>
            <br>
            <em>Преимущества SQL</em> - наличие стандартов и независимость от конкретной СУБД. <br>
            <em>Недостатки SQL</em> - сложность. <br>
          br
          p.
            <dfn>Классификация по модели данных:</dfn><br>
            <em>Иерархическая</em><br>
            <em>Объектная и объектно-ориентированная</em><br>
            <em>Объектно-реляционная</em><br>
            <em>Реляционная</em><br>
            <em>Сетевая</em><br>
            <em>Функциональная</em><br>
            <br>
          p.
            <dfn>Типы отношений:</dfn><br>
            <em>Один к одному (one-to-one)</em> <br>
            <em>Один ко многим (one-to-many)</em> <br>
            <em>Многие к одному (many-to-one)</em> <br>
            <em>Многие ко многим (many-to-many, реализуется через отдельную таблицу)</em> <br>
          img(src="../img/sql/SQL12.png" alt="")
          p Источник:
            a(href="https://drawsql.app/") Рисовать диаграмму БД онлайн
            a(href="https://sql-ex.ru/?Lang=0") sql-ex
            a(href="https://sqlbolt.com/lesson/") sqlbolt
            a(href="https://sql-academy.org/ru/guide") sql-academy
            a(href="https://www.w3schools.com/sql/default.asp") W3Schools SQL Tutorial
            a(href="https://www.w3schools.com/sql/exercise.asp?") w3schools SQL Exercises
        
        //- Data Definition Language, DDL
        details
          summary Операторы определения данных (Data Definition Language, DDL)
          p.
            <dfn>CREATE</dfn> - создает объект БД (саму базу, таблицу, представление, пользователя и т. д.)<br>
            to create a new SQL database<br>
            <dfn>CREATE DATABASE</dfn> database name;<br>
            Создать таблицу table со столбцами id, field_1, field_2, field_3.<br>
            По каждому столбцу заданы тип и количество символов.<br>
          pre
            code.
              <dfn>CREATE TABLE</dfn> table(
                id <dfn>INT PRIMARY KEY</dfn>,
                field_1 <dfn>VARCHAR</dfn>(100),
                field_2 <dfn>VARCHAR</dfn>(30),
                field_3 <dfn>INT</dfn>
              );
          p.
            <dfn>DESCRIBE</dfn> table - информация о таблице<br>
            <dfn>PRIMARY KEY</dfn> - уникальный идентификатор записей.<br>
            <dfn>FOREIGN KEY</dfn> - внешний ключ, значения идентификатора записей в связанной таблице.<br>
            <dfn>SERIAL</dfn> - автоинкремент идентификатора в PostgreSQL<br>
            <dfn>AUTO_INCREMENT</dfn> - автоинкремент идентификатора в MySQL<br>
          pre
            code.
              <dfn>CREATE TABLE</dfn> table(
                id <dfn>SERIAL PRIMARY KEY</dfn>,
                field_1 <dfn>VARCHAR</dfn>(100),
                field_2 <dfn>VARCHAR</dfn>(30),
                field_3 <dfn>INT</dfn>
              );
            
          p.
            Ограничения на уровне таблицы:<br>
            Значения в столбцах id и field_1 уникальные и не пустые<br>
            Значения столбца field_table_2_id - ссылки на id таблицы table_2<br>
            Либо RESTRICT - запретить удалять id таблицы table_2<br>
            Либо CASCADE -  при удалении id таблицы table_2, удалить соответствующие записи<br>
            Ограничение с именем positive_field<br>
            Значения в столбце field_3 должны быть положительными<br>
          pre
            code.
              <dfn>CREATE TABLE</dfn> table_1(
                id <dfn>PRIMARY KEY</dfn>,
                field_1 <dfn>VARCHAR</dfn>(100) <dfn>UNIQUE NOT NULL</dfn>, 
                field_2 <dfn>VARCHAR</dfn>(30),
                field_3 <dfn>INT</dfn>,
                field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id)
                <dfn>ON DELETE RESTRICT</dfn>
                <dfn>CONSTRAINT</dfn> positive_field
                <dfn>CHEK</dfn> (field_3 >= 0)
              );
          p Уникальный идентификатор состоит из двух столбцов
          pre
            code.    
              <dfn>CREATE TABLE</dfn> table_1(
                field_table_2_id <dfn>INT REFERENCES</dfn> table_2(id),
                field_table_3_id <dfn>INT REFERENCES</dfn> table_3(id),
                quantity <dfn>INT</dfn>,
                <dfn>PRIMARY KEY</dfn>(field_table_2_id, field_table_3_id)
              );
          p.
            <dfn>ALTER</dfn> - изменяет объект
            Изменить таблицу table, добавить столбец field_4 с типом BOOLEAN
          pre
            code.
              <dfn>ALTER TABLE</dfn> table 
              <dfn>ADD COLUMN</dfn> field_4 <dfn>BOOLEAN</dfn>;
            <br>
          p Изменить таблицу table, удалить столбец field_4
          pre
            code.
              <dfn>ALTER TABLE</dfn> table 
              <dfn>DROP COLUMN</dfn> field_4;
            <br>
          p Изменить таблицу table, переименовать столбец field_4 в field_5
          pre
            code.
              <dfn>ALTER TABLE</dfn> table 
              <dfn>RENAME COLUMN</dfn> field_4 <dfn>TO</dfn> field_5;
            <br>
          p Изменить таблицу table, переименовать в another_table
          pre
            code.
              <dfn>ALTER TABLE</dfn> table 
              <dfn>RENAME TO</dfn> another_table;
            <br>     
          p <dfn>DROP</dfn> - удаляет объект
          code <dfn>DROP TABLE</dfn> table 

          p Скрипт создания таблицы:
          pre
            code.
              <dfn>DROP TABLE IF EXISTS</dfn> table;
              <dfn>CREATE TABLE</dfn> table(
                id <dfn>SERIAL PRIMARY KEY</dfn>,
                field_1 <dfn>VARCHAR</dfn>(100),
                field_2 <dfn>VARCHAR</dfn>(30),
                field_3 <dfn>INT</dfn>
              );
            <br>
          p <dfn>BACKUP</dfn> - резервное копирование
          pre
            code.
              <dfn>BACKUP DATABASE</dfn> testDB
              <dfn>TO DISK</dfn> = 'D:\backups\testDB.bak'; 
            
        //- Data Manipulation Language, DML
        details
          summary Операторы манипуляции данными (Data Manipulation Language, DML)
          //- SELECT
          details
            summary SELECT
            p <dfn>SELECT</dfn> - выбирает данные, удовлетворяющие заданным условиям, 
            code <dfn>SELECT * FROM</dfn> table
            p.
              Для примера используем таблицу table со столбцами field_1, field_2 и т.д.
              У каждого столбца свои значения value_1, value_2, value_3 и т.д.
              Выбираю столбец (field_1) и столбец (field_2) из таблицы (table)
            pre
              code.
                <dfn>SELECT</dfn> field_1, field_2
                <dfn>FROM</dfn> table;
            p Ключевое слово AS назначает псевдоним f1 столбцу field_1
            pre
              code.
                <dfn>SELECT</dfn> field_1 <dfn>AS</dfn> f1
                <dfn>FROM</dfn> table;
            p Выбрать только уникальные значения столбца field_1
            pre
              code.
                <dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
                <dfn>FROM</dfn> table;
            p Выбрать первых 10 уникальных значений столбца field_1
            pre
              code.
                <dfn>SELECT</dfn> <dfn>DISTINCT</dfn>(field_1)
                <dfn>FROM</dfn> table
                <dfn>LIMIT</dfn> 10;
            p Выбрать из таблицы table все строки со значением value в столбце field_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_2 = 'value';
            p Ключевое слово WHERE и фильтр field_2 = 'value'
            pre.
              Используем в <dfn>WHERE</dfn>:
                =         Равно
                <>, !=    Неравно
                >         Больше
                >=        Больше или равно
                <         Меньше
                <=        Меньше или равно
                BETWEEN   Значение в диапозоне
                IN        Значение в списке
                LIKE      Соответствие шаблону
                AND       Логическое И
                OR        Логическое ИЛИ
                NOT       Логическое НЕ

            p Выбрать из таблицы table все строки со значениями от value_1 по value_2 в столбце field_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_2
                <dfn>BETWEEN</dfn> value_1 AND value_2;
              
            p Выбрать из таблицы table все строки со значениями по списку IN из столбца field_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_2
                <dfn>IN</dfn> (value_1, value_2, value_3);
              
            p Выбрать из таблицы table все строки, у которых в столбе field_2 значение содержит value
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_2
                <dfn>LIKE</dfn> '%value%';
            p.
              Спец.символы в шаблонах LIKE:<br>
              <dfn>%</dfn> - любое количество символов (можно и без символов)<br>
              <dfn>_</dfn> - ровно один символ
              
            p Return all customers starting with "a", "b", "c", "d", "e" or "f":
            pre
              code.
                <dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
                <dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[a-f]%';
              
            p Return all customers starting with either "b", "s", or "p":
            pre
              code.
                <dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
                <dfn>WHERE</dfn> CustomerName <dfn>LIKE</dfn> '[bsp]%';
              
            p Return all customers starting with NOT either "b", "s", or "p":
            pre
              code.
                <dfn>SELECT</dfn> * <dfn>FROM</dfn> Customers
                <dfn>WHERE</dfn> City <dfn>LIKE</dfn> '[!bsp]%';
              
            p Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = value_3
                <dfn>AND</dfn> field_2 = value_2;
              
            p Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 либо в столбце field_2 значение value_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = value_3
                <dfn>OR</dfn> field_2 = value_2;
              
            p Выбрать из таблицы table все строки со значениями вне списка IN из столбца field_2
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_2
                <dfn>NOT IN</dfn> (value_1, value_2, value_3);
              
            p.
              Порядок сортировки в ORDER BY:<br>
              <dfn>ASC</dfn> (ascending) - сортировка по возрастанию (по умолчанию)<br>
              <dfn>DESC</dfn> (descending) - сортировка по убыванию<br>
            
            p.
              Выбрать из таблицы table все строки и отсортировать их по столбцу field_3
              Сортировка данных по столбцу field_3, по умолчанию это ASC
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>ORDER BY</dfn> field_3
            p Сортировка данных по столбцу field_3 по убыванию
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
              
            p Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 и отсортировать по столбцу field_3 по убыванию
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = value_3
                <dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>;
              
            p Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2 и отсортировать по столбцу field_3 по убыванию и вывести первые пять строк
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = value_3
                <dfn>AND</dfn> field_2 = value_2
                <dfn>ORDER BY</dfn> field_3 <dfn>DESC</dfn>
                <dfn>LIMIT</dfn> 5;
              
            p Выбрать из таблицы table все строки и отсортировать по двум столбцам
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>FROM</dfn> table
                <dfn>ORDER BY</dfn> field_3, field_2;
              
            p Выбрать из таблицы table столбец field_1 строки в котором не имеют значений
            pre
              code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NULL</dfn>; 
              
            p Выбрать из таблицы table столбец field_1 строки в котором имеют значения
            pre
              code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 <dfn>IS</dfn> <dfn>NOT</dfn> <dfn>NULL</dfn>;
              
            p.
              The EXISTS operator is used to test for the existence of any record in a subquery.
              The EXISTS operator returns TRUE if the subquery returns one or more records.
            pre
              code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> <dfn>EXISTS</dfn>
                (<dfn>SELECT</dfn> field_2
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> condition); 
              
            p ANY means that the condition will be true if the operation is true for any of the values in the range.
            pre
              code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = <dfn>ANY</dfn>
                (<dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> condition);
              
            p ALL means that the condition will be true only if the operation is true for all values in the range.
            pre
              code.
                <dfn>SELECT</dfn> <dfn>ALL</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> condition;code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = <dfn>ALL</dfn>
                (<dfn>SELECT</dfn> field_2
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> condition);
              
            p Copy all columns into a new table
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>INTO</dfn> newtable [IN externaldb]
                <dfn>FROM</dfn> oldtable
                <dfn>WHERE</dfn> condition;
              
            p The following SQL statement uses the IN clause to copy the table into a new table in another database
            pre
              code.
                <dfn>SELECT</dfn> *
                <dfn>INTO</dfn> CustomersBackup2017
                <dfn>IN</dfn> 'Backup.mdb'
                <dfn>FROM</dfn> Customers;
              
            p The following SQL statement copies only a few columns into a new table
            pre
              code.
                <dfn>SELECT</dfn> CustomerName, ContactName
                <dfn>INTO</dfn> CustomersBackup2017
                <dfn>FROM</dfn> Customers;
            br  
            p.
              <dfn>Агрегатные функции:</dfn>
              <br>
              <dfn>COUNT</dfn> - Возвращает количество строк источника записей
              Считает количество записей в таблице table
            pre
              code.
                <dfn>SELECT</dfn> <dfn>COUNT</dfn>(*)
                <dfn>FROM</dfn> table
            p Считает количество записей в столбцe field_2 таблицы table
            pre
              code.
                <dfn>SELECT</dfn> <dfn>COUNT</dfn>(field_2)
                <dfn>FROM</dfn> table
            p Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам и посчитать сколько записей каждого вида
            pre
              code.
                <dfn>SELECT</dfn> field_2,
                <dfn>COUNT</dfn>(*)
                <dfn>FROM</dfn> table
                <dfn>GROUP BY</dfn> field_2
              
            p.
              Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
              посчитать сколько записей каждого вида в столбце field_3 и вывести в новом столбе field_3
            pre
              code.
                  <dfn>SELECT</dfn> field_2,
                  <dfn>COUNT</dfn>(field_2) AS field_3
                  <dfn>FROM</dfn> table
                  <dfn>GROUP BY</dfn> field_2
            br 
            p.
              <dfn>SUM</dfn> - Возвращает сумму значений в указанном столбце.
              Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
              посчитать сколько записей каждого вида и суммировать значения в столбце field_3 соответствующих сгруппированным видам
            pre
              code.
                <dfn>SELECT</dfn> field_2,
                <dfn>COUNT</dfn>(*),
                <dfn>SUM</dfn>(field_3)
                <dfn>FROM</dfn> table
                <dfn>GROUP BY</dfn> field_2
            <br>  
            p.
              <dfn>AVG</dfn> - Возвращает среднее значение в указанном столбце.
              Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
              посчитать среднее значение по каждому виду в столбце field_3.
              Среднее расчитывается со знаками после запятой.
            pre
              code.
                <dfn>SELECT</dfn> field_2,
                <dfn>AVG</dfn>(field_3) 
                <dfn>FROM</dfn> table
                <dfn>GROUP BY</dfn> field_2
              
            p Посчитать среднее без знака после запятой
            pre
              code.
                <dfn>SELECT</dfn> field_2,
                <dfn>SUM</dfn>(field_3)/<dfn>COUNT</dfn>(*)
                <dfn>AS</dfn> average 
                <dfn>FROM</dfn> table
                <dfn>GROUP BY</dfn> field_2
            br  
            p.
              <dfn>MIN</dfn> - Возвращает минимальное значение в указанном столбце
              Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам,
              определить минимальное и максимальное значение каждого вида в столбце field_3, вывести столбец field_2 
              с групированными значениями, столбец минимальных и столбец максимальных значений каждого вида,
              отсортировать по убыванию по столбцу максимальных значений
            pre
              code.
                <dfn>SELECT</dfn> field_2,
                <dfn>MIN</dfn>(field_3),
                <dfn>MAX</dfn>(field_3)
                <dfn>FROM</dfn> table
                <dfn>GROUP BY</dfn> field_2
                <dfn>ORDER BY MAX</dfn>(field_3) <dfn>DESC</dfn>
            br
            p.
              <dfn>MAX</dfn> - Возвращает максимальное значение в указанном столбцe.
              Считает все функции в таблице table
            pre
              code.
                <dfn>SELECT COUNT</dfn>(*),
                <dfn>MIN</dfn>(field_2),
                <dfn>MAX</dfn>(field_2),
                <dfn>SUM</dfn>(field_2),
                <dfn>AVG</dfn>(field_2)
                <dfn>FROM</dfn> table
            br  
            p <dfn>LENGTH()</dfn> - возвращает длину строки
            pre
              code.
                <dfn>SELECT</dfn> field_1
                <dfn>FROM</dfn> table
                <dfn>WHERE LENGTH</dfn>(field_2) > 15;
              
            p Вывести id строк, в которых значение temperature больше temperature предыдущего дня 
            pre
              code.
                <dfn>SELECT</dfn> current_day.id
                <dfn>FROM</dfn> Weather <dfn>AS</dfn> current_day
                <dfn>WHERE EXISTS</dfn> (
                  <dfn>SELECT</dfn> 1
                  <dfn>FROM</dfn> Weather <dfn>AS</dfn> yesterday
                  <dfn>WHERE</dfn> current_day.temperature > yesterday.temperature
                  <dfn>AND</dfn> current_day.recordDate = yesterday.recordDate + 1
                );
            br 
            p.
              <dfn>Подзапросы (subqueries)</dfn>:<br>
              Сначала выполняются подзапросы.
              Выбрать из таблицы table все строки со значением value_3 в столбце field_1,
              отсортировать по видам в столбце field_2, посчитать количество строк по каждому виду,
              отсортировать виды, у которых количество строк больше 10.
              HAVING работает с результатами группировки
            pre
              code.
                <dfn>SELECT</dfn> field_2, <dfn>COUNT</dfn>(*)
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_1 = value_3
                <dfn>GROUP BY</dfn> field_2
                <dfn>HAVING COUNT</dfn>(*) > 10
              
            p Выбрать столбцы field_2 и field_3 из таблицы table и выбрать максимальное значение столбца field_3 таблицы table
            pre
              code.
                <dfn>SELECT</dfn> field_2, field_3
                <dfn>FROM</dfn> table
                <dfn>WHERE</dfn> field_3 = (
                  <dfn>SELECT</dfn> <dfn>MAX</dfn>(field_3) 
                  <dfn>FROM</dfn> table)
              
            p Выбрать столбцы field_2 и field_3 из таблицы table_1 и отобрать строки, id которых есть в столбце field_table_1_id таблицы table_2
            pre
              code.
                <dfn>SELECT</dfn> field_2, field_3
                <dfn>FROM</dfn> table_1
                <dfn>WHERE</dfn> id <dfn>IN</dfn> (
                  <dfn>SELECT</dfn> field_table_1_id 
                  <dfn>FROM</dfn> table_2)
              
            p.
              Выбрать значения id таблицы table_1 у которых в столбце field_3 значение value_1,
              увеличить значения столбца field_2 на 500 в строках, 
              у которых значение в столбце field_table_1_id равно значениям отобранных id
            pre
              code.
                <dfn>UPDATE</dfn> table_2
                <dfn>SET</dfn> field_2 = field_2 + 500
                <dfn>WHERE</dfn> field_table_1_id = (
                  <dfn>SELECT</dfn> id 
                  <dfn>FROM</dfn> table_1
                  <dfn>WHERE</dfn> field_3 = value_1)
            br  
            p.
              <dfn>Представления</dfn>:<br>
              Представление <dfn>VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.<br>
              Данные в представлении не хранятся, представление ссылается на таблицу.<br>
              Представление можно создавать из нескольких таблиц.<br>
              Используется как обычная таблица.<br>
              Применяется для ограничения доступа к данным, сокрытия реализации БД,
              для избегания повторять выполнение сложных запросов и составных таблиц.<br>
              Удалить представление <dfn>DROP VIEW</dfn>
            pre
              code.
                <dfn>CREATE VIEW</dfn> table_v field_1, field_2
                <dfn>AS SELECT</dfn> field_1, field_2
                <dfn>FROM</dfn> table
            p.
              Материализованное представление <dfn>MATERIALIZED VIEW</dfn> - псевдоним для запроса <dfn>SELECT</dfn>.
              Поддерживаются не всеми СУБД.
              Данные храняться в представлении.
              Представление можно создавать из нескольких таблиц.
              Используется как обычная таблица.
              Применяется для часто используемых запросом с длительным выполнением.
              В случае изменения данных в таблице, на которую ссылается материализованное представление, <br>
              выполнить <dfn>REFRESH MATERIALIZED VIEW</dfn> table_v <br>
              Удалить материализованное представление <dfn>DROP MATERIALIZED VIEW</dfn>
            pre
              code.
                <dfn>CREATE MATERIALIZED VIEW</dfn> table_v field_1, field_2
                <dfn>AS SELECT</dfn> field_1, field_2
                <dfn>FROM</dfn> table
            br    
            p.
              <dfn>Индексы</dfn>:<br>
              Индексы - повышают производительность выполнения запросов <dfn>SELECT</dfn>.<br>
              СУБД применяют индексы при выполнении операторов автоматически.<br>
              Создать индекс<br>
              Название индекса table_field_idx<br>
              Индекс создаётся для столбца field таблицы table<br>
            pre
              code.
                <dfn>CREATE INDEX</dfn> table_field_idx
                <dfn>ON</dfn> table(field)
            p Удаление индекса
            code <dfn>DROP INDEX</dfn> table_field_idx;
          
          //- CASE
          details
            summary CASE
            p.
              The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement).<br>
              So, once a condition is true, it will stop reading and return the result.<br>
              If no conditions are true, it returns the value in the ELSE clause.<br>
              If there is no ELSE part and no conditions are true, it returns NULL.
            pre
              code.
                <dfn>CASE</dfn>
                  <dfn>WHEN</dfn> condition1 <dfn>THEN</dfn> result1
                  <dfn>WHEN</dfn> condition2 <dfn>THEN</dfn> result2
                  <dfn>WHEN</dfn> conditionN <dfn>THEN</dfn> resultN
                  <dfn>ELSE</dfn> result
                <dfn>END</dfn>; 
              
          //- JOIN
          details
            summary JOIN
            p.
              Внутренее объединение INNER:<br>
              Внутренее объединение - это соединение строк из одной таблицы 
              для которых есть соответствующие строки из другой таблицы.<br>
              <br>
              <dfn>Неявное объединение:</dfn><br>
              Выбрать все столбцы из таблицы table_1 и table_2,<br>
              строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 
              равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2
            pre
              code.
                <dfn>SELECT</dfn> * 
                <dfn>FROM</dfn> table_1, table_2
                <dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id
            p либо
            pre
              code.
                <dfn>SELECT</dfn> * <dfn>FROM</dfn> table_1 
                <dfn>CROSS</dfn> <dfn>JOIN</dfn> table_2 
                <dfn>WHERE</dfn> table_1.id = table_2.field_table_1_id
            br
            p.
              <dfn>Явное объединение:</dfn><br>
              Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
              строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
              равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2
            pre
              code.
                <dfn>SELECT</dfn> table_1.field.2, table_2.field_3
                <dfn>FROM</dfn> table_1 <dfn>JOIN</dfn> table_2 
                <dfn>ON</dfn> table_1.id = table_2.field_table_1_id
            br
            p Псевдонимы
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
                <dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
            p либо
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 t1 <dfn>JOIN</dfn> table_2 t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
            p.
              Выбрать столбeц field.2 из таблицы table_1 и столбец field.3 из table_2,
              строки сопоставить по значению в столбце id (PRIMARY KEY) table_1
              равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2,
              отобрать строки где значение в столбце field_2 таблицы table_1 равно value_1
              и где значение в столбце field_3 таблицы table_2 равно value_4, отсортировать по столбцу field_2 таблицы table_2
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
                <dfn>JOIN</dfn> table_2 <dfn>AS</dfn> t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
                <dfn>WHERE</dfn> t1.field_2 = value_1
                <dfn>AND</dfn> t2.field_3 = value_4
                <dfn>ORDER BY</dfn> t2.field_2 DESC
            br
            p.
              Внешнее объединение {[LEFT] | [RIGHT] | [FULL]} OUTER:
              Внутренее объединение - это соединение строк из одной таблицы 
              для которых нет соответствующих строк из другой таблицы.
            br
            p <dfn>LEFT</dfn> - все строки таблицы слева от ключевого слова <dfn>JOIN</dfn>
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
                <dfn>LEFT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
            br
            p <dfn>RIGHT</dfn> - все строки таблицы справа от ключевого слова <dfn>JOIN</dfn>
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
                <dfn>RIGHT OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
            br
            p <dfn>FULL</dfn> - все строки обеих таблиц
            pre
              code.
                <dfn>SELECT</dfn> t1.field.2, t2.field_3
                <dfn>FROM</dfn> table_1 <dfn>AS</dfn> t1 
                <dfn>FULL OUTER JOIN</dfn> table_2 <dfn>AS</dfn> t2
                <dfn>ON</dfn> t1.id = t2.field_table_1_id
            br
            p.
              Перекрёсное объединение CROSS:
              Перекрёсное объединение - это соединение строк из обоих таблиц 
              по принципу каждая с каждой.
            pre
              code.
                  <dfn>SELECT</dfn> t1.field.2, t2.field_3
                  <dfn>FROM</dfn> table_1 <dfn>CROSS JOIN</dfn> table_2
              
          //- INSERT
          details
            summary INSERT
            p.
              <dfn>INSERT</dfn> добавляет новые данные
              Вставить в таблицу table значение value_2 в столбец field_1, value_4 в столбец field_2
            pre
              code.
                <dfn>INSERT INTO</dfn> table (field_1, field_2)
                <dfn>VALUES</dfn> (value_2, value_4);
            p Copy all columns from one table to another table
            pre
              code.
                <dfn>INSERT</dfn> <dfn>INTO</dfn> table2
                <dfn>SELECT</dfn> * <dfn>FROM</dfn> table1
                <dfn>WHERE</dfn> condition;
            p Copy only some columns from one table into another table
            pre
              code.
                <dfn>INSERT</dfn>
                <dfn>INTO</dfn> table2 (column1, column2, column3, ...)
                <dfn>SELECT</dfn> column1, column2, column3, ...
                <dfn>FROM</dfn> table1 <dfn>WHERE</dfn> condition;
              
          //- UPDATE
          details
            summary UPDATE
            p.
              <dfn>UPDATE</dfn> изменяет существующие данные
              Обновить значения value_3 в столбец field_2, value_2 в столбец field_3, в строке с id = 1
            pre
              code.
                <dfn>UPDATE</dfn> table
                <dfn>SET</dfn> field_2 = value_3, field_3 = value_2
                <dfn>WHERE</dfn> id = 1
            p.
              Обновить значения во всех строках где в столбце field_2 значение value_1, 
              вставить в столбец field_3 значение value_2
            pre
              code.
                <dfn>UPDATE</dfn> table
                <dfn>SET</dfn> field_3 = value_2
                <dfn>WHERE</dfn> field_2 = value_1
              
          //- DELETE
          details
            summary DELETE
            p.
              <dfn>DELETE</dfn> удаляет данные<br>
              Удалить из таблицы table строку с id = 2
            code <dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> id = 2
              
            p Удалить из таблицы table строки со значением value_1 в столбце field_2
            code <dfn>DELETE</dfn> <dfn>FROM</dfn> table <dfn>WHERE</dfn> field_2 = value_1
              
            p Удалить из таблицы table все данные
            code <dfn>DELETE</dfn> <dfn>FROM</dfn> table

            p to delete all data inside a table.
            code <dfn>TRUNCATE</dfn> <dfn>TABLE</dfn> table;
          
          //- UNION
          details
            summary UNION
            p.
              <dfn>UNION</dfn> – объединение:<br>
              применяется для объединения результатов двух SQL-запросов
              в единую таблицу, состоящую из схожих строк.<br> Оба запроса должны
              возвращать одинаковое число столбцов и совместимые типы данных
              в соответствующих столбцах!!!
            pre
              code.
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
                <dfn>UNION</dfn> <dfn>ALL</dfn>
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
              
          //- INTERSECT
          details
            summary INTERSECT
            p.
              <dfn>INTERSECT</dfn> - Пересечение:<br>
              Пересечение — множество, состоящее из элементов, которые
              одновременно принадлежат всем данным множествам.<br>
              <dfn>INTERSECT</dfn>, также как и <dfn>UNION</dfn> обладает ограничением на результат
              запросов, которые должны быть совместимы по объединению
            pre
              code.
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
                <dfn>INTERSECT</dfn>
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
              
          //- MINUS или EXCEPT
          details
            summary MINUS или EXCEPT
            p.
              <dfn>MINUS или EXCEPT</dfn> - Разность:<br>
              Разность двух множеств — это операция, результатом которой
              является множество, в которое входят все элементы первого
              множества, не входящие во второе множество
            pre
              code.
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table1
                <dfn>MINUS</dfn> <span>либо</span> <dfn>EXCEPT</dfn>
                <dfn>SELECT</dfn> columns <dfn>FROM</dfn> table2
              
        //- Data Control Language, DCL
        details
          summary Операторы определения доступа к данным (Data Control Language, DCL)
          p.
            <dfn>GRANT</dfn> - предоставляет пользователю (группе) разрешения на определенные операции с объектом<br>
            <dfn>REVOKE</dfn> - отзывает ранее выданные разрешения<br>
            <dfn>DENY</dfn> - задает запрет, имеющий приоритет над разрешением<br>

        //- Transaction Control Language, TCL
        details
          summary Операторы управления транзакциями (Transaction Control Language, TCL)
          p.
            <dfn>Транзакция</dfn> - последовательность команд SQL, 
            которые должны быть выполнены полностью или не выполнены вообще.
            <br>
            Например перевод денег со счёта на счёт
          pre
            code.
              <dfn>START</dfn> <dfn>TRANSACTION</dfn>;
              <dfn>UPDATE</dfn> accounts
              <dfn>SET</dfn> balance = balance - 15000
              <dfn>WHERE</dfn> account_number = 1234567;
              <dfn>UPDATE</dfn> accounts
              <dfn>SET</dfn> balance = balance + 15000
              <dfn>WHERE</dfn> account_number = 9876543;
            
          p.
            <dfn>COMMIT</dfn> применяет транзакцию, записывает изменения в базу данных<br>
            либо<br>
            <dfn>ROLLBACK</dfn> откатывает все изменения, сделанные в контексте текущей транзакции<br>
            В PostgreSQL <dfn>START TRANSACTION</dfn> и <dfn>AUTOCOMMIT</dfn> включён по умолчанию.<br>
            <dfn>SET AUTOCOMMIT</dfn> = value; value может быть 1 (ON) либо 0 (OFF)<br>
            <dfn>SAVEPOINT</dfn> - делит транзакцию на более мелкие участки

      //- Rust

    //- Libraries
    details
      summary.menu__submenu Libraries

      //- jQuery
      details
        summary.menu__submenu_lv1 jQuery
        p.
          (function( $ ) {alert($.fn.jquery);}) - проверить версию<br>
          <br>
          Подключить<br>
        code &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;
        p.
          <b>compressed</b> - сжатая и минифицированная, поключают к готовому сайту<br>
          <b>uncompressed</b> - обычная, удобочитаемая, поключают при разработке<br>
          <b>slim</b> - без анимации и без Ajax<br>
          <br>
          <em>Скрипт</em>
        pre
          code.
            <span>запускать скрипт только после загрузки страницы</span>
            $(document).ready(function() {
              <span>при нажатии кнопки</span>
              $("button").on("click", function() {
                <span>скрыть заголовок в течении 3-х секунд</span>
                $("h1").hide(3000);
              });
            });
        br
        p <em>Селекторы</em> - все как в CSS
        pre
          code.  
            $('a'); = document.querySelectorAll("a");
            $('sel').method();

            <span>выбрать элементы по атрибуту - target</span>
            $('a[target]');

            <span>выбрать элементы с атрибутом target равное _blank</span>
            $('a[target="_blank"]')
        br
        p.
          По элементам форм:<br>
          :button<br>
          :password<br>
          :disabled<br>
          :file<br>
          <br>
          CSS
        code $("p").css("background-color", "#2ecc71");
        br
        p.
          Пример:<br>
          &lt;a href="https://ya.ru" target="_blank" title="Переход на Яндекс"&gt;Yandex&lt;/a&gt<br>
          <br>
          Выбрать элементы, у которых значение атрибута:<br>
          <b>$('a[href^="https"]')</b> - href начинается с https<br>
          <b>$('a[href$=".ru"]')</b> - href заканчивается на .ru<br>
          <b>$('a[title~="Яндекс"]')</b> - title содержит слово Яндекс<br>
          <b>$('a[title*="epe"]')</b> - title содержит подстроку ере<br>
          <b>$('a[href!="https://www.google.com"]')</b> - выберет элементы, у которых либо нет указанного атрибута, либо у атрибута другое значение
          <br>
          <em>Фильтры</em><br>
          <b>$("li:first").css("color", "green")</b>;<br> 
          - <b>:first, :last, :even, :odd</b> - первый, последний, чётный, нечётный из выборки<br>
          - <b>:eq(), :gt(), :lt()</b> - индексы элемнтов выборки<br>
          - <b>:root, :header, :focus, :lang()</b>, :target - HTML-элементы<br>
          - <b>:not()</b>, :animated - отрицанние и анимирование<br>
          <br>
          <b>$("li").filter(":first").css("color", "green")</b>; - :first - не является частью языка css, поэтому через метод filter()
        br
        a(href="https://jquery.com") jQuery
        a(href="https://www.w3schools.com/jquery/default.asp") W3schools
        a(href="https://core.trac.wordpress.org/query") Wordpress jQuery

      //- Alpinejs
      details
        summary.menu__submenu_lv1 Alpinejs
        a(href="https://alpinejs.dev/") alpinejs<br>
        p К событию JS нужно добавить @. Например @click. 
        a(href="https://developer.mozilla.org/ru/docs/Web/Events") Events

        //- Directives
        table
          caption Directives
          thead
            tr 
              th Directive
              th Description
          tbody 
            tr
              td 
                a(href="https://alpinejs.dev/directives/data") x-data
              td определяет часть HTML как компонент Alpinejs и предоставляет ему данные 
            tr
              td 
                a(href="https://alpinejs.dev/directives/init") x-init
              td позволяет выполнить действие в момент когда Alpinejs инициализирует элемент 
            tr
              td 
                a(href="https://alpinejs.dev/directives/show") x-show
              td показывает или прячет DOM элемент
            tr
              td 
                a(href="https://alpinejs.dev/directives/bind") x-bind
              td устанавливает атрибуты HTML элемента на основании вычислений
            tr
              td 
                a(href="https://alpinejs.dev/directives/on") x-on
              td выполняет код при получении события
            tr
              td 
                a(href="https://alpinejs.dev/directives/text") x-text
              td вставляет текст в элемент
            tr
              td 
                a(href="https://alpinejs.dev/directives/html") x-html
              td вставляет html разметку в элемент
            tr
              td 
                a(href="https://alpinejs.dev/directives/model") x-model
              td связавыет значение с данными
            tr
              td 
                a(href="https://alpinejs.dev/directives/modelable") x-modelable
              td указывает значение, которое нужно связать со значением x-model
            tr
              td 
                a(href="https://alpinejs.dev/directives/for") x-for
              td создаёт DOM элементы перебирая массивы и объекты
            tr
              td 
                a(href="https://alpinejs.dev/directives/transition") x-transition
              td плавное появление и исчезновение элемента
            tr
              td 
                a(href="https://alpinejs.dev/directives/effect") x-effect
              td меняет элемент когда меняются его зависимости
            tr
              td 
                a(href="https://alpinejs.dev/directives/ignore") x-ignore
              td Alpine пропускает этот элемент во время инициализации
            tr
              td 
                a(href="https://alpinejs.dev/directives/ref") x-ref
              td обозначает элемент для $refs
            tr
              td 
                a(href="https://alpinejs.dev/directives/cloak") x-cloak
              td.
                скрывает элемент пока не загрузится Alpine<br>
                add to CSS [x-cloak] { display: none !important; }
            tr
              td 
                a(href="https://alpinejs.dev/directives/teleport") x-teleport
              td переносит часть шаблона < template > в другую часть страницы
            tr
              td 
                a(href="https://alpinejs.dev/directives/if") x-if
              td добавляет и удаляет элементы по словию
            tr
              td 
                a(href="https://alpinejs.dev/directives/id") x-id
              td.
                собирает в массив id сгенерированные с помощью $id<br>
                создаёт им scope и добавляет к ним суффикс

        //- Magics
        table
          caption Magics
          thead
            tr
              th Magic
              th Description
          tbody 
            tr
              td 
                a(href="https://alpinejs.dev/magics/el") $el
              td выбирает текущий элемент
            tr
              td
                a(href="https://alpinejs.dev/magics/refs") $refs
              td выбирает элемент c x-ref
            tr
              td
                a(href="https://alpinejs.dev/magics/store") $store
              td доступ к глобальному хранилищу, созданного через Alpine.store()
            tr
              td
                a(href="https://alpinejs.dev/magics/watch") $watch
              td наблюдает за указанным элементом
            tr
              td
                a(href="https://alpinejs.dev/magics/dispatch") $dispatch
              td создает события браузера
            tr
              td
                a(href="https://alpinejs.dev/magics/nextTick") $nextTick
              td выполняет действие после после выполнения первого
            tr
              td
                a(href="https://alpinejs.dev/magics/root") $root
              td выбирает ближайший родительский элемент с x-data
            tr
              td
                a(href="https://alpinejs.dev/magics/data") $data
              td содежит значения всех x-data, через которых всплывает событие
            tr
              td
                a(href="https://alpinejs.dev/magics/id") $id
              td создаёт id для элементов избегая конфликтов одинаковых имён

        //- Globals
        table
          caption Globals
          thead
            tr
              th Global
              th Description
          tbody 
            tr
              td 
                a(href="https://alpinejs.dev/globals/alpine-data") Alpine.data()
              td вынести контекст x-data в отдельную функцию и переиспользовать
            tr
              td 
                a(href="https://alpinejs.dev/globals/alpine-bind") Alpine.bind()
              td вынести контекст x-data в отдельную функцию и переиспользовать
            tr
              td 
                a(href="https://alpinejs.dev/globals/alpine-store") Alpine.store()
              td управление глобальным хранилищем

      //- React
      details
        summary.menu__submenu_lv1 React
        p.
          <b>npx create-react-app название папки (проекта)</b><br>
            - создаст папку с названием проекта и стартовым шаблоном внутри.<br>
          <em>JSX</em>:<br>
            - это синтаксический сахар для React.createElement.<br>
            - это расширение JS, чтобы объяснить React как выглядит UI.<br>
            - напоминает язык шаблонов, наделённый силой JavaScript.<br>
            - производит элементы React.<br>
            - преобразуется в JS функцию, которая возвращает JS объект.<br>
            После компиляции каждое JSX-выражение становится обычным вызовом JS-функции, результат которого  - объект JS.<br>
          <br>
          &lt;div&gt;&lt;/div&gt; = &lt;div/&gt; - если тэг пустой, то самозакрывающийся тэг.<br>
          Если разделить выражение на строки, то его нужно обернуть в ().<br>
          Запись атрибутов в camelCase.<br>
          Кавычки (для строковых литералов), фигурные скобки (для JS-выражений), но не то и другое вместе.<br>
          <br>
          &lt;div tabIndex=”0”&gt;&lt;/div&gt; - литералы в строке<br>
          &lt;img src={user.avatarUrl}&gt; - JS выражения в { }<br>
          <br>
        pre
          code.
            const name = ‘Иван-Царевич’; <span> - создали переменную</span>
            <span>создали элемент с переменной внутри.</span>
            const element = &lt;h1&gt;Здравствуй, {name}!&lt;/h1&gt;;
            
        br
        p.
          Элемент описывает то, что будет на экране.<br>
          команда ReactDOM-у отрисовать созданный элемент
        pre
          code.
            ReactDOM.render(
              element,
              document.getElementById('root'))
        p.
          внутри элемента страницы с выбранным id<br>
          <br>
          <em>&lt;div/&gt</em>; - DOM-тэг с маленькой буквы<br>
          <em>&lt;Welcome/&gt</em>; - компонент с большой.<br>
          <br>
          Первоначальный рендеринг компонента в DOM называется “монтированием” - (mounting).<br>
          Каждый раз когда DOM-узел, созданный компанентом, удаляется, происходит “размонтирование” - (unmounting).<br>
          <br>
          <em>Методы жизненного цикла</em>:<br>
          <em>componentDidMount() {...}</em> - запускается после того, как компонент отрендерился в DOM<br>
          <em>componentWillUnmount() {...}</em> - запускается перед размонтированием<br>
          <br>
          Поля <em>this.props</em> и <em>this.state</em> в классах особенные, и их устанавливает сам React.<br>
          Присвоить значение this.state можно только в конструкторе,
          в остальных случаях только через изменение: <b>this.state({comment: ‘Привет’})</b>.<br>
          Родитель-компонент передаёт своё состояние дочерним компонентам в виде пропса.<br>
          Это однонаправленный поток данных.<br>
          <br>
          <em>this.props</em> и <em>this.state</em> могут обновляться асинхронно поэтому операции с ними нужно проводить внутри функции,
          получая текущие значения в качестве параметров:<br>
        code.
          this.setState((state.props) => ({
            counter: state.counter + props.increment
          }))
        br
        p.
          <em>Обработка событий</em>:<br>
          HTML: &lt;button onclick="activateLasers()"&gt; Активировать лазеры &lt;/button&gt;<br>
          React: &lt;button onClick={activateLasers}&gt; Активировать лазеры &lt;/button&gt;<br>
          activateLasers - это функция-обработчик события<br>
          <br>
          В React есть соглашение об именах:<br>
          <em>on[имя события]</em> - для пропсов, отвечающих за события,<br>
          <em>handle[имя события]</em> - для методов, обрабатывающих события.<br>
          События в React в camelCase.<br>
          <br>
          Чтобы предотвратить обработчик события по умолчанию, нужно вызвать <b>preventDefault()</b>.<br>
        pre
          code.
            function ActionLink() {
              function handleClick(e) {
                e.preventDefault()
                console.log(‘По ссылке кликнули’)
              }
              return (
                &lt;a href=”#”
                onClick={handleClick}&gt;
                Нажми на меня &lt;/a&gt;
              )
            }
        br
        p.
          Если ссылаться на метод как на ссылку - без вызова, т.е. без () поcле него, например, <b>onClick={this.handleClick}</b>,
          этот метод нужно привязать к контексту:<br>
          в конструкторе <b>this.handleClick = this.handleClick.bind(this)</b>;<br>
          в render() &lt;button onClick={this.handleClick}&gt;<br>
          или так:<br>
        pre
          code.
            handleClick = () => {
              console.log('значение this: ', this)
            }
            &lt;button
              onClick={this.handleClick}&gt;
              Нажми на меня
            &lt;/button&gt;
        p или так:
        pre
          code.
            handleClick() {console.log('значение this: ', this)}
            &lt;button onClick={this.handleClick()}&gt;
              Нажми на меня
            &lt;/button&gt;
          <br>
        p.
          Чтобы передать свой аргумент (например id строки) в обработчик события:<br>
          <em>е</em> - событие React передаётся явно в стрелочных функциях и автоматически в bind.<br>
        pre
          code.
            &lt;button onClick={this.deleteRow.bind(this, id)}&gt;
              Удалить строку
            &lt;/button&gt; <span>- Function.prototype.bind</span>

            &lt;button onClick={(e) => this.deleteRow(id, e)}&gt;
              Удалить строку
            &lt;/button&gt;
        p.
          - стрелочная функция - при каждом рендере создаётся новый коллбэк.<br>
          Если этот коллбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.<br>
          Снижение производительности.<br>
          <br>
          <em>Структура проекта</em>:<br>
          <em>index.html</em> - точка входа в сайт<br>
          <em>index.js</em> - подключает необходимое окружение (react, react-dom, index.css, App.js, serviceWorker.js)<br>
          <em>index.css</em> - задаёт стили<br>
          <em>serviceWorker.js</em><br>
          <em>setupTests.js</em><br>
          <em>context.js</em><br>
          <em>App.js</em> - подключает (объединяет) все компоненты<br>
          Файл .css можно не импортировать, т.к. React ищет его сам в своей папке, либо в папках выше.<br>
          <br>
          <em>Компонент</em>:<br>
          Это функция или класс (работают одинаково).<br>
          Один компонент - одна ответственность.<br>
          Компонент содержит логику и разметку в JSX.<br>
          Компоненты можно вкладывать в друг друга.<br>
          <br>
          Чтобы создать компонент нужно в файле с расширением js написать:<br>
          <em>import React from 'react'</em>; - в начале<br>
          и<br>
          <em>export default App</em>; - в конце.<br>
          <br>
          Сначала создаём самый маленький компонент, потом вверх по иерархии.<br>
          <br>
          <em>Компонент в виде класса</em>:
        pre
          code.
            class Example extends React.Component {
              <span>конструктор объектов</span>
              constractor (props) {
              <span>обязательная ссылка на родителя</span>
              super (props)
              <span>задаём начальное состояние</span>
              this.state = { … }
            }
              <span>говорит React что нужно отобразиь на экране</span>
              render() {
                <span>возвращает JSX объект</span>
                return…
              }
            }
        p.
          В JS - классах всегда нужно вызывать <em>super</em> при объявлении конструктора подкласса.
          Все классовые React - компоненты, у которых есть constractor 
          должны начинаться с вызова <b>super (props)</b>.
          <br>
          <em>Компонент в виде функции (функциональный компонент)</em>:
        pre
          code.
            <span>подключение</span>
            import React from 'react';
            …
            const styles = { }

            <span>принимает пропсы</span>
            function Example (props) { 
              <span>либо так:</span>
              const Example = (props) => {{
                логика на JS
                разметка JSX
                <span>возвращает JSX объект</span>
                return …
                
              }
              export default Example
            }

            <span>компонент объявлен как класс</span>
            class Clock extends React.Component {
              constructor (props) {
                super (props);
                <span>задаём начальное состояние
                при создании объекта</span>
                this.state = {date: new Date()};
              }

              componentDidMount() {
                <span>метод жизненного цикла,
                который React вызывает когда коипонент &lt;Clock/&gt;
                примонтируется в DOM</span>

                <span>вызываем метод tick() каждую секунду</span>
                this.timerID = setInterval ( 
                () => this.tick(), 1000
                );
              }

              componentWillUnmount() {
                <span>метод жизненного цикла,
                который Ract вызывает когда компонент &lt;Clock/&gt;
                удалится из DOM</span>
              }

              tick() {
                this.setState({
                  <span>обновляем состояние компонента,
                  присваивая новое значение свойства date</span>
                  date: new Date()
                });
              }

              render() {
                return (
                  &lt;div&gt;
                    &lt;h1&gt;
                      Привет мир!
                    &lt;/h1&gt;

                    &lt;h2&gt;
                      Сейчас {this.state.date.toLocaleTimeString()}
                    &lt;/h2&gt;
                  &lt;/div&gt;
                );
              }
            }

            ReactDOM.render(
              &lt;Clock/&gt;,
              document.getElementById('root')
            );
        br
        p.
          <em>Пропс</em>:<br>
          <em>JSON</em> - объявляем объект в переменную:
        pre
          code.
            const user = {
              firstName = ‘Марья’,
              lastName = ‘Маревна’
            }
        p и обращаемся к пропсам:
        pre
          code.
            user.firstName
            user.lastName
        br
        p.
          <em>this.props</em> - объект, кототрый содержит свойства, которые были определены тем, кто вызывает этот компонент.<br>
          Вложенный контент может быть доступен через <b>props.children</b>
        pre
          code.
            <span>в props получаем значения value и onClick
            из класса Board ниже</span>
            function Square (props) { 
              return(
                &lt;button onClick={props.onClick}&gt;
                  {props.value}
                &lt;/button&gt;
              )}

            <span>возвращаем кнопку для подстановки
            в качестве объекта this
            в блок render в классе Board</span>
                                                                                                          
            class Board extends React.Component{
              <span>props i из блока render() ниже</span>
              renderSquare(i){
                <span>в компанент Square втуливаем значения value и onClick</span>
                return(
                  &lt;Square
                    <span>собираем получаемые пропсы в массив</span>
                    value = {this.props.square[i]}
                    <span>создаём обработчик на событие onClick для каждого пропса i</span>
                    onClick = {() = this.props.onClick(i)}
                  /&gt;
                )
              }
              render() {
                return(
                  <span>передаем в функцию renderSquaer
                  (props.value) - 0 или 1 или 2</span>
                  &lt;div&gt;
                    {this.renderSquare(0)}
                    {this.renderSquare(1)}
                    {this.renderSquare(2)}
                  &lt;/div&gt;
                )
              }
            }

            <span>компонент объявлен как функция</span>
            function Welcome(props) {
              return (
                &lt;h1&gt;
                  Привет, {props.name}!
                &lt;/h1&gt;
              );
            }
            <span>или так:</span>
            <span>компонент объявлен как класс</span>
            class Welcome extends React.Component { 
              render () {
                return (
                  &lt;h1&gt;
                    Привет, {this.props.name}!
                  &lt;/h1&gt;
                );
              }
            }

            const element = &lt;Welcome name="Алиса"/&gt;;
            ReactDOM.render(
              element,
              document.getElementById('root')
            );
        p.
          name=”Алиса” - передаётся в функцию Welcome в виде объекта <b>{name: 'Алиса'}</b> - это props.<br>
          Функция Welcome возвращает элемент &lt;h1&gt;Привет, Алиса!&lt;/h1&gt; в ReactDOM.<br>
          <br>
          Пропсы нужно только читать.<br>
          React-компоненты не меняют свои входные данные.<br>
          Компонент никогда не должен что-то записывать в свои пропсы:
        pre
          code.
            function sum(a, b) {
              return a + b;
            }
            <span>а вот так нельзя:</span>
            function withdraw(account, amount) {
              account.total -= amount;
            }
        p.
          Передать пропс можно от родителя к потомку пропустив несколько промежуточных потомков
          напрямую с помощью <b>React.createContext()</b>.<br>
          Для этого создаём отдельный файл context.js и используем &lt;Context.Provider&gt;.<br>
          <br>
          <em>Файл context.js</em>:
        pre
          code.
            import React from 'react'
            const Context = React.createContext()
            export default Context
            <span>с помощью Context.Provider
            передаю любое JS сквозь всех потомков</span>
            &lt;Context.Provider value={{ … }}&gt;
            &lt;div className=”...”&gt;
            &lt;h1&gt; Hello world! &lt;/h1&gt;
            &lt;Example/&gt;
            &lt;/div&gt;
            &lt;/Context.Provider&gt;
        p.
          <em>Состояние</em>:<br>
          Сохранять и изменять можно только состояния <em>(state)</em>.<br>
          Конкретный state контролируется и доступен только конкретному компоненту.<br>
          Состояние содержит данные, специфичные для этого компонента. Они могут изменятся со временем.<br>
          Состояние определяется пользователем и должно быть простым объектом JS.<br>
          Состояние можно изменять только через <b>setState()</b>, присвоить состоянию значение напрямую можно только в конструкторе.<br>
          Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.<br>
          Этот процесс называется “нисходящим” (“top-down”) или “однонаправленным” (“unidirectional”) потоком данных.<br>
          <br>
          Если несколько компонентов должны отражать одни и теже изменяющиеся данные, 
          то нужно поднимать общее состояние до ближайшего общего предка.<br>
          Чтобы собрать данные из нескольких дочерних элементов, или чтобы дать возможность двум компонентам общаться,
          вам нужно объявить общее состояние внутри родительского компонента.<br>
          Родительский компонент может передать состояние обратно дочерним элементам с помощью пропсов.<br>
          Это поддерживает синхронизацию дочерних компонентов друг с другом и с родительким компонентом.<br>
          <br>
          <em>Хуки</em>:
        code const [todos, setTodos] = React.useState([ ])
        p.
          Это функции, с которыми можно “подцепиться” к состоянию
          и к методам жизненного цикла React из функциональных компонентов.<br>
          Хуки не работают в классах, а используются вместо них.<br>
          Хуки вызывают только на верхнем уровне (не в циклах, условиях и т.д.)<br>
          Хуки вызывают только из функциональных компонентов React, не из обычных JS-функций.<br>
          Если имя функции начинается с use (useSamething) и использует другие хуки,
          то такая функция это пользовательский хук.<br>
          <br>
          <em>useState(i)</em> - возвращает массив из двух элементов:<br>
            состояние (это state - состояние) и функцию, которая изменяет это состояние.<br>
            Имена даём возвращаемому состоянию и функции произвольно.<br>
          <br>
          <em>useEffect(i)</em> - React запускает эффекты useEffect(() => {...}) после каждого рендера, включая первый рендер.
        pre
          code.
            useEffect(() => {
            fetch('http://…')
              .then(responce=>responce.json())
              .then(todos=>{
                setTodos(todos)
              })
            }, [])
        <br>
        p вызвать хук можно либо
        pre
          code.
            import React, { useEffect } from 'react'
            useEffect(i) {...}
            <span>либо</span>
            React.useEffect(i) {...}
        br
        p.
          Сравнение хука и класса:<br>
          <em>Хук</em>:
        pre
          code.
            <span>подключение хука</span>
            import React, {useState} from 'react'
            function Example() {
              <span>0 это начальное состояние,
              это может быть не объект</span>
              const [count, setCount] = useState(0)
              return (
                &lt;div&gt;
                  &lt;p&gt;Вы нажали {count} раз &lt;/p&gt;
                  &lt;button
                    onClick={() => setCount(count + 1)}
                  &gt;
                    Нажми на меня
                  &lt;/button&gt;
                &lt;/div&gt;
              )
            }
        br
        p <em>Класс</em>:
        pre
          code.
            class Example extends React.Component {
              constractor (props) {
                super (props)
                this.state = {
                  count: 0
                }
              }
              render () {
                return (
                  &lt;div&gt;
                    &lt;p&gt;
                      Вы нажали {this.state.count} раз
                    &lt;/p&gt;
                    &lt;button 
                      onClick={() => this.setState({
                        count.this.state.count + 1
                      })}
                    &gt;
                        Нажми на меня
                    &lt;/button&gt;
                  &lt;/div&gt;
                )
              }
            }
        p.
          Чтобы наделить функциональный компонент состоянием нужно либо преобразовать его в класс, либо добавить в него хук.<br>
          React запоминает значение переменной состояния между вызовами функции.<br>
          <em>Итого</em>:
        pre
          code.
            <span>подключаем хук</span>
            import React, {useState} from 'react'
            <span>добавляем переменную в функцию</span>
            const [count, setCount] = useState(0)
            <span>вызываем функцию изменения</span>
            &lt;button onClick={() => setCount(count + 1)}&gt;
        br
        p.
          <em>Хук еффекта выполняет побочные действия</em>:<br>
          - загрузка данных<br>
          - оформление подписки и изменение DOM вручную<br>
          - представляет собой совокупность методов componentDidMount, componentDidUpdate и componentWillUnmount.<br>
          <br>
          Эффекты позволяют выполнить дополнительный код после того, как React обновил DOM, т.е. после каждого рендера.<br>
          Любой эффект может возвратить функцию, которая сбросит его.<br>
          React будет сбрасывать эффект перед тем, как компонент размонтируется. Например оформление и отмена подписки:
        pre
          code.
            import React , {useState, useEffect} from 'react'
            function FriendStatus(props) {
              const [isOnline, setIsOnline] = useState(null)
              useEffect(() => {
                function handleStatusChange(status) {
                  setIsOnline(status.isOnline)
                }
                ChatAPI.subscribeToFriendStatus(
                  props.friend.id,
                  handleStatusChange
                )
                <span>сброс эффекта</span>
                return function cleanup() {
                  ChatAPI.unsubscribeFromFriendStatus(
                    props.friend.id,
                    handleStatusChange
                  )
                }
              })
              if (isOnline === null) {
                return ‘Загрузка…’
              }
              return isOnline ? ‘В сети’ : ‘Не в сети’
            }
        p.
          Чтобы React выполнял эффект только в случае изменения нужен второй аргумент в виде массива,
          с которым будет сравниваться значение первого аргумента.<br>
          При каждом рендере react сравнивает новое значение переменной в первом аргументе со старым значением переменной,
          указанным во втором аргументе (в массиве).
        pre
          code.
            <span>стрелочная функция это первый аргумент эффекта</span>
            useEffect(() => {
              function handleStatusChange(status) {
                setIsOnline(status.isOnline)
              }
              ChatAPI.subscribeToFriendStatus(
                props.friend.id,
                handleStatusChange
              )
              return() => {
                ChatAPI.unsubscribeFromFriendStatus(
                  props.friend.id,
                  handleStatusChange
                )
              }
            }
            <span>это второй аргумент эффекта
            со старым значением переменной,
            по которому будет сравнение первого аргумента:
            повторно подписаться только если
            props.friend.id изменился.</span>
            [props.friend.id])
        br
        p <em>Обычный эффект без сброса</em>:
        pre
          code.
            import React, {useState, useEffect} from 'react'
            function Example() {
              const [count, setCount] = useState(0)
              useEffect(() => {
                document.title = `Вы нажали ${count} раз`
            <span>перезапускать эффект только если count поменялся</span>
              }, [count])
              return (
                &lt;div&gt;
                  &lt;p&gt;
                    Вы нажали {count} раз
                  &lt;/p&gt;
                  &lt;button
                    onClick={() => setCount(count + 1)}
                  &gt;
                    Нажми на меня
                  &lt;/button&gt;
                &lt;/div&gt;
              )
            }
        br
        p.
          Для корректной работы с хуками нужно установить плагин для ESLint:<br>
          <b>npm i eslint-plugin-react-hooks --save -dev</b>
        pre
          code.
            useContext:
            import React, {useContext} from 'react'
            const themes = {
              light: {
                foreground: “#000000”,
                background: “#eeeeee”
              }
              dark: {
                foreground: “#ffffff”,
                background: “#222222”
              }
            }
            <span>создаём объект контекста со свойством light</span>
            const ThemeContext = React.createContext(themes.light)
            function App() {
              return(
                <span>значение value определяет текущее значение</span>
                &lt;ThemeContext.Provider
                  value={themes.dark}
                &gt;
                <span>передаваемого в Toolbar контекста.
                При обновлении значения - новый рендер.</span>
                &lt;Toolbar/&gt;
                <span>Меняем контекст на тёмную тему.</span>
                &lt;/ThemeContext.Provider&gt;
              )								
            }
            <span>передаём контекст потомку</span>
            function Toolbar (props) {
              return(
                &lt;div&gt;
                  &lt;ThemedButton/&gt;
                &lt;/div&gt;
              )
            }
            function ThemedButton() {
            <span>используем контекст с тёмной темой</span>
              const theme = useContext(ThemeContext)
              return (
                &lt;button style={{background: theme.background, color: theme.foreground}}&gt; Я стилизован темой из контекста! &lt;/button&gt;
              )
            }
        br
        p.
          <em>Управляемый компонент</em>:<br>
          Если форму обрбатывать с помощью JS-функции, у которой есть доступ к введённым данным,
          то такая форма называется “управляемым компонентом”.<br>
          Библиотека Formik.<br>
          Или, другими словами, <em>управляемый компонент</em> - это элемент формы рендер,
          поведение при пользовательском вводе и значение которого контролирует React.<br>
        pre
          code.
            class NameForm extends React.Component{
              constructor(props){
                super(props)
                this.state={value:' '}
                this.handleChange=this.handleChange.bind(this)
                this.handleSubmit=this.handleSubmit.bind(this)
              }
              handleChange(event) {
                this.setState({value: event.target.value})
              }
              handleSubmit(event){
                alert('Отправленное имя: ' + this.state.value)
                <span>отменяем действие по умолчанию</span>
                event.preventDefault()
              }
              render() {
                return (
                  &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;label&gt;
                      Имя:
                      &lt;input
                        type=”text”
                        value={this.state.value}
                        onChange={this.handleChange}
                      /&gt;
                    &lt;/label&gt;
                    &lt;input
                      type=”Submit”
                      value=”Отправить”
                    /&gt;
                  &lt;/form&gt;
                )
              }
            }
        br
        p.
          в атрибуте value всегда будет отражаться React состояние <b>this.state.value</b>,
          а каждое нажатие клавиш через <b>handleChange</b> будет это состояние изменять и React будет обновлять поле ввода по мере печатанья.
        pre
          code.
            &lt;textarea&gt;
              также как
            &lt;input/&gt;
            &lt;textarea
              value={this.state.value}
              onChange={this.handleChange}
            &gt;
        p Чтобы использовать несколько тегов input нужно каждому дать свой атрибут name.
        pre
          code.
            &lt;select&gt;
              &lt;option value=”grapefruit”&gt;
                Грейпфрут
              &lt;/option&gt;
              &lt;option value=”lime”&gt;
                Лайм
              &lt;/option&gt;
              &lt;option selected value=”coconut”&gt;
                Кокос
              &lt;/option&gt;
              &lt;option value=”mango”&gt;
                Манго
              &lt;/option&gt;
            &lt;/select&gt;
        p если в value передать массив, то можно выбрать несколько опций:
        code &lt;select multiple={true} value={[‘Б’, ‘В’]}&gt;
        p.
          в React выбранный элемент присваивается в конструкторе по умолчанию:<br>
          <b>this.state={value='cocnut'}</b>,<br>
          а потом изменяется через setState:<br>
          <b> &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;/select&gt</b>;<br>
          Если установить значение value, то пользователь изменить его не сможет:<br>
        code ReactDOM.render(&lt;input value=”Привет”/&gt;)
        p.
          Для любых изменяемых данных в React -приложении должен быть один “источник истины” (state).<br>
          Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.<br>
          Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка.<br>
          Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами,
          вы должны полагаться на однонаправленный поток данных
            - это водопад пропсов от родителя к потомку,
          в который каждый компонент добавляет свой state в виде пропса (props).<br>
          <br>
          <em>Композиция</em>:<br>
          Вместо наследования:
        pre
          code.
            function FancyBorder(props) {
              return (
                  <span>поместить в div всё,
                  что выделено тэгом
                  &lt;FancyBorder&gt;</span>
                &lt;div
                  className={'FancyBorder FancyBorder-' + props.color}
                &gt;
                  {props.children}
                &lt;/div&gt;
              )
            }
            function Dialog(props) {
              return (
                  <span>определяю тэг &lt;FancyBorder&gt;
                  и его содержимое для подстановки</span>
                &lt;FancyBorder color="blue"&gt;
                  &lt;h1 className="Dialog-title"&gt;
                    {props.title}
                  &lt;/h1&gt;
                  &lt;p className="Dialog-message"&gt;
                    {props.message}
                  &lt;/p&gt;
                &lt;/FancyBorder&gt;
              )
            }
            function WelcomDialog() {
              return (
                <span>определяю компонент для рендера
                и задаю значение пропсов</span>
                &lt;Dialog
                  title="Welcom"
                  message="Thank you for visiting our spacecraft!"
                /&gt;
              )
            }
            ReactDOM.render(
              &lt;WelcomDialog/&gt;,
              document.getElementById('root')
            )
        br
        p.
          <em>Ключи</em>:<br>
          Ключи помогают React определить, какие элементы были изменены, добавлены или удалены.
        pre
          code.
            const todoItems = todos.map((todo) => 
              &lt;li key={todo.id}&gt;
                {todo.text}
              &lt;/li&gt;
            )
            function NumberList(props) {
              const numbers = props.numbers
              <span>функция map() преобразует массив numbers в список</span>
              const listItems = numbers.map((number) =>
                &lt;ListItem
                  <span>ключ нужно определить внутри массива, ключ это строка</span>
                  key={number.toString()}
                  value={number}
                /&gt;
              )
              return (
                &lt;ul&gt;
                  {listItems}
                &lt;/ul&gt;
              )
            }
            <span>или так:</span>
            function NumberList(props) {
              const numbers = props.numbers
              return (
                &lt;ul&gt;
                  {numbers.map((number) => 
                    &lt;ListItem
                      key={number.toString()}
                      value={number}
                    /&gt;
                  )}
                &lt;/ul&gt;
              )
            }
        br
        p.
          <em>Валидирование типов</em>:<br>
          Библиотека prop-types нужна для задания типов переменных:<br>
          <b>npm i prop-types</b>.
        pre
          code.
            import PropTypes from 'prop-types'

            function Example ({prop1, prop2, prop3}) {...}
            Example.propTypes={
              prop1: PropTypes.object.isRequired,
              prop2: PropTypes.number,
              prop3: PropTypes.func.isRequired,
            }
            export default Example
        br
        p <em>Условный рендеринг</em>:
        pre
          code.
            if (isLoggedIn) {
              return &lt;UserGreeting/&gt;;
            }
            return &lt;GuestGreeting/&gt;;

            {
              unreadMessages.length > 0 && 
              &lt;h2&gt;
                у вас {unreadMessages.length} непрочитанных сообщений.
              &lt;/h2&gt;
            }
            Пользователь 
              &lt;b&gt;{
                isLoggedIn ? 'сейчас' : 'не'
              }&lt;/b&gt;
            на сайте.
        br
        img(src="../img/js/react/react.png" alt="")
        img(src="../img/js/react/react0.png" alt="")
        img(src="../img/js/react/React1.png" alt="")
        img(src="../img/js/react/React2.png" alt="")
        img(src="../img/js/react/React3.png" alt="")
        img(src="../img/js/react/React4.png" alt="")
        img(src="../img/js/react/React5.png" alt="")
        img(src="../img/js/react/React6.png" alt="")
        img(src="../img/js/react/React7.png" alt="")
        img(src="../img/js/react/React8.png" alt="")
        img(src="../img/js/react/React9.png" alt="")
        img(src="../img/js/react/React10.png" alt="")
        img(src="../img/js/react/React11.png" alt="")
        img(src="../img/js/react/React12.png" alt="")
        img(src="../img/js/react/React13.png" alt="")
        img(src="../img/js/react/React14.png" alt="")
        img(src="../img/js/react/React15.png" alt="")
        img(src="../img/js/react/React16.png" alt="")
        img(src="../img/js/react/React17.png" alt="")
        img(src="../img/js/react/React18.png" alt="")
        img(src="../img/js/react/React19.png" alt="")
        img(src="../img/js/react/React20.png" alt="")
        img(src="../img/js/react/React21.png" alt="")
        img(src="../img/js/react/React22.png" alt="")
        img(src="../img/js/react/React23.png" alt="")
        img(src="../img/js/react/React24.png" alt="")
        img(src="../img/js/react/React25.png" alt="")
        img(src="../img/js/react/React26.png" alt="")
        img(src="../img/js/react/React27.png" alt="")
        img(src="../img/js/react/React28.png" alt="")
        img(src="../img/js/react/React29.png" alt="")
        img(src="../img/js/react/React30.png" alt="")
        img(src="../img/js/react/React31.png" alt="")
        img(src="../img/js/react/React32.png" alt="")
        img(src="../img/js/react/React33.png" alt="")
        img(src="../img/js/react/React34.png" alt="")

      //- Redux
      details
        summary.menu__submenu_lv1 Redux
        a(href="https://redux.js.org/introduction/getting-started") Redux
        p Весь базовый функционал redux умещается в малюсенький файлик
        pre
          code.
            function createStore(reducer, initialState) {
              let state = initialState
              return {
                dispatch: action => { state = reducer(state, action) },
                getState: () => state
              }
            }
        br
        p.
          <dfn>createStore</dfn> - возвращает объект с полем “dispatch”.<br>
          <dfn>dispatch</dfn> - это функция, которая всего лишь применяет редюсер к нашему текущему состоянию
          <b>(newState = reducer(state, action))</b>.<br>
          <br>
          С этими 7 строками уже можно писать TodoApp.<br>
          Инициализация хранилища:
        pre
          code.
            function todosReducer(state, action) {
              switch (action.type) {
                case 'ADD_TODO':
                  return [
                    ...state,
                    {
                      id: action.id,
                      text: action.text,
                      completed: false
                    }
                  ]
                case 'TOGGLE_TODO':
                  return state.map(todo => {
                    if (todo.id === action.id) {
                      return { ...todo, completed: !todo.completed }
                    }
                    return todo
                  })
                  default: return state
              }
            }

            const initialTodos = []

            const store = createStore(todoReducer, initialTodos)
        br
        p Использование:
        pre
          code.
            store.dispatch({
              type: 'ADD_TODO',
              id: 1,
              text: 'Понять на сколько redux прост'
            })

            store.getState() -  [{ 
                                  id: 1,
                                  text: ‘Понять насколько redux прост’,
                                  completed: false
                                }]
            store.dispatch({
              type: 'TOGGLE_TODO',
              id: 1
            })

            store.getState() -  [{
                                  id: 1,
                                  text: ‘Понять насколько redux прост’,
                                  completed: true
                                }]
        br
        p Метод combineReducers позволяет вместо того, чтобы создавать один огромный reducer для всего состояния приложения сразу, разбивать его на отдельные модули.
        pre
          code.
            function counterReducer(state, action) {
              if (action.type === 'ADD') {
                return state + 1
              } else {
                return state
              }
            }

            const reducer = combineReducers({
              todoState: todoReducer, 
              counterState: counterReducer
            })

            const initialState = {
              todoState: [],
              counterState: 0,
            }

            const store = createStore(reducer, initialState)
        br
        p Если упростить, то:
        pre
          code.
            function reducer(state, action) {
              return {
                todoState: todoReducer(state, action),
                counterState: counterReducer(state, action),
              }
            }
        br
        p.
          Но этот код плохо масштабируется.<br>
          Если у нас 2 “под-состояния”, нам нужно дважды написать (state, action),
          а хорошие программисты так не делают.<br>
          Если редюсоров и стэйтов много, то через обработку коллекции редюсеров:
        pre
          code.
            function combineReducers(reducersMap) {
              return function combinationReducer(state, action) {
                const nextState = {}
                Object.entries(reducersMap).forEach(([key, reducer]) => {
                  nextState[key] =  reducer(state[key], action)
                })
                return nextState
              }
            }
        br
        p <dfn>middleware в разрезе redux</dfn> - это какая-то штука, которая слушает все dispatch и при определенных условиях делает что-то.
        pre
          code.
            const createStoreWithMiddleware = applyMiddleware(somdfniddleware)(createStore)
            const store = createStoreWithMiddleware(reducer, initialState)
        br
        p.
          <dfn>applyMiddleware</dfn> переопределяет метод dispatch, добавляя перед (или после) обновлением состояния какую-то пользовательскую логику.<br>
          самый популярный middleware от создателей redux - <dfn>redux-thunk</dfn>, чаще всего используют при асинхронных операциях.<br>
          Его смысл сводится к тому, что можно передавать в store.dispatch сложные функции<br>
        pre
          code.
            const thunk = store => dispatch => action => {
              if (typeof action === 'function') {
                return action(store.dispatch, store.getState)
              }
              return dispatch(action)
            }
        br
        p.
          метод createStore принимал атрибуты (reducer, initialState) и возвращал объект с ключами { dispatch, getSate }.<br>
          метод applyMiddleware берёт уже реализованный метод createStore и переопределяет его возвращаемое значение:
        pre
          code.
            function applyMiddleware(middleware) {
              return function createStoreWithMiddleware(createStore) {
                return (reducer, state) => {
                  const store = createStore(reducer, state)
                  return {
                    dispatch: action => middleware(store)(store.dispatch)(action),
                    getState: store.getState,
                  }
                }
              }
            }
        br
        p <dfn>form</dfn>:
        pre
          code.
            import { useDispatch } from 'react-redux'
            import { createPost } from 'actions/posts'

            const [postData, setPostData] = useState({
              creator: ' ',
              title: ' ',
              message: ' '
            })

            const dispatch = useDispatch()

            const handleSubmit = (e) => {
              e.preventDefault()
              dispatch(createPost(postData))
            }
        br
        p <dfn>action</dfn>:
        pre
          code.
            export const createPost = (post) => async (dispatch) => {
            try {
              const { data } = await api.createPost(post)
              dispatch ({ type: 'CREATE', payload: data })
              } catch (error) {
                console.log(error)
              }
            }
        br
        p <dfn>api</dfn>:
        code export const createPost = (newPost) => axios.post(url, newPost)
        br
        p <dfn>server/controllers</dfn>:
        pre
          code.
            export const createPost = async (req, res) => {
              const post = req.body;
              const newPostMessage = new PostMessage({
                …post,
                creator: req.userId,
                createdAt: new Date().toISOString()
              })

              try {
                await newPostMessage.save();
                res.status(201).json(newPostMessage);
              } catch (error) {
                res.status(409).json({ message: error.message });
              }
            }
        br
        p <dfn>server/models</dfn>:
        pre
          code.
            import mongoose from 'mongoose'

            const postSchdfna = mongoose.Schdfna({
              title: String,
              message: String,
              name: String,
              creator: String,
              tags: [String],
              selectedFile: String,
              likes: { type: [String], default: [] },
              createdAt: {
                type: Date,
                default: new Date(),
              },
            })

            export default mongoose.model('PostMessage', postSchdfna);
        br
        p <dfn>reducers</dfn>:
        pre
          code.
            export default (post = [ ], action) => {
              switch (action.type) {
                case 'FATCH_ALL':
                  return action.payload;
                case 'CREATE':
                  return [ …posts, action.payload ];
                default: return posts;
              }
            }
        br
        img(src="../img/js/react/redux.jpg" alt="")

      //- React Native

    //- Frameworks
    details
      summary.menu__submenu Framewrks

      //- WordPress
      details
        summary.menu__submenu_lv1 WordPress

        //- Источники
        details
          summary.menu__submenu Источники
          a(href="https://developer.wordpress.org/") WordPress<br>
          a(href="https://developer.wordpress.org/block-editor/reference-guides/") Guides<br>
          a(href="https://developer.wordpress.org/reference/functions/") wp core functions<br>
          a(href="https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page/") wp story book<br>
          a(href="https://codex.wordpress.org/") Codex<br>
          a(href="https://codex.wordpress.org/Theme_Unit_Test") Theme_Unit_Test<br>
          a(href="https://wordpress.org/plugins/theme-check/") Theme-check<br>
          a(href="https://wordpress.org/plugins/debug-bar/") Debug-bar<br>
          a(href="https://wordpress.org/plugins/query-monitor/") Query-monitor<br>
          a(href="https://wordpress.org/plugins/cmb2/") custom fields & metaboxes classic theme PHP adding<br>
          a(href="https://gutenberg.10up.com/") custom fields & metaboxes block theme React adding<br>
          a(href="https://happyprime.github.io/wphtml-converter/") Convert WordPress block HTML to its JavaScript object or PHP array forms.<br>
          a(href="https://wp-kama.ru") WP-Kama<br>
          a(href="https://developer.woocommerce.com/docs/") Woocommerce<br>
          a(href="https://github.com/ndiego/editor-curation-examples") Отключение и блокировка блоков
          a(href="https://www.briancoords.com/") Brian Coords

          //- Plugins
          p.
            Plugins:<br>
            Advanced Custom Fields PRO<br>
            Contact Form 7<br>
            Site Kit by Google<br>
            SVG Support<br>
            UpdraftPlus - Backup/Restore<br>
            Wordfence Security<br>
            Select Yoast SEO<br>
            Yoast SEO<br>
            Cyr to lat<br>
            Show current template<br>
            
        //-ACF
        details
          summary.menu__submenu ACF
          a(href="https://www.youtube.com/watch?v=Q5zcWpRMl9s") ACF
          p Стандартный вывод информации из ACF (текст, ссылка на картинку и т.п.):
          code &lt;?php the_field('имя_поля'); ?&gt;
          br
          p Вывод повторителя:
          pre
            code.
              &lt;?php if(get_field('имя_повторителя')): ?&gt;
                &lt;?php while(has_sub_field('имя_повторителя')) : ?&gt;
                  &lt;div&gt;
                    &lt;img(src="&lt;?php the_sub_field('имя_поля'); ?&gt;"&gt;
                  &lt;/div&gt;
                &lt;?php endwhile; ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Повторитель в повторителе:
          pre
            code.
              &lt;?php if(get_field('имя_повторителя_1')): ?&gt;
                &lt;?php while(has_sub_field('имя_повторителя_1')) : ?&gt;
                  &lt;div&gt;
                    &lt;mg(src="&lt;?php the_sub_field('имя_поля_повторителя_1'); ?&gt;"&gt;
                    &lt;ul&gt;
                      &lt;?php if(get_sub_field('имя_повторителя_2')): ?&gt;
                      &lt;?php while(has_sub_field('имя_повторителя_2')) : ?&gt;
                        &lt;?php the_sub_field('имя_поля_повторителя_2'); ?&gt;
                      &lt;?php endwhile; ?&gt;
                      &lt;?php endif; ?&gt;
                  &lt;/div&gt;
                &lt;?php endwhile; ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Вывод группы полей:
          pre
            code.
              &lt;?php if( have_rows('имя_группы') ): ?&gt;
              &lt;?php while( have_rows('имя_группы') ): the_row(); ?&gt;
                &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
                  &lt;i class="fa fa-vk" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
                &lt;a href="&lt;?php the_sub_field('имя_поля_группы'); ?&gt;"&gt;
                  &lt;i class="fa fa-facebook" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;
              &lt;?php endwhile; ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Тип поля “Галерея”
          pre
            code.
              &lt;?php if ($img_gallery = get_field("имя_галереи")) : ?&gt;
                &lt;?php foreach ($img_gallery as $img) : ?&gt;
                  &lt;?php if ($img) : ?&gt;
                    &lt;?= "&lt;img
                      src="&lt;?= esc_url($img['sizes']['thumbnail']) ?&gt;"
                      alt="&lt;?= esc_attr($img['alt']) ?&gt;"
                      loading="lazy"
                      width="&lt;?= esc_attr($image_array['width']) ?&gt;"
                      height="&lt;?= esc_attr($image_array['height']) ?&gt;"
                    /&gt;" ?&gt;
                  &lt;?php endif; ?&gt;
                &lt;?php endforeach; ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Тип поля “Объект записи”
          pre
            code.
              &lt;?php if ($post_objects = get_field("имя_объекта_записи")) : ?&gt;
                &lt;?php
                foreach ($post_objects as $post) : setup_postdata($post); ?&gt;
                  &lt;?php if ($post) : ?&gt;
                    &lt;?php the_title(); ?&gt;
                    &lt;?php the_excerpt(); ?&gt;
                    &lt;?php the_field("имя_поля_объекта_записи"); ?&gt;
                    &lt;?php the_permalink(); ?&gt;
                  &lt;?php endif; ?&gt;
                &lt;?php endforeach; ?&gt;
                &lt;?php wp_reset_postdata(); ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Тип поля “Гибкое содержание”
          pre
            code.
              &lt;?php if (have_rows('имя_гибкого_содержания')) : ?&gt;
                &lt;?php while (have_rows('имя_гибкого_содержания')) : the_row(); ?&gt;
                  &lt;?php if (get_row_layout() == 'hero') : ?&gt;
                    &lt;?php get_template_part("template-parts/hero-section") ?&gt;
                  &lt;?php elseif (get_row_layout() == 'about') : ?&gt;
                    &lt;?php get_template_part("template-parts/about-section") ?&gt;
                  &lt;?php elseif (get_row_layout() == 'contacts') : ?&gt;
                    &lt;?php get_template_part("template-parts/contacts-section") ?&gt;
                  &lt;?php endif; ?&gt;
                &lt;?php endwhile; ?&gt;
              &lt;?php endif; ?&gt;
          br
          p Тип поля “Ссылка”
          pre
            code.
              &lt;?php if (get_field('имя_ссылки')) : ?&gt;
                &lt;a
                  href="&lt;?= get_field('имя_ссылки')['url'] ?&gt;"
                  target="&lt;?= get_field('имя_ссылки')['target'] ?&gt;"&gt;
                  &lt;?= get_field('имя_ссылки')['title'] ?&gt;
                &lt;/a&gt;
              &lt;?php endif; ?&gt;
          br
          p Вывод поля ACF только если оно заполнено
          pre
            code.
              &lt;?php if (get_field("имя_поля")) { ?&gt;
                &lt;?php the_field("имя_поля"); ?&gt;
              &lt;?php } ?&gt;
          br
          p Страница опций ACF
          pre
            code.
              if (function_exists("acf_add_options_page")) {
                acf_add_options_page(array(
                  "page_title" => "Опции темы",
                  "menu_title" => "Опции темы",
                  "menu_slug"  => "theme_settings",
                ));
              }
          br
          p Вывод полей из страницы с опций
          code &lt;?php the_field("имя_поля", "option"); ?&gt;
          p.
            Для нумерации строк в плагине Advanced Custom Fields (ACF) необходимо использовать функцию get_field(), которая позволяет извлечь данные из поля.<br>
            В примере ниже строки будут нумероваться с помощью цикла for:
          pre
            code.
              &lt;?php if( have_rows('service') ): $i = 0; ?&gt;
              &lt;?php while ( have_rows('service') ) : the_row(); $i++; ?&gt;
                &lt;?php echo $i; ?&gt;
              &lt;? endwhile; endif; ?&gt;

        //- functions.php
        details
          summary.menu__submenu functions.php
          p.
            Есть несколько причин, по которым вы можете увидеть сломанный сайт с белым экраном.<br>
            Одна из таких причин — когда файл functions.php(или любой файл PHP) имеет пробел после закрывающего ?>
          pre
            code.
              &lt;?php
              add_action( 'after_setup_theme', function () {
                add_theme_support( 'wp-block-styles' );
              });
              <span>подключить файл из родительской темы</span>
              include get_parent_theme_file_path( 'inc/helpers.php' );
              <span>подключить файл из дочерней темы</span>
              include get_theme_file_path( 'inc/helpers.php' );
              <span>функция загрузки таблиц стилей для каждого блока в редакторе и на фронтенде wp_enqueue_block_style()</span>   
              add_action( 'wp_enqueue_scripts', function () {
                <span>ставлю в очередь navigation.js</span>
                wp_enqueue_script( 'theme-slug-navigation',
                  get_parent_theme_file_uri( 'assets/js/navigation.js' ),
                  array(),
                  wp_get_theme()->get( 'Version' ),
                  true
                );
                <span>добавляю JS в head область на фронтенде</span>
                wp_add_inline_script( 'theme-slug-navigation',
                  'console.log( "Testing" );'
                );
              });
              <span>JS для редактора блоков</span>
              add_action( 'enqueue_block_editor_assets',
                'theme_slug_enqueue_editor_scripts', function () {
                  <span>ставлю в очередь editor.js для редактора</span>
                  wp_enqueue_script('theme-slug-editor',
                    get_parent_theme_file_uri( 'assets/js/editor.js' ),
                    array(),
                    wp_get_theme()->get( 'Version' ),
                    true
                  );
                });
          p.
            Список включенных скриптов - wp-includes/script-loader.php<br>
            Обращение к файлу изображения:<br>
          code &lt;img(src="&lt;?php echo esc_url( get_theme_file_uri( 'assets/img/example.webp' ) ); ?&gt;" alt="" /&gt;
          p Шрифты подключать через theme.json
        
        //- wp-config.php
        details
          summary.menu__submenu wp-config.php
          pre
            code.
              if ( ! defined( 'WP_DEBAG' ) ) {
                define('WP_DEBAG', true);
              }

              if ( ! defined( 'SCRIPT_DEBUG' ) ) {
                define('SCRIPT_DEBUG', true);
              }

              if ( ! defined( 'WP_DEBUG_DISPLAY' ) ) {
                define('WP_DEBUG_DISPLAY', false);
              }

              if ( ! defined( 'WP_DEBUG_LOG' ) ) {
                define('WP_DEBUG_LOG', ABSPATH . '/wp-content/' . date('Y-m-d', strtotime('now')) . '-debug.log');
              }

              if ( ! defined( 'WP_DEVELOPMENT_MODE' ) ) {
                define('WP_DEVELOPMENT_MODE', 'all');
              }
              
        //- block
        details
          summary.menu__submenu block

          //- Создать блок
          details
            summary Создать блок
            p Создать блок
            code npx @wordpress/create-block kweblock --namespace=kweb --variant=dynamic
            p Чтобы добавить ещё блок добавить --no-plugin
            p Автоформат добавить в package.json
            code "prettier": "@wordpress/prettier-config"

            // https://developer.wordpress.org/block-editor/getting-started/fundamentals/registration-of-a-block/
            p.
              <dfn>register_block_type()</dfn> - регистрация нового блока php,<br>
              возвращает WP_Block_Type, с данными:<br>
              $attributes: Массив атрибутов блока.<br>
              $content: разметка блока, хранящаяся в базе данных, если таковая имеется.<br>
              $block: Экземпляр класса WP_Block, который представляет отображаемый блок (метаданные блока).<br>
              генерит разметку на фронте либо<br>
              render_block и render_callback() указывают что отобразить<br>
              <dfn>registerBlockType()</dfn> - регистрация нового блока index.js (@wordpress/blocks),<br>
              возвращает WPBlock и регистрирует edit.js в редакторе<br>
              <dfn>wp_register_script()</dfn> - регистрация скрипта, пакет @wordpress/scripts<br>
              <dfn>wp_register_style()</dfn> - регистрация стиля

            //- @wordpress/scripts
            p установить @wordpress/scripts отдельно
            code npm install --save-dev @wordpress/scripts
            p добавить скрипты в package.json
            pre
              code.
                "scripts": {
                  "build": "wp-scripts build",
                  "format": "wp-scripts format",
                  "lint:js": "wp-scripts lint-js",
                  "start": "wp-scripts start"
                }
            p.
              Минимальный набор:<br>
              в папке wp-content/plugins/my-app создать<br>
              - my-app.php – для создания страницы плагина<br>
              - src/index.js – для JavaScript-приложения<br>
              - src/style.css – для стилей<br>
              - package.json – для процесса сборки<br>
              В файле package.json<br>
            pre
              code.
                {
                  "name": my-app",
                  "version": "1.1.0",
                  "private": true,
                  "description": "My App",
                  "author": "Me",
                  "license": "GPL-2.0-or-later",
                  "keywords": [
                    "WordPress",
                    "block"
                  ],
                  "homepage": "https://github.com/WordPress/gutenberg-examples/",
                  "repository": "git+https://github.com/WordPress/gutenberg-examples.git",
                  "bugs": {
                    "url": "https://github.com/WordPress/gutenberg-examples/issues"
                  },
                  "main": "build/index.js",
                  "devDependencies": {
                    "@wordpress/scripts": "^24.0.0"
                  },
                  "scripts": {
                    "build": "wp-scripts build",
                    "format": "wp-scripts format",
                    "lint:js": "wp-scripts lint-js",
                    "packages-update": "wp-scripts packages-update",
                    "start": "wp-scripts start"
                  }
                }

            //- Dynamic blocks
            p.
              регистрирую блок в index.js<br>
              переопределять реализацию save() не нужно<br>
              edit() отображает блок в редакторе
            pre
              code.
                import { registerBlockType } from '@wordpress/blocks';
                import { useSelect } from '@wordpress/data';
                import { useBlockProps } from '@wordpress/block-editor';

                registerBlockType( 'gutenberg-examples/example-dynamic', {
                  apiVersion: 3,
                  title: 'Example: last post',
                  icon: 'megaphone',
                  category: 'widgets',

                  edit: () => {
                    const blockProps = useBlockProps();
                    const posts = useSelect( ( select ) => {
                      return select( 'core' ).getEntityRecords( 'postType', 'post' );
                    }, [] );

                    return (
                      &lt;div { ...blockProps }&gt;
                        { ! posts && 'Loading' }
                        { posts && posts.length === 0 && 'No Posts' }
                        { posts && posts.length > 0 && (
                          &lt;a href={ posts[ 0 ].link }&gt;
                            { posts[ 0 ].title.rendered }
                          &lt;/a&gt;
                        ) }
                      &lt;/div&gt;
                    );
                  },
                } );
            p.
              регистрирую блок в plugin.php<br>
              разметку возвращаю из gutenberg_examples_dynamic_render_callback()
            pre
              code.
                &lt;?php
                /**
                * Plugin Name: Gutenberg examples dynamic
                */
                function gutenberg_examples_dynamic_render_callback( $block_attributes, $content ) {
                  $recent_posts = wp_get_recent_posts( array(
                    'numberposts' => 1,
                    'post_status' => 'publish',
                  ) );
                  if ( count( $recent_posts ) === 0 ) {
                    return 'No posts';
                  }
                  $post = $recent_posts[ 0 ];
                  $post_id = $post['ID'];
                  return sprintf(
                    '&lt;a class="wp-block-my-plugin-latest-post" href="%1$s"&gt;%2$s&lt;/a&gt;',
                    esc_url( get_permalink( $post_id ) ),
                    esc_html( get_the_title( $post_id ) )
                  );
                }

                function gutenberg_examples_dynamic() {
                  <span>automatically load dependencies and version</span>
                  $asset_file = include( plugin_dir_path( __FILE__ ) . 'build/index.asset.php');
                  wp_register_script(
                    'gutenberg-examples-dynamic',
                    plugins_url( 'build/block.js', __FILE__ ),
                    $asset_file['dependencies'],
                    $asset_file['version']
                  );
                  register_block_type( 'gutenberg-examples/example-dynamic', array(
                    'api_version' => 3,
                    'editor_script' => 'gutenberg-examples-dynamic',
                    'render_callback' => 'gutenberg_examples_dynamic_render_callback'
                  ) );
                }
                add_action( 'init', 'gutenberg_examples_dynamic' );
            p.
              Рендеринг на стороне сервера рассматривается как запасной вариант;<br>
              рендеринг на стороне клиента в JavaScript всегда предпочтительнее;<br>
              использует пакет wp-server-side-render
            pre
              code.
                import { registerBlockType } from '@wordpress/blocks';
                import ServerSideRender from '@wordpress/server-side-render';
                import { useBlockProps } from '@wordpress/block-editor';
                registerBlockType( 'gutenberg-examples/example-dynamic', {
                  apiVersion: 3,
                  title: 'Example: last post',
                  icon: 'megaphone',
                  category: 'widgets',
                  edit: function ( props ) {
                    const blockProps = useBlockProps();
                    return (
                      &lt:div { ...blockProps }&gt;
                        &lt:ServerSideRender
                          block="gutenberg-examples/example-dynamic"
                          attributes={ props.attributes }
                        /&gt;
                      &lt:/div&gt;
                    );
                  },
                } );

          //- InnerBlocks
          details
            summary InnerBlocks
            p один блок может содержать только один InnerBlocks компонент.
            pre
              code.
                import { registerBlockType } from '@wordpress/blocks';
                import { InnerBlocks, useBlockProps } from '@wordpress/block-editor';
                registerBlockType( 'gutenberg-examples/example-06', {
                  // ...
                  edit: () => {
                    const blockProps = useBlockProps();
                    return (
                      &lt;div { ...blockProps }&gt;
                        &lt;InnerBlocks /&gt;
                      &lt;/div&gt;
                    );
                  },
                  save: () => {
                    const blockProps = useBlockProps.save();
                    return (
                      &lt;div { ...blockProps }&gt;
                        &lt;InnerBlocks.Content /&gt;
                      &lt;/div&gt;
                    );
                  },
                } );
            p ограничитель какие блоки могут быть прямыми потомками
            pre
              code.
                const { allowedBlocks } = attributes;
                //...
                &lt;InnerBlocks allowedBlocks={ allowedBlocks } /&gt;;
            p.
              allowedBlocks - указывает какие потомки могут быть прямыми потомками<br>
              parent - для вложенного блока, может быть только прямым потомком<br>
              ancestor - для вложенного блока, может быть только потомком
            pre
              code.
                {
                  "title": "Column",
                  "name": "core/column",
                  "parent": [ "core/columns" ],
                }
                //...
                {
                  "title": "Comment Author Name",
                  "name": "core/comment-author-name",
                  "ancestor": [ "core/comment-template" ],
                }
                //...
                {
                  "title": "Navigation",
                  "name": "core/navigation",
                  "allowedBlocks": [ "core/navigation-link", "core/search", "core/social-links", "core/page-list", "core/spacer" ],
                }
            p useInnerBlocksProps - хук для большего контроля над разметкой внутренних областей блоков
            pre
              code.
                import { registerBlockType } from '@wordpress/blocks';
                import { useBlockProps, useInnerBlocksProps } from '@wordpress/block-editor';
                registerBlockType( 'gutenberg-examples/example-06', {
                  edit: () => {
                    const blockProps = useBlockProps();
                    const { children, ...innerBlocksProps } = useInnerBlocksProps( blockProps );
                    return (
                      &lt;div {...innerBlocksProps}&gt;
                        { children }
                        <!-- Insert any arbitrary html here at the same level as the children -->
                      &lt;/div&gt;
                    );
                  },
                } );
            p.
              по умолчанию блоки в InnerBlocks отображаются вертикально<br>
              горизонтально их ориентировать с помощью css
            code &lt;InnerBlocks orientation="horizontal" /&gt;
            p отображает значки перемещения блоков в дочерних блоках горизонтально и обеспечивает правильную работу перетаскивания.
            p блок по умолчанию из списка дозволенных
            code &lt;InnerBlocks defaultBlock={['core/paragraph', {placeholder: "Lorem ipsum..."}]} directInsert /&gt;
            p набор блоков, которые предварительно заполняют компонент InnerBlocks, пока нет своего содержимого.
            pre
              code.
                const MY_TEMPLATE = [
                  [ 'core/image', {} ],
                  [ 'core/heading', { placeholder: 'Book Title' } ],
                  [ 'core/paragraph', { placeholder: 'Summary' } ],
                ];
                //...
                edit: () => {
                  return (
                    &lt;InnerBlocks
                      template={ MY_TEMPLATE }
                      templateLock="all"
                    /&gt;
                  )&gt;
                },
            p templateLock - свойство, чтобы заблокировать шаблон
            // https://github.com/WordPress/gutenberg/tree/HEAD/packages/block-editor/src/components/inner-blocks/README.md#templatelock

          //- Изменить блок
          details
            summary Изменить блок
            // https://developer.wordpress.org/block-editor/getting-started/fundamentals/javascript-in-the-block-editor/
            p Создать файл webpack.config.js и добавить свой код для выполнения webpack
            pre
              code.
                const defaultConfig = require("@wordpress/scripts/config/webpack.config");
                var config = {
                  ...defaultConfig,
                  entry: {
                    ...defaultConfig.entry(),
                    "custom/index": "./src/custom/index.js",
                  },
                };
            p Внутри папки src создать папку custom и в ней файл index.js
            pre
              code.
                import { unregisterBlockType } from "@wordpress/blocks";
                import domReady from "@wordpress/dom-ready";
                const unregisterBlocks = ["core/verse"];
                domReady(function () {
                  unregisterBlocks.forEach(block) => {
                    unregisterBlockType(block);
                  });
                });
            p В файле kweblock.php добавить код для подключения функционала из custom/index.js
            pre
              code.
                function kweblock_enqueue_editor_modifications() {
                  $asset_file = include plugin_dir_path( __FILE__ ) . 'build/custom/index.assets.php';
                  wp_enqueue_script(
                    'kweblock_enqueue_editor_modifications',
                    plugins_url( '/build/custom/index.js', __FILE__ ),
                    $asset_file['dependencies'],
                    $asset_file['version'],
                    true
                  );
                }
                add_action( 'enqueue_block_editor_assets', 'kweblock_enqueue_editor_modifications' );
            // new variation for the Media & Text block
            pre
              code.
                function example_enqueue_block_variations() {
                  wp_enqueue_script(
                    'example-enqueue-block-variations',
                    get_template_directory_uri() . '/assets/js/variations.js',
                    array( 'wp-blocks' ),
                    wp_get_theme()->get( 'Version' ),
                    false
                  );
                }
                add_action( 'enqueue_block_editor_assets', 'example_enqueue_block_variations' );
            // in variations.js file:
            pre
              code.
                wp.blocks.registerBlockVariation(
                  'core/media-text',
                  {
                    name: 'media-text-custom',
                    title: 'Media & Text Custom',
                    attributes: {
                      align: 'wide',
                      backgroundColor: 'tertiary'
                    },
                  }
                );
            p создать шаблон блока типа post сразу с подгрузкой других блоков
            pre
              code.
                add_action( 'init', function() {
                  $post_type_object = get_post_type_object( 'post' );
                  $post_type_object->template = array(
                    array( 'core/image' ),
                    array( 'core/heading' )
                  );
                } );
            // https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/extending-the-query-loop-block/
            a(href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-variations/") Вариации Query Loop block
            p.
              Для того чтобы вариация цикла запросов работала правильно, нам необходимо:
              – Зарегистрировать вариацию блока для core/query блока с некоторыми значениями по умолчанию
              – Определить макет для вариации блока
              – Использовать namespaceатрибут в isActiveсвойстве вариации блока
            pre
              code.
                const MY_VARIATION_NAME = 'my-plugin/books-list';
                registerBlockVariation( 'core/query', {
                  name: MY_VARIATION_NAME,
                  title: 'Books List',
                  description: 'Displays a list of books',
                  <span>указываю активную вариацию, можно итак: isActive: [ 'namespace' ],</span>
                  isActive: ( { namespace, query } ) => {
                    return (
                      namespace === MY_VARIATION_NAME
                      && query.postType === 'book'
                    );
                  },
                  icon: <span>An SVG icon can go here</span>,
                  attributes: {
                    namespace: MY_VARIATION_NAME,
                    query: {
                      perPage: 6,
                      pages: 0,
                      offset: 0,
                      <span>предопределил тип записи для цикла запросов</span>
                      postType: 'book',
                      order: 'desc',
                      orderBy: 'date',
                      author: '',
                      search: '',
                      exclude: [],
                      sticky: '',
                      inherit: false,
                    },
                  },
                  <span>включил отображение блока в редакторе</span>
                  scope: [ 'inserter' ],
                  }
                );
            p.
              Блок Query Loop определяет, есть ли активная вариация и есть ли для неё шаблоны.<br>
              Если есть, то эти шаблоны будут единственными, если нет - шаблоны по умолчанию.
            a(href="https://developer.wordpress.org/block-editor/reference-guides/block-api/block-patterns/") привязать шаблон
            p.
              отключить элементы управления запросами allowedControls<br>
              inherit – переключатель наследованияя запроса непосредственно из шаблона.<br>
              postType – список доступных типов сообщений.<br>
              order – список для выбора порядка запроса.<br>
              sticky – список для выбора способа обработки прикрепленных сообщений.<br>
              taxQuery – фильтры таксономий для текущего выбранного типа записи.<br>
              author – Показывает поле ввода для фильтрации запроса по автору.<br>
              search – Показывает поле ввода для фильтрации запроса по ключевым словам.<br>
              format – Показывает поле ввода для фильтрации запроса по массиву/коллекции форматов .<br>
              parents – Показывает поле ввода для фильтрации запроса с использованием родительской(их) сущности(ей).
            pre
              code.
                {
                  <span>variation properties</span>
                  allowedControls: [ 'inherit', 'order', 'taxQuery', 'search' ],
                }
            p.
              пустой массив скроет все элементы управления<br>
              <br>
              Подключить пользовательские элементы управления через хук React подключенный к фильтру блока
            pre
              code.
                import { InspectorControls } from '@wordpress/block-editor';
                export const withBookQueryControls = ( BlockEdit ) => ( props ) => {
                  <span>We only want to add these controls if it is our variation,</span>
                  <span>so here we can implement a custom logic to check for that, similar</span>
                  <span>to the `isActive` function described above.</span>
                  <span>The following assumes that you wrote a custom `isMyBooksVariation`</span>
                  <span>function to handle that.</span>
                  return isMyBooksVariation( props ) ? (
                    &lt;&gt;
                      &lt;BlockEdit key="edit" { ...props } /&gt;
                      &lt;InspectorControls&gt;
                        &lt;BookAuthorSelector /&gt; { /** Our custom component */ }
                      &lt;/InspectorControls&gt;
                    &lt;/&gt;
                  ) : (
                    &lt;BlockEdit key="edit" { ...props } /&gt;
                  );
                };
                addFilter( 'editor.BlockEdit', 'core/query', withBookQueryControls );
            p Подключить пользовательские элементы управления через фильтр query_loop_block_query_vars
            pre
              code.
                {
                  <span>variation properties</span>
                  attributes: {
                    <span>variation attributes</span>
                    query: {
                      <span>more query settings if needed</span>
                      postType: 'book',
                      <span>Our custom query parameter</span>
                      bookAuthor: 'J. R. R. Tolkien'
                    }
                  }
                }
            p подключаюсь к фильтру на фронте (когда есть доступ к блоку)
            pre
              code.
                if( 'my-plugin/books-list' === $block[ 'attrs' ][ 'namespace' ] ) {
                  add_filter(
                    'query_loop_block_query_vars',
                    function( $query ) {
                      <span>You can read your block custom query parameters here and build your query</span>
                    },
                  );
                }
            p подключаюсь к запросу API записи в редакторе через фильтр rest_{$this->post_type}_query
            pre
              code.
                add_filter(
                  'rest_book_query',
                  function( $args, $request ) {
                    <span>We can access our custom parameters from here</span>
                    $book_author = $request->get_param( 'bookAuthor' );
                    <span>your custom query logic</span>
                  }
                );
            // https://developer.wordpress.org/block-editor/reference-guides/filters/block-filters/
            p изменить поведение или отключить блок
            // https://developer.wordpress.org/block-editor/reference-guides/packages/packages-plugins/
            // https://developer.wordpress.org/block-editor/reference-guides/packages/packages-edit-post/
            p registerPlugin - определить все элементы пользовательского интерфейса плагина в одном месте
            // https://developer.wordpress.org/block-editor/reference-guides/filters/editor-filters/
            p отфильтровать редактор

          //- CSS
          details
            summary CSS
            // https://github.com/WordPress/block-development-examples
            p Inline style - передаю стили в хук React useBlockProps
            pre
              code.
                import { registerBlockType } from '@wordpress/blocks';
                import { useBlockProps } from '@wordpress/block-editor';
                registerBlockType( 'gutenberg-examples/example-02-stylesheets', {
                  edit() {
                    const greenBackground = {
                      backgroundColor: '#090',
                      color: '#fff',
                      padding: '20px',
                    };
                    const blockProps = useBlockProps( { style: greenBackground } );
                    return (
                      &lt;p { ...blockProps }&gt;Hello World (from the editor, in green).&lt;/p&gt;
                    );
                  },
                  save() {
                    const redBackground = {
                      backgroundColor: '#900',
                      color: '#fff',
                      padding: '20px',
                    };
                    const blockProps = useBlockProps.save( { style: redBackground } );
                    return (
                      &lt;p { ...blockProps }&gt;Hello World (from the frontend, in red).&lt;/p&gt;
                    );
                  },
                } );
            // useBlockProps - обёртка блока
            // https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#block-wrapper-props
            p.
              Хук useBlockProps автоматически включает имя класса для блока,
              генерирует имя для каждого блока, используя имя блока с префиксом wp-block-,
              заменет / разделитель пространства имен символом -.
            // https://developer.wordpress.org/block-editor/getting-started/fundamentals/block-in-the-editor/
            p.
              <dfn>useBlockProps()</dfn> - позволяет изменить аттрибуты в оболочке блока,
              определяет внешнюю разметку блока в редакторе
              (это хук из @wordpress/block-editor)
              <dfn>useBlockProps.save()</dfn> - добавляет классы и атрибуты при сохранении в базу
              <dfn>get_block_wrapper_attributes()</dfn> - добавляет классы и атрибуты при динамическом рендере
              wp-block - класс с общими для блоков настройками
            // то же самое, но через отдельные файлы
            p block.json
            pre
              code.
                {
                  "apiVersion": 3,
                  "name": "gutenberg-examples/example-02-stylesheets",
                  "title": "Example: Stylesheets",
                  "icon": "universal-access-alt",
                  "category": "layout",
                  "editorScript": "file:./block.js",
                  "editorStyle": "file:./editor.css",
                  "style": "file:./style.css"
                }
            p editor.css - green background
            pre
              code.
                .wp-block-gutenberg-examples-example-02-stylesheets {
                  background: #090;
                  color: white;
                  padding: 20px;
                }
            p style.css - red background
            pre
              code.
                .wp-block-gutenberg-examples-example-02-stylesheets {
                  background: #900;
                  color: white;
                  padding: 20px;
                }
            p.
              Если использовать `@wordpress/scripts`, то необходимо импортировать таблицу стилей в соответствующий файл JavaScript<br>
              В `edit.js` - `import './editor.scss';`<br>
              В `index.js` - `import './style.scss';`<br>
              В `view.js` - `import './view.scss';`
            //- wp_enqueue_style
            p.
              для включения нескольких файлов использовать wp_enqueue_style на хуках:<br>
              enqueue_block_editor_assets – загружать только в режиме редактора<br>
              enqueue_block_assets – загружается как в интерфейсе, так и в редакторе<br>
              переменная стиля из theme.json в style.scss:
            code var(--wp--preset--color--contrast)
            p переменная стиля из theme.json в json файле:
            code var:preset|color|contrast

          //- Editor
          details
            summary Editor
            p.
              @wordpress/block-editor - пакет позволяет создавать автономные редакторы блоков,
              библиотека JavaScript, которая обеспечивает основную функциональность редактора.
            a(href="https://developer.wordpress.org/block-editor/how-to-guides/platform/custom-block-editor/") Собственный редактор блоков
            p.
              @wordpress/components and @wordpress/block-editor - пакеты для редактора<br>
              для отдельной установки:
            code npm install --save @wordpress/components
            p.
              storybook - https://wordpress.github.io/gutenberg/?path=/docs/docs-introduction--page<br>
              Block Toolbar - компонент BlockControls (@wordpress/block-editor)<br>
              Settings Sidebar - компонент InspectorControls (@wordpress/block-editor)<br>
              CSS компонентов находится по адресу node_modules/@wordpress/components/build-style/style.css<br>
              в консоле браузера wp.data.select('core/editor').getBlocks() - вернет все доступные блоки

          //- Работа с данными
          details
            summary Работа с данными
            p.
              @wordpress/core-data - предоставляет resolvers, selectors и actions для работы с API ядра WordPress
    
      //- Laravel
      details
        summary.menu__submenu_lv1 Laravel
      
        //- Framework
        details
          summary Framework
          p.
            Laravel - это фреймворк MVC, который использует шаблон проектирования MVC (Model-View-Controller).<br>
            Он разделяет приложение на три основных компонента:<br>
            - Модель (Model) - отвечает за работу с данными и бизнес-логикой приложения.<br>
            - Представление (View) - отвечает за отображение данных пользователю.<br>
            - Контроллер (Controller) - связывает модель и представление, обрабатывает запросы и управляет логикой приложения.<br>

          //- Artisan
          //- интерфейс командной строки в Laravel
          details
            summary Create app
            pre
              code.
                php artisan list    // списка всех доступных команд Artisan
                php artisan help migrate    // вызвать справку
                php artisan tinker    // взаимодействовать с приложением из командной строки
                php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"    // конфигурационный файл Tinker
                'commands' => [App\Console\Commands\ExampleCommand::class]    // добавление команд в config/tinker.php
                'dont_alias' => [App\Models\User::class]    //    черный список псевдонимов классов в config/tinker.php
                php artisan make:command SendEmails   // сгенерировать новую команду в app/Console/Commands
                - определить команду artisan в виде класса
                namespace App\Console\Commands;
                use App\Models\User;
                use App\Support\DripEmailer;
                use Illuminate\Console\Command;
                class SendEmails extends Command {
                  protected $signature = 'mail:send {user}';    // имя команды и вводимые данные
                  protected $description = 'Отправка письма пользователю';  // описание команды для list
                  public function handle(DripEmailer $drip): void
                  {$drip->send(User::find($this->argument('user')));}}    // выполнение команды
                - коды завершения команды:
                0 - команда выполнена успешно
                // вернуть ошибку из public function handle()
                $this->error('Что-то пошло не так.');
                return 1;
                // прервать выполнение комады и вернуть код завершения 1
                $this->fail('Что-то пошло не так.');
                - определить команду artisan в routes/console.php
                Artisan::command('mail:send {user}', function (string $user) {$this->info("Отправка почты на: {$user}!");});
                - типизация зависимостей
                use App\Models\User;
                use App\Support\DripEmailer;
                Artisan::command('mail:send {user}', function (DripEmailer $drip, string $user) {$drip->send(User::find($user));});
                - добавить описание команды
                Artisan::command('mail:send {user}', function (string $user) { })->purpose('Отправка письма пользователю');
                - изолированные команды: одновременно выполняется только один экземпляр команды
                namespace App\Console\Commands;
                use Illuminate\Console\Command;
                use Illuminate\Contracts\Console\Isolatable;
                class SendEmails extends Command implements Isolatable { }
                // выполнить изолированную команду: блокировка других экземпляров этой команды в кэш-драйвере
                php artisan mail:send 1 --isolated
                // указать код статуса завершения, если команда не может выполниться
                php artisan mail:send 1 --isolated=12
                // задать id команды для изоляции в кэше (по умолчанию - имя команды)
                public function isolatableId(): string {return $this->argument('user');}
                // время блокировки истекает либо по завершению команды либо через час после прерывания выполнения команды
                  настроить время блокировки
                use DateTimeInterface;
                use DateInterval;
                public function isolationLockExpiresAt(): DateTimeInterface|DateInterval {return now()->addMinutes(5);}
                - вводимые данные (использовать пакет Prompts)
                protected $signature = 'mail:send {user}';    // один обязательный аргумент user
                protected $signature = 'mail:send {user?}';    // один необязательный аргумент user
                protected $signature = 'mail:send {user=foo}';    // один необязательный аргумент user со значением по умолчанию
                protected $signature = 'mail:send {user} {--queue}';    // параметр {--queue} как логический переключатель
                php artisan mail:send 1   // вызов команды: user = 1, --queue = false
                php artisan mail:send 1 --queue   // вызов команды: user = 1, --queue = true
                protected $signature = 'mail:send {user} {--queue=}';   //  параметр {--queue=} ожидает значение
                php artisan mail:send 1   // вызов команды: user = 1, --queue = null
                php artisan mail:send 1 --queue=foo   // вызов команды: user = 1, --queue = foo
                protected $signature = 'mail:send {user} {--queue=default}';   // параметр --queue со значением по умолчанию
                protected $signature = 'mail:send {user} {--Q!queue}';   // назначить псевдоним Q для параметра --queue
                php artisan mail:send 1 -Qfoo  // вызов команды: user = 1, --queue = foo
                - назначить описания входным аргументам и параметрам
                protected $signature = 'mail:send {user : Идентификатор пользователя} {--queue : Поставить ли задание в очередь}';
                - массивы вводимых данных
                protected $signature = 'mail:send {user*}'    // аргумент ожидает массив данных
                php artisan mail:send 1 2   // вызов команды: user = [1, 2]
                protected $signature = 'mail:send {user?*}'    // необязательный аргумент ожидает массив данных
                protected $signature = 'mail:send {--id*}'    // параметр ожидает массив данных
                php artisan mail:send --id=1 --id=2   // вызов команды: id = [1, 2]
                - запрос отсутствующего ввода
                // запросить у пользователя ввод значения аргумента
                namespace App\Console\Commands;
                use Illuminate\Console\Command;
                use Illuminate\Contracts\Console\PromptsForMissingInput;
                class SendEmails extends Command implements PromptsForMissingInput {
                  protected $signature = 'mail:send {user}';}
                // настроить вопрос для пользователя
                protected function promptForMissingArgumentsUsing(): array {
                  return ['user' => 'Какой идентификатор пользователя должен получать почту?'];}
                // настроить вопрос для пользователя с заполнителем
                return ['user' => 'Какой идентификатор пользователя должен получать почту?', 'Например: 123'];}
                // полный контроль запроса на ввод данных пользователем
                use App\Models\User;
                use function Laravel\Prompts\search;
                return [
                  'user' => fn () => search(
                    label: 'Найдите пользователя:',
                    placeholder: 'Например: Тейлор Отвелл',
                    options: fn ($value) => strlen($value) > 0
                      ? User::where('name', 'like', "%{$value}%")->pluck('name', 'id')->all() : [])];
                // запрашивать у пользователя только после автоматического запроса ввести отсутствующие аргументы
                use Symfony\Component\Console\Input\InputInterface;
                use Symfony\Component\Console\Output\OutputInterface;
                use function Laravel\Prompts\confirm;
                protected function afterPromptingForMissingArguments(InputInterface $input, OutputInterface $output): void {
                  $input->setOption('queue', confirm(
                    label: 'Хотите поставить почту в очередь?',
                    default: $this->option('queue')));}
                - получить доступ к значениям введенных аргументов и параметров (методы argument и option)
                public function handle(): void {$userId = $this->argument('user');}
                $arguments = $this->arguments();    // получить все аргументы в виде массива
                $queueName = $this->option('queue');    // получить параметр
                $options = $this->options();    // получить массив
                // запросить у пользователя данные во время выполнения команды
                public function handle(): void {$name = $this->ask('Как вас зовут?');}
                $name = $this->ask('Как вас зовут?', 'Тейлор');   // со значением по умолчанию
                $password = $this->secret('Какой пароль?');   // вводимые символы не отображаются
                if ($this->confirm('Хотите продолжить?')) { }   // запрос подтверждения «yes or no»
                if ($this->confirm('Хотите продолжить?', true)) { }   // со значением по умолчанию
                // возможные варианты автоматического завершения
                $name = $this->anticipate('Как вас зовут?', ['Тейлор', 'Дэйл']);
                // принимать введенные пользователем данные, и возвращать массив вариантов для автозавершения
                $name = $this->anticipate('Какой у вас адрес?', function (string $input) { // возврнуть массив вариантов... });
                // предопределенный набор вариантов 
                $name = $this->choice(
                  'Как вас зовут?',       // вопрос пользователю
                  ['Тейлор', 'Дэйл'],     // массиив предопределенных вариантов
                  $defaultIndex,          // индекс значения по умолчанию из массива вариантов
                  $maxAttempts = null,    // максимальное количество попыток
                  $allowMultipleSelections = false);    // множественный выбор
                - вывод данных в консоль (методы line, info, comment, question, warn и error)
                public function handle(): void {$this->info('Команда выполнена успешно!');}
                $this->error('Something went wrong!');
                $this->line('Отобразить это на экране');
                $this->newLine();   // отобразить пустую строку
                $this->newLine(3);   // отобразить 3 пустые строки
                // форматирование нескольких строк / столбцов данных ('Name', 'Email' - имена столбцов)
                use App\Models\User;
                $this->table(['Name', 'Email'], User::all(['name', 'email'])->toArray());
                // отображать индикатор выполнения
                use App\Models\User;
                $users = $this->withProgressBar(User::all(), function (User $user) {$this->performTask($user);});
                // настроить индикатор вручную
                $users = App\Models\User::all();
                $bar = $this->output->createProgressBar(count($users));
                $bar->start();
                foreach ($users as $user) {
                  $this->performTask($user);
                  $bar->advance();}
                $bar->finish();
                - в bootstrap/app.php
                // сканировать каталоги на наличие команд (по умолчанию в app/Console/Commands)
                ->withCommands([__DIR__.'/../app/Domain/Orders/Commands'])
                // зарегистрировать команду вручную
                use App\Domain\Orders\Commands\SendEmails;
                ->withCommands([SendEmails::class])
                - запустить команду Artisan в маршруте или контроллере
                use Illuminate\Support\Facades\Artisan;
                Route::post('/user/{user}/mail', function (string $user) {
                  $exitCode = Artisan::call('mail:send', ['user' => $user, '--queue' => 'default']);});
                либо
                Artisan::call('mail:send 1 --queue=default');
                либо с массивом
                Route::post('/mail', function () {$exitCode = Artisan::call('mail:send', ['--id' => [5, 13]]);});
                либо с логическим переключателем
                $exitCode = Artisan::call('migrate:refresh', ['--force' => true,]);
                - поставить команды Artisan в очередь для обработки в фоновом режиме
                use Illuminate\Support\Facades\Artisan;
                Route::post('/user/{user}/mail', function (string $user) {
                  Artisan::queue('mail:send', ['user' => $user, '--queue' => 'default']);});
                // указать соединение или очередь, в которую должна быть отправлена команда
                Artisan::queue('mail:send', ['user' => 1, '--queue' => 'default'])
                  ->onConnection('redis')->onQueue('commands');
                // вызвать другие команды из существующей
                public function handle(): void {$this->call('mail:send', ['user' => 1, '--queue' => 'default']);}
                // вызвать команду в тихом режиме
                $this->callSilently('mail:send', ['user' => 1, '--queue' => 'default']);
                - прослушивать сигналы операционных систем в командах Artisan и выполнять код при их возникновении
                public function handle(): void {
                  $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);
                  while ($this->shouldKeepRunning) { }}
                // прослушивания нескольких сигналов сразу
                $this->trap([SIGTERM, SIGQUIT], function (int $signal) {
                  $this->shouldKeepRunning = false;
                  dump($signal);});
                - опубликовать заготовки создания классов командой make для их изменения
                php artisan stub:publish
                - Artisan запускает три события при выполнении команд:
                Illuminate\Console\Events\ArtisanStarting - после запуска Artisan
                Illuminate\Console\Events\CommandStarting - перед запуском команды
                Illuminate\Console\Events\CommandFinished - после завершения команды

          //- Create app
          details
            summary Create app
            pre
              code.
                laravel new example-app
                cd example-app
                php artisan sail:install
            p добавить псевдоним в ~/.zshrc
            pre
              code.
                alias sail='zsh $([ -f sail ] && echo sail || echo vendor/bin/sail)'
                alias sailar='zsh $([ -f sail ] && echo sail artisan || echo vendor/bin/sail artisan)'
                sailar list
                sail up -d
                sailar migrate
                http://localhost
            p остановить контейнеры
            code sail stop 
            p удалить контейнеры
            code sail down
            p удалить контейнеры и тома
            code sail down -v
            p удалить контейнеры, тома и образы
            code sail down --rmi all
            p удалить только тома
            code sail down --volumes
            p удалить контейнеры, которые не определены в docker-compose.yml
            code sail down --remove-orphans
            p пересобрать контейнеры
            code sail build
            p пересобрать контейнеры без кеша
            code sail build --no-cache
            p пересобрать контейнеры с обновлением образов без кеша
            code sail build --pull --no-cache
            p запуск очереди
            code sail artisan queue:work --queue=default --tries=3 --timeout=90 --sleep=3 --delay=0 --max-jobs=1000 --max-time=3600
            p версия php
            code sail php --version
            p выполнить скрипт php
            code sail php script.php
            p установить пакет
            code sail composer require laravel/sanctum
            p запустить скрипт npm
            code sail npm run dev
            p запустить yarn
            code sail yarn
            p запустить сервер на указанном хосте
            code sail artisan serve --host=yourhost
            p Обновить образы:
            pre
              code.
                docker compose down -v
                sail build --no-cache
                sail up -d
              
          //- Folder structure
          details
            summary Folder structure
            p.
              - app - основная папка приложения, код приложения<br>
              - bootstrap - начальная загрузка приложения и кеширование<br>
              - config - конфигурация приложения<br>
              - database - миграции, фабрики, наполнители (seeders), sqlite<br>
              - public - публичная папка приложения, точка входа всех запросов: index.php, оптимизированные ресурсы и автозагрузка<br>
              - resources - неотимизированные и нескомпилированные ресурсы: шаблоны, images, js, css<br>
              - routes - маршруты приложения на указанный метод<br>
              - storage - временные файлы приложения: логи, скомпилированные шаблоны, файлы сессий и кеша<br>
              - tests - тесты приложения<br>
              - vendor - сomposer-зависимости приложения<br>
              - node_modules - node-зависимости приложения<br>
              - .gitignore - файл игнорирования git<br>
              - .gitattributes - файл атрибутов git<br>
              - .dockerignore - файл игнорирования docker<br>
              - .docker-compose.yml - файл конфигурации docker<br>
              - .env - файл окружения приложения<br>
              - .env.example - пример файла окружения приложения<br>
              - .editorconfig - файл конфигурации редактора<br>
              - artisan - консольная команда приложения<br>
              - composer.json - файл сomposer-зависимостей приложения<br>
              - package.json - файл node-зависимостей приложения<br>
              - phpunit.xml - файл конфигурации тестов приложения<br>
              - vite.config.js - файл конфигурации vite приложения<br>

          //- Lifecycle
          details
            summary Lifecycle
            p.
              - Браузер - запрос пользователя<br>
              - Apache / Nginx - веб сервер<br>
              - public/index.php - загружает автозагрузчик<br>
              - bootstrap/app.php - создаёт экземпляр фреймворка<br>
              - laravel - создаёт экземпляр приложения и контейнер служб (регистрация всех сервис-провайдеров bootstrap/providers.php)<br>
              - НТТР-ядро - запрос поступает НТТР-ядру (либо ядру консоли)<br>
              - bootstrappers - массив загрузчиков для обработки ошибок, логирования, среда окружения, middleware<br>
              - маршрутизатор - направляет запрос на указанный метод по маршруту<br>
              - middleware - фильтрация НТТР-запросов<br>
              - контроллер или представление - выполнение метода<br>
              - middleware - фильтрация НТТР-ответов<br>
              - НТТР-ядро - возвращает объект ответа в экзепмляр приложения<br>
              - экземляр приложения - отправляет содержимое ответа в браузер<br>
              - Браузер - рендеринг ответа<br>
            pre
              code.
                Браузер
                  Apache / Nginx -> public/index.php -> bootstrap/app.php
                    laravel -> экземляр приложения
                      НТТР-ядро -> bootstrappers
                        маршрутизатор
                          middleware                                   
                            контроллер -> представление
                          middleware
                      НТТР-ядро
                    экземляр приложения
                Браузер

          //- Configuration
          details
            summary Configuration
            p.
              - config/app.php - конфигурация приложения<br>
              - config/database.php - конфигурация БД<br>
              - config/queue.php - конфигурация очередей<br>
              - config/mail.php - конфигурация почты<br>
              - config/broadcasting.php - конфигурация широковещательных каналов<br>
              - config/filesystems.php - конфигурация файловых систем<br>
              - config/logging.php - конфигурация логирования<br>
              - config/session.php - конфигурация сессий<br>
              - config/services.php - конфигурация сервисов<br>
              - config/queue.php - конфигурация очередей<br>
              - config/cors.php - конфигурация CORS<br>
              - config/sanctum.php - конфигурация Sanctum<br>
              - config/schedule.php - конфигурация планировщика задач<br>
              <br>
              - .env - файл окружения приложения<br>
              - .env.example - пример файла окружения приложения<br>
              - .env.testing - файл окружения для тестов<br>
              - .env.dusk.local - файл окружения для Dusk-тестов<br>
              - .env.dusk.example - пример файла окружения для Dusk-тестов<br>
              - .env.dusk.testing - файл окружения для Dusk-тестов<br>
              <br>
              - php artisan about - обзор конфигурации<br>
              - php artisan about --only=environment - обзор определенного раздела конфигурации<br>
              - php artisan config:show database - обзор  определенного файла конфигурации<br>
              - $_ENV - суперглобальная переменная содержит все переменные, перечисленные в файле .env<br>
              - 'debug' => env('APP_DEBUG', false) - использовать только в конфигурационных файлах для получения значений переменных конфигурации, второй параметр - значение по умолчанию если нет значения переменной<br>
              - текущее окружение<br>
            pre
              code.
                use Illuminate\Support\Facades\App;
                $environment = App::environment();
            p.
              - php artisan env:encrypt - шифрование файла .env<br>
              - доступ к значениям конфигурации<br>
            pre
              code.
                use Illuminate\Support\Facades\Config;
                $value = Config::get('app.timezone');
                $value = config('app.timezone');
            p.
              - php artisan config:cache - кешировать все конфигурационные файлы в один файл при деплое<br>
              - php artisan config:clear - очистки кэша конфигурации<br>
              - php artisan config:publish - публикация файлов конфигурации для модификации<br>
              - php artisan down - включить режим обслуживания<br>
              - php artisan up - отключить режим обслуживания<br>
              - php artisan optimize - оптимизация приложения<br>
              - php artisan optimize:clear - очистка кеша приложения<br>

          //- Logging
          details
            summary Logging
            p.
              - логирование - запись сообщений в журнал<br>
              - лог-файл - файл, в который записываются сообщения<br>
              - уровень логирования - уровень важности сообщения<br>
              - канал (драйвер) логирования - способ записи сообщений в журнал<br>
              - драйверы логирования: single, daily, syslog, errorlog, monolog, null, custom<br>
              - конфигурация ведения журнала config/logging.php<br>
              - изменить имя канала<br>
            pre
              code.
                'stack' => [
                  'driver' => 'stack',
                  'name' => 'channel-name',
                  'channels' => ['single', 'slack'],
                ],
            p конфигурация для продакшина
            pre
              code.
                'channels' => [
                  'stack' => [
                    'driver' => 'stack',
                    'channels' => ['syslog', 'slack'],  
                    'ignore_exceptions' => false,
                  ],
                  'syslog' => [
                    'driver' => 'syslog',
                    'level' => env('LOG_LEVEL', 'debug'),
                    'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
                    'replace_placeholders' => true,
                  ],
                  'slack' => [
                    'driver' => 'slack',
                    'url' => env('LOG_SLACK_WEBHOOK_URL'),
                    'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
                    'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
                    'level' => env('LOG_LEVEL', 'critical'),
                    'replace_placeholders' => true,
                  ],
                ],
            p.
              - уровни журнала в порядке убывания критичности: emergency, alert, critical, error, warning, notice, info, и debug<br>
              - уровень по умолчанию - debug<br>
              - методы записи по уровням<br>
            pre
              code.
                use Illuminate\Support\Facades\Log;
                Log::emergency($message);
                Log::alert($message);
                Log::critical($message);
                Log::error($message);
                Log::warning($message);
                Log::notice($message);
                Log::info($message);
                Log::debug($message);
            p в контроллере
            pre
              code.
                namespace App\Http\Controllers;
                use App\Http\Controllers\Controller;
                use App\Models\User;
                use Illuminate\Support\Facades\Log;
                use Illuminate\View\View;
                class UserController extends Controller
                {
                  - Показать профиль конкретного пользователя.
                  public function show(string $id): View
                  {
                    Log::info('Showing the user profile for user: {id}', ['id' => $id]);
                    return view('user.profile', [
                      'user' => User::findOrFail($id)
                    ]);
                  }
                }
            p регистрировать в журнале id каждого запроса
            pre
              code.
                namespace App\Http\Middleware;
                use Closure;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Log;
                use Illuminate\Support\Str;
                use Symfony\Component\HttpFoundation\Response;
                class AssignRequestId
                {
                  - Обработчик входящего запроса
                  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
                  public function handle(Request $request, Closure $next): Response
                  {
                    $requestId = (string) Str::uuid();
                    Log::withContext([
                      'request-id' => $requestId
                    ]);
                    $response = $next($request);
                    $response->headers->set('Request-Id', $requestId);
                    return $response;
                  }
                }
            p регистрировать id каждого запроса по всем каналам
            pre
              code.
                public function handle(Request $request, Closure $next): Response
                  {
                    $requestId = (string) Str::uuid();
                    Log::shareContext([
                      'request-id' => $requestId
                    ]);
                  }
            p запись в указанный канал
            pre
              code.
                use Illuminate\Support\Facades\Log;
                Log::channel('slack')->info('Something happened!');
            p запись в несколько каналов
            code Log::stack(['single', 'slack'])->info('Something happened!');
            p создать канал по запросу
            pre
              code.
                use Illuminate\Support\Facades\Log;
                Log::build([
                  'driver' => 'single',
                  'path' => storage_path('logs/custom.log'),
                ])->info('Something happened!');
            p создать канал по запросу и включить в стэк
            pre
              code.
                use Illuminate\Support\Facades\Log;
                $channel = Log::build([
                  'driver' => 'single',
                  'path' => storage_path('logs/custom.log'),
                ]);
                Log::stack(['slack', $channel])->info('Something happened!');
            p настроить канал вручную через свой класс
            pre
              code.
                'single' => [
                  'driver' => 'single',
                  'tap' => [App\Logging\CustomizeFormatter::class],
                  'path' => storage_path('logs/laravel.log'),
                  'level' => env('LOG_LEVEL', 'debug'),
                  'replace_placeholders' => true,
                ],
            p свой класс
            pre
              code.
                namespace App\Logging;
                use Illuminate\Log\Logger;
                use Monolog\Formatter\LineFormatter;
                class CustomizeFormatter
                {
                  - Настроить переданный экземпляр регистратора.
                  public function __invoke(Logger $logger): void
                  {
                    foreach ($logger->getHandlers() as $handler) {
                      $handler->setFormatter(new LineFormatter(
                        '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'
                      ));
                    }
                  }
                }
            p указать обработчик
            pre
              code.
                'logentries' => [
                  'driver'  => 'monolog',
                  'handler' => Monolog\Handler\SyslogUdpHandler::class,
                  'with' => [
                    'host' => 'my.logentries.internal.datahubhost.company.com',
                    'port' => '10000',
                  ],
                ],
            p задать форматирование
            pre
              code.
                'browser' => [
                  'driver' => 'monolog',
                  'handler' => Monolog\Handler\BrowserConsoleHandler::class,
                  'formatter' => Monolog\Formatter\HtmlFormatter::class,
                  'formatter_with' => [
                    'dateFormat' => 'Y-m-d',
                  ],
                ],

                либо
                'newrelic' => [
                  'driver' => 'monolog',
                  'handler' => Monolog\Handler\NewRelicHandler::class,
                  'formatter' => 'default',
                ],
            p обрабатывать сообщения перед их записью в журнал
            pre
              code.
                'memory' => [
                  'driver' => 'monolog',
                  'handler' => Monolog\Handler\StreamHandler::class,
                  'with' => [
                    'stream' => 'php://stderr',
                  ],
                  'processors' => [
                    // Simple syntax
                    Monolog\Processor\MemoryUsageProcessor::class,

                    // With options
                    [
                    'processor' => Monolog\Processor\PsrLogMessageProcessor::class,
                    'with' => ['removeUsedContextFields' => true],
                    ],
                  ],
                ],
            p создать канал через фабрику
            pre
              code.
                'channels' => [
                  'example-custom-channel' => [
                    'driver' => 'custom',
                    'via' => App\Logging\CreateCustomLogger::class,
                  ],
                ],
            p класс фабрика
            pre
              code.
                namespace App\Logging;
                use Monolog\Logger;
                class CreateCustomLogger
                {
                  - Создать экземпляр собственного регистратора Monolog
                  public function __invoke(array $config): Logger
                  {
                    return new Logger(/* ... */);
                  }
                }
            p просмотр сообщений в журнале
            pre
              code.
                composer require laravel/pail
                php artisan pail

                либо
                php artisan pail -v
            p фильтровать вывод инфы
            code php artisan pail --filter="QueryException"
            p фильтровать по сообщениям
            code php artisan pail --message="User created" created"
            p фильтровать по уровням
            code php artisan pail --level=error
            p фильтровать по пользователю
            code php artisan pail --user=1

          //- Packages
          details
            summary Packages
            p.
              - Cashier (Stripe) - платежная система Stripe<br>
              - Cashier (Paddle) - платежная система Paddle<br>
              - Dusk - автоматизация и тестирование браузеров<br>
              - Envoy - выполнение задач на удаленных серверах<br>
              - Fortify - backend реализация authentication<br>
              - Folio - роутер, основанный на страницах для упрощения маршрутизации<br>
              - Homestead - локальная среда разработки на Vagrant<br>
              - Horizon - панель управления и конфигурацию для Redis системы очередей<br>
              - Mix - компиляция и минимизация файлов CSS и JavaScript<br>
              - Octane - увеличивает производительность приложения<br>
              - Passport - обеспечивает полную реализацию OAuth2 сервера для приложения<br>
              - Pennant - комплект флагов без крафт. Флаги позволяют постепенно внедрять новые функции приложений, А/Б тестировать новые интерфейсы, дополнять стратегию развития на основе ствола<br>
              - Pint - стиль кода, устанавливается по умолчанию<br>
              - Precognition - предвидеть результат будущего HTTP-запроса, выполнит всю промежуточную обработку маршрута и разрешит зависимости контроллера, включая валидацию запросов формы без выполнения метода контроллера.<br>
              - Prompts - добавление красивых и удобных форм и подсказок к приложениям командной строки с функциями браузера<br>
              - Pulse - сведения о производительности и использовании приложения<br>
              - Reverb - масштабируемый в реальном времени WebSocket коммуникаций<br>
              - Sail - взаимодействие со средой разработки Docker<br>
              - Sanctum - система аутентификации для SPA (приложения с одной страницей), мобильные приложения и простые токены-API<br>
              - Scout - полнотекстовоый поиск<br>
              - Socialite аутентификация через соц.сети<br>
              - Telescope предоставляет информацию о поступающих запросах, исключениях, записях записей, баз данных, задаваемых заданий, почтовых сообщений, уведомлениях, операциях кэша, запланированных задачах, переменных дампов и т.д.<br>
              - Valet среда разработки для мак

          //- Testing
          details
            summary Testing
            p.
              - pest: это обёртка для phpunit.<br>
              - файл tests/Pest.php - конфигурация тестов<br>
              - создаю тест
            code php artisan make:test
            p запускаю тест
            code php artisan test
            p - создание теста в tests/Feature
            code php artisan make:test UserTest
            p - создание теста в tests/Unit
            code php artisan make:test UserTest --unit
            p - создание юнит-теста с использованием Pest, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода
            code php artisan make:test UserTest --pest --unit --force --quiet --no-interaction --no-ansi
            p. 
              - php artisan test - запуск тестов<br>
              - ./vendor/bin/phpunit - запуск тестов<br>
              - ./vendor/bin/pest - запуск тестов<br>
              <br>
              - ./vendor/bin/phpunit tests/Feature/UserTest.php::testBasic<br>
              - ./vendor/bin/phpunit tests/Unit/UserTest.php::testBasic<br>
              <br>
              - настроить переменные окружения testing можно в phpunit.xml<br>
              - после внесения изменений выполнить очистку кэша<br>
            code php artisan config:clear
            p.
              - при тесторовании вместо .env можно использовать .env.testing<br>
              - сгенерировать новый тестовый файл .env.testing<br>
            code cp .env.example .env.testing
            p в UserTest
            pre
              code.
                test('basic', function () {
                    expect(true)->toBeTrue();
                });
            p передать аргументы
            code php artisan test --testsuite=Feature --stop-on-failure
            p запуск тестов в командной строке
            pre
              code.
                ./vendor/bin/phpunit
                либо
                ./vendor/bin/pest
                либо
                php artisan test
            p параллельный запуск тестов
            pre
              code.
                composer require brianium/paratest --dev
                php artisan test --parallel
                // настроить количество процессов - не более количества ядер ЦП на компьюторе
                php artisan test --parallel --processes=4
                // пересоздать тестовые БД
                php artisan test --parallel --recreate-databases
            p.
              хуки параллельного тестирования:<br>
              подготовка определенные ресурсы, используемые тестами<br>
              $token - токен процесса<br>
              $testCase - текущий тестовый класс<br>
            pre
              code.
                namespace App\Providers;
                use Illuminate\Support\Facades\Artisan;
                use Illuminate\Support\Facades\ParallelTesting;
                use Illuminate\Support\ServiceProvider;
                use PHPUnit\Framework\TestCase;
                class AppServiceProvider extends ServiceProvider
                {
                  public function boot(): void
                  {
                    ParallelTesting::setUpProcess(function (int $token) {});
                    ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {});
                    // Выполнится при создании тестовой БД...
                    ParallelTesting::setUpTestDatabase(function (string $database, int $token) {
                      Artisan::call('db:seed');
                    });
                    ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {});
                    ParallelTesting::tearDownProcess(function (int $token) {});
                  }
                }
            p доступ к текущему “токену” параллельного процесса из любого места приложения
            code $token = ParallelTesting::token();
            p отчет о покрытии тестами (требуется Xdebug или PCOV.)
            code php artisan test --coverage
            p задать минимальный порог покрытия тестами
            code php artisan test --coverage --min=80.3
            p получить список десяти самых медленных тестов
            code php artisan test --profile
            p.
              - сделать запрос к приложению - вызвать в тесте методы get, post, put, patch, или delete<br>
              - один тест - один запрос<br>
            pre
              code.
                test('the application returns a successful response', function () {
                  $response = $this->get('/');
                  $response->assertStatus(200);
                });
            p настройки заголовков запроса
            pre
              code.
                test('interacting with headers', function () {
                  $response = $this->withHeaders([
                    'X-Header' => 'Value',
                  ])->post('/user', ['name' => 'Sally']);
                  $response->assertStatus(201);
                });
            p установить значения файлов Cookies
            pre
              code.
                test('interacting with cookies', function () {
                  $response = $this->withCookie('color', 'blue')->get('/');
                  $response = $this->withCookies([
                    'color' => 'blue',
                    'name' => 'Taylor',
                  ])->get('/');
                });
            p установить данные сессии
            pre
              code.
                test('interacting with the session', function () {
                  $response = $this->withSession(['banned' => false])->get('/');
                });
            p actingAs – аутентифицировать указанного пользователя как текущего
            pre
              code.
                use App\Models\User;
                test('an action that requires authentication', function () {
                  $user = User::factory()->create();
                  $response = $this->actingAs($user)
                            ->withSession(['banned' => false])
                            ->get('/');
                });
            p с использованием гэйта
            code $this->actingAs($user, 'web')
            p проверка и отладка содержимого ответа
            pre
              code.
                test('basic test', function () {
                  $response = $this->get('/');
                  $response->dumpHeaders();
                  $response->dumpSession();
                  $response->dump();
                });
                либо
                test('basic test', function () {
                  $response = $this->get('/');
                  $response->ddHeaders();
                  $response->ddSession();
                  $response->dd();
                });
            p тесты исключений
            pre
              code.
                use App\Exceptions\InvalidOrderException;
                use Illuminate\Support\Facades\Exceptions;
                test('exception is thrown', function () {
                  Exceptions::fake();
                  $response = $this->get('/order/1');
                  Было ли выброшено исключение InvalidOrderException
                  Exceptions::assertReported(InvalidOrderException::class);
                  Было ли выброшено исключение InvalidOrderException с заданным сообщением
                  Exceptions::assertReported(function (InvalidOrderException $e) {
                    return $e->getMessage() === 'The order was invalid.';
                  });
                });
            p указанное исключение и никаких исключений не было создано во время запроса
            pre
              code.
                Exceptions::assertNotReported(InvalidOrderException::class);
                Exceptions::assertNothingReported();
            p отключить обработку исключений для данного запроса
            code $response = $this->withoutExceptionHandling()->get('/');
            p проверить, что приложение не использует устаревшие функции
            code $response = $this->withoutDeprecationHandling()->get('/');
            p проверить, что код внутри замыкания генерирует исключение указанного типа
            pre
              code.
                $this->assertThrows(
                  fn () => (new ProcessOrder)->execute(),
                  OrderInvalid::class
                );
            p проверить, что код внутри замыкания генерирует исключение указанного типа, а исключение равно заданому значению
            pre
              code.
                $this->assertThrows(
                  fn () => (new ProcessOrder)->execute(),
                  fn (OrderInvalid $e) => $e->orderId() === 123;
                );
            p.
              тесты JSON API<br>
              методы для тестирования API-интерфейсов JSON и их ответов: json, getJson, postJson, putJson, patchJson, deleteJson, и optionsJson<br>
              сделать запрос POST к /api/user<br>
            pre
              code.
                test('making an api request', function () {
                  $response = $this->postJson('/api/user', ['name' => 'Sally']);
                  $response
                    ->assertStatus(201)
                    // метод assertJson используется для подтверждения наличия фрагмента JSON в ответе JSON
                    ->assertJson([
                      'created' => true,
                    ]);
                });
            p получить доступ к данным ответа JSON как к массиву
            code expect($response['created'])->toBeTrue();
            p проверить, что массив в точности соответствует JSON
            pre
              code.
                test('asserting an exact json match', function () {
                  $response = $this->postJson('/user', ['name' => 'Sally']);
                  $response
                    ->assertStatus(201)
                    ->assertExactJson([
                      'created' => true,
                    ]);
                });
            p убедиться, что ответ JSON содержит данные по указанному пути
            pre
              code.
                test('asserting a json path value', function () {
                  $response = $this->postJson('/user', ['name' => 'Sally']);
                  $response
                    ->assertStatus(201)
                    ->assertJsonPath('team.owner.name', 'Darian');
                });
            p динамическое определение, должно ли утверждение выполниться
            code $response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);
            p последовательное тестирование ответов JSON
            pre
              code.
                use Illuminate\Testing\Fluent\AssertableJson;
                test('fluent json', function () {
                  $response = $this->getJson('/users/1');
                  $response
                    ->assertJson(fn (AssertableJson $json) =>
                      $json->where('id', 1)
                        // where - для присутствующего атрибута 
                        ->where('name', 'Victoria Faith')
                        ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
                        ->whereNot('status', 'pending')
                        // missing - для отсутствующего атрибута JSON
                        ->missing('password')
                        // etc - в объекте JSON могут присутствовать другие атрибуты
                        ->etc()
                      );
                });
            p проверить, что атрибут присутствует или отсутствует (has и missing)
            pre
              code.
                $response->assertJson(fn (AssertableJson $json) =>
                  $json->has('data')
                    ->missing('message')
                );
            p наличие или отсутствие нескольких атрибутов (hasAll и missingAll)
            pre
              code.
                $response->assertJson(fn (AssertableJson $json) =>
                  $json->hasAll(['status', 'data'])
                    ->missingAll(['message', 'code'])
                );
            p присутствует ли хотя бы один из заданного списка
            pre
              code.
                $response->assertJson(fn (AssertableJson $json) =>
                  $json->has('status')
                    ->hasAny('data', 'message', 'code')
                );
            p проверить маршрут, который возращает всех пользователей
            pre
              code.
                Route::get('/users', function () {
                  return User::all();
                });
            p тест по первому пользователю
            pre
              code.
                $response
                  ->assertJson(fn (AssertableJson $json) =>
                    $json->has(3)
                      ->first(fn (AssertableJson $json) =>
                        $json->where('id', 1)
                          ->where('name', 'Victoria Faith')
                          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
                          ->missing('password')
                          ->etc()
                      )
                  );
            p проверить маршрут, который возвращает коллекцию JSON с именованными ключами
            pre
              code.
                Route::get('/users', function () {
                  return [
                    'meta' => [...],
                    'users' => User::all(),
                  ];
                })
                тест
                $response
                  ->assertJson(fn (AssertableJson $json) =>
                    $json->has('meta')
                      ->has('users', 3)
                      ->has('users.0', fn (AssertableJson $json) =>
                        $json->where('id', 1)
                          ->where('name', 'Victoria Faith')
                          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
                          ->missing('password')
                          ->etc()
                      )
                  );
                либо
                $response
                  ->assertJson(fn (AssertableJson $json) =>
                    $json->has('meta')
                      ->has('users', 3, fn (AssertableJson $json) =>
                        $json->where('id', 1)
                          ->where('name', 'Victoria Faith')
                          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
                          ->missing('password')
                          ->etc()
                      )
                  );
            p проверить тип
            pre
              code.
                $response->assertJson(fn (AssertableJson $json) =>
                  $json->whereType('id', 'integer')
                    ->whereAllType([
                      'users.0.name' => 'string',
                      'meta' => 'array'
                    ])
                );
            p проверить наличие одного из типов, допустимые типы: string, integer, double, boolean, array, и null
            pre
              code.
                $response->assertJson(fn (AssertableJson $json) =>
                  $json->whereType('name', 'string|null')
                    ->whereType('id', ['string', 'integer'])
                );
            p.
              тесты загрузки файлов<br>
              протестировать форму загрузки аватара<br>
              метод fake есть у класса UploadedFile и у фасада Storage<br>
            pre
              code.
                use Illuminate\Http\UploadedFile;
                use Illuminate\Support\Facades\Storage;
                test('avatars can be uploaded', function () {
                  Storage::fake('avatars');
                  $file = UploadedFile::fake()->image('avatar.jpg');
                  $response = $this->post('/avatar', [
                    'avatar' => $file,
                  ]);
                  Storage::disk('avatars')->assertExists($file->hashName());
                });
            p подтвердить, что переданный файл не существует
            pre
              code.
                Storage::fake('avatars');
                Storage::disk('avatars')->assertMissing('missing.jpg');
            p указать ширину, высоту и размер изображения (в килобайтах)
            code UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);
            p создать pdf
            code UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);
            p явно определить MIME-тип файла
            pre
              code.
                UploadedFile::fake()->create(
                  'document.pdf', $sizeInKilobytes, 'application/pdf'
                );
            p тесты шаблонов: assertSee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee и assertDontSeeText
            pre
              code.
                test('a welcome view can be rendered', function () {
                  $view = $this->view('welcome', ['name' => 'Taylor']);
                  $view->assertSee('Taylor');
                });
            p получить необработанное отрисованное содержимое шаблона
            code $contents = (string) $this->view('welcome');
            p добавить в глобальную коллекцию ошибок сообщения об ошибках
            pre
              code.
                $view = $this->withViewErrors([
                  'name' => ['Please provide a valid name.']
                ])->view('form');
                $view->assertSee('Please provide a valid name.');
            p метод blade возвращает экземпляр Illuminate\Testing\TestView
            pre
              code.
                $view = $this->blade(
                  '&lt;x-component :name="$name" /&gt;',
                  ['name' => 'Taylor']
                );
                $view->assertSee('Taylor');
            p метод component возвращает экземпляр Illuminate\Testing\TestComponent
            pre
              code.
                $view = $this->component(Profile::class, ['name' => 'Taylor']);
                $view->assertSee('Taylor');
            a(href="http://laravel.su/docs/12.x/http-tests#utverzdeniia-otvetov") доступные утверждения ответов
            p.
              тесты аутентификации<br>
              пользователь аутентифицирован<br>
            code $this->assertAuthenticated($guard = null);
            p пользователь не аутентифицирован
            code $this->assertGuest($guard = null);
            p конкретный пользователь аутентифицирован
            code $this->assertAuthenticatedAs($user, $guard = null);
            p.
              тесты валидации<br>
              ответ содержит ошибки валидации для указанных ключей<br>
            pre
              code.
                $response->assertInvalid(['name', 'email']);
                // либо
                $response->assertInvalid([
                  'name' => 'The name field is required.',
                  'email' => 'valid email address',
                ]);
            p.
              тесты консоли<br>
              метод artisan для вызова Artisan-команды из теста,<br>
              метод assertExitCode, проверить, что команда завершилась с указанным кодом (код 0 - успех, остальное - нет)<br>
            pre
              code.
                test('console command', function () {
                  $this->artisan('inspire')->assertExitCode(0);
                });
            p команда не завершилась с заданным кодом
            pre
              code.
                $this->artisan('inspire')->assertNotExitCode(1);
                // либо
                $this->artisan('inspire')->assertSuccessful();
                $this->artisan('inspire')->assertFailed();
            p.
              тесты ввода/вывода<br>
              метод expectsQuestion - имитировать ввод пользователя в консольных командах<br>
              метод assertExitCode - ожидаемый код завершения команды<br>
              метод expectsOutput - ожидаемый при выполнении команды текст<br>
            p консольная команда
            pre
              code.
                Artisan::command('question', function () {
                  $name = $this->ask('What is your name?');
                  $language = $this->choice('Which language do you prefer?', [
                    'PHP',
                    'Ruby',
                    'Python',
                  ]);
                  $this->line('Your name is '.$name.' and you prefer '.$language.'.');
                });
            p проверить команду
            pre
              code.
                test('console command', function () {
                  $this->artisan('question')
                    ->expectsQuestion('What is your name?', 'Taylor Otwell')
                    ->expectsQuestion('Which language do you prefer?', 'PHP')
                    ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')
                    ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')
                    ->assertExitCode(0);
                });
            p expectsSearch, чтобы имитировать ввод пользователя, результаты поиска и выбор
            pre
              code.
                test('console command', function () {
                  $this->artisan('example')
                    ->expectsSearch('What is your name?', search: 'Tay', answers: [
                      'Taylor Otwell',
                      'Taylor Swift',
                      'Darian Taylor'
                    ], answer: 'Taylor Otwell')
                    ->assertExitCode(0);
                });
            p проверить, что команда не генерирует никакого вывода
            pre
              code.
                test('console command', function () {
                  $this->artisan('example')
                    ->doesntExpectOutput()
                    ->assertExitCode(0);
                });
            p проверить часть вывода
            pre
              code.
                test('console command', function () {
                  $this->artisan('example')
                    ->expectsOutputToContain('Taylor')
                    ->assertExitCode(0);
                });
            p команды ожидает ответа «да» или «нет»
            pre
              code.
                $this->artisan('module:import')
                  ->expectsConfirmation('Do you really wish to run this command?', 'no')
                  ->assertExitCode(1);
            p проверить таблицу
            pre
              code.
                $this->artisan('users:all')
                  ->expectsTable([
                    'ID',
                    'Email',
                  ], [
                    [1, 'taylor@example.com'],
                    [2, 'abigail@example.com'],
                  ]);
            p включить генерацию консольных событий при выполнении тестов
            pre
              code.
                use Illuminate\Foundation\Testing\WithConsoleEvents;
                uses(WithConsoleEvents::class);
            p.
              тесты БД<br>
              сброс БД после каждого теста<br>
            pre
              code.
                use Illuminate\Foundation\Testing\RefreshDatabase;
                uses(RefreshDatabase::class);
                test('basic example', function () {
                  $response = $this->get('/');
                });
            p.
              полностью сбросить БД
              - использовать трейты Illuminate\Foundation\Testing\DatabaseMigrations или Illuminate\Foundation\Testing\DatabaseTruncation<br>
              - использовать фабрику в тестах<br>
            pre
              code.
                use App\Models\User;
                test('models can be instantiated', function () {
                    $user = User::factory()->create();
                });
            p использовать наполнитель в тестах
            pre
              code.
                use Database\Seeders\OrderStatusSeeder;
                use Database\Seeders\TransactionStatusSeeder;
                use Illuminate\Foundation\Testing\RefreshDatabase;
                uses(RefreshDatabase::class);
                test('orders can be created', function () {
                  // Run the DatabaseSeeder...
                  $this->seed();
                  // Run a specific seeder...
                  $this->seed(OrderStatusSeeder::class);
                  Run an array of specific seeders...
                    $this->seed([
                      OrderStatusSeeder::class,
                      TransactionStatusSeeder::class,
                  ]);
                });
            p автоматически заполнять базу данных перед каждым тестом
            pre
              code.
                namespace Tests;
                use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
                abstract class TestCase extends BaseTestCase
                {
                  - Указывает, следует ли запускать наполнитель по умолчанию перед каждым тестом.
                  - @var bool
                  protected $seed = true;
                }
                либо
                use Database\Seeders\OrderStatusSeeder;
                protected $seeder = OrderStatusSeeder::class;
            p таблица в базе данных содержит указанное количество записей
            code $this->assertDatabaseCount('users', 5);
            p таблица в базе данных не содержит записей
            code $this->assertDatabaseEmpty('users');
            p таблица в базе данных содержит записи, соответствующие переданным ключ/значение
            pre
              code.
                $this->assertDatabaseHas('users', [
                  'email' => 'sally@example.com',
                ]);
            p таблица в базе данных не содержит записей, соответствующих переданным ключ/значение
            pre
              code.
                $this->assertDatabaseMissing('users', [
                  'email' => 'sally@example.com',
                ]);
            p модель была «программно удалена»
            code $this->assertSoftDeleted($user);
            p модель не была «программно удалена»
            code $this->assertNotSoftDeleted($user);
            p данная модель существует в базе данныхuse App\Models\User;
            pre
              code.
                $user = User::factory()->create();
                $this->assertModelExists($user);
            p данной модели не существует в базе данных
            pre
              code.
                use App\Models\User;
                $user = User::factory()->create();
                $user->delete();
                $this->assertModelMissing($user);
            p ожидаемое числа запросов к базе данных во время выполнения теста
            code $this->expectsDatabaseQueryCount(5);
            p.
              имитация:<br>
              использовать подставной экземпляр объекта вместо создания самого объекта<br>
            pre
              code.
                use App\Service;
                use Mockery;
                use Mockery\MockInterface;
                test('something can be mocked', function () {
                  $this->instance(
                    Service::class,
                    Mockery::mock(Service::class, function (MockInterface $mock) {
                      $mock->shouldReceive('process')->once();
                    })
                  );
                });
                // либо
                use App\Service;
                use Mockery\MockInterface;
                $mock = $this->mock(Service::class, function (MockInterface $mock) {
                  $mock->shouldReceive('process')->once();
                });
            p имитировать несколько методов объекта
            pre
              code.
                use App\Service;
                use Mockery\MockInterface;
                $mock = $this->partialMock(Service::class, function (MockInterface $mock) {
                  $mock->shouldReceive('process')->once();
                });
            p шпионы записывают любое взаимодействие между шпионом и тестируемым кодом
            pre
              code.
                use App\Service;
                $spy = $this->spy(Service::class);
                $spy->shouldHaveReceived('process');
            p для контроллера
            pre
              code.
                namespace App\Http\Controllers;
                use Illuminate\Support\Facades\Cache;
                class UserController extends Controller
                {
                  - Получить список всех пользователей приложения
                  public function index(): array
                  {
                    $value = Cache::get('key');
                    return [];
                  }
                }
            p имитировать вызов фасада Cache
            pre
              code.
                use Illuminate\Support\Facades\Cache;
                test('get index', function () {
                  Cache::shouldReceive('get')
                        ->once()
                        ->with('key')
                        ->andReturn('value');
                  $response = $this->get('/users');
                });
            p шпионить за фасадом
            pre
              code.
                use Illuminate\Support\Facades\Cache;
                test('values are be stored in cache', function () {
                  Cache::spy();
                  $response = $this->get('/');
                  $response->assertStatus(200);
                  Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);
                });
            p управлять текущим временем
            pre
              code.
                test('time can be manipulated', function () {
                  // Travel into the future...
                  $this->travel(5)->milliseconds();
                  $this->travel(5)->seconds();
                  $this->travel(5)->minutes();
                  $this->travel(5)->hours();
                  $this->travel(5)->days();
                  $this->travel(5)->weeks();
                  $this->travel(5)->years();
                  // Travel into the past...
                  $this->travel(-5)->hours();
                  // Travel to an explicit time...
                  $this->travelTo(now()->subHours(6));
                  // Return back to the present time...
                  $this->travelBack();
                });
                либо
                $this->travel(5)->days(function () {
                  // Test something five days into the future...
                });
                $this->travelTo(now()->subDays(10), function () {
                  // Test something during a given moment...
                });
                либо
                use Illuminate\Support\Carbon;
                // Freeze time and resume normal time after executing closure...
                $this->freezeTime(function (Carbon $time) { });
                // Freeze time at the current second and resume normal time after executing closure...
                $this->freezeSecond(function (Carbon $time) { })
            p блокировка неактивных сообщений на форуме
            pre
              code.
                use App\Models\Thread;
                test('forum threads lock after one week of inactivity', function () {
                  $thread = Thread::factory()->create();
                  $this->travel(1)->week();
                  expect($thread->isLockedByInactivity())->toBeTrue();
                });
            p тесты браузера

        //- Application
        details
          summary Application

          //- Catalog namespace App
          details
            summary Catalog namespace App
            p.
              - Broadcasting - классы широковещательных каналов<br>
              - Console - пользовательские команды Artisan<br>
              - Events - классы событий<br>
              - Notifications - уведомления о событиях, которые происходят в приложении<br>
              - Exceptions - классы исключений<br>
              - Http - логика обработки поступающих запросов: классы контроллеров, middleware и запросов<br>
              - Jobs - планировщики заданий<br>
              - Listeners - обработчики событий<br>
              - Controllers - логика обработки запросов<br>
              - Middleware - фильтрация запросов<br>
              - Mail - классы для работы с почтой<br>
              - Models - классы моделей Eloquent для взаимодействия с таблицами БД<br>
              - Policies - классы политик авторизации определяют возможные действия пользователя<br>
              - Providers - классы поставщиков служб: таких как база данных, очереди, валидация и маршрутизация<br>
              - Rules - классы правил валидации<br>
              - Requests - правила валидации запроса<br>
              - Resources - классы ресурсов API<br>
              - Services - классы сервисов, которые реализуют бизнес-логику приложения<br>
              - Traits - классы трейтов, которые могут быть использованы в других классах<br>
            
          //- Routes
          //- маршрут это URI и поведение при запросе этого URI
          details
            summary Routes
            p.
              маршрут это URI и поведение при запросе этого URI<br>
              ананимные функции маршрутов - это альтернатива контроллеров и консольных команд в виде классов<br>
              routes/console.php не определяет HTTP-маршруты, он определяет консольные точки входа<br>
              - api.php - маршруты API<br>
              - channels.php - маршруты широковещательной передачи<br>
              - console.php - маршруты консоли<br>
              - web.php - маршруты веб-приложения<br>
            pre
              code.
                use Illuminate\Support\Facades\Route;
                Route::get('/greeting', function () {return 'Hello World';});   // вернуть 'Hello World'
                Route::get('/jobs', [JobController::class, 'index']);    // вызывать метод index JobController при переходе на /jobs
            p маршруты НТТР-методов
            pre
              code.
                Route::get($uri, $callback);    // маршрут с методом get всегда указывать первым
                Route::post($uri, $callback);
                Route::put($uri, $callback);
                Route::patch($uri, $callback);
                Route::delete($uri, $callback);
                Route::options($uri, $callback);
                Route::any('/', function () {});   // все методы на одном маршруте
                Route::match(['get', 'post'], '/', function () {});    // несколько методов на одном маршруте
                Route::redirect('/here', '/there', 301);   // перенаправить маршрут, третий необязательный параметр (301)
                Route::view('/welcome', 'welcome', ['name' => 'Taylor']);    // вернуть шаблон 'welcome' с переменной 'name'
                // маршруты поддоменов указывать перед маршрутами корневого домена
                Route::domain('{account}.example.com')->group(function () {
                  Route::get('/user/{id}', function (string $account, string $id) {});
                });
            p artisan для маршрутов
            pre
              code.
                // кеш маршрутов
                php artisan route:cache    // кешировать
                php artisan route:clear    // очистить
                // список маршрутов
                php artisan route:list -v    // просмотреть список маршрутов с малой информацией
                php artisan route:list -vv    // просмотреть список маршрутов с подробной информацией
                php artisan route:list --path=api    // просмотреть список api-маршрутов
                php artisan route:list --except-vendor    // просмотреть список маршрутов без встроенных
                php artisan route:list --only-vendor    // просмотреть список только встроенных маршрутов
                // API-маршруты
                php artisan install:api   // установить пакет Sanctum и создать routes/api.php
            p настройка маршрутизации в bootstrap/app.php
            pre
              code.
                // параметры и зависимости маршрута
                Route::get('/posts/{post}/comments/{comment}', function (Request $request, string $postId, string $commentId) {});
                // изменить ключ
                Route::get('/posts/{post:slug}', function (Post $post) {return $post;});
                // у необязательного параметра должно быть значение по умолчанию
                Route::get('/user/{name?}', function (?string $name = 'John') {return $name;});
                // формат маршрута в регулярном выражении
                Route::get('/user/{id}/{name}', function (string $id, string $name) { })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);
                // методы типовых шаблонов регулярных выражений
                whereNumber('id')
                whereAlpha('name')
                whereAlphaNumeric('name')
                whereUuid('id')
                whereUlid('id')
                whereIn('category', ['movie', 'song', 'painting'])
                whereIn('category', CategoryEnum::cases())
            p в App\Providers\AppServiceProvider
            pre
              code.
                // глобальный шаблон
                use Illuminate\Support\Facades\Route;
                public function boot(): void
                {Route::pattern('id', '[0-9]+');}
                // связывание модели и URI
                {Route::model('user', User::class);}  // в маршруте: Route::get('/users/{user}', function (User $user) { });
                // поменять логику связывания модели и URI
                {Route::bind('user', function (string $value) {return User::where('name', $value)->firstOrFail();});}
                // ограничение частоты запросов
                {RateLimiter::for('api', function (Request $request) {return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());});}
                // ограничение частоты запросов и своё сообщение
                {RateLimiter::for('global', function (Request $request) {
                  return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
                    return response('Custom response...', 429, $headers);
                  });
                });}
                // ограничение частоты запросов по статусу пользователя
                {RateLimiter::for('uploads', function (Request $request) {
                  return $request->user()->vipCustomer() ? Limit::none() : Limit::perMinute(100);
                });}
                // ограничение частоты запросов отдельно по ip и id
                {RateLimiter::for('uploads', function (Request $request) {
                  return $request->user() ? Limit::perMinute(100)->by($request->user()->id) : Limit::perMinute(10)->by($request->ip());
                });}
                // ограничение частоты запросов по маршрутам
                {Route::middleware(['throttle:uploads'])->group(function () {
                  Route::post('/audio', function () {});
                  Route::post('/video', function () {});
                });}
            p маршрут и модель
            pre
              code.
                - wildcard {user} and parametr function (User $user): привязка модели к маршруту,
                  по умолчанию {user} - это id, но можно задать название столба таблицы {user:name}
                // привязка модели
                Route::get('/users/{user}', function (User $user) {return $user->email;});
                либо
                Route::get('/users/{user}', function (User $user) {return view('users.show', ['user' => $user]);});
                // привязка дочерней модели к родительской
                Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {return $post;})->scopeBindings();
                // с группировкой
                Route::scopeBindings()->group(function () {
                  Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {return $post;});
                });
                // не использовать область действия привязоки
                Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {return $post;})->withoutScopedBindings();
            p маршрут и контроллер
            pre
              code.
                Route::get('/user/{id}', [UserController::class, 'show']);    // к методу
                Route::post('/server', ProvisionServer::class);   // контроллер одиночного действия
                Route::get('/profile', [UserController::class, 'show'])->middleware('auth');   // с middleware
                Route::put('/post/{id}', function (string $id) {})->middleware(EnsureUserHasRole::class.':editor,publisher');    // с параметром для middleware
                Route::get('/user/profile', [UserProfileController::class, 'show'])->name('profile');    // именованный маршрут
                // именованный маршрут с параметрами
                Route::get('/user/{id}/profile', function (string $id) { })->name('profile');
                $url = route('profile', ['id' => 1, 'photos' => 'yes']);
                if ($request->route()->named('profile')) {} // был ли запрос на маршрут
                // ресурсный маршрут должен быть последним 
                Route::resource('photos', PhotoController::class);   // к ресурсному контроллеру
                // выбор методов в ресурсном контроллере
                Route::resource('photos', PhotoController::class)->only(['index', 'show']);
                Route::resource('photos', PhotoController::class)->except(['create', 'store', 'update', 'destroy']);
                // редирект при отсутствии модели
                Route::resource('photos', PhotoController::class)->missing(function (Request $request) {
                  return Redirect::route('photos.index');
                });
                Route::resource('photos', PhotoController::class)->withTrashed();    // использовать программно удалённые модели
                Route::resource('photos.comments', PhotoCommentController::class);    // вернёт: /photos/{photo}/comments/{comment}
                Route::resource('photos.comments', CommentController::class)->shallow();   // при уникальных идентификаторах вернёт: /photos/{photo}/comments
                Route::resource('photos', PhotoController::class)->names(['create' => 'photos.build']);  // именованный ресурсный маршрут
                Route::resource('users', AdminUserController::class)->parameters(['users' => 'admin_user']);  // вернёт: /users/{admin_user}
                Route::resource('photos.comments', PhotoCommentController::class)->scoped(['comment' => 'slug']);   // вернёт: /photos/{photo}/comments/{comment:slug}
                Route::apiResource('photos', PhotoController::class);   // ресурсные api-маршруты - маршруты без create и edit
            p создание URL-адреса и перенаправление по именованному маршруту
            pre
              code.
                $url = route('profile');
                return redirect()->route('profile');
                return to_route('profile');
            p группировка маршрутов
            pre
              code.
                // маршруты c общим контроллером
                  Route::controller(JobController::class)->group( function()
                  {
                    Route::get('/jobs', 'index');
                    Route::get('/jobs/create', 'create');
                    Route::get('/jobs/{job}', 'show');
                    Route::get('/jobs/{job}/edit', 'edit');
                    Route::post('/jobs', 'store');
                    Route::patch('/jobs/{job}', 'update');
                    Route::delete('/jobs/{job}', 'destroy');
                  });
                Route::middleware(['first', 'second'])->group(function () {Route::get('/', function () {});});  // по middleware `first` и `second`
                Route::prefix('admin')->group(function () {Route::get('/users', function () {});});   // по преффиксу: /admin/users
                Route::name('admin')->group(function () {Route::get('/users', function () {})->name('users');});  // по имени маршрута: admin.users
            p middleware can(действие, маршрут) - на этот маршрут разрешено тому, кому политикой разрешено совершать указанное действие
            pre
              code.
                // обновить пост
                Route::put('/post/{post}', function (Post $post) { })->middleware('can:update,post');
                либо
                Route::put('/post/{post}', function (Post $post) { })->can('update', 'post');
            p определить названия маршрутов в Enums
            pre
              code.
                namespace App\Enums;
                enum Category: string {
                  case Fruits = 'fruits';
                  case People = 'people';
                }
                // в маршруте
                use App\Enums\Category;
                use Illuminate\Support\Facades\Route;
                Route::get('/categories/{category}', function (Category $category) {return $category->value;});
                Route::fallback(function () {});   // резевный маршрут, если запрос не соответствует ни одному маршруту
            p перенаправить
            pre
              code.
                Route::get('/dashboard', function () {
                  return redirect('/home/dashboard');    // на указанную страницу
                });
                Route::post('/user/profile', function () {
                  return back()->withInput();   // перенаправить обратно с записью в сессию данных ввода и фильтром middleware
                })->middleware('web');
                return redirect()->away('https://www.google.com');  // на внешний домен
                return redirect()->action([UserController::class, 'profile'], ['id' => 1]); // на метод контроллера
                return redirect()->route('profile', ['id' => 1]);   // на именованный маршрут
                return redirect()->route('profile', [$user]);       // на именованный маршрут с указанием модели
                // на именованный маршрут с указанием столбца как ключа
                return redirect()->route('/profile/{id:slug}', [$user]);
                - задать ключ маршрута в модели
                public function getRouteKey(): mixed                
                {return $this->slug;}
                // с записью указанных данных в сессию
                return redirect('/dashboard')->with('status', 'Profile updated!');
                - отобразить запись в шаблоне
                @if (session('status'))
                    &lt;div class="alert alert-success"&gt;{{ session('status') }}&lt;/div&gt;
                @endif
                // перенаправить на ответ
                return response()->view('hello', $data, 200)->header('Content-Type', $type);    // с HTML
                return response()->json(['name' => 'Abigail', 'state' => 'CA'])->withCallback($request->input('callback'));   // с JSON
                return response()->download($pathToFile, $name, $headers);    // заставить браузер пользователя загрузить файл
                return response()->file($pathToFile, $headers);   // отображение файла в браузере без загрузки
            p выполнить тест
            pre
              code.
                Route::get('test', function () {
                  $job = Job::first();
                  TranslateJob::dispatch($job);
                  return 'Done';
                });
            p ресурсный маршрут
            pre
              code.
                Route::resource('uri', controller);
                Route::resource('jobs', JobController::class);
                // сформирует для методов класса контроллера маршруты:
                jobs.index <span>- показать всё списком</span>
                jobs.show <span>- показать один</span>
                jobs.create <span>- создать</span>
                jobs.edit <span>- редактировать</span>
                jobs.store <span>- сохранить</span>
                jobs.update <span>- обновить</span>
                jobs.destroy <span>- уничтожить</span>
                // маршруты только для 'index' и 'show'
                Route::resource('jobs', JobController::class, ['only' => ['index', 'show']]);
                // все маршруты кроме 'edit'
                Route::resource('jobs', JobController::class, ['except' => ['edit']]);

          //- Middleware
          //- проверка и фильтрация HTTP-запросов и HTTP-ответов
          details
            summary Middleware
            p middleware - класс для проверки и фильтрации HTTP-запросов, HTTP-ответов, HTTP-заголовков, HTTP-тел, HTTP-методов
            pre
              code.
                // создать
                php artisan make:middleware MyMiddleware
                либо указать путь
                php artisan make:middleware App\Http\Middleware\MyMiddleware
                либо указать путь и пространство имен
                php artisan make:middleware App\Http\Middleware\MyMiddleware --namespace=App\Http\Middleware
            p получает запрос, сравнивает значение токена из запроса и либо перенаправляет на домашнюю страницу, либо пропускает запрос дальше в приложение
            pre
              code.
                namespace App\Http\Middleware;
                use Closure;
                use Illuminate\Http\Request;
                use Symfony\Component\HttpFoundation\Response;
                class MyMiddleware
                {
                  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
                  public function handle(Request $request, Closure $next): Response
                  {
                    if ($request->input('token') !== 'my-secret-token') {return redirect('/home');} // выполняется до обработки запроса приложением
                    return $next($request);
                  }
                }
                либо
                  public function handle(Request $request, Closure $next): Response
                  {
                    return $next($request);
                    // выполняется после обработки запроса приложением
                    return $response;
                  }
                // с параметром
                class EnsureUserHasRole
                {
                  - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
                  public function handle(Request $request, Closure $next, string $role): Response
                  {
                    if (! $request->user()->hasRole($role)) {}
                    return $next($request);
                  }
                }
            p в bootstrap/app.php
            pre
              code.
                // группировка
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->appendToGroup('group-name', [
                    First::class,
                    Second::class,
                  ]);
                  $middleware->prependToGroup('group-name', [
                    First::class,
                    Second::class,
                  ]);
                })
                // добавить к группе
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->web(append: [EnsureUserIsSubscribed::class]);  // применяется к routes/web.php
                  $middleware->api(prepend: [EnsureTokenIsValid::class]);  // применяется к routes/api.php
                })
                // заменить middleware в группе
                $middleware->web(replace: [StartSession::class => StartCustomSession::class]);
                // удалить middleware из группы
                $middleware->web(remove: [StartSession::class]);
                // псевдоним для middleware
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->alias(['subscribed' => EnsureUserIsSubscribed::class]);
                })
                Route::get('/profile', function () { })->middleware('subscribed'); // применить псевдоним middleware
                // перенаправить пользователя если он гость
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->redirectGuestsTo('/login');
                  либо
                  $middleware->redirectGuestsTo(fn (Request $request) => route('login'));
                })
                // перенаправить пользователя если он аутентифицирован
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->redirectUsersTo('/panel');
                  либо
                  $middleware->redirectUsersTo(fn (Request $request) => route('panel'));
                })
            p в маршруте
            pre
              code.
                Route::get('/flights', function () { })->middleware('auth');    // доступ только для аутентифицированных
                Route::get('/profile', function () { })->middleware(['auth', 'verified']);   // доступ только с подтверждённым email
                Route::get('/flights', function () { })->middleware('auth:admin');    // доступ только для аутентифицированных по guard 'admin' из config/auth.php
            p метод share может возвращать общие данные для всех страниц Inertia
            pre
              code.
                namespace App\Http\Middleware;
                use App\Models\Post;
                use Illuminate\Http\Request;
                use Inertia\Middleware;
                class HandleInertiaRequests extends Middleware
                {
                  public function share(Request $request)
                  {
                    return [...parent::share($request), 'auth' => [
                      'user' => $request->user(),
                      'permissions' => ['post' => ['create' => $request->user()->can('create', Post::class)]],
                    ]];
                  }
                }
            p форматирование значений поля ввода input настраивается Illuminate\Foundation\Http\Middleware\TrimStrings и Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull в bootstrap/app.php
            p доверенные прокси указать в bootstrap/app.php
            pre
              code.
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustProxies(at: [
                    '192.168.1.1',
                    '10.0.0.0/8',
                  ]);
                })
                заголовки доверенных прокси
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustProxies(headers: Request::HEADER_X_FORWARDED_FOR |
                    Request::HEADER_X_FORWARDED_HOST |
                    Request::HEADER_X_FORWARDED_PORT |
                    Request::HEADER_X_FORWARDED_PROTO |
                    Request::HEADER_X_FORWARDED_AWS_ELB
                  );
                })
                доверять всем прокси
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustProxies(at: '*');
                })
            p доверенный host
            pre
              code.
                имя хоста, на которого реагировать указать в bootstrap/app.php
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustHosts(at: ['laravel.test']);
                })
                не доверять поддоменам хоста
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustHosts(at: ['laravel.test'], subdomains: false);
                })
                указать доверенные хосты в файле конфигурации
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->trustHosts(at: fn () => config('app.trusted_hosts'));
                })

          //- Controllers
          //- обработать HTTP-запрос и вернуть HTTP-ответ, view, JSON, файл, редирект
          details
            summary Controllers
            p контроллеры - классы, которые обрабатывают HTTP-запросы и возвращают HTTP-ответы, view, JSON, файлы и редиректы
            pre
              code.
                php artisan make:controller UserController    // создать контроллер
                php artisan make:controller ProvisionServer --invokable    // создать контроллер одного действия
                // создать ресурсный контроллер
                php artisan make:controller PhotoController --resource
                либо
                php artisan make:controller PhotoController -r
                php artisan make:controller PhotoController --model=Photo --resource --requests   // с привязкой к моделе и валидацией
                php artisan make:controller PhotoController --api    // api-контроллер контроллер без create и edit
            //- Methods
            table
              caption Methods
              thead
                tr
                  th Controller Method 
                  th Action
              tbody
                tr
                  td index
                  td view all
                tr
                  td show
                  td view one
                tr
                  td create
                  td show form for create
                tr
                  td store
                  td create
                tr
                  td edit
                  td show form for edit
                tr
                  td update
                  td update
                tr
                  td destroy
                  td delete
            p контроллере
            pre
              code.
                // избежать проблему n+1: with([ ])
                public function __invoke()
                {
                  $jobs = Job::query()->with(['employer', 'tags'])->where('title', 'LIKE', '%'.request('q').'%')->get();
                  return view('results', ['jobs' => $jobs]);
                }
                // указать middleware в контроллере
                class UserController extends Controller implements HasMiddleware
                {
                  public static function middleware(): array
                  {
                    return [
                      'auth',
                      new Middleware('log', only: ['index']),
                      new Middleware('subscribed', except: ['store']),
                    ];
                  }
                }
                // реализовать middleware в контроллере
                public static function middleware(): array
                {
                  return [
                    function (Request $request, Closure $next) {
                      return $next($request);
                    },
                  ];
                }
                // внедрить зависимости через конструктор
                use App\Repositories\UserRepository;
                class UserController extends Controller
                {
                  public function __construct(protected UserRepository $users) { }
                }
                // внедрить зависимости через параметры функции
                use Illuminate\Http\RedirectResponse;
                use Illuminate\Http\Request;
                class UserController extends Controller
                {
                  public function store(Request $request): RedirectResponse
                  {
                    $name = $request->name;
                    return redirect('/users');
                  }
                }
                // получить параметр из маршрута
                - маршрут
                use App\Http\Controllers\UserController;
                Route::put('/user/{id}', [UserController::class, 'update']);
                - контроллер
                class UserController extends Controller
                {
                  public function update(Request $request, string $id): RedirectResponse
                  {
                    // действия с пользователем
                    return redirect('/users');
                  }
                }

          //- Authentication
          //- проверка, что пользователя тот, за кого себя выдает
          details
            summary Authentication
            p.
              - аутентификация - процесс проверки подлинности пользователя, чтобы убедиться, что он тот, за кого себя выдает<br>
              - конфигурация в config/auth.php, в массиве guards "охранники" для аутентификации пользователя<br>
              - информацию об аутентифицированном пользователе хранится в сессии пользователя<br>
              - файл cookie, отправленный браузеру, содержит идентификатор сессии, чтобы последующие запросы к приложению могли связать пользователя с правильной сессией<br>
              - встроенные службы аутентификации Laravel для запросов из веб-браузеров и доступны через фасады Auth и Session<br>
              - встроенные службы аутентификации ориентированы на web-аутентификацию на основе файлов cookie<br>
              - Fortify - серверная служба аутентификации<br>
              - при каждом запросе к API удаленная служба отправляет API-токен, приложение проверяет входящий токен по таблице допустимых API-токенов и «аутентифицирует» запрос как выполняемый пользователем, связанным с этим API-токеном<br>
              - библиотеки Passport и Sanctum ориентированы на аутентификацию токена API
              - Passport – надежный и сложный пакет для аутентификации API, когда нужен весь функционал OAuth2<br>
              - Sanctum –  простое и полное решение для аутентификации API, аутентификации SPA и мобильной аутентификации, включая поддержку «scopes» или «abilities»<br>
              - Laravel автоматически хеширует пароли пользователей при аутентификации<br>
              - настроить сложность хеширования в config/hashing.php или в BCRYPT_ROUNDS из .env<br>
            pre
              code.
                php artisan config:publish hashing    // опубликовать config/hashing.php
                'rehash_on_login' => false    // отключить автоматическое хеширование
            p.
              встроенная аутентификация: use Illuminate\Support\Facades\Auth;<br>
              "запомнить меня" - аутентифирован до выхода из системы вручную, столбец remember_token в таблице users<br>
            pre
              code.
                $user = Auth::user();   // получить текущего аутентифицированного пользователя
                $id = Auth::id();   // получить текущего аутентифицированного пользователя по идентификатору
                $user = $request->user();   // получить текущего аутентифицированного пользователя из запроса
                if (Auth::check()) { }    // проверить что пользователь аутентифицировался
                if (Auth::guard('admin')->attempt($credentials)) { }   // С указанием guard из config/auth.php
                if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) { }   // параметр "запомнить меня"
                if (Auth::viaRemember()) { }   // есть ли "запомнить меня"
                if (Auth::once($credentials)) { }    // аутентификации пользователя только для одного запроса без сессии и cookie
                Auth::login($user);   // передать пользователя на аутентификацию
                Auth::login($user, $remember = true);   // передать пользователя на аутентификацию с "запомнить меня"
                Auth::guard('admin')->login($user);   // передать пользователя на аутентификацию с указанием guard
                Auth::loginUsingId(1);    // аутентификация по id
                Auth::loginUsingId(1, remember: true);    // аутентификация по id с "запомнить меня"
            p Basic HTTP - аутентификация без cookie и страницы входа
            pre
              code.
                Route::get('/profile', function () { })->middleware('auth.basic');
                - добавить в .htaccess для HTTP Basic и PHP FastCGI
                RewriteCond %{HTTP:Authorization} ^(.+)$
                RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
                - использовать в middleware
                namespace App\Http\Middleware;
                use Closure;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Auth;
                use Symfony\Component\HttpFoundation\Response;
                class AuthenticateOnceWithBasicAuth
                {
                  public function handle(Request $request, Closure $next): Response
                  {return Auth::onceBasic() ?: $next($request);}
                }
                далее
                Route::get('/api/user', function () { })->middleware(AuthenticateOnceWithBasicAuth::class);
            p выход пользователя из приложения
            pre
              code.
                public function logout(Request $request): RedirectResponse
                {
                  Auth::logout();   // удалить информацию аутентификации из сессии пользователя
                  $request->session()->invalidate();    // аннулировать сессию пользователя
                  $request->session()->regenerateToken();   // повторно сгенерировать токен CSRF пользователя
                  return redirect('/');
                }
            p аннулировать сессии на других устройствах, без аннулирования сессии на текущем устройстве
            pre
              code.
                // в маршруте
                Route::middleware(['auth', 'auth.session'])->group(function () {
                    Route::get('/', function () { });
                });
                // в контроллере
                Auth::logoutOtherDevices($currentPassword);
            p настроить время, через которое нужно повторно ввести пароль: password_timeout в config/auth.php
            pre
              code.
                // форма подтверждения пароля
                Route::get('/confirm-password', function () {
                    return view('auth.confirm-password');
                })->middleware('auth')->name('password.confirm');
                - далее
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Hash;
                use Illuminate\Support\Facades\Redirect;
                Route::post('/confirm-password', function (Request $request) {
                  if (! Hash::check($request->password, $request->user()->password)) {
                    return back()->withErrors([
                      'password' => ['Предоставленный пароль не соответствует нашим записям.']
                    ]);
                  }
                  $request->session()->passwordConfirmed();
                  return redirect()->intended();
                })->middleware(['auth', 'throttle:6,1']);
                - далее
                Route::get('/settings', function () { })->middleware(['password.confirm']);
                Route::post('/settings', function () { })->middleware(['password.confirm']);
            p добавить свой guard
            pre
              code.
                namespace App\Providers;
                use App\Models\User;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Auth;
                class AppServiceProvider extends ServiceProvider
                {
                  public function boot(): void
                  {
                    Auth::viaRequest('custom-token', function (Request $request) {
                      return User::where('token', (string) $request->token)->first();
                    });
                  }
                }
                // в config/auth.php
                'guards' => [
                  'api' => [
                    'driver' => 'jwt',
                    'provider' => 'users',
                  ],
                ],
                либо
                'guards' => [
                  'api' => [
                    'driver' => 'custom-token',
                  ],
                ],
                // в маршруте
                Route::middleware('auth:api')->group(function () { });
            p свой провайдер аутентификации пользователей для нереляционной БД
            pre
              code.
                namespace App\Providers;
                use App\Extensions\MongoUserProvider;
                use Illuminate\Contracts\Foundation\Application;
                use Illuminate\Support\Facades\Auth;
                use Illuminate\Support\ServiceProvider;
                class AppServiceProvider extends ServiceProvider
                {
                  public function boot(): void
                  {
                    Auth::provider('mongo', function (Application $app, array $config) {
                      return new MongoUserProvider($app->make('mongo.connection'));
                    });
                  }
                }
                // в config/auth.php
                'providers' => [
                  'users' => [
                    'driver' => 'mongo',
                  ],
                ],
                'guards' => [
                  'web' => [
                    'driver' => 'session',
                    'provider' => 'users',
                  ],
                ]
            p собственная аутентификации пользователей<br>
            pre
              code.
                namespace App\Http\Controllers;
                use Illuminate\Http\Request;
                use Illuminate\Http\RedirectResponse;
                use Illuminate\Support\Facades\Auth;
                class LoginController extends Controller
                {
                  public function authenticate(Request $request): RedirectResponse
                  {
                    $credentials = $request->validate([
                      'email' => ['required', 'email'],
                      'password' => ['required'],
                    ]);
                    if (Auth::attempt($credentials)) {
                      $request->session()->regenerate();
                      return redirect()->intended('dashboard');
                    }
                    return back()->withErrors([
                      'email' => 'Предоставленные учетные данные не соответствуют нашим записям.',
                    ])->onlyInput('email');
                  }
                }
                // Дополнительные условия аутентификации
                if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) { }
                либо
                use Illuminate\Database\Eloquent\Builder;
                if (Auth::attempt([
                  'email' => $email,
                  'password' => $password,
                  fn (Builder $query) => $query->has('activeSubscription'),
                ])) { }
                либо
                if (Auth::attemptWhen([
                  'email' => $email,
                  'password' => $password,
                ], function (User $user) {return $user->isNotBanned();})) { }

            //- Email verification
            //- отправка электронного письма со ссылкой для подтверждения
            details 
              summary Email verification
              p автоматическая отправка электронного письма со ссылкой для подтверждения
              pre
                code.
                  namespace App\Models;

                  use Illuminate\Contracts\Auth\MustVerifyEmail;
                  use Illuminate\Foundation\Auth\User as Authenticatable;
                  use Illuminate\Notifications\Notifiable;

                  class User extends Authenticatable implements MustVerifyEmail
                  {
                      use Notifiable;
                  }
              p при регистрации пользователя вручную
              pre
                code.
                  use Illuminate\Auth\Events\Registered;
                  event(new Registered($user));
              p.
                - в таблице users миграции 0001_01_01_000000_create_users_table.php столбец столбец email_verified_at для даты и времени подтверждения email<br>
                - Чтобы правильно реализовать подтверждение электронной почты, необходимо определить три маршрута:<br>
                - отображения пользователю уведомления об отправке ссылки подтверждения<br>
              pre
                code.
                  Route::get('/email/verify', function () {
                      return view('auth.verify-email');
                  })->middleware('auth')->name('verification.notice');
              p обработки запроса при нажатии на ссылку подтверждения
              pre
                code.
                  use Illuminate\Foundation\Auth\EmailVerificationRequest;

                  Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
                      $request->fulfill();

                      return redirect('/home');
                  })->middleware(['auth', 'signed'])->name('verification.verify');
              p повторная отправка ссылки подтверждения
              pre
                code.
                  use Illuminate\Http\Request;

                  Route::post('/email/verification-notification', function (Request $request) {
                      $request->user()->sendEmailVerificationNotification();

                    return back()->with('message', 'Verification link sent!');
                  })->middleware(['auth', 'throttle:6,1'])->name('verification.send');
              p изменить сообщение о подтверждении в App\Providers\AppServiceProvider
              pre
                code.
                  use Illuminate\Auth\Notifications\VerifyEmail;
                  use Illuminate\Notifications\Messages\MailMessage;

                  public function boot(): void
                  {
                      VerifyEmail::toMailUsing(function (object $notifiable, string $url) {
                          return (new MailMessage)
                              ->subject('Verify Email Address')
                              ->line('Click the button below to verify your email address.')
                              ->action('Verify Email Address', $url);
                      });
                  }
            
            //- Fortify
            //- backend реализация authentication
            details 
              summary Fortify
              p установить Fortify<br>
              code ./sail composer require laravel/fortify<br>
              p создать папки и роуты Fortify<br>
              code ./sail artisan fortify:install<br>
              p обновить БД<br>
              code ./sail artisan migrate<br>

          //- Session
          //- хранение данных между запросами
          details
            summary Session
            p.
              сессия - это способ хранения данных между запросами в виде массива, JSON и отдельных переменных в файлах, базе данных, кэше или в памяти<br>
              по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
              драйверы кеша и БД могут быть использованы для хранения данных сессии<br>
            pre
              code.
                php artisan session:table
                php artisan migrate
            p.
              по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br>
              драйверы кеша и БД могут быть использованы для хранения данных сессии<br>
            pre
              code.
                php artisan session:table
                php artisan migrate
            p.
              настройка хранения сессии в config/session.php<br>
              - file – сессии хранятся в storage/framework/sessions.<br>
              - cookie – сессии хранятся в безопасных, зашифрованных файлах Cookies.<br>
              - database – сессии хранятся в реляционной базе данных.<br>
              - memcached / redis – сессии хранятся в одном из этих быстрых хранилищ на основе кеша.<br>
              - dynamodb – сессии хранятся в AWS DynamoDB.<br>
              - array – сессии хранятся в массиве PHP и не будет сохранены.<br>
              - по умолчанию database, данные сессии в таблице sessions в 0001_01_01_000000_create_users_table.php<br>
              получить данные из сессии<br>
            pre
              code.
                - через экземпляр Request
                namespace App\Http\Controllers;
                use Illuminate\Http\Request;
                use Illuminate\View\View;
                class UserController extends Controller
                {
                  public function show(Request $request, string $id): View
                  {
                    $value = $request->session()->get('key', 'default');
                    $user = $this->users->find($id);
                    return view('user.profile', ['user' => $user]);
                  }
                }
                - через глобальный помощник session
                Route::get('/home', function () {
                  $value = session('key');    // получить часть данных из сессии
                  $value = session('key', 'default');   // получить часть данных из сессии с указанием значения по умолчанию
                  session(['key' => 'value']);    // сохранить часть данных в сессию
                });
                $data = $request->session()->all();   // получить все данные сессии
                $data = $request->session()->only(['username', 'email']);   // получить только указанные данные сессии
                $data = $request->session()->except(['username', 'email']);   // получить данные сессии без указанных
                $value = $request->session()->pull('key', 'default');   // получает и удаляет элемент из сессии
                if ($request->session()->has('users')) { }   // наличие элемента в сессии не равного null
                if ($request->session()->exists('users')) { }    // наличие элемента в сессии в т.ч. null
                if ($request->session()->missing('users')) { }    // элемент в сессии либо null, либо отсутствует
            p данные в сессии
            pre
              code.
                $request->session()->put('key', 'value');   // сохранить через экземпляр запроса
                session(['key' => 'value']);    // сохранить через глобальный помощник «session»
                $request->session()->push('user.teams', 'developers');    // вставка нового значения
                // увеличение и уменьшение целочисленных значений в сессии
                $request->session()->increment('count');
                $request->session()->increment('count', $incrementBy = 2);
                $request->session()->decrement('count');
                $request->session()->decrement('count', $decrementBy = 2);
                $request->session()->now('status', 'Задача выполнена успешно!');    // сохранить только для текущего запроса
                $request->session()->flash('status', 'Задача выполнена успешно!');    // сохранить только для следующего запроса
                $request->session()->reflash();   // для нескольких запросов одновременно, потом удаление
                $request->session()->keep(['username', 'email']);   // сохранить отдельные данные для следующего запроса
                $request->session()->forget('name');    // удалить единственный ключ
                $request->session()->forget(['name', 'status']);    // удалить несколько ключей
                $request->session()->flush();   // удалить все данные из сессии
                $request->session()->regenerate();    // повторно сгенерировать идентификатор сессии
                $request->session()->invalidate();    // удалить идентификатор сессии все её данные
            p блокировка сессии
            pre
              code.
                // по умолчанию блокировка 10 сек и ожидание получения блокировки 10 сек
                Route::post('/profile', function () { })->block();
                Route::post('/profile', function () { })->block($lockSeconds = 10, $waitSeconds = 10);
                Route::post('/order', function () { })->block($lockSeconds = 10, $waitSeconds = 10);

          //- CSRF
          //- токен CSRF для защиты от атак CSRF, хранится в сессии
          details
            summary CSRF
            p.
              - CSRF - это атака, при которой злоумышленник отправляет запрос от имени пользователя без его ведома<br>
              - Laravel использует токены CSRF для защиты от атак CSRF<br>
              - токены CSRF хранятся в сессии пользователя и проверяются при каждом запросе<br>
              - токены CSRF могут быть использованы только для POST, PUT, PATCH и DELETE запросов<br>
            pre
              code.
                Route::get('/token', function (Request $request) {
                  $token = $request->session()->token();    // доступ к токену CSRF
                  либо
                  $token = csrf_token();
                });
            p в каждой форме с методом «POST», «PUT», «PATCH» или «DELETE» должен быть токен
            pre
              code.
                &lt;form method="POST" action="/profile"&gt;
                  @csrf
                  либо
                  &lt;input type="hidden" name="_token" value="{{ csrf_token() }}" /&gt;
                &lt;/form&gt;
            p исключить маршруты из проверки токена в файле bootstrap/app.php
            pre
              code.
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->validateCsrfTokens(except: [
                    'stripe/*',
                    'http://example.com/foo/bar',
                    'http://example.com/foo/*',
                  ]);
                })
            p добавить токен
            pre
              code.
                &lt;meta name="csrf-token" content="{{ csrf_token() }}"&gt;    // в HTML-заголовок X-CSRF-TOKEN
                &lt;meta name="x-xsrf-token" content="{{ csrf_token() }}"&gt;    // в заголовок X-XSRF-TOKEN
            p По умолчанию файл resources/js/bootstrap.js включает HTTP-библиотеку Axios, которая автоматически отправляет заголовок X-XSRF-TOKEN.

          //- Autherization
          //- проверка прав доступа пользователя
          details
            summary Autherization
            p.
              авторизация - проверка прав доступа пользователя, основаная на политиках и шлюзах, может быть выполнена с помощью:<br>
              - middleware, контроллеров, моделей и шаблонов<br>
              - фасадов, классов и функций<br>
              - политик и шлюзов, которые могут быть определёны в любом месте приложения и использоваться вместе<br>
            
            //- Gates
            //- проверка прав пользователя на действия без модели или ресурса
            details
              summary Gates
              p.
                Gate (шлюз) - это функция проверки прав пользователя без использования модели или ресурса, например просмотр панели управления администратора.<br>
                - объявляется в App\Providers\AppServiceProvider методом boot()<br>
                - исспользуется для простых ограничений ролей<br>
                - аргументом всегда принимает пользователя, к которому применяет ограничения<br>
                - методы шлюза для авторизации полномочий: allows, denies, check, any, none, authorize, can, cannot<br>
                - директивы авторизации Blade: @can, @cannot, @canany<br>
                - дополнительные аргументы по необходимости.<br>
              pre
                code.
                  namespace App\Providers;
                  use App\Models\Post;
                  use App\Models\User;
                  use Illuminate\Support\Facades\Gate;
                  class AppServiceProvider extends ServiceProvider
                  - может ли пользователь обновить модель
                  public function boot(): void
                  {
                    Gate::define('update-post', function (User $user, Post $post) {
                      return $user->id === $post->user_id;
                    });
                  }
                  либо вынести логику в отдельный класс (политику) и объявить в App\Providers\AppServiceProvider
                  use App\Policies\PostPolicy;
                  use Illuminate\Support\Facades\Gate;
                  public function boot(): void
                  {
                    Gate::define('update-post', [PostPolicy::class, 'update']);
                  }
              p.
                Gate::define - объявляю Gate,<br>
                'update-post' - название возможности предоставляемой пользователю<br>
                function (User $user, Post $post) - вернёт true/false,<br>
                true - этому пользователю можно пользоваться этой возможностью<br>
                false - этому пользователю нельзя пользоваться этой возможностью<br>
                После этого в любом контроллере можем проверять роль конкрено указав пользователя
              pre
                code.
                  if (Gate::forUser($user)->allows('update-post', $post)) { }   // если может редактировать пост
                  if (Gate::forUser($user)->denies('update-post', $post)) { }   // если не может редактировать пост
                  if (Gate::allows('update-post', $post)) { }               // если разрешено
                  if (Gate::denies('update-post', $post)) {abort(403);}     // если запрещено
                  if (Gate::any(['update-post', 'delete-post'], $post)) { }   // если может редактировать и удалять
                  if (Gate::none(['update-post', 'delete-post'], $post)) { }    // если не может редактировать и удалять
                  if (Gate::check('create-post', [$category, $pinned])) { }   // дополнительный контекст для check
                  Gate::authorize('update-post', $post);   // проверить роль текущего пользователя встроенным методом
                  Gate::authorize('update', App\Models\Post::class);   // 'update' - действие, $post - объект модели, либо класс модели
                  Gate::allowIf(fn (User $user) => $user->isAdministrator());   // встроенная роверка авторизации
                  Gate::denyIf(fn (User $user) => $user->banned());   // встроенная роверка авторизации
              p авторизация действий через шлюзы
              pre
                code.
                  namespace App\Http\Controllers;
                  use App\Http\Controllers\Controller;
                  use App\Models\Post;
                  use Illuminate\Http\RedirectResponse;
                  use Illuminate\Http\Request;
                  use Illuminate\Support\Facades\Gate;
                  class PostController extends Controller
                  {
                    public function update(Request $request, Post $post): RedirectResponse
                    {
                      if (! Gate::allows('update-post', $post)) {abort(403);}
                      return redirect('/posts');
                    }
                  }
                  либо
                  public function update(Request $request, Post $post): RedirectResponse
                  {
                    Gate::authorize('update', $post);   // если пользователь не авторизован для 'update', то выбросит исключение
                    return redirect('/posts');
                  }
                  либо
                  public function create(Request $request): RedirectResponse
                  {
                    Gate::authorize('create', Post::class);   // класс определяет какую политику использовать при авторизации
                    return redirect('/posts');
                  }
                  // дополнительный контекст при принятии решений об авторизации
                  Gate::define('create-post', function (User $user, Category $category, bool $pinned) {
                    if (! $user->canPublishToGroup($category->group)) {return false;}
                    elseif ($pinned && ! $user->canPinPosts()) {return false;}
                    return true;
                  });
              p ответ шлюза
              pre
                code.
                  use App\Models\User;
                  use Illuminate\Auth\Access\Response;
                  use Illuminate\Support\Facades\Gate;
                  Gate::define('edit-settings', function (User $user) {
                    return $user->isAdmin ? Response::allow() : Response::deny('Вы должны быть администратором.');
                  });
                  - полный возвращенный шлюзом ответ
                  $response = Gate::inspect('edit-settings');
                  if ($response->allowed()) { }
                  else {echo $response->message();}
                  - код статуса HTTP-ответа вручную
                  Gate::define('edit-settings', function (User $user) {
                    return $user->isAdmin ? Response::allow() : Response::denyWithStatus(404);
                  });
                  - ответ 404
                  Gate::define('edit-settings', function (User $user) {
                    return $user->isAdmin ? Response::allow() : Response::denyAsNotFound();
                  });
                  - before выполняется перед всеми другими проверками авторизации
                  Gate::before(function (User $user, string $ability) {
                    if ($user->isAdministrator()) {return true;}
                  });
                  - after выполненяется после всех других проверок авторизации
                  Gate::after(function (User $user, string $ability, bool|null $result, mixed $arguments) {
                    if ($user->isAdministrator()) {return true;}
                  });

            //- Policies
            //- логика авторизации пользователя на действия с конкретной моделью или ресурсом
            details
              summary Policies
              p.
                политики - это классы с логикой авторизации пользователя на действия с конкретной моделью или ресурсом.<br>
                по конвенции название политики содержит название модели.<br>
              code php artisan make:policy PostPolicy --model=Post   // создать политику с привязкой к модели: создаст методы для модели Post
              table
                caption Methods
                thead
                  tr
                    th Policy Method 
                    th Action
                tbody
                  tr
                    td viewAny
                    td view all
                  tr
                    td view
                    td view one
                  tr
                    td create
                    td create & store
                  tr
                    td update
                    td edit
                  tr
                    td delete
                    td mark as delete
                  tr
                    td restore
                    td unmark as delete
                  tr
                    td forceDelete
                    td permanently delete
              p.
                Laravel проверит наличие политик в app/Models/Policies, а затем в app/Policies. Назвать политику не по конвенции:
              pre
                code.
                  namespace App\Providers;
                  use App\Models\ModelName;
                  use App\Policies\PolicyName;
                  use Illuminate\Support\Facades\Gate;
                  class AppServiceProvider extends ServiceProvider {
                    public function boot(): void
                    {
                      Gate::policy(Order::class, OrderPolicy::class);
                    }
                  }
                  - использовать
                  Gate::guessPolicyNamesUsing(function (string $modelClass) { });
              p политика
              pre
                code.
                  namespace App\Policies;
                  use App\Models\Post;
                  use App\Models\User;
                  class PostPolicy
                  {
                    public function update(User $user, Post $post): bool
                    {
                      return $user->id === $post->user_id;
                    }
                  }
                  return $user->id === $post->user_id ? Response::allow() : Response::deny('You do not own this post.');    // подробный ответ
                  return $user->id === $post->user_id ? Response::allow() : Response::denyWithStatus(404);    // настроить HTTP-ответ
                  return $user->id === $post->user_id ? Response::allow() : Response::denyAsNotFound();   // встроенный ответ 404
                  return $user->role == 'writer';   // имеет ли пользователь право создавать посты
                  return $user?->id === $post->user_id;   // $user типа User либо null: авторизация для не аутентифицированных пользователей
                  return $user->id === $post->user_id && $user->canUpdateCategory($category);   // проверка id и роли пользователя
                  Gate::authorize('update', [$post, $request->category]);   // передать методу дополнительный контекст в массиве
                  // before будет выполнен перед любыми другими методами в политике
                  public function before(User $user, string $ability): bool|null
                  {
                    if ($user->isAdministrator()) {return true;}    // выполнить предварительную авторизацию
                    return null;
                  }
              p.
                контроллер<br>
                - модель App\Models\User включает два метода авторизации: can и cannot<br>
                - если для модели зарегистрирована политика, то can вызовет политику,<br>
                - если нет политики, то can вызовет шлюз<br>
              pre
                code.
                  namespace App\Http\Controllers;
                  use App\Http\Controllers\Controller;
                  use App\Models\Post;
                  use Illuminate\Http\RedirectResponse;
                  use Illuminate\Http\Request;
                  class PostController extends Controller
                  {
                    public function update(Request $request, Post $post): RedirectResponse
                    {
                      if ($request->user()->cannot('update', $post)) {abort(403);}
                      return redirect('/posts');
                    }
                  }
                  public function store(Request $request): RedirectResponse
                  {
                    if ($request->user()->cannot('create', Post::class)) {abort(403);}    // имя класса определяет используемую политику
                    return redirect('/posts');
                  }

          //- Requests
          //- создать правила валидации, авторизации и преобразования данных в контроллерах, маршрутах и сервисах
          details
            summary Requests
            p запросы позволяют создавать правила валидации, авторизации и преобразования данных в контроллерах, маршрутах и сервисах
            pre
              code.
                php artisan make:request StoreUserRequest    // создать запрос
                php artisan make:request StoreUserRequest --rules=store    // создать запрос с правилами валидации
                php artisan make:request App\Http\Requests\StoreUserRequest   // указать путь к классу
                php artisan make:request App\Http\Requests\StoreUserRequest --namespace=App\Http\Requests   // указать путь к классу и пространство имен
            p в запросе App/Http/Requests
            pre
              code.
                public function authorize(): bool {return true;}    // если логика авторизации обрабатывается в другом месте
                - авторизация запросов
                use App\Models\Comment;
                public function authorize(): bool
                {
                  $comment = Comment::find($this->route('comment'));    // route() - доступ к параметрам URI
                  return $comment && $this->user()->can('update', $comment);  // user() - текущй аутентифицированный пользователь
                }
                return $this->user()->can('update', $this->comment);    // либо с привязкой модели к маршруту
                - изменить сообщения об ошибках
                public function messages(): array
                {
                  return [
                    'title.required' => 'A title is required',
                    'body.required' => 'A message is required',
                  ];
                }
                - изменить имя атрибута
                public function attributes(): array
                {return ['email' => 'email address'];}
                - подготовить данные из запроса для валидации
                use Illuminate\Support\Str;
                protected function prepareForValidation(): void
                {$this->merge(['slug' => Str::slug($this->slug)]);}
                - получить отвалидированные данные
                $validated = $request->validated();
                либо через валидатор
                $validated = $validator->validated();
                либо метод safe вернёт экземпляр Illuminate\Support\ValidatedInput с методами only, except, и all
                $validated = $request->safe()->only(['name', 'email']);
                $validated = $request->safe()->except(['name', 'email']);
                $validated = $request->safe()->all();
                - итерировать проверенные данные
                foreach ($request->safe() as $key => $value) { }
                - доступ к проверенным данным как в массиве
                $validated = $request->safe();
                $email = $validated['email'];
                - добавить поля к проверенным данным
                $validated = $request->safe()->merge(['name' => 'Taylor Otwell']);
                - получить проверенные данные в виде экземпляра collection
                $collection = $request->safe()->collect();
                - нормализовать данные после валидации
                protected function passedValidation(): void
                {$this->replace(['name' => 'Taylor']);}
                - данные формы ввода
                $input = $request->all();   // все данные в виде массива
                $input = $request->collect();   // все данные в виде коллекции
                $input = $request->input();   // все данные как ассоциированный массив
                $name = $request->input('name', 'Sally');   // данные одного поля, второй параметр - значение по умолчанию
                $name = $request->input('products.0.name');   // получить элемент из массива данных формы
                $names = $request->input('products.*.name');  // получить по указанному фильтру массив из массива данных формы
                $query = $request->query();   // все данные из строки запроса в виде ассоциативного массива
                $name = $request->query('name', 'Helen');   // данные отдельного параметра из строки запроса, второй параметр - значение по умолчанию
                $name = $request->string('name')->trim();   // в виде объекта String
                $perPage = $request->integer('per_page');   // в виде целого числа
                $archived = $request->boolean('archived');  // в логическом виде
                $elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');    // дата - имя параметра, формат вывода и часовой пояс
                $status = $request->enum('status', Status::class);    // перечисление - имя параметра и класс перечислений
                $products = $request->enums('products', Product::class);    // перечесления в виде массива
                $input = $request->only(['username', 'password']);    // получить только указанный массив
                $input = $request->only('username', 'password');    // получить только указанный список
                $input = $request->except(['credit_card']);   // получить всё кроме указанного массива
                $input = $request->except('credit_card');   // получить всё кроме указанного списка
                if ($request->has('name')) { }    // если есть параметр в запросе
                if ($request->has(['name', 'email'])) { }    // если есть в запросе все параметры из массива
                if ($request->hasAny(['name', 'email'])) { }    // если есть в запросе любой параметр из массива
                $request->whenHas('name', function (string $input) { });    // выполнить функцию если в запросе параметр есть
                $request->whenHas('name', function (string $input) { }, function () { });    // выполнить первую функцию если в запросе параметр есть, вторую если нет
                if ($request->filled('name')) { }   // проверить есть ли значение
                if ($request->isNotFilled('name')) { }    // проверить отсутствие значения или пустая строка
                if ($request->isNotFilled(['name', 'email'])) { }   // все ли отсутствуют или пустые
                if ($request->anyFilled(['name', 'email'])) { }   // true если хоть один не пустой
                $request->whenFilled('name', function (string $input) { });   // если не пустой, то выполнит действие
                $request->whenFilled('name', function (string $input) { }, function () { });    // если нет значения, то выполнить второе действие
                if ($request->missing('name')) { }    // проверить существует ли ключ параметра в запросе
                $request->whenMissing('name', function () { }, function () { });    // если отсутствует, то первое действие, если присутствует - то второе
                $request->merge(['votes' => 0]);    // объединить существующие данные запроса с данными из ввода с перезаписью по ключу
                $request->mergeIfMissing(['votes' => 0]);   // добавить в запрос данные из ввода если в запросе такого ключа нет
                $request->flash();    // сохранить входные данные запроса в сессии, для доступа только во время следующего запроса
                $request->flashOnly(['username', 'email']);   // сохранить в сессии входные данные запроса только по указанным ключам
                $request->flashExcept('password');   // сохранить в сессии входные данные запроса кроме указанного ключа
                return redirect('/form')->withInput();    // сохранить в сессии входные данные запроса и вернуть к форме
                return redirect()->route('user.create')->withInput();    // сохранить в сессии входные данные запроса и перенаправить по маршруту
                return redirect('/form')->withInput($request->except('password'));  // сохранить в сессии входные данные запроса кроме указанного ключа и вернуть к форме
                $username = $request->old('username');    // получить данные предыдущего запроса
                &lt;input type="text" name="username" value="{{ old('username') }}"&gt;    // получить данные предыдущего запроса в шаблоне Blade
                $value = $request->cookie('name');   // получить значение cookie
                $file = $request->file('photo');    // получить файл из запроса
                $file = $request->photo;    // получить файл из запроса динамически
                if ($request->hasFile('photo')) { }   // проверить если файл в запросе
                if ($request->file('photo')->isValid()) { }   // валидация загрузки файла
                $path = $request->photo->path();    // доступ к пути файла
                $extension = $request->photo->extension();    // доступ к расширению файла
                - сохранить файл из запроса
                $path = $request->photo->store('images', 's3'); // имя файла автоматически, 's3' - имя диска сохранения (необязательный)
                $path = $request->photo->storeAs('images', 'filename.jpg', 's3');   // задать имя файла
            p сообщение об ошибке
            pre
              code.
                $validator - экземпляр Illuminate\Support\Facades\Validator
                $errors = $validator->errors();   // вернёт экземпляр Illuminate\Support\MessageBag
                echo $errors->first('email');   // получить первое сообщение об ошибке для указанного поля
                - Illuminate\Support\MessageBag - набор методов для работы с сообщениями об ошибках
                foreach ($errors->get('email') as $message) { }    // получить массив всех сообщений для указанного поля
                foreach ($errors->get('attachments.*') as $message) { }    // получить все сообщения для каждого из элементов массива
                foreach ($errors->all() as $message) { }   // получить массив всех сообщений для всех полей
                if ($errors->has('email')) { }   // проверить наличие сообщений об ошибках для указанного поля
            p при ошибке, Laravel запишет ошибки и входящие данные запроса в массив $errors сессии
            pre
              code.
                - /resources/views/post/create.blade.php
                &lt;h1&gt;Создание поста блога&lt;/h1&gt;
                @if ($errors->any())
                  &lt;div class="alert alert-danger"&gt;
                    &lt;ul&gt;
                      @foreach ($errors->all() as $error)
                        &lt;li&gt;{{ $error }}&lt;/li&gt;
                      @endforeach
                    &lt;/ul&gt;
                  &lt;/div&gt;
                @endif
                - проверить наличие ошибок и вывести
                &lt;label for="title"&gt;Название сообщения&lt;/label&gt;
                &lt;input
                  id="title"
                  type="text"
                  name="title"
                  class="@error('title') is-invalid @enderror"
                /&gt;
                @error('title')
                  &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;
                @enderror
                - перезаполнить форму данными предыдущего запроса из сессии
                $title = $request->old('title');
                либо
                &lt;input type="text" name="title" value="{{ old('title') }}"&gt;
            p доступ к запросу
            pre
              code.
                - в контроллере
                namespace App\Http\Controllers;
                use Illuminate\Http\RedirectResponse;
                use Illuminate\Http\Request;
                class UserController extends Controller
                {
                  public function store(Request $request): RedirectResponse
                  {
                    $name = $request->input('name');
                    return redirect('/users');
                  }
                }
                - в маршруте
                Route::get('/', function (Request $request) { });
            p путь запроса
            pre
              code.
                $uri = $request->path();    // получить путь запроса
                if ($request->is('admin/*')) {}   // соответствие пути запроса шаблону
                if ($request->routeIs('admin.*')) {}    // соответствие пути запроса именованному маршруту
                $url = $request->url();   // получить URL для входящего запроса
                $urlWithQueryString = $request->fullUrl();   // получить полный URL для входящего запроса
                $request->fullUrlWithQuery(['type' => 'phone']);   // добавить строку запроса в массив переменных строки запроса
                $request->fullUrlWithoutQuery(['type']);   // получить строку запроса без указанного параметра
            p получить host входящего запроса
            pre
              code.
                $request->host();
                $request->httpHost();
                $request->schemeAndHttpHost();
            p метод запроса
            pre
              code.
                - данные формы могут быть отправлены в запросе с помощью метода GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD, TRACE, CONNECT<br>
                $method = $request->method();   // получить
                if ($request->isMethod('post')) { }   // проверить
            p заголовок запроса
            pre
              code.
                - получить из запроса данные JSON: заголовок Content-Type = application/json<br>
                - получить из запроса данные формы: заголовок Content-Type = application/x-www-form-urlencoded<br>
                $value = $request->header('X-Header-Name', 'default');    // второй параметр не обязательный
                if ($request->hasHeader('X-Header-Name')) { }    // проверить наличие заголовка
                $token = $request->bearerToken();    // получить токен из заголовка Authorization
                $ipAddress = $request->ip();    // получить ip-адрес клиента, который сделал запрос
                $ipAddresses = $request->ips();   // все ip-адреса с перенаправлением и прокси
            p тип контента в заголовке Accept
            pre
              code.
                $contentTypes = $request->getAcceptableContentTypes();   // получить массив типов контента, принятые запросом
                if ($request->accepts(['text/html', 'application/json'])) { }    // true если один из типов контента принят запросом, иначе false
                $preferred = $request->prefers(['text/html', 'application/json']);   // указать предпочитаемый для запроса тип контента из массива
                if ($request->expectsJson()) {}    // если ждём только JSON
            p получить запрос в формате PSR-7
            pre
              code.
                - установить зависимости
                composer require symfony/psr-http-message-bridge
                composer require nyholm/psr7
                - интерфейс в маршрут или контроллер
                use Psr\Http\Message\ServerRequestInterface;
                Route::get('/', function (ServerRequestInterface $request) { });          

            //- Validate
            //- проверка данных на соответствие указанным правилам
            details
              summary Validate
              p валидация - проверка данных на соответствие встроенным и пользовательских правилам
              pre
                code.
                  - валидация и авторизация данных
                  namespace App\Http\Requests;
                  use Illuminate\Foundation\Http\FormRequest;
                  class StoreUserRequest extends FormRequest
                  {
                    public function authorize(): bool
                    {return true;}
                    public function rules(): array
                    {return [
                      'name' => 'required|string|max:255',
                      'email' => 'required|string|email|max:255|unique:users',
                      'password' => 'required|string|min:8|confirmed',
                    ]};
                  }
                  - применение в контроллере
                  use App\Http\Requests\StoreUserRequest;
                  class UserController extends Controller
                  {
                    public function store(StoreUserRequest $request): RedirectResponse
                    {
                      // использую уже валидированые данные
                      return redirect('/users');
                    }
                  }
                  - применение в маршруте
                  use App\Http\Requests\StoreUserRequest;
                  Route::post('/user', function (StoreUserRequest $request) {
                    // использую уже валидированые данные
                    return redirect('/users');
                  });
                  - применение в middleware
                  use App\Http\Requests\StoreUserRequest;
                  class StoreUserMiddleware
                  {
                    public function handle(Request $request, Closure $next): Response
                    {
                      $request->validateWithBag('user', (new StoreUserRequest())->rules());
                      return $next($request);
                    }
                  }
              p валидация в контроллере
              pre
                code.
                  - routes/web.php
                  use App\Http\Controllers\PostController;
                  Route::get('/post/create', [PostController::class, 'create']);
                  Route::post('/post', [PostController::class, 'store']);
                  - App\Http\Controllers\PostController.php
                  namespace App\Http\Controllers;
                  use Illuminate\Http\RedirectResponse;
                  use Illuminate\Http\Request;
                  use Illuminate\View\View;
                  class PostController extends Controller
                  {
                    // показать форму для создания нового сообщения в блоге
                    public function create(): View
                    {return view('post.create');}
                    // сохранить новую запись в блоге
                    public function store(Request $request): RedirectResponse
                    {
                    $validated = $request->validate([
                      'title' => 'required|unique:posts|max:255',
                      'body' => 'required',
                    ]);
                    либо
                    $validatedData = $request->validate([
                      'title' => ['required', 'unique:posts', 'max:255'],
                      'body' => ['required'],
                    ]);
                    либо сохранение любых сообщений об ошибках в именованную коллекцию ошибок
                    $validatedData = $request->validateWithBag('post', [
                      'title' => ['required', 'unique:posts', 'max:255'],
                      'body' => ['required'],
                    ]);
                    return redirect('/posts');
                    }
                  }
                  - bail: прекратить выполнение правил валидации для атрибута после первой ошибки
                  $request->validate([
                    'title' => 'bail|required|unique:posts|max:255',
                    'body' => 'required',
                  ]);
                  - вложенные поля в HTTP-запросе
                  $request->validate([
                    'title' => 'required|unique:posts|max:255',
                    'author.name' => 'required',
                    'author.description' => 'required',
                  ]);
                  - экранировать символ
                  $request->validate([
                    'title' => 'required|unique:posts|max:255',
                    'v1\.0' => 'required',
                  ]);
                  - необязательные поля помечать nullable
                  $request->validate([
                    'title' => 'required|unique:posts|max:255',
                    'body' => 'required',
                    'publish_at' => 'nullable|date',
                  ]);
              p создать свой валидатор
              pre
                code.
                  $validator = Validator::make($request->all(), [
                    'title' => 'required|unique:posts|max:255',
                    'body' => 'required',
                  ]);
                  if ($validator->fails()) {return redirect('/post/create')->withErrors($validator)->withInput();} // withErrors() - передать ошибки в $errors сессии
                  if ($validator->stopOnFirstFailure()->fails()) { }   // прекратить валидацию всех атрибутов после возникновения первой ошибки
                  $validated = $validator->validated();   // получить проверенные данные
                  $validated = $validator->safe()->only(['name', 'email']);   // получить только указанные данные
                  $validated = $validator->safe()->except(['name', 'email']);   // получить все данные кроме указанных
                  - для автоматического перенаправления вызвать validate()
                  Validator::make($request->all(), [
                    'title' => 'required|unique:posts|max:255',
                    'body' => 'required',
                  ])->validate();
                  - свои сообщения об ошибках в валидаторе
                  $validator = Validator::make($input, $rules, $messages = [
                    'required' => 'Поле :attribute является обязательным.',
                  ]);
                  - сохранить сообщения об ошибках в именованной коллекции ошибок
                  Validator::make($request->all(), [
                    'title' => 'required|unique:posts|max:255',
                    'body' => 'required',
                  ])->validateWithBag('post');
                  - свои имена для атрибутов валидатора
                  $validator = Validator::make($input, $rules, $messages, [
                    'email' => 'Адрес электронной почты',
                  ]);
                  - дополнительная валидация after()
                  $validator = Validator::make(/* ... */);
                  $validator->after(function ($validator) {
                    if ($this->somethingElseIsInvalid()) {
                      $validator->errors()->add('field', 'Что-то не так с этим полем!');
                    }
                  });
                  - exclude_if - не проверять это поле, если указанное поле имеет заданное значение
                  $validator = Validator::make($data, [
                    'has_appointment' => 'required|boolean',
                    'appointment_date' => 'exclude_if:has_appointment,false|required|date',
                    'doctor_name' => 'exclude_if:has_appointment,false|required|string',
                  ]);
                  - exclude_unless - не проверять это поле, если указанное поле не имеет заданное значение
                  $validator = Validator::make($data, [
                    'has_appointment' => 'required|boolean',
                    'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
                    'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
                  ]);
                  - sometimes - проверить поле если оно существует
                  $validator = Validator::make($data, [
                      'email' => 'sometimes|required|email',
                  ]);
                  $validator = Validator::make($request->all(), ['photos.profile' => 'required|image']);  // HTTP-запрос содержит поле photos[profile]
                  //проверить каждый элемент массива
                  $validator = Validator::make($request->all(), [
                    'person.*.email' => 'email|unique:users',
                    'person.*.first_name' => 'required_with:person.*.last_name',
                  ]);
              p правила валидации
              pre
                code.
                  php artisan make:rule Uppercase   // создать правило
                  php artisan make:rule Uppercase --implicit   // создать правило для обязательного атрибута
                  - в app/Rules/Uppercase.php
                  namespace App\Rules;
                  use Closure;
                  use Illuminate\Contracts\Validation\ValidationRule;
                  class Uppercase implements ValidationRule
                  {
                    public function validate(string $attribute, mixed $value, Closure $fail): void
                    {if (strtoupper($value) !== $value) {$fail('The :attribute must be uppercase.');}}
                  }
                  - применить правило
                  use App\Rules\Uppercase;
                  $request->validate(['name' => ['required', 'string', new Uppercase]]);
                  if (strtoupper($value) !== $value) {$fail('validation.uppercase')->translate();}  // вызвать локализацию сообщения об ошибке
                  либо
                  $fail('validation.location')->translate(['value' => $this->value], 'fr')
                  - доступ к внешним данным из класса правил
                  namespace App\Rules;
                  use Illuminate\Contracts\Validation\DataAwareRule;
                  use Illuminate\Contracts\Validation\ValidationRule;
                  class Uppercase implements DataAwareRule, ValidationRule
                  {
                    protected $data = [];
                    public function setData(array $data): static
                    {
                      $this->data = $data;
                      return $this;
                    }
                  }
                  - доступ к экземпляру валидатора, выполняющему проверку
                  namespace App\Rules;
                  use Illuminate\Contracts\Validation\ValidationRule;
                  use Illuminate\Contracts\Validation\ValidatorAwareRule;
                  use Illuminate\Validation\Validator;
                  class Uppercase implements ValidationRule, ValidatorAwareRule
                  {
                    protected $validator;
                    public function setValidator(Validator $validator): static
                    {
                      $this->validator = $validator;
                      return $this;
                    }
                  }
                  - правило без создания класса через $fail
                  use Illuminate\Support\Facades\Validator;
                  use Closure;
                  $validator = Validator::make($request->all(), [
                    'title' => ['required', 'max:255',
                      function (string $attribute, mixed $value, Closure $fail) {
                        if ($value === 'foo') {$fail("The {$attribute} is invalid.");}
                      },
                    ],
                  ]);
                  protected $stopOnFirstFailure = true;   // прекратить валидацию всех атрибутов после первой ошибки
                  - перенаправить при ошибке вручную
                  protected $redirect = '/dashboard';
                  либо
                  protected $redirectRoute = 'dashboard';
              p именованные коллекции ошибок позволяют делить ошибки валидации на разные группы (экземпляр MessageBag)
              pre
                code.
                  return redirect('/register')->withErrors($validator, 'login');    // задать имя коллекции ошибок
                  {{ $errors->login->first('email') }}    // получить доступ к именованной коллекции из переменной $errors сессии
              p каждое встроенное правило валидации Laravel содержит текст сообщения об ошибке в файле lang/en/validation.php
              pre
                code.
                  // свой перевод - скопируй lang/en/validation.php и отредактируй
                  php artisan lang:publish    // опубликовать сообщения по умолчанию
                  - в resources/lang/ru/validation.php
                  'custom' => [
                    'email' => [
                      'required' => 'Нам нужно знать ваш адрес электронной почты!',
                      'max' => 'Ваш адрес электронной почты слишком длинный!'
                    ],
                  ],
                  'attributes' => ['email' => 'email address']    // заменить имя атрибута по умолчанию
                  // пользовательские имена для атрибутов
                  Validator::make($request->all(), ['credit_card_number' => 'required_if:payment_type,cc']);
                  'values' => ['payment_type' => ['cc' => 'кредитная карта']],    // в resources/lang/ru/validation.php
                  // использование одного сообщения валидации для полей на основе массива
                  'custom' => [
                    'person.*.email' => [
                      'unique' => 'Each person must have a unique email address',
                    ]
                  ]    
              p проверка полей при условии
              pre
                code.
                  - создать валидатор
                  use Illuminate\Support\Facades\Validator;
                  $validator = Validator::make($request->all(), [
                    'email' => 'required|email',
                    'stars' => 'required|numeric',
                  ]);
                  - условие проверки: reason - поле проверки, required|max:500 - правила проверки,
                  - function (Fluent $input) - условие, при котором проверяем
                  use Illuminate\Support\Fluent;
                  $validator->sometimes('reason', 'required|max:500', function (Fluent $input) {return $input->stars >= 100;});
                  либо
                  $input = [
                    'channels' => [
                      ['type' => 'email', 'address' => 'abigail@example.com'],
                      ['type' => 'url', 'address' => 'https://example.com'],
                    ],
                  ];
                  $validator->sometimes('channels.*.address', 'email', function (Fluent $input, Fluent $item) {
                      return $item->type === 'email';
                  });
                  $validator->sometimes('channels.*.address', 'url', function (Fluent $input, Fluent $item) {
                      return $item->type !== 'email';
                  });
              p валидация массивов
              pre
                code.
                  use Illuminate\Support\Facades\Validator;
                  $input = [
                    'user' => [
                      'name' => 'Taylor Otwell',
                      'username' => 'taylorotwell',
                      'admin' => true,
                    ],
                  ];
                  Validator::make($input, ['user' => 'array:name,username']);   // правило array - список разрешенных ключей массива
              p применить правила проверки к каждому элементу массива подлежащего проверке атрибута
              pre
                code.
                  use App\Rules\HasPermission;
                  use Illuminate\Support\Facades\Validator;
                  use Illuminate\Validation\Rule;
                  $validator = Validator::make($request->all(), [
                    'companies.*.id' => Rule::forEach(function (string|null $value, string $attribute) {
                      return [
                        Rule::exists(Company::class, 'id'),
                        new HasPermission('manage-company', $value),
                      ];
                    }),
                  ]);
              p указать индекс или позицию элемента массива в сообщении об ошибке
              pre
                code.
                  use Illuminate\Support\Facades\Validator;
                  $input = [
                    'photos' => [
                      ['name' => 'BeachVacation.jpg', 'description' => 'Фото моего пляжного отдыха!'],
                      ['name' => 'GrandCanyon.jpg', 'description' => '']
                    ],
                  ];
                  Validator::validate(
                    $input,
                    ['photos.*.description' => 'required'],
                    ['photos.*.description.required' => 'Пожалуйста, укажите описание для фото № :position.']
                  );
              p валидация файлов
              pre
                code.
                  - для файла
                  Validator::validate($input, ['attachment' => [
                    'required', File::types(['mp3', 'wav'])->min(1024)->max(12 * 1024)],
                  ]);
                  либо с размерами kb, mb, gb и tb
                  File::image()->min('1kb')->max('10mb')
                  - для изображения
                  Validator::validate($input, [
                    'photo' => ['required',   // dimensions - размер изображения
                      File::image()->min(1024)->max(12 * 1024)->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500))],
                  ]);
              p валидация паролей
              pre
                code.
                  use Illuminate\Support\Facades\Validator;
                  use Illuminate\Validation\Rules\Password;
                  $validator = Validator::make($request->all(), ['password' => ['required', 'confirmed', Password::min(8)],]);
                  Password::min(8)    // не менее 8 символов
                  Password::min(8)->letters()   // хотя бы одна буква
                  Password::min(8)->mixedCase()   // хотя бы одна заглавная и одна строчная буква
                  Password::min(8)->numbers()   // хотя бы одна цифра
                  Password::min(8)->symbols()   // хотя бы один символ
                  Password::min(8)->uncompromised()   // убедиться, что пароль не был скомпрометирован
                  Password::min(8)->letters()->mixedCase()->numbers()->symbols()->uncompromised()   // все вместе
              p указать правила проверки паролей по умолчанию в одном месте приложения
              pre
                code.
                  namespace App\Providers
                  use Illuminate\Validation\Rules\Password;
                  class AppServiceProvider extends ServiceProvider {
                    public function boot(): void
                    {
                      Password::defaults(function () {
                        $rule = Password::min(8);
                        return $this->app->isProduction() ? $rule->mixedCase()->uncompromised() : $rule;
                      });
                    }
                  }
                  - применить правила проверки паролей по умолчанию
                  'password' => ['required', Password::defaults()],

            //- Exceptions
            //- управляет исключениями и выводом сообщений о них
            details
              summary Exceptions
              p.
                - метод withExceptions в bootstrap/app.php управляет исключениями и выводом сообщений о них<br>
                - $exceptions - экземпляр Illuminate\Foundation\Configuration\Exceptions<br>
                - debug в config/app.php определяет сколько показать информации об ошибке<br>
                - переменная окружения APP_DEBUG в .env при разработке = true, на продакшине false<br>
                - выполняться, когда необходимо сообщить об исключении определенного типа<br>
                - сообщения об исключениях записываются в журнал с указанием уровня серьезности и важности<br>
                - по умолчанию Laravel преобразует исключения в HTTP-ответ<br>
              pre
                code.
                  - создать исключения с методами render и report, если файл уже существует, без вывода сообщений в консоль,
                    без интерактивного ввода и без ANSI-вывода
                  php artisan make:exception CustomException --render --report --force --quiet --no-interaction --no-ansi
              p опубликовать стандартные шаблоны страниц ошибок
              code php artisan vendor:publish --tag=laravel-errors
              p шаблоны страниц ошибок если нет страницы для нужного кода ошибки
              pre
                code.
                  resources/views/errors/4xx.blade.php
                  resources/views/errors/5xx.blade.php
              p вывести ошибку в resources/views/errors/404.blade.php
              code &lt;h2&gt;{{ $exception->getMessage() }}&lt;/h2&gt;
              p вызвать исключение
              pre
                code.
                  abort(404);
                  abort(403, 'Unauthorized action.');
                  abort(403, 'Unauthorized action.', ['X-Header' => 'Value']);
              p управлять исключениями в bootstrap/app.php
              pre
                code.
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->report(function (InvalidOrderException $e) { });})
                  - остановить регистрацию исключения в стек журналов логирования по умолчанию
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->report(function (InvalidOrderException $e) { })->stop();})
                  либо
                  $exceptions->report(function (InvalidOrderException $e) {return false;});
                  - определить свои собственные глобальные контекстные данные
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->context(fn () => ['foo' => 'bar']);})
                  - об одном экземпляре исключения сообщать только один раз
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->dontReportDuplicates();})
                  применить
                  $original = new RuntimeException('Whoops!');
                  report($original); // сообщено
                  try {throw $original;} catch (Throwable $caught) {report($caught);} // проигнорировано
                  report($original); // проигнорировано
                  report($caught); // проигнорировано
                  - задать сообщению уровень для записи
                  use PDOException;
                  use Psr\Log\LogLevel;
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->level(PDOException::class, LogLevel::CRITICAL);})
                  - игнорировать исключения
                  use App\Exceptions\InvalidOrderException;
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->dontReport([InvalidOrderException::class]);})
                  либо
                  namespace App\Exceptions;
                  use Exception;
                  use Illuminate\Contracts\Debug\ShouldntReport;
                  class PodcastProcessingException extends Exception implements ShouldntReport { }
                  - прекратить игнорировать определенный тип исключения
                  use Symfony\Component\HttpKernel\Exception\HttpException;
                  ->withExceptions(function (Exceptions $exceptions) {$exceptions->stopIgnoring(HttpException::class);})
                  - изменить тип исключения
                  use App\Exceptions\InvalidOrderException;
                  use Illuminate\Http\Request;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->render(function (InvalidOrderException $e, Request $request) {
                      return response()->view('errors.invalid-order', status: 500);
                    });
                  })
                  либо
                  use Illuminate\Http\Request;
                  use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->render(function (NotFoundHttpException $e, Request $request) {
                      if ($request->is('api/*')) {return response()->json(['message' => 'Record not found.'], 404);}
                    });
                  })
                  - отобразить исключение в формате JSON
                  use Illuminate\Http\Request;
                  use Throwable;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->shouldRenderJsonWhen(function (Request $request, Throwable $e) {
                      if ($request->is('admin/*')) {return true;}
                      return $request->expectsJson();
                    });
                  })
                  - настроить HTTP-ответ на исключение
                  use Symfony\Component\HttpFoundation\Response;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->respond(function (Response $response) {
                      if ($response->getStatusCode() === 419) {
                        return back()->with(['message' => 'The page expired, please try again.']);
                      }
                      return $response;
                    });
                  })
                  - выбрать случайное количество исключений
                  use Illuminate\Support\Lottery;
                  use Throwable;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->throttle(function (Throwable $e) {return Lottery::odds(1, 1000);});
                  })
                  - выбрать исключения определённого типа
                  use Illuminate\Broadcasting\BroadcastException;
                  use Illuminate\Cache\RateLimiting\Limit;
                  use Throwable;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->throttle(function (Throwable $e) {
                      if ($e instanceof BroadcastException) {return Limit::perMinute(300);}
                    });
                  })
                  либо
                  use Illuminate\Broadcasting\BroadcastException;
                  use Illuminate\Cache\RateLimiting\Limit;
                  use Throwable;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->throttle(function (Throwable $e) {
                      if ($e instanceof BroadcastException) {return Limit::perMinute(300)->by($e->getMessage());}
                    });
                  })
                  либо
                  use App\Exceptions\ApiMonitoringException;
                  use Illuminate\Broadcasting\BroadcastException;
                  use Illuminate\Cache\RateLimiting\Limit;
                  use Illuminate\Support\Lottery;
                  use Throwable;
                  ->withExceptions(function (Exceptions $exceptions) {
                    $exceptions->throttle(function (Throwable $e) {
                      return match (true) {
                        $e instanceof BroadcastException => Limit::perMinute(300),
                        $e instanceof ApiMonitoringException => Lottery::odds(1, 1000),
                        default => Limit::none(),
                      };
                    });
                  })
              p добавить уникальный контекст для конкретного исключения
              pre
                code.
                  namespace App\Exceptions;
                  use Exception;
                  class InvalidOrderException extends Exception
                  {
                    public function context(): array
                    {return ['order_id' => $this->orderId];}
                  }
              p сообщить об исключении и продолжить обработку текущего запроса, не отображая страницу с ошибкой
              pre
                code.
                  public function isValid(string $value): bool
                  {
                    try {
                      // Проверка `$value`
                    } catch (Throwable $e) {
                      report($e);
                      return false;
                    }
                  }
              p поведение отчетов и отображение ошибок определено методами report и render
              pre
                code.
                  namespace App\Exceptions;
                  use Exception;
                  use Illuminate\Http\Request;
                  use Illuminate\Http\Response;
                  class InvalidOrderException extends Exception
                  {
                    public function report(): void { }    // отчитаться об исключении
                    public function render(Request $request): Response    // преобразовать исключение в HTTP-ответ
                    {return response();}
                  }

          //- Response
          //- HTTP-ответ пользователю
          details
            summary Response
            p Response - это HTTP-ответ, который возвращается пользователю в виде HTML, JSON, XML, текстового файла, изображения, редиректа и т.д.
            pre
              code.
                - вернуть ответ в контроллере
                return response('Hello World', 200);
                return response()->json(['name' => 'John Doe']);    // вернуть JSON-ответ
                return response()->json(['name' => 'John Doe'], 200, [], JSON_PRETTY_PRINT);    // вернуть JSONP-ответ
                return redirect('/home');   // вернуть редирект
                return redirect('/home')->with('status', 'Profile updated!');   // вернуть редирект с сообщением
                // добавить заголовки
                return response($content)->header('Content-Type', $type)->header('X-Header-One', 'Header Value')->header('X-Header-Two', 'Header Value');
                return response($content)->withHeaders(['Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value',]);
                - вернуть ответ в маршруте
                Route::get('/', function () {return 'Hello World';});   // преобразует в НТТР-ответ
                Route::get('/', function () {return [1, 2, 3];});   // преобразует в JSON
                Route::get('/user/{user}', function (User $user) {return $user;});    // модель преобразует в JSON
                Route::get('/home', function () {return response('Hello World', 200)->header('Content-Type', 'text/plain');});  // передать код и заголовок
                - установить Cache-Control
                Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
                  Route::get('/privacy', function () {});
                  Route::get('/terms', function () {});
                });
            p cookies
            pre
              code.
                - добавить файл куки к ответу
                return response('Hello World')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);
                - поставить куки в очередь для добавления к ответу когда он будет создан
                use Illuminate\Support\Facades\Cookie;
                Cookie::queue('name', 'value', $minutes);
                либо
                $cookie = cookie('name', 'value', $minutes);
                return response('Hello World')->cookie($cookie);
                - удалить куки, обнулив срок действия
                return response('Hello World')->withoutCookie('name');
                либо Cookie::expire('name');
                - отключить шифрование и подпись куки в bootstrap/app.php
                ->withMiddleware(function (Middleware $middleware) {
                  $middleware->encryptCookies(except: ['cookie_name']);
                })
            p потоковые ответы
            pre
              code.
                function streamedContent(): Generator {
                    yield 'Hello, ';
                    yield 'World!';
                }
                Route::get('/stream', function () {
                  return response()->stream(function (): void {
                    foreach (streamedContent() as $chunk) {
                      echo $chunk;
                      ob_flush();
                      flush();  // для отправки буферизованного содержимого
                      sleep(2); // Simulate delay between chunks...
                    }
                  }, 200, ['X-Accel-Buffering' => 'no']);
                });
                - отправить JSON из маршрута
                use App\Models\User;
                Route::get('/users.json', function () {
                  return response()->streamJson(['users' => User::cursor()]);
                });
                - отправить в ответ результат функции без записи на диск
                use App\Services\GitHub;
                return response()->streamDownload(function () {
                  echo GitHub::api('repo')->contents()->readme('laravel', 'laravel')['contents'];
                }, 'laravel-readme.md');
            p создать свой ответ
            pre
              code.
                namespace App\Providers;
                use Illuminate\Support\Facades\Response;
                use Illuminate\Support\ServiceProvider;
                class AppServiceProvider extends ServiceProvider
                {
                  public function boot(): void
                  {Response::macro('caps', function (string $value) {
                    return Response::make(strtoupper($value));
                  });}
                }
                - применить в контроллере
                return response()->caps('foo');

        //- Views
        details
          summary Views

          //- Templates
          //- шаблоны - это HTML и директивы Blade в файле с расширением .blade.php
          details 
            summary Templates
            //- Blade
            details 
              summary Blade
              p.
                - шаблоны Blade - это HTML и директивы Blade в файле с расширением .blade.php, компилируются в обычные PHP-файлы и кэшируются<br>
                - могут содержать: обычный PHP-код, другие шаблоны Blade, директивы Blade, секции, компоновщики и компоненты<br>
              pre
                code.
                  - создать Blade-шаблон
                  php artisan make:view greeting
                  - для шаблонов blade вызов глобального помошника view
                  Route::get('/', function () {return view('greeting', ['name' => 'James']);});
                  либо вызов фасада View
                  use Illuminate\Support\Facades\View;
                  return View::make('greeting', ['name' => 'James']);
                  greeting - имя файла шаблона
                  name - вывести в шаблоне значение, либо в шаблон массив данных
                  return View::first(['custom.admin', 'admin'], $data);   // вызвать первый шаблон из массива
                  if (View::exists('admin.profile')) { }    // существует ли шаблон
                  return view('greeting')->with('name', 'Victoria')->with('occupation', 'Astronaut');   // передать в шаблон отдельные данные
                  return view('admin.profile', $data);    // вызвать resources/views/admin/profile.blade.php
                  - в App\Providers\AppServiceProvider
                  public function boot(): void {View::share('key', 'value');}   // сделать данные доступными для всех шаблонов
              p.
                Templates composers - это классы или анонимные функции для создания многоразовых шаблонов, чтобы привязывать к шаблону данные перед его отрисовкой.<br>
                Привязываемые данные:<br>
                - не зависят от контроллеров<br>
                - зависят от других данных<br>
                - зависят от других шаблонов<br>
                - зависят от других компонентов<br>
                - данные к шаблону, которые вызываются при его каждой отрисовке<br>
              pre
                code.
                  в App\Providers\AppServiceProvider
                  public function boot(): void
                  {
                    Facades\View::composer('profile', ProfileComposer::class);    // компоновщик на основе класса
                    Facades\View::composer('welcome', function (View $view) { });   // компоновщик на основе анонимной функции
                  }
                  - создать нового компоновщика профиля
                  namespace App\View\Composers;
                  use App\Repositories\UserRepository;
                  use Illuminate\View\View;
                  class ProfileComposer
                  {
                    public function __construct(protected UserRepository $users) { }
                    public function compose(View $view): void
                    {$view->with('count', $this->users->count());}    // привязать данные к шаблону
                  }
                  - прикрепить компоновщик к нескольким шаблонам
                  use App\Views\Composers\MultiComposer;
                  use Illuminate\Support\Facades\View;
                  View::composer(['profile', 'dashboard'], MultiComposer::class);
                  - прикрепить компоновщик ко всем шаблонам
                  use Illuminate\Support\Facades;
                  use Illuminate\View\View;
                  Facades\View::composer('*', function (View $view) { });
                  - создатели шаблонов выполняются сразу после создания экземпляра, не дожидаясь отрисовки шаблона
                  use App\View\Creators\ProfileCreator;
                  use Illuminate\Support\Facades\View;
                  View::creator('profile', ProfileCreator::class);
              p оптимизация шаблонов
              pre
                code.
                  php artisan view:cache    // предварительная компиляция всех шаблонов при развёртывании
                  php artisan view:clear    // очистка кеша шаблонов
                  php artisan view:clear   // удалить кешированные шаблоны
                  {{ }}    // поместить РНР код в шаблон Blade
                  {{ time() }}    //текущее UNIX-время
                  Привет, {!! $name !!}   // отключить экранирование данных (экранирование нужно для предотвращения XSS-атак)
                  Привет, @{{ name }} либо @@if()   // передать в HTML без обработки
                  - передать в HTML без обработки несколько строк
                  @verbatim
                    &lt;div class="container"&gt;
                      Hello, {{ name }}.
                    &lt;/div&gt;
                  @endverbatim
                  &lt;script&gt; var app = {{ Js::from($array) }}; &lt;/script&gt;    // передать массив шаблону в виде JSON
              
            //- Blade directives
            //- директивы Blade - команды для выполнения действий в шаблонах Blade
            details
              summary Blade directives
              p.
                директивы Blade - это команды для выполнения действий в шаблонах Blade, начинаются с символа @, могут быть вложенными друг в друга и содержать параметры, другие директивы Blade, код (PHP, HTML, JavaScript, CSS)
              pre
                code.
                  - условие
                  @if (count($records) === 1)<span>у меня есть одна запись!</span>
                  @elseif (count($records) > 1)<span>у меня есть несколько записей!</span>
                  @else<span>у меня нет записей!</span>
                  @endif
                  @unless (Auth::check())<span>вы не вошли в систему</span>@endunless
                  @isset($records)<span>переменная $records определена и не равна null</span>@endisset
                  @empty($records)<span>переменная $records считается «пустой»</span>@endempty
                  - аутентификация
                  @auth<span>пользователь аутентифицирован</span>@endauth
                  @guest<span>пользователь не аутентифицирован</span>@endguest
                  - аутентификация с правилом guard
                  @auth('admin')<span>пользователь аутентифицирован</span>@endauth
                  @guest('admin')<span>пользователь не аутентифицирован</span>@endguest
                  - ошибки валидации
                  &lt;input id="title" type="text" class="@error('title') is-invalid @enderror"/&gt;
                  @error('title')&lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;@enderror
                  либо
                  &lt;input id="email" type="email" class="@error('email') is-invalid @else is-valid @enderror"/&gt;
                  - стэки
                  @push('scripts')&lt;script src="/example.js"&gt;&lt;/script&gt;@endpush   // для отображения в других шаблонах
                  @pushIf($shouldPush, 'scripts')&lt;script src="/example.js"&gt;&lt;/script&gt;@endPushIf    // добавить при условии
                  @prepend('scripts')<span>это будет первое</span>@endprepend   // добавить в начало стэка
                  &lt;head&gt;@stack('scripts')&lt;/head&gt;    // отобразить весь стэк
                  - среда окружения
                  @production<span>содержимое, отображаемое только в эксплуатационном окружении</span>@endproduction
                  @env('staging')<span>приложение запущено в «переходном» окружении</span>@endenv
                  @env(['staging', 'production'])<span>приложение запущено в «переходном» или «рабочем» окружении</span>@endenv
                  - секции
                  // есть ли в секции наследуемого шаблона содержимое
                  @hasSection('navigation')
                    &lt;div class="pull-right"&gt;
                      @yield('navigation')
                    &lt;/div&gt;
                    &lt;div class="clearfix"&gt;&lt;/div&gt;
                  @endif
                  // нет ли в секции содержимого
                  @sectionMissing('navigation')
                    &lt;div class="pull-right"&gt;
                      @include('default-navigation')
                    &lt;/div&gt;
                  @endif
                  - сессия
                  // есть ли сессия
                  @session('status')
                    &lt;div class="p-4"&gt;{{ $value }}&lt;/div&gt;
                  @endsession
                  - передать данные от родителя к ребенку @aware
                  // родитель
                  @props(['color' => 'gray'])
                  &lt;ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}&gt;{{ $slot }}&lt;/ul&gt;
                  // ребенок
                  @aware(['color' => 'gray'])
                  &lt;li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}&gt;{{ $slot }}&lt;/li&gt;
                  - подключить службу
                  @inject('metrics', 'App\Services\MetricsService')
                  &lt;div&gt;<span>Ежемесячный доход:</span> {{ $metrics->monthlyRevenue() }}&lt;/div&gt;
                  - отдать в исходящий HTTP-ответ фрагмент шаблона
                  // в шаблоне
                  @fragment('user-list')
                    &lt;ul&gt;
                      @foreach ($users as $user)
                        &lt;li&gt;{{ $user->name }}&lt;/li&gt;
                      @endforeach
                    &lt;/ul&gt;
                  @endfragment
                  // в роуте или контроллере
                  return view('dashboard', ['users' => $users])->fragment('user-list');
                  - отдать в исходящий HTTP-ответ фрагмент шаблона при условии (true - фрагмент, false - всё)
                  return view('dashboard', ['users' => $users])->fragmentIf($request->hasHeader('HX-Request'), 'user-list');
                  - отдать в исходящий HTTP-ответ фрагмент шаблона несколько фрагментов
                  view('dashboard', ['users' => $users])->fragments(['user-list', 'comment-list']);
                  view('dashboard', ['users' => $users])->fragmentsIf($request->hasHeader('HX-Request'),['user-list', 'comment-list']);
                  - свитч
                  @switch($i)
                    @case(1)
                      первый case...
                      @break
                    @case(2)
                      второй case...
                      @break
                    @default
                      case по умолчанию...
                  @endswitch
                  - циклы
                  @for ($i = 0; $i < 10; $i++) <span>Текущее значение</span> {{ $i }} @endfor
                  @foreach ($users as $user) &lt;p&gt;<span>Это пользователь</span> {{ $user->id }}&lt;/p&gt; @endforeach
                  @forelse ($users as $user) &lt;li&gt;{{ $user->name }}&lt;/li&gt;
                  @empty &lt;p&gt;<span>Нет пользователей</span>&lt;/p&gt;
                  @endforelse
                  @while (true) &lt;p&gt;<span>Я зацикливаюсь навсегда.</span>&lt;/p&gt; @endwhile
                  - пропуск текущей итерации @continue или завершение @break
                  @foreach ($users as $user)
                    @if ($user->type == 1)
                      @continue
                    @endif
                    &lt;li&gt;{{ $user->name }}&lt;/li&gt;
                    @if ($user->number == 5)
                      @break
                    @endif
                  @endforeach
                  - пропуск и завершение при условии
                  @foreach ($users as $user)
                    @continue($user->type == 1)
                    &lt;li&gt;{{ $user->name }}&lt;/li&gt;
                    @break($user->number == 5)
                  @endforeach
                  - информация о цикле в переменной $loop
                  @foreach ($users as $user)
                    @if ($loop->first)<span>это первая итерация</span>@endif
                    @if ($loop->last)<span>это последняя итерация</span>@endif
                    &lt;p&gt;<span>это пользователь</span> {{ $user->id }}&lt;/p&gt;
                  @endforeach
                  - $loop родительского цикла
                  @foreach ($users as $user)
                    @foreach ($user->posts as $post)
                      @if ($loop->parent->first)<span>это первая итерация родительского цикла</span>@endif
                    @endforeach
                  @endforeach
                  <span>
                  $loop->index - Индекс текущей итерации цикла (начинается с 0).<br>
                  $loop->iteration - Текущая итерация цикла (начинается с 1).<br>
                  $loop->remaining - Итерации, оставшиеся в цикле.<br>
                  $loop->count - Общее количество элементов в итерируемом массиве.<br>
                  $loop->first - Первая ли это итерация цикла.<br>
                  $loop->last - Последняя ли это итерация цикла.<br>
                  $loop->even - Четная ли это итерация цикла.<br>
                  $loop->odd - Нечетная ли это итерация цикла.<br>
                  $loop->depth - Уровень вложенности текущего цикла.<br>
                  $loop->parent - Переменная родительского цикла во вложенном цикле.<br>
                  </span>
                  - создать свою директиву datetime форматирует переданный $var (экземпляр DateTime)
                  App\Providers\AppServiceProvider
                  public function boot(): void
                  {
                    Blade::directive('datetime', function (string $expression) {
                      return "&lt;?php echo ($expression)->format('m/d/Y H:i'); ?&gt;";
                    });
                  }
                  // вызвать
                  @datetime($var)
              p классы и стили по условию
              pre
                code.
                  - класс
                  @php
                    $isActive = false;
                    $hasError = true;
                  @endphp
                  &lt;span @class([
                    'p-4',        // числовой ключ отрисовывается всегда
                    'font-bold' => $isActive,
                    'text-gray-500' => ! $isActive,
                    'bg-red' => $hasError,
                  ])&gt;&lt;/span&gt;
                  &lt;span class="p-4 text-gray-500 bg-red"&gt;&lt;/span&gt;
                  - стиль
                  @php
                      $isActive = true;
                  @endphp
                  &lt;span @style([
                    'background-color: red',
                    'font-weight: bold' => $isActive,
                  ])&gt;&lt;/span&gt;
                  &lt;span style="background-color: red; font-weight: bold;"&gt;&lt;/span&gt;
              p атрибуты
              pre
                code.
                  @checked
                  &lt;input
                    type="checkbox"
                    name="active"
                    value="active"
                    @checked(old('active', $user->active))
                  /&gt;

                  @selected
                  &lt;select name="version"&gt;
                    @foreach ($product->versions as $version)
                      &lt;option value="{{ $version }}" @selected(old('version') == $version)&gt;{{ $version }}&lt;/option&gt;
                    @endforeach
                  &lt;/select&gt;

                  @disabled
                  &lt;button type="submit" @disabled($errors->isNotEmpty())&gt;Отправить&lt;/button&gt;

                  @readonly
                  &lt;input
                    type="email"
                    name="email"
                    value="email@laravel.com"
                    @readonly($user->isNotAdmin())
                  /&gt;

                  @required
                  &lt;input
                    type="text"
                    name="title"
                    value="title"
                    @required($user->isAdmin())
                  /&gt;
              p @include подключение дочерних шаблонов (компоненты лучше)
              pre
                code.
                  @include('shared.errors')   // включить шаблон
                  @include('view.name', ['status' => 'complete'])   // включенный шаблон имеет доступ к родительским данным, добавить данные массивом
                  @includeIf('view.name', ['status' => 'complete'])   // включить шаблон, который может отсутствовать
                  - включить шаблон по логическому условию
                  @includeWhen($boolean, 'view.name', ['status' => 'complete'])
                  @includeUnless($boolean, 'view.name', ['status' => 'complete'])
                  @includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])    // включить первый шаблон из массива
                  __DIR__ и __FILE__ ссылаются на расположение кешированного, скомпилированного шаблона.
              p @each отрисовка шаблона с коллекцией
              pre
                code.
                  шаблон отрисовывается для каждого элемента в массиве
                  @each('view.name', $jobs, 'job' 'view.empty')
                  view.name - шаблон, $jobs - массив, job - текущий элемент массива, view.empty - шаблон если массив пустой
              p @once сработает только раз
              pre
                code.
                  @once
                    @push('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endpush
                  @endonce
                  либо
                  @pushOnce('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endPushOnce
                  либо
                  @prependOnce('scripts')&lt;script&gt;<span>JavaScript</span>&lt;/script&gt;@endPrependOnce
              p @php код РНР в шаблоне
              pre
                code.
                  @php$counter = 1;@endphp
              p @use импорт класса
              pre
                code.
                  @use('App\Models\Flight')   // без псевдонима
                  @use('App\Models\Flight', 'FlightModel')    // с псевдонимом
              p отобразить часть страницы только, если пользователь авторизован
              pre
                code.
                  @can('update', $post)
                    текущий пользователь может обновить пост
                  @elsecan('create', App\Models\Post::class)
                    текущий пользователь может создавать новые посты
                  @else
                    показать чать страницы по умолчанию
                  @endcan

                  @cannot('update', $post)
                    текущий пользователь не может обновить пост
                  @elsecannot('create', App\Models\Post::class)
                    текущий пользователь не может создавать новые посты
                  @endcannot

                  @canany(['update', 'view', 'delete'], $post)
                    текущий пользователь может обновить, просмотреть или удалить пост
                  @elsecanany(['create'], \App\Models\Post::class)
                    текущий пользователь может создать пост
                  @endcanany

                  тоже самое 
                  @if (Auth::user()->can('update', $post))<span>текущий пользователь может обновить пост</span>@endif
                  @unless (Auth::user()->can('update', $post))<span>текущий пользователь не может обновить пост</span>@endunless
                
                  - если для действия не требуется экземпляр модели, то можно указать политику авторизации через класс
                  @can('create', App\Models\Post::class)<span>текущий пользователь может создавать посты</span>@endcan
                  @cannot('create', App\Models\Post::class)<span>текущий пользователь не может создавать посты</span>@endcannot
                  {{-- --}}    // комментарии Blade не включаются в итоговый HTML

            //- Components
            //- компоненты - это многоразовые элементы интерфейса
            details
              summary Components
              p.
                компоненты - это многоразовые элементы интерфейса, созданые с помощью команды artisan или вручную на основе классов или анонимных функций<br>
                и могут содержать:<br>
                - другие компоненты, шаблоны и директивы Blade<br>
                - методы и события, которые могут быть вызваны из шаблона<br>
                - атрибуты, которые могут быть переданы в шаблон<br>
                - свойства, которые могут быть доступны из шаблона<br>
                - слоты, которые могут быть заполнены другими компонентами или шаблонами<br>
                - компоненты автоматически обнаруживаются в каталогах app/View/Components и resources/views/components<br>
              pre
                code.
                  - создать компонент
                  php artisan make:component Alert    // на основе класса
                  php artisan make:component Alert --inline   // на основе встроенного шаблона
                  php artisan make:component forms.input --view   // анонимный компонент
                  - отобразить компонент
                  &lt;x-forms.input /&gt;
                  // отобразить компонент на основе полученного значения или переменной ($componentName = "secondary-button";)   
                  &lt;x-dynamic-component :component="$componentName" class="mt-4" /&gt;
                  // если shouldRender() вернёт true - компонент отражается, false - нет
                  use Illuminate\Support\Str;
                  public function shouldRender(): bool
                  {return Str::length($this->message) > 0;}
                  - выражения и переменные PHP передавать компоненту через атрибуты c символом : впереди
                  &lt;x-alert type="error" :message="$message"/&gt;
                  - общедоступные данные в конструкторе класса компонента доступны в шаблоне компонента
                  namespace App\View\Components;
                  use Illuminate\View\Component;
                  use Illuminate\View\View;
                  class Alert extends Component
                  {
                    public function __construct(public string $type, public string $message) { }
                    public function render(): View {return view('components.alert');}
                  }
                  &lt;div class="alert alert-{{ $type }}"&gt;{{ $message }}&lt;/div&gt;
                  // аргументы конструктора в camelCase, а аргументы в атрибутах HTML в kebab-case
                  public function __construct(public string $alertType) { }
                  &lt;x-alert alert-type="danger"/&gt;
                  // при одинаковых именах атрибута и переменной можно сократить
                  &lt;x-profile :$userId :$name /&gt;   // сокращенный синтаксис атрибутов
                  &lt;x-profile :user-id="$userId" :name="$name" /&gt;    // эквивалентно
                  - так как Alpine.js тоже использует префикс :, то добавить ещё : для РНР
                  &lt;x-button ::class="{ danger: isDeleting }"&gt;<span>отправить</span>&lt;/x-button&gt;    // шаблон Blade
                  &lt;button :class="{ danger: isDeleting }"&gt;<span>отправить</span>&lt;/button&gt;   // HTML
                  - в классе компонента можно задать метод
                  public function isSelected(string $option): bool {return $option === $this->selected;}    // в классе
                  &lt;option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}"&gt;{{ $label }}&lt;/option&gt;    // в шаблоне
                  - все атрибуты не из конструктора компонента автоматически добавляются в $attributes
                  &lt;div {{ $attributes }}&gt;<span>содержание компонента</span>&lt;/div&gt;   // HTML
                  - слияние атрибутов
                  &lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;{{ $message }}&lt;/div&gt;   // компонент
                  &lt;x-alert type="error" :message="$message" class="mb-4"/&gt;    // шаблон
                  &lt;div class="alert alert-error mb-4"&gt;<span>содержимое переменной $message</span>&lt;/div&gt;   // HTML
                  либо
                  &lt;button {{ $attributes->merge(['type' => 'button']) }}&gt;{{ $slot }}&lt;/button&gt;
                  - фильтрация атрибутов
                  {{ $attributes->filter(fn (string $value, string $key) => $key == 'foo') }}   // оставит атрибут если true, остальные удалит
                  {{ $attributes->whereStartsWith('wire:model') }}    // начинается с
                  {{ $attributes->whereDoesntStartWith('wire:model') }}   // не начинается с
                  - проверить есть ли атрибут
                  @if ($attributes->has('class'))&lt;div&gt;<span>атрибут class присутствует</span>&lt;/div&gt;@endif
                  @if ($attributes->has(['name', 'class']))&lt;div&gt;<span>все указанные атрибуты присутствуют</span>&lt;/div&gt;@endif
                  @if ($attributes->hasAny(['href', ':href', 'v-bind:href']))&lt;div&gt;<span>один из указанных атрибутов присутствует</span>&lt;/div&gt;@endif
                  - получить атрибут
                  {{ $attributes->get('class') }}   // получить значение атрибута
                  {{ $attributes->only(['class']) }}    // только по ключу
                  {{ $attributes->except(['class']) }}    // кроме тех кто с ключом
                  - вынести классы в одну переменную
                    @php
                      $classes = 'className1 className2';
                    @endphp
                    &lt;div {{ $attributes(['class' => $classes]) }}&gt;{{ $slot }}&lt;/div&gt;
                  - менять вид компонента, изменяя свойства компонента в вёрстке
                  @props(['size' => 'base'])
                  @php
                    $classes = "className1 className2";
                    if ($size === 'base') {$classes .= " className3";}
                    if ($size === 'small') {$classes .= " className4";}
                  @endphp
                  &lt;a href="#" class="{{ $classes }}"&gt;{{ $slot }}&lt;/a&gt;
              p Anonymous Components - компоненты, которые не имеют класса и создаются с помощью встроенного шаблона в resources/views/components
              pre
                code.
                  resources/views/components/alert.blade.php
                  &lt;x-alert/&gt;    // в шаблоне
                  либо
                  resources/views/components/inputs/button.blade.php
                  &lt;x-inputs.button/&gt;    // в шаблоне
                  - компонент из нескольких компонентов
                  /resources/views/components/accordion/accordion.blade.php
                  /resources/views/components/accordion/item.blade.php
                  &lt;x-accordion&gt;
                    &lt;x-accordion.item&gt;
                      ...
                    &lt;/x-accordion.item&gt;
                  &lt;/x-accordion&gt;
                  - переменные и атрибуты
                  // в компоненте
                  @props(['type' => 'info', 'message'])   // info - значение по умолчанию
                  &lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;{{ $message }}&lt;/div&gt;
                  // в шаблоне
                  &lt;x-alert type="error" :message="$message" class="mb-4"/&gt;
                  - задать свой путь к анонимному компоненту
                  // для panel.blade.php
                  App\Providers\AppServiceProvider
                  public function boot(): void {Blade::anonymousComponentPath(__DIR__.'/../components');}
                  &lt;x-panel /&gt;   // в шаблоне
                  либо с пространством имен
                  Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');
                  &lt;x-dashboard::panel /&gt;   // в шаблоне
              p.
                Slots - это области в шаблоне компонента для заполнения другими компонентами или шаблонами<br>
                могут быть именованными или анонимными и содержать:<br>
                - другие слоты<br>
                - атрибуты и данные, которые могут быть переданы в шаблон<br>
                - методы и события, которые могут быть вызваны из шаблона<br>
                - свойства, которые могут быть доступны из шаблона<br>
              pre
                code.
                  // компонент
                  &lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;
                  &lt;div class="alert alert-danger"&gt;{{ $slot }}&lt;/div&gt;
                  // шаблон
                  &lt;x-alert&gt;
                    &lt;x-slot:title&gt;
                      Ошибка сервера
                    &lt;/x-slot&gt;
                    &lt;strong&gt;Упс!&lt;/strong&gt; Что-то пошло не так!
                  &lt;/x-alert&gt;
                  - существует ли контент
                  // комментарий считается контентом
                  &lt;span class="alert-title"&gt;{{ $title }}&lt;/span&gt;
                  &lt;div class="alert alert-danger"&gt;
                    @if ($slot->isEmpty()) <span>Это содержимое по умолчанию, если слот пуст.</span>
                    @else{{ $slot }}
                    @endif
                  &lt;/div&gt;
                  // без комментария
                  @if ($slot->hasActualContent())<span>В области нет комментариев.</span>@endif
                  - доступ к данным и методам класса компонента из слота
                  &lt;x-alert&gt;
                    &lt;x-slot:title&gt;{{ $component->formatAlert('Ошибка сервера') }}&lt;/x-slot&gt;
                    &lt;strong>Упс!&lt;/strong> Что-то пошло не так!
                  &lt;/x-alert&gt;
                  - доступ к атрибутам слота из компонента
                  @props(['heading','footer'])
                  &lt;div {{ $attributes->class(['border']) }}&gt;
                    &lt;h1 {{ $heading->attributes->class(['text-lg']) }}&gt;{{ $heading }}&lt;/h1&gt;
                    {{ $slot }}
                    &lt;footer {{ $footer->attributes->class(['text-gray-700']) }}&gt;{{ $footer }}&lt;/footer&gt;
                  &lt;/div&gt;
                  - разметка в классе компонента
                  public function render(): string
                  {
                    return &lt;&lt;&lt;blade
                      &lt;div class="alert alert-danger"&gt;{{ $slot }}&lt;/div&gt;
                    blade;
                  }
              p.
                - Layouts - шаблоны, которые могут содержать:<br>
                - другие макеты, шаблоны и компоненты<br>
                - атрибуты, которые могут быть переданы в шаблон<br>
                - методы и события, которые могут быть вызваны из шаблона<br>
                - свойства, которые могут быть доступны из шаблона<br>
                - слоты, которые могут быть заполнены другими компонентами или шаблонами<br>
              pre
                code.
                  // resources/views/components/layout.blade.php
                  &lt;html&gt;
                    &lt;head&gt;
                      &lt;title&gt;{{ $title ?? 'Менеджер задач' }}&lt;/title&gt;
                    &lt;/head&gt;
                    &lt;body&gt;
                      &lt;h1>Задачи&lt;/h1&gt;
                      &lt;hr/&gt;
                      {{ $slot }}
                    &lt;/body&gt;
                  &lt;/html&gt;
                  // resources/views/tasks.blade.php
                  &lt;x-layout&gt;
                    &lt;x-slot:title&gt;<span>пользовательский заголовок</span>&lt;/x-slot&gt;
                    @foreach ($tasks as $task)
                      &lt;div&gt;{{ $task }}&lt;/div&gt;
                    @endforeach
                  &lt;/x-layout&gt;
                  // app/routes/web.php
                  use App\Models\Task;
                  Route::get('/tasks', function () {return view('tasks', ['tasks' => Task::all()]);});
                  - наследование
                  // resources/views/layouts/app.blade.php
                  &lt;html&gt;
                    &lt;head&gt;&lt;title><span>Имя приложения - @yield('title')</span>&lt;/title&gt;&lt;/head&gt;
                    &lt;body&gt;
                      @section('sidebar')<span>Это главная боковая панель.</span>@show   // определяет и дополняет секцию
                      &lt;div class="container"&gt;@yield('content')&lt;/div&gt;// @yield('content', 'Содержимое по умолчанию')
                    &lt;/body&gt;
                  &lt;/html&gt;
                  // resources/views/child.blade.php
                  @extends('layouts.app')
                  @section('title', 'Название страницы')
                  @section('sidebar')
                    @@parent    // для добавления (а не перезаписи) содержимого к боковой панели макета
                    &lt;p&gt;<span>Это добавляется к главной боковой панели.</span>&lt;/p&gt;
                  @endsection
                  @section('content')&lt;p&gt;<span>Это содержимое моей страницы.</span>&lt;/p&gt;@endsection

          //- URL creation
          //- генерация URL-адресов приложения
          details
            summary URL creation
            p url используется для генерации URL-адресов приложения
            pre
              code.
                url("/posts/{$post->id}");  // http://example.com/posts/1
                - URL-адрес с запросом
                echo url()->query('/posts', ['search' => 'Laravel']);   // https://example.com/posts?search=Laravel
                echo url()->query('/posts?sort=latest', ['search' => 'Laravel']);   // http://example.com/posts?sort=latest&search=Laravel
                echo url()->query('/posts?sort=latest', ['sort' => 'oldest']);  // http://example.com/posts?sort=oldest
                echo $url = url()->query('/posts', ['columns' => ['title', 'body']]);   // http://example.com/posts?columns%5B0%5D=title&columns%5B1%5D=body
                echo urldecode($url);   // http://example.com/posts?columns[0]=title&columns[1]=body
                - получить URL
                echo url()->current();    // получить текущий URL без строки запроса
                echo url()->full();   // получить текущий URL, включая строку запроса
                echo url()->previous();   // получить полный URL-адрес предыдущего запроса
                либо через фасад
                use Illuminate\Support\Facades\URL;
                echo URL::current();
                - route помощник генерации URL-адресов для именованных маршрутов
                Route::get('/post/{post}', function (Post $post) {})->name('post.show');
                echo route('post.show', ['post' => 1]); // http://example.com/post/1
                либо
                Route::get('/post/{post}/comment/{comment}', function (Post $post, Comment $comment) {})->name('comment.show');
                echo route('comment.show', ['post' => 1, 'comment' => 3]);  // http://example.com/post/1/comment/3
                // что не является параметром машрута, то является запросом
                echo route('post.show', ['post' => 1, 'search' => 'rocket']);   // http://example.com/post/1?search=rocket
                route('post.show', ['post' => $post]);    // автоматически извлечь ключ маршрута из модели
                - подписанные URL: URL-адрес с хешом «подписи», добавленный к строке запроса, чтобы защитить URL
                // отказаться от подписки
                use Illuminate\Support\Facades\URL;
                return URL::signedRoute('unsubscribe', ['user' => 1]);
                // исключить домен из хеша подписанного URL
                return URL::signedRoute('unsubscribe', ['user' => 1], absolute: false);
                // временный подписанный URL-адрес
                return URL::temporarySignedRoute('unsubscribe', now()->addMinutes(30), ['user' => 1]);
                // проверка подлиности подписанного URL
                use Illuminate\Http\Request;
                Route::get('/unsubscribe/{user}', function (Request $request) {
                  if (! $request->hasValidSignature()) {abort(401);}
                })->name('unsubscribe');
                // игнорировать page и order при проверке подлиности подписанного URL
                if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {abort(401);}
                - signed из Illuminate\Routing\Middleware\ValidateSignature - это middleware для проверки подлиности подписанного URL
                Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed');
                // без включения домена в хеш подписи
                Route::post('/unsubscribe/{user}', function (Request $request) {})->name('unsubscribe')->middleware('signed:relative');
                - настроить в bootstrap/app.php свой ответ на недействительную подпись URL
                use Illuminate\Routing\Exceptions\InvalidSignatureException;
                ->withExceptions(function (Exceptions $exceptions) {
                  $exceptions->render(function (InvalidSignatureException $e) {
                    return response()->view('errors.link-expired', status: 403);
                  });
                })
                - URL для методов контроллера
                use App\Http\Controllers\HomeController;
                $url = action([HomeController::class, 'index']);
                $url = action([UserController::class, 'profile'], ['id' => 1]);   // с параметрами для метода контроллера
                - URL::defaults определяет значение по умолчанию для параметра запроса
                // создать middleware
                namespace App\Http\Middleware;
                use Closure;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\URL;
                use Symfony\Component\HttpFoundation\Response;
                class SetDefaultLocaleForUrls {
                  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
                  public function handle(Request $request, Closure $next): Response {
                    URL::defaults(['locale' => $request->user()->locale]);
                    return $next($request);
                }}
                // дать в bootstrap/app.php приоритет выполнения middleware
                ->withMiddleware(function (Middleware $middleware) {$middleware->prependToPriorityList(
                  before: \Illuminate\Routing\Middleware\SubstituteBindings::class,
                  prepend: \App\Http\Middleware\SetDefaultLocaleForUrls::class,
                );})
                Route::get('/{locale}/posts', function () { })->name('post.index');

          //- Form
          //- подмена метода формы
          details 
            summary Form
            pre
              code.
                &lt;form action="/example" method="POST"&gt;
                  @method('PUT')
                  @csrf
                &lt;/form&gt;
                либо
                &lt;form action="/example" method="POST"&gt;
                  &lt;input type="hidden" name="_method" value="PUT"&gt;
                  &lt;input type="hidden" name="_token" value="{{ csrf_token() }}"&gt;
                &lt;/form&gt;

          //- Vite
          //- инструмент сборки приложения на JavaScript и CSS
          details 
            summary Vite
            p.
              - Vite - это инструмент сборки на JavaScript и CSS, использует ES-модули и поддерживает:<br>
              - HMR (горячая перезагрузка модулей) для быстрой разработки<br>
              - TypeScript, JSX, CSS и другие языки<br>
              - плагины для расширения функциональности<br>
              - SSR (серверный рендеринг) для создания приложений с серверным рендерингом<br>
              - предварительную выборку, предзагрузку и кеширование ресурсов для оптимизации загрузки<br>
              p.
                vite компелирует, кеширует и отслеживает изменения в папке resources<br>
                resources/views/components/layout.blade.php создаю компонент layout<br>
                вставляю компонент на страницу
              code &lt;x-layout&gt;&lt;/x-layout&gt;
              p.
                в файле .env указать место хранения загружаемых файлов<br>
                варианты значений в файле config/filesystems.php
              code FILESYSTEM_DISK=public
              p.
                при загрузке изображения оно будет сохранено в storage/app/public<br>
                чтобы оно отображалось сделать ссылку:
              code php artisan storage:link
              p Встроенные шаблоны для писем
              code ./sail artisan vendor:publish --tag=laravel-mail
            pre
              code.
                - Blade: vite.config.js
                import { defineConfig } from 'vite';
                import laravel from 'laravel-vite-plugin';
                export default defineConfig({
                  plugins: [
                    laravel({
                      input: ['resources/css/app.css', 'resources/js/app.js'],
                      refresh: true,
                    }),
                  ],
                });
                &lt;head&gt;@vite(['resources/css/app.css', 'resources/js/app.js'])&lt;/head&gt;    // в корневом шаблоне
                - SPA: vite.config.ts
                resources/js/app.tsx    // точка входа в SPA-приложение
                laravel({
                  input: 'resources/js/app.tsx',  // точка входа vite в приложение
                  ssr: 'resources/js/ssr.tsx',    // точка входа ssr в приложение
                  refresh: true,  // обновит браузер при сохранении файла
                }),
                import '../css/app.css';    // импорт CSS в resources/js/app.tsx
                // в корневом шаблоне
                &lt;head&gt;
                  @viteReactRefresh
                  @vite(['resources/js/app.jsx'])
                &lt;/head&gt;
                - подключить ресурсы в resources/js/app.js для обработки 
                import.meta.glob([
                  '../images/**',
                  '../fonts/**',
                ]);
                &lt;img src="{{ Vite::asset('resources/images/logo.png') }}"&gt;    // в шаблоне
                - в App\Providers\AppServiceProvider
                public function boot(): void
                {Vite::macro('image', fn (string $asset) => $this->asset("resources/images/{$asset}"));}    // создать макрос
                &lt;img src="{{ Vite::image('logo.png') }}" alt="Laravel Logo"&gt;    // в шаблоне
                // предварительная выборка рессурсов при загрузке приложения
                public function boot(): void
                {Vite::prefetch(concurrency: 3);}   // максимум три параллельные загрузки вместе с загрузкой страницы
                {Vite::prefetch();}  // загрузить всё параллельно с загрузкой страницы
                {Vite::prefetch(event: 'vite:prefetch');}   // предзагрузка в ручную по событию
                // в шаблоне отправить событие для загрузки русурсов через три секунды после загрузки страницы
                &lt;script&gt;
                  addEventListener('load', () => setTimeout(() => {dispatchEvent(new Event('vite:prefetch'))}, 3000))
                &lt;/script&gt;
                - отключить vite для всех тестов
                namespace Tests;
                use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
                abstract class TestCase extends BaseTestCase
                {
                  protected function setUp(): void {parent::setUp();}
                }
                test('without vite example', function () {$this->withoutVite();});    // отключить vite в одном тесте

          //- Livewire
          details 
            summary Livewire
                
              //- Component Livewire
              details
                summary Create component Livewire
                p В livewire можно указывать роут на класс компонента
                pre
                  code.
                    Route::get('/posts', ShowPosts::class);
                    Route::get('/posts/create', CreatePost::class);
                p.
                  для этого необходимо создать шаблон для всех компонентов<br>
                  (components.layouts.app.blade.php)
                code ./sail artisan livewire:layout
                  p Компонент имеет доступ к публичным свойствам и методам своего класса
                  pre
                    code.
                      php artisan make:livewire ComponentName
                      <span>or</span>
                      php artisan make:livewire component-name
                      
                  p Создать компонент в папке
                  pre
                    code.
                      php artisan make:livewire FolderName\\ComponentName
                      <span>or</span>
                      php artisan make:livewire folder-name.component-name

                  p Создать компонент с тестом
                  code code ./sail artisan make:livewire create-post --pest

                  p Создать шаблон для компонентов livewire
                  code ./sail artisan livewire:layout

                  p Выбирать разные шаблоны на весь класс
                  pre
                    code.
                      #[Layout('layouts.app')] 
                      class CreatePost extends Component { }
                  p Выбирать разные шаблоны на методе
                  pre
                    code.
                      #[Layout('layouts.app')] 
                      public function render()
                      {
                        return view('livewire.create-post');
                      }
                  p Выбирать разные шаблоны динамически
                  pre
                    code.
                      public function render()
                      {
                        return view('livewire.create-post')
                          ->layout('layouts.app'); 
                      }
                  p Через @yield('content') указываю файл шаблона
                  pre
                    code.
                      &lt;body&gt;
                        @yield('content')
                      &lt;/body&gt;
                  p.
                    Метод render() можно не указывать<br>
                    Livewire будет автоматически выводить view с названием как у класса
                  
                  p В класс User.php добавить подстановку title в шаблон
                  code.
                    use Livewire\Attributes\Title;
                    #[Title('title')]
                  p Подстановка title динамически
                  pre
                    code.
                      public function render()
                      {
                        return view('livewire.create-post')
                          ->title('Create Post'); 
                      }

                  p задаю свойства livewire компонента в классе
                  code public $title = 'Post title...';

                  p задаю свойства livewire компонента в виде
                  code <h1>Title: "{{ $title }}"</h1>

                  p Дополнительные свойства при рендере в классе
                  code.
                    return view('livewire.create-post')->with([
                      'author' => Auth::user()->name,
                    ]);

                  p Дополнительные свойства при рендере в виде
                  code Author: {{ $author }}

                  p При выводе в любом цикле всегда указывать ключ
                  pre
                    code.
                      @foreach ($posts as $post)
                        &lt;livewire:post-item :$post :key="$post->id"&gt;
                        @livewire(PostItem::class, ['post' => $post], key($post->id))
                      @endforeach

                  p Привязка ввода к свойству класса
                  code &lt;input type="text" id="title" wire:model="title"&gt;

                  p Привязка ввода к методу класса
                  pre
                    code.
                      &lt;form wire:submit="save"&gt;
                        &lt;button type="submit"&gt;Save&lt;/button&gt;
                      &lt;/form&gt;

                  p Получить значения и очистить поля ввода
                  pre
                    code.
                      class ManageTodos extends Component
                      {
                        public $todos = [];
                        public $todo = '';
                        public function addTodo()
                        {
                          $this->todos[] = $this->todo;
                          $this->reset('todo'); 
                        }
                      }
                  p Получить значения и очистить поля ввода
                  pre
                    code.
                      class ManageTodos extends Component
                      {
                        public $todos = [];
                    
                        public $todo = '';
                    
                        public function addTodo()
                        {
                          $this->todos[] = $this->pull('todo');
                        }
                      }
                      // The same as $this->all() and $this->reset();
                      $this->pull();
            
                      // The same as $this->only(...) and $this->reset(...);
                      $this->pull(['title', 'content']);
                  
                  p Только авторизированный пользователь может изменить данные
                  pre
                    code.
                      public function update()
                      {
                        $post = Post::findOrFail($this->id);
                        $this->authorize('update', $post); 
                        $post->update(...);
                      }
                  p Изменение свойства возможно только внутри класса
                  pre
                    code.
                      class UpdatePost extends Component
                      {
                        #[Locked] 
                        public $id;
                      }
                  p Свойства Eloquent моделей по умолчанию изменять возможно только внутри класса
                  pre
                    code.
                      class UpdatePost extends Component
                      {
                        public Post $post; 
                        public $title;
                        public $content;
                        
                        public function update()
                        {
                          $this->post->update([
                            'title' => $this->title,
                            'content' => $this->content,
                          ]);
                          session()->flash('message', 'Post updated successfully!');
                        }
                      }

                  p.
                    Свойство #[Computed] кеширует запрошенные данные,<br>
                    чтобы отправлять каждый раз новый запрос.<br>
                    Обращаться к свойству через объект $this->todos
                  pre
                    code.
                      use Livewire\Attributes\Computed;

                      #[Computed]
                      public function todos()
                      {
                        return Auth::user()
                          ->todos()
                          ->select(['title', 'content'])
                          ->get();
                      }
                  
                      public function markAllComplete() 
                      {
                        $this->todos->each->complete();
                      }

                  p Вывод компонента в Blade view
                  code &lt;livewire:create-post /&gt;

                  p Вывод компонента в Blade view со значением
                  code &lt;livewire:create-post title="Initial Title" /&gt;

                  p Вывод компонента в Blade view с динамическим значением переменной
                  code &lt;livewire:create-post :title="$initialTitle" /&gt;

                  p Инициализация переменной в классе при подключении компонента
                  pre
                    code.
                      class CreatePost extends Component
                      {
                        public $title;
                        public function mount($title = null)
                        {
                          $this->title = $title;
                        }
                      }

                  p livewire инициализирует переменную автоматически
                  pre
                    code.
                      class CreatePost extends Component
                      {
                        public $title;
                      }

                  p Инлайн компонент - это один файл где разметка внутри метода render()
                  code ./sail artisan make:livewire CreatePost --inline

                  p В routes/web.php добавить
                  pre
                    code.
                      use App\Livewire\User\User;
                      Route::get('user', User::class);
                  p В классе UserCreate.php добавить переход на страницу uri без перезагрузки страницы с сервера
                  code $this->redirect('/user', navigate: true);
                  p.
                    Свойства и методы формы вынесены в отдельный класс UserForm<br>
                    В компоненте User объект класса UserForm определён как form<br>
                    Обращения к свойствам класса UserForm через form<br>
                  p Подключить assets в layout/app.blade.php
                  pre
                    code.
                      @assets
                        &lt;script src="https://cdn.jsdelivr.net/npm/pikaday/pikaday.js" defer&gt;&lt;/script&gt;
                        &lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css"&gt;
                      @endassets

                      @vite(['resources/css/app.css', 'resources/js/app.js'])
                  
                  // Actions
                  p $refresh - проверяет БД и отображает на странице
                  code &lt;button type="button" wire:click="$refresh"&gt;...&lt;/button&gt;
                  p $commit - отслеживает изменения компонета на сервере
                  code &lt;button type="button" wire:click="$commit"&gt;...&lt;/button&gt;
                  // Event listeners
                  p.
                    wire:click<br>
                    wire:submit<br>
                    wire:keydown<br>
                    wire:keyup<br>
                    wire:mouseenter<br>
                    wire:* - любой текст после wire: может быть названием события<br>
                    Livewire поддерживает любые событыя браузера, например wire:transitionend<br>
                  a(href="https://livewire.laravel.com/docs/actions") слушатели событий<br>
                  br
                  p.
                    wire:loading - загрузчик<br>
                    wire:click="delete({{ $post->id }})" - передать в класс параметр<br>
                    wire:click="$parent.removePost({{ $post->id }})" - обращаюсь к методу родительского компонента<br>
                    wire:click="$set('query', '')" - заменил значение свойства query на пустую строку<br>
                    wire:click="$toggle('sortAsc')" - при каждом нажатии меняет true/false
                  pre
                    code.
                      &lt;button wire:click="$toggle('sortAsc')"&gt;
                        Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}
                      &lt;/button&gt;
                  p.
                    wire:click="$dispatch('post-deleted')" - срабатывает событие<br>
                    $event - даёт доступ к событиям JS, например при нажатии enter<br>
                    передать значение ввода в search() - метод класса компонента
                  code &lt;input type="text" wire:keydown.enter="search($event.target.value)"&gt;
                  p.
                    При выполнении метода с #[Renderless] метод render() этого же класса не выполняется,<br>
                    либо skipRender() внутри метода<br>
                  pre
                    code.
                      #[Renderless] 
                      public function incrementViewCount()
                      {
                        $this->post->incrementViewCount();
                      }

                      public function incrementViewCount()
                      {
                        $this->post->incrementViewCount();
                        $this->skipRender(); 
                      }
                  p.
                    wire:dirty.class="border-yellow" - позволяет менять класс<br>
                    если значение поля отличается от значения этого поля в БД
                  code &lt;input type="text" wire:model.blur="title" wire:dirty.class="border-yellow"&gt;
                  p.
                    Пока поле ввода title будет в фокусе, будет Unsaved...<br>
                    когда фокус уйдёт, значение будет записано в БД и Unsaved... исчезнет
                  pre
                    code.
                      &lt;input type="text" wire:model.blur="title"&gt;
                      &lt;div wire:dirty wire:target="title"&gt;Unsaved...&lt;/div&gt;
                  p Можно выносить части Livewire компонентов в Blade компоненты
                  pre
                    code.
                      &lt;form wire:submit="save"&gt;
                        &lt;x-input-text name="title" wire:model="title" /&gt;
                        &lt;x-input-text name="content" wire:model="content" /&gt;
                        &lt;button type="submit"&gt;Save&lt;/button&gt;
                      &lt;/form&gt;
                  p Blade компонент
                  pre
                    code.
                      @props(['name'])
                      &lt;input type="text" name="{{ $name }}" {{ $attributes }}&gt;
                      &lt;div&gt;
                          @error($name) &lt;span class="error"&gt;{{ $message }}&lt;/span&gt; @enderror
                      &lt;/div&gt;

                  //- Events
                  p породить событие post-created
                  code $this->dispatch('post-created', title: $post->title);
                  p по событию выполнить метод
                  pre
                    code.
                      #[On('post-created')] 
                      public function updatePostList($title) { }
                  p породить событие post-created с динамическим аттрибутом
                  pre
                    code.
                      $this->dispatch("post-updated.{$post->id}");

                      #[On('post-updated.{post.id}')]
                  p.
                    презагрузить родительский компонент,<br>
                    если в дочернем компоненте будет событие saved
                  code &lt;livewire:edit-post @saved="$refresh"&gt;
                  p.
                    вызвать метод close() родительского компонента<br>
                    если в дочернем компоненте будет saved конткретного postId
                  code &lt;livewire:edit-post @saved="close($event.detail.postId)"&gt;

              //- Validation
              details
                summary Validation
                p.
                  В основном такая же как в ларавел, но метод validate() применяется на объекте компонента<br>
                  Метод validate() возвращает массив отвалидированных данных либо массив ошибок
                pre
                  code.
                    public function save()
                    {
                      $validated = $this->validate([ 
                        'title' => 'required|min:3',
                        'content' => 'required|min:3',
                      ]);
                      Post::create($validated);
                      return redirect()->to('/posts');
                    }
                p.
                  В форме ввода не фронте отобразить ошибку валидации с помощью<br>
                  директивы @error(), по ключу title выводиться значение $message
                pre
                  code.
                    &lt;input type="text" wire:model="title"&gt;
                    &lt;div&gt;@error('title') {{ $message }} @enderror&lt;/div&gt;
                p Задать правила валидации можно разными способами
                pre
                  code.
                    <span>методом validate()</span>
                    $validated = $this->validate([
                      <span>массивом</span>
                      'name' => ['required', 'min:2', 'max:30'],
                      <span>строкой через разделитель</span>
                      'email' => 'required|email|max:30',
                      'password' => 'required|min:6',
                    ]);
                    <span>параметром #[Validate()]</span>
                    <span>отслеживает изменение значений</span>
                    <span>использует стандартные валидаторы ларавел</span>
                    <span>свой текст сообщения</span>
                    #[Validate('required', message: 'Имя обязательно')]
                    <span>своё имя поля в сообщении</span>
                    #[Validate('min:2', as: 'Name')]
                    #[Validate('max:30')]
                    public string $name;
                    <span>написать свои правила валидации</span>
                    protected function rules(): array
                    {
                      return [
                        'name' => ['required', 'min:2', 'max:30'],
                        'email' => 'required|email|max:30',
                        'password' => 'required|min:6',
                      ];
                    }
                    <span>написать свои тексты сообщений об ошибке</span>
                    protected function messages(): array
                    {
                      return [
                        <span>название поля.валидатор => текст ошибки</span>
                        'name.required' => 'Имя обязательно!',
                        'name.min' => 'Имя должно быть длиннее!',
                        'email.required' => 'Введите почту!',
                        'password.required' => 'Пароль обязателен!',
                      ];
                    }
                p.
                  Если правила валидации заданы параметром #[Validate()]<br>
                  или методом rules(),<br>
                  то метод validate() вызываем без параметров
                code $validated = $this->validate();
                p Создаю пользователя в БД
                code User::create($validated);
                p.
                  wire:model.blur="name" - real-time validation<br>
                  срабатывает по событию либо <dfn>.live</dfn> либо <dfn>.blur</dfn><br>
                  работает при использовании параметра валидирования #[Validate()]<br>
                  wire:model.live="name" - отправляет на сервер введенный знак сразу<br>
                  wire:model.live.debounce="name" - отправляет на сервер введенное значение через 200мс после последнего нажатия<br>
                  wire:model.live.debounce.5ms="name" - отправляет на сервер введенное значение через 5мс после нажатия<br>

              //- Form
              details
                summary Form
                p.
                  B компоненте создаю форму и меняю действие по умолчанию на вызов метода save из класса<br>
                  Форма вызывает метод обработки при надатии на enter или на кнопку Save<br>
                  B полях ввода данных привязываю данные к свойствам компонента<br>
                  Свойство компонента wire:model привязывает к полю ввода свойство класса wire:model="name"<br>
                pre
                  code.
                    &lt;form wire:submit.prevent="save"&gt;
                      &lt;input type="text" wire:model="name"&gt;
                      &lt;input type="email" wire:model="email"&gt;
                      &lt;button type="submit"&gt;Save&lt;/button&gt;
                    &lt;/form&gt;
                p.
                  B методе сохранения данных вызываю метод валидации данных<br>
                  Если данные валидны, то сохраняю данные в БД<br>
                  Если данные не валидны, то вывожу ошибку
                pre
                  code.
                    public function save()
                    {
                      $validated = $this->validate([
                        'name' => 'required|min:3',
                        'email' => 'required|email',
                      ]);
                      User::create($validated);
                    }
                p.
                  Вывести ошибку валидации можно c помощью директивы @error()<br>
                  По ключу name выводится значение $message
                pre
                  code.
                    &lt;input type="text" wire:model="name"&gt;
                    &lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;
                p.
                  Вывести ошибку валидации можно c помощью директивы @error()<br>
                  По ключу name выводится значение $message
                pre
                  code.
                    &lt;input type="text" wire:model="name"&gt;
                    &lt;div&gt;@error('name') {{ $message }} @enderror&lt;/div&gt;
                p.
                  Вывести ошибку валидации можно c помощью директивы @error()<br>
                  По ключу name выводится значение $message
                pre
                  code.
                    &lt;input type="text" wire:model="name"&gt;
                p Получить все данные формы
                code $this->all();
                p Получить данные выборочных полей
                code $this->only(['name', 'email'])
                p.
                  Метод pull() - это метод only() + reset()<br>
                  Заберёт из формы данные полей name и email<br>
                  и очистит поля формы name и email
                code $this->pull(['name', 'email'])
                p заберёт из формы все данные и очистит форму
                code $this->pull();
                p.
                  Создать класс формы в app/Livewire/Forms/FormName.php
                code php artisan livewire:form FormName
                p.
                  При создании компонентов CreatePost, UpdatePost и т.д.
                  в классах компонентов будут вызываться методы и свойства класса FormName.php.
                  T.e. все свойства и методы формы в одном классе и исспользуются разными компонентами.
                  Для доступа к свойствам и методам калсса формы в классе компонента создаётся её объект form
                  и обращение к свойствам и методам через объект.
                  B классе компонента:
                pre
                  code.
                    public UserForm $form;
                    public function save()
                    {$this->form->saveUser();}
                p B шаблоне компонента:
                code wire:model="form.name"

              //- Events
              details
                summary Events
                p.
                  События позволяю прослушивать события в другом компоненте.
                  Сгенерировать событие: метод dispatch()
                code.
                  $this->dispatch('eventname');
                  <span>or</span>
                  $this->dispatch('eventname', title: $post->title);
                p В другом (других) компоненте добавить слушателя события
                code.
                  use Livewire\Attributes\On;
                  #[On('eventname')]
                  public function updatePost($title) {}

        //- Data
        details
          summary Data

          //- Encryption
          //- процесс шифрования и дешифрования
          details
            summary Encryption
            p.
              - шифрование - это процесс преобразования данных в неразборчивый вид с помощью алгоритма шифрования<br>
              - дешифрование - это процесс преобразования зашифрованных данных в исходный вид с помощью алгоритма дешифрования<br>
              - Laravel использует библиотеку OpenSSL и Sodium для шифрования и дешифрования данных<br>
              - ключ шифрования хранится в переменной окружения APP_KEY в .env файле<br>
              - параметр key в config/app.php устанавливается через APP_KEY в .env<br>
              - ключ шифрования должен быть уникальным для каждого приложения случайным набором символов длинной 32 байта или 256 бит и защищёным от доступа посторонних лиц<br>
              - драйверы шифрования: bcrypt, argon, argon2id, scrypt, md5, sha1, sha256, sha512, whirlpool, ripemd160, tiger1600, haval1600, gost, gost-crypto<br> 
              - при изменении ключа все сеансы аутентификации пользователей будут завершены.
            pre
              code.
                php artisan key:generate    // сгенерировать ключ
                - для плавной смены ключа предыдущие ключи шифрования указать в переменной окружения APP_PREVIOUS_KEYS
                APP_KEY="base64:J63qRTDLub5NuZvP+kb8YIorGS6qFYHKVo6u7179stY="
                APP_PREVIOUS_KEYS="base64:2nLsGFGzyoae2ax3EF2Lyq/hH6QghBGLIq5uL+Gp8/w="
                - зашифровать значение
                namespace App\Http\Controllers;
                use Illuminate\Http\RedirectResponse;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Crypt;
                class DigitalOceanTokenController extends Controller {
                  public function store(Request $request): RedirectResponse {
                    $request->user()->fill(['token' => Crypt::encryptString($request->token)])->save();
                    return redirect('/secrets');
                }}
                - расшифровать значения
                use Illuminate\Contracts\Encryption\DecryptException;
                use Illuminate\Support\Facades\Crypt;
                try {$decrypted = Crypt::decryptString($encryptedValue);}
                catch (DecryptException $e) { }

          //- Hashing
          //- необратимый процесс преобразования данных в неразборчивый вид
          details
            summary Hashing
            p.
              хеширование - это необратимый процесс преобразования данных в неразборчивый вид с помощью алгоритма хеширования,<br>
              используется для хранения паролей и проверки целостности, подлинности, идентичности, уникальности, безопасности, доступности, конфиденциальности данных<br>
              - Laravel использует библиотеку Hash, Argon2, Bcrypt, Argon2id для хеширования данных<br>
              - драйвер хеширования bcrypt, argon и argon2id указан в переменной HASH_DRIVER в .env<br>
              - HASH_VERIFY в .env: true - сверять алгоритм хеширования пароля с установленным, false - любой алгоритм хеширования
            pre
              code.
                php artisan config:publish hashing    // опубликовать файл конфигурации хеширования для настройки параметров драйвера хеширования
                namespace App\Http\Controllers;
                use Illuminate\Http\RedirectResponse;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Hash;
                class PasswordController extends Controller {
                  // Обновить пароль пользователя
                  public function update(Request $request): RedirectResponse
                  {
                    $request->user()->fill(['password' => Hash::make($request->newPassword)])->save();
                    return redirect('/profile');
                }}
                $hashed = Hash::make('password', ['rounds' => 12]);   // коэффициент работы Bcrypt
                $hashed = Hash::make('password', ['memory' => 1024, 'time' => 2, 'threads' => 2]);    // коэффициент работы Argon2
                if (Hash::check('plain-text', $hashedPassword)) { }   // сверить хеш
                if (Hash::needsRehash($hashed)) {$hashed = Hash::make('plain-text');}   // нужно ли повторно хешировать

          //- Password Reset
          //- сброс пароля
          details 
            summary Password Reset
            p.
              для сброса пароля нужно:<br>
              - в App\Models\User<br>
              Illuminate\Notifications\Notifiable<br>
              Illuminate\Contracts\Auth\CanResetPassword<br>
              - в 0001_01_01_000000_create_users_table.php токен сброса пароля<br>
              - в bootstrap/app.php указать trustHosts - отвечать только на запросы указанных хостов<br>
              - форма запроса ссылки сброса пароля с полем для email<br>
            pre
              code.
                Route::get('/forgot-password', function () {return view('auth.forgot-password');
                })->middleware('guest')->name('password.request');
                - сверить почту и отправить на неё ссылку
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Password;
                Route::post('/forgot-password', function (Request $request) {
                  $request->validate(['email' => 'required|email']);
                  $status = Password::sendResetLink($request->only('email'));
                  return $status === Password::ResetLinkSent
                    ? back()->with(['status' => __($status)])
                    : back()->withErrors(['email' => __($status)]);
                })->middleware('guest')->name('password.email');
                - форма ввода нового пароля, после перехода по ссылке сброса пароля
                Route::get('/reset-password/{token}', function (string $token) {
                  return view('auth.reset-password', ['token' => $token]);
                })->middleware('guest')->name('password.reset');
                - проверка входящего запроса и обновление пароля пользователя в базе данных
                use App\Models\User;
                use Illuminate\Auth\Events\PasswordReset;
                use Illuminate\Http\Request;
                use Illuminate\Support\Facades\Hash;
                use Illuminate\Support\Facades\Password;
                use Illuminate\Support\Str;
                Route::post('/reset-password', function (Request $request) {
                  $request->validate([
                    'token' => 'required',
                    'email' => 'required|email',
                    'password' => 'required|min:8|confirmed',
                  ]);
                  $status = Password::reset(
                    $request->only('email', 'password', 'password_confirmation', 'token'),
                    function (User $user, string $password) {$user->forceFill(['password' => Hash::make($password)
                      ])->setRememberToken(Str::random(60));
                      $user->save();
                      event(new PasswordReset($user));
                  });
                  return $status === Password::PasswordReset
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withErrors(['email' => [__($status)]]);
                })->middleware('guest')->name('password.update');
                php artisan auth:clear-resets   // удалить просроченные токены
                - для автоматизации добавить в планировщик
                use Illuminate\Support\Facades\Schedule;
                Schedule::command('auth:clear-resets')->everyFifteenMinutes();
                - в App\Providers\AppServiceProvider изменить URL-адрес ссылки для сброса пароля
                use App\Models\User;
                use Illuminate\Auth\Notifications\ResetPassword;
                public function boot(): void
                {
                  ResetPassword::createUrlUsing(function (User $user, string $token) {
                    return 'https://example.com/reset-password?token='.$token;
                  });
                }
                - свой вариант уведомления для отправки пользователю ссылки для сброса пароля
                use App\Notifications\ResetPasswordNotification;
                public function sendPasswordResetNotification($token): void
                {
                  $url = 'https://example.com/reset-password?token='.$token;
                  $this->notify(new ResetPasswordNotification($url));
                }

          //- SQL-request creation
          //- либо построитель SQL-запросов, либо Eloquent ORM
          details
            summary Request creation
            p.
              - Конфигурация баз данных в config/database.php
              - Параметры конфигурации определяются значениями переменных окружения в .env
              - Фасад DB содержит методы для каждого типа запроса: select, update, insert, delete, и statement.
            pre
              code.
                - команды artisan
                php artisan db    // подключиться к базе данных
                php artisan db mysql    // подключиться к базе данных и указать имя соединения
                php artisan db:show   // просмотр БД
                php artisan db:show --database=pgsql    // просмотр БД с именем соединения
                php artisan db:show --counts --views   // количество строк и представления для просмотра
                php artisan db:table users   // обзор отдельной таблицы
                php artisan db:monitor --databases=mysql,pgsql --max=100    // мониторить соединения mysql и pgsql каждую минуту и отправить событие Illuminate\Database\Events\DatabaseBusy при количестве открытых соединений больше 100
            p в App\Providers\AppServiceProvider
            pre
              code.
                - слушатель SQL-запроса
                namespace App\Providers;
                use Illuminate\Database\Events\QueryExecuted;
                use Illuminate\Support\Facades\DB;
                use Illuminate\Support\ServiceProvider;
                class AppServiceProvider extends ServiceProvider {
                  public function register(): void { }
                  public function boot(): void
                  {
                    DB::listen(function (QueryExecuted $query) {
                      // $query->sql;
                      // $query->bindings;
                      // $query->time;
                      // $query->toRawSql();
                    });
                }}
                - вызвать функцию когда время выполнения запроса дольше указанного
                namespace App\Providers;
                use Illuminate\Database\Connection;
                use Illuminate\Support\Facades\DB;
                use Illuminate\Support\ServiceProvider;
                use Illuminate\Database\Events\QueryExecuted;
                class AppServiceProvider extends ServiceProvider {
                  public function register(): void { }
                  public function boot(): void
                  {DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) { });}
                }
                - слушать событие Illuminate\Database\Events\DatabaseBusy 
                use App\Notifications\DatabaseApproachingMaxConnections;
                use Illuminate\Database\Events\DatabaseBusy;
                use Illuminate\Support\Facades\Event;
                use Illuminate\Support\Facades\Notification;
                public function boot(): void {
                  Event::listen(function (DatabaseBusy $event) {
                    Notification::route('mail', 'dev@example.com')->notify(new DatabaseApproachingMaxConnections(
                      $event->connectionName,
                      $event->connections
                    ));
                });}
            p Illuminate\Support\Facades\Schema;
            pre
              code.
                - проверка БД
                use Illuminate\Support\Facades\Schema;
                $tables = Schema::getTables();
                $views = Schema::getViews();
                $columns = Schema::getColumns('users');
                $indexes = Schema::getIndexes('users');
                $foreignKeys = Schema::getForeignKeys('users');
                $columns = Schema::connection('sqlite')->getColumns('users');   // проверить соединение с БД
            p Illuminate\Support\Facades\DB
            pre
              code.
                - показать список всех пользователей приложения
                namespace App\Http\Controllers;
                use App\Http\Controllers\Controller;
                use Illuminate\Support\Facades\DB;
                use Illuminate\View\View;
                class UserController extends Controller {
                  public function index(): View {
                    $users = DB::select('select * from users where active = ?', [1]);
                    return view('user.index', ['users' => $users]);
                }}
                - select всегда возвращает массив
                $users = DB::select('select * from users');
                foreach ($users as $user) {echo $user->name;}
                - чтобы получить значение в виде числа
                $burgers = DB::scalar("select count(case when food = 'burger' then 1 end) as burgers from menu");
                - получить все наборы результатов, возвращенных хранимой процедурой
                [$options, $notifications] = DB::selectResultSets(
                  "CALL get_user_options_and_notifications(?)", $request->user()->id
                );
                - связывания параметров, используя именованные привязки
                $results = DB::select('select * from users where id = :id', ['id' => 1]);
                - insert
                DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);
                - update
                $affected = DB::update('update users set votes = 100 where name = ?',['Anita']);
                - delete 
                $deleted = DB::delete('delete from users');
                - запрос общего типа
                DB::statement('drop table users');
                - запрос SQL без привязки каких-либо значений
                DB::unprepared('update users set votes = 100 where name = "Dries"');
                - Если в config/database.php несколько соединений, то получить доступ к соединению с помощью метода connection
                $users = DB::connection('sqlite')->select(/* ... */);
                - получить доступ к базовому экземпляру PDO текущего соединения
                $pdo = DB::connection()->getPdo();
                - выполнение набора операций в транзакции
                DB::transaction(function () {
                    DB::update('update users set votes = 1');
                    DB::delete('delete from posts');
                });
                либо с количеством попыток при взаимоблокировке
                DB::transaction(function () {
                    DB::update('update users set votes = 1');
                    DB::delete('delete from posts');
                }, 5);
                - транзакция вручную
                DB::beginTransaction();   // начать транзакцию
                DB::rollBack();   // откатить транзакцию
                DB::commit();   // зафиксировать транзакцию
                - получить все строки таблицы
                $users = DB::table('users')->get();
                - получить доступ к значению каждого столбца
                $users = DB::table('users')->get();
                foreach ($users as $user) {echo $user->name;}
                - получить одну строку или один столбец
                $user = DB::table('users')->where('name', 'John')->first();
                return $user->email;
                либо если строки может не быть
                $user = DB::table('users')->where('name', 'John')->firstOrFail();
                - получить одно значение из строки
                $email = DB::table('users')->where('name', 'John')->value('email');
                - получить одну строку по значению столбца id
                $user = DB::table('users')->find(3);
                - получить значения одного столбца в виде коллекции
                use Illuminate\Support\Facades\DB;
                $titles = DB::table('users')->pluck('title');
                foreach ($titles as $title) {echo $title;}
                - получить значения одного столбца в виде коллекции с ключами из столбца name
                $titles = DB::table('users')->pluck('title', 'name');
                foreach ($titles as $name => $title) {echo $title;}
                - извлекать данные частями
                DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
                  foreach ($users as $user) { }
                });
                - остановить обработку после получения части данных
                DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
                    return false;
                });
                - при изменении данных одновременно с получением по частям
                DB::table('users')->where('active', false)->chunkById(100, function (Collection $users) {
                  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['active' => true]);}
                });
                - сгруппировать логически условия запроса
                DB::table('users')->where(function ($query) {$query->where('credits', 1)->orWhere('credits', 2);
                })->chunkById(100, function (Collection $users) {
                  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['credits' => 3]);}
                });
                - метод lazy() возвращает данные по частям в виде экземпляра LazyCollection
                DB::table('users')->orderBy('id')->lazy()->each(function (object $user) { });
                - при изменении данных одновременно с получением по частям использовать методы lazyById или lazyByIdDesc
                DB::table('users')->where('active', false)->lazyById()->each(function (object $user) {
                  DB::table('users')->where('id', $user->id)->update(['active' => true]);
                });
                - построитель запросов также содержит методы count, max, min, avg, и sum
                $users = DB::table('users')->count();
                $price = DB::table('orders')->max('price');
                либо
                $price = DB::table('orders')->where('finalized', 1)->avg('price');
                - проверить существование записей
                if (DB::table('orders')->where('finalized', 1)->exists()) { }
                if (DB::table('orders')->where('finalized', 1)->doesntExist()) { }
                - указать собственное выражение SELECT для запроса
                $users = DB::table('users')->select('name', 'email as user_email')->get();
                - вернуть уникальные результаты
                $users = DB::table('users')->distinct()->get();
                - добавить столбец к существующему выражению SELECT
                $query = DB::table('users')->select('name');
                $users = $query->addSelect('age')->get();
                - cырые sql-выражения
                $users = DB::table('users')->select(DB::raw('count(*) as user_count, status'))
                  ->where('status', '<>', 1)->groupBy('status')->get();
                $orders = DB::table('orders')->selectRaw('price * ? as price_with_tax', [1.0825])->get();
                $orders = DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 100)', [200])->get();
                $orders = DB::table('orders')->select('department', DB::raw('SUM(price) as total_sales'))
                  ->groupBy('department')->havingRaw('SUM(price) > ?', [2500])->get();
                $orders = DB::table('orders')->orderByRaw('updated_at - created_at DESC')->get();
                $orders = DB::table('orders')->select('city', 'state')->groupByRaw('city, state')->get();
                $users = DB::table('users')->join('contacts', 'users.id', '=', 'contacts.user_id')
                  ->join('orders', 'users.id', '=', 'orders.user_id')
                  ->select('users.*', 'contacts.phone', 'orders.price')->get();
                $users = DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')->get();
                $users = DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')->get();
                $sizes = DB::table('sizes')->crossJoin('colors')->get();
                DB::table('users')->join('contacts', function (JoinClause $join) {
                  $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
                })->get();
                DB::table('users')->join('contacts', function (JoinClause $join) {
                  $join->on('users.id', '=', 'contacts.user_id')->where('contacts.user_id', '>', 5);
                })->get();
                - присоединить запрос к подзапросу
                $latestPosts = DB::table('posts')->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
                  ->where('is_published', true)->groupBy('user_id');
                $users = DB::table('users')->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {
                  $join->on('users.id', '=', 'latest_posts.user_id');
                })->get();
                - боковые соединения с подзапросом
                // получить коллекцию пользователей, а также три последних блог-поста пользователя
                $latestPosts = DB::table('posts')
                  ->select('id as post_id', 'title as post_title', 'created_at as post_created_at')
                  ->whereColumn('user_id', 'users.id')->orderBy('created_at', 'desc')->limit(3);
                $users = DB::table('users')->joinLateral($latestPosts, 'latest_posts')->get();
                - объединение двух или более запросов Unions
                $first = DB::table('users')->whereNull('first_name');
                $users = DB::table('users')->whereNull('last_name')->union($first)->get();
                // запросы, объединенные с использованием метода unionAll, не будут удалять повторяющиеся результаты
                $users = DB::table('users')->where('votes', '=', 100)->where('age', '>', 35)->get();
                либо
                $users = DB::table('users')->where('votes', 100)->get();
                либо
                $users = DB::table('users')->where('votes', '>=', 100)->get();
                $users = DB::table('users')->where('votes', '<>', 100)->get();
                $users = DB::table('users')->where('name', 'like', 'T%')->get();
                либо
                $users = DB::table('users')->where([
                  ['status', '=', '1'],
                  ['subscribed', '<>', '1'],
                ])->get();
                - метод orWhere для добавления к запросу с помощью оператора OR
                $users = DB::table('users')->where('votes', '>', 100)->orWhere('name', 'John')->get();
                либо
                $users = DB::table('users')->where('votes', '>', 100)->orWhere(function (Builder $query) {
                  $query->where('name', 'Abigail')->where('votes', '>', 50);})->get();
                // сформирует запрос: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)
                - методы whereNot и orWhereNot могут использоваться для отрицания заданной группы ограничений запроса
                $products = DB::table('products')->whereNot(function (Builder $query) {
                  $query->where('clearance', true)->orWhere('price', '<', 10);})->get();
                - выбрать все записи, где хотя бы один столбец из списка соответствует определенному значению
                $users = DB::table('users')->where('active', true)
                  ->whereAny(['name', 'email', 'phone'],'like', 'Example%')->get();
                // сформирует запрос: 
                SELECT * FROM users
                WHERE active = true AND (name LIKE 'Example%' OR email LIKE 'Example%' OR phone LIKE 'Example%')
                - извлечение записей, где все указанные столбцы соответствуют заданному условию
                $posts = DB::table('posts')->where('published', true)
                  ->whereAll(['title', 'content'], 'like', '%Laravel%')->get();
                // сформирует запрос:
                SELECT * FROM posts
                WHERE published = true AND (title LIKE '%Laravel%' AND content LIKE '%Laravel%')
                - извлечения записей, в которых ни один из заданных столбцов не соответствует заданному ограничению
                $posts = DB::table('albums')->where('published', true)
                  ->whereNone(['title', 'lyrics', 'tags'], 'like', '%explicit%')->get();
                // сформирует запрос:
                SELECT * FROM albums
                WHERE published = true
                AND NOT ( title LIKE '%explicit%' OR lyrics LIKE '%explicit%' OR tags LIKE '%explicit%')
                - запрос к столбцу типа JSON
                $users = DB::table('users')->where('preferences->dining->meal', 'salad')->get();
                - запрос массивов JSON
                $users = DB::table('users')->whereJsonContains('options->languages', 'en')->get();
                либо
                $users = DB::table('users')->whereJsonContains('options->languages', ['en', 'de'])->get();
                - длина массива JSON
                $users = DB::table('users')->whereJsonLength('options->languages', 0)->get();
                $users = DB::table('users')->whereJsonLength('options->languages', '>', 1)->get();
                - сопоставления с образцом
                $users = DB::table('users')->whereLike('name', '%John%')->get();
                - включить поиск с учетом регистра
                $users = DB::table('users')->whereLike('name', '%John%', caseSensitive: true)->get();
                - or с условием LIKE
                $users = DB::table('users')->where('votes', '>', 100)->orWhereLike('name', '%John%')->get();
                - не такой как образец
                $users = DB::table('users')->whereNotLike('name', '%John%')->get();
                - or с условием NOT LIKE
                $users = DB::table('users')->where('votes', '>', 100)->orWhereNotLike('name', '%John%')->get();
                - значение переданного столбца содержится в указанном массиве
                $users = DB::table('users')->whereIn('id', [1, 2, 3])->get();
                - значение переданного столбца не содержится в указанном массиве
                $users = DB::table('users')->whereNotIn('id', [1, 2, 3])->get();
                - объект запроса как аргумент
                $activeUsers = DB::table('users')->select('id')->where('is_active', 1);
                $users = DB::table('comments')->whereIn('user_id', $activeUsers)->get();
                // сформирует запрос
                select * from comments where user_id in (select id from users where is_active = 1)
                - проверяет, что значение столбца находится между двумя значениями
                $users = DB::table('users')->whereBetween('votes', [1, 100])->get();
                - проверяет, что значение столбца находится за пределами двух значений
                $users = DB::table('users')->whereNotBetween('votes', [1, 100])->get();
                - проверяет, что значение столбца находится между двумя значениями двух столбцов в одной строке таблицы
                $patients = DB::table('patients')
                  ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();
                - проверяет, что значение столбца находится за пределами двух значений двух столбцов в одной строке таблицы
                $patients = DB::table('patients')
                  ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();
                - проверяет, что значение переданного столбца равно NULL
                $users = DB::table('users')->whereNull('updated_at')->get();
                - проверяет, что значение переданного столбца не равно NULL
                $users = DB::table('users')->whereNotNull('updated_at')->get();
                - сравнение значения столбца с датой
                $users = DB::table('users')->whereDate('created_at', '2016-12-31')->get();
                - сравнение значения столбца с конкретным месяцем
                $users = DB::table('users')->whereMonth('created_at', '12')->get();
                - сравнение значения столбца с определенным днем месяца
                $users = DB::table('users')->whereDay('created_at', '31')->get();
                - сравнение значения столбца с конкретным годом
                $users = DB::table('users')->whereYear('created_at', '2016')->get();
                - сравнение значения столбца с определенным временем
                $users = DB::table('users')->whereTime('created_at', '=', '11:20:45')->get();
                - проверка равенства двух столбцов
                $users = DB::table('users')->whereColumn('first_name', 'last_name')->get();
                либо
                $users = DB::table('users')->whereColumn('updated_at', '>', 'created_at')->get();
                либо
                $users = DB::table('users')->whereColumn([
                  ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at']])->get();
                - всегда группировать вызовы метода orWhere в круглых скобках
                $users = DB::table('users')->where('name', '=', 'John')->where(function (Builder $query) {
                  $query->where('votes', '>', 100)->orWhere('title', '=', 'Admin');})->get();
                // сформирует запрос
                select * from users where name = 'John' and (votes > 100 or title = 'Admin')
                - WHERE EXISTS
                $users = DB::table('users')->whereExists(function (Builder $query) {
                  $query->select(DB::raw(1))->from('orders')->whereColumn('orders.user_id', 'users.id');
                })->get();
                либо
                $orders = DB::table('orders')->select(DB::raw(1))->whereColumn('orders.user_id', 'users.id');
                $users = DB::table('users')->whereExists($orders)->get();
                // в обоих случаях получим
                select * from users where exists (select 1 from orders where orders.user_id = users.id)
                - сравнивает результаты подзапроса с переданным значением
                $users = User::where(function (Builder $query) {
                  $query->select('type')->from('membership')->whereColumn('membership.user_id', 'users.id')
                    ->orderByDesc('membership.start_date')->limit(1);}, 'Pro')->get();
                - сравнивает столбец с результатами подзапроса
                $incomes = Income::where('amount', '<', function (Builder $query) {
                  $query->selectRaw('avg(i.amount)')->from('incomes as i');})->get();
                - whereFullText и orWhereFullText добавят полнотекстовые “условия” в запрос для столбцов, имеющих полнотекстовые индексы
                $users = DB::table('users')->whereFullText('bio', 'web developer')->get();
                - сортировать результаты запроса по конкретному столбцу
                $users = DB::table('users')->orderBy('name', 'desc')->get();
                либо
                $users = DB::table('users')->orderBy('name', 'desc')->orderBy('email', 'asc')->get();
                - latest и oldest: упорядочить результаты по дате, по умолчанию по столбцу created_at, либо указать столбец сортировки
                $user = DB::table('users')->latest()->first();
                - сортировка результатов запроса в случайном порядке
                $randomUser = DB::table('users')->inRandomOrder()->first();
                - Метод reorder удаляет все примененые выражения ORDER BY
                $query = DB::table('users')->orderBy('name');
                $unorderedUsers = $query->reorder()->get();
                - удалить все существующие выражения ORDER BY и применить к запросу совершенно новый порядок
                $query = DB::table('users')->orderBy('name');
                $usersOrderedByEmail = $query->reorder('email', 'desc')->get();
                - группировка результатов запроса
                $users = DB::table('users')->groupBy('account_id')->having('account_id', '>', 100)->get();
                - фильтрация результатов в заданном диапазоне
                $report = DB::table('orders')->selectRaw('count(id) as number_of_orders, customer_id')
                  ->groupBy('customer_id')->havingBetween('number_of_orders', [5, 15])->get();
                - группировка по нескольким столбцам
                $users = DB::table('users')->groupBy('first_name', 'status')->having('account_id', '>', 100)->get();
                - take: ограничить количество результатов, возвращаемых запросом
                - skip: пропустить указанное количество результатов из запроса
                $users = DB::table('users')->skip(10)->take(5)->get();
                либо limit и offset
                $users = DB::table('users')->offset(10)->limit(5)->get();
                - применить выражение при условии: when выполняет переданную функцию если первый аргумент равен true
                $role = $request->input('role');
                $users = DB::table('users')->when($role, function (Builder $query, string $role) {
                  $query->where('role_id', $role);})->get();
                - второя переданная when функция будет выполнена если первый аргумент равен false
                $sortByVotes = $request->boolean('sort_by_votes');
                $users = DB::table('users')->when($sortByVotes, function (Builder $query, bool $sortByVotes) {
                  $query->orderBy('votes');}, function (Builder $query) {$query->orderBy('name');})->get();
                - вставка записей в таблицу БД
                DB::table('users')->insert(['email' => 'kayla@example.com', 'votes' => 0]);
                - каждый из массивов это запись, которую нужно вставить в таблицу
                DB::table('users')->insert([
                  ['email' => 'picard@example.com', 'votes' => 0],
                  ['email' => 'janeway@example.com', 'votes' => 0],
                ]);
                - игнорировать ошибки при вставке записей в базу данных
                DB::table('users')->insertOrIgnore([
                  ['id' => 1, 'email' => 'sisko@example.com'],
                  ['id' => 2, 'email' => 'archer@example.com'],
                ]);
                - вставляет новые записи в таблицу, используя подзапрос
                DB::table('pruned_users')->insertUsing(['id', 'name', 'email', 'email_verified_at'],
                DB::table('users')->select('id', 'name', 'email', 'email_verified_at')
                ->where('updated_at', '<=', now()->subMonth()));
                - вставить запись и затем получить идентификатор этой записи
                $id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);
                - вставляет записи, которые не существуют, и обновляет записи, которые уже существуют, новыми значениями<br>
                - попытается вставить две записи. Если запись уже существует с такими же значениями столбцов departure и destination, то обновит столбец price этой записи<br>
                DB::table('flights')->upsert([
                  ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
                  ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
                ], ['departure', 'destination'], ['price']);
                - обновить существующие записи
                $affected = DB::table('users')->where('id', 1)->update(['votes' => 1]);
                - Если запись существует, она будет обновлена значениями второго аргумента.<br>
                - Если запись не может быть найдена, будет вставлена новая запись с объединенными атрибутами обоих аргументов<br>
                DB::table('users')->updateOrInsert(['email' => 'john@example.com', 'name' => 'John'], ['votes' => '2']);
                либо через условие
                DB::table('users')->updateOrInsert(['user_id' => $user_id],fn ($exists) => $exists 
                  ? ['name' => $data['name'],'email' => $data['email']]
                  : ['name' => $data['name'], 'email' => $data['email'], 'marketable' => true]);
                - обновление столбца JSON
                $affected = DB::table('users')->where('id', 1)->update(['options->enabled' => true]);
                - методы увеличения или уменьшения значения конкретного столбца
                DB::table('users')->increment('votes', 5);
                DB::table('users')->decrement('votes', 5);
                либо
                DB::table('users')->increment('votes', 1, ['name' => 'John']);
                - увеличивать или уменьшать значения нескольких столбцов с помощью методов incrementEach и decrementEach
                DB::table('users')->incrementEach(['votes' => 5, 'balance' => 100]);
                - удалить записи из таблицы
                $deleted = DB::table('users')->delete();
                $deleted = DB::table('users')->where('votes', '>', 100)->delete();
                - удаление всех записей из таблицы и сброс автоинкрементного идентификатора на ноль
                DB::table('users')->truncate();
                - предотвратить изменение выбранных строк до тех пор, пока транзакция не будет зафиксирована
                DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
                - предотвращает изменение выбранных записей
                DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();
                - отобразить связанные параметры запроса и сам SQL-запрос
                DB::table('users')->where('votes', '>', 100)->dd();
                DB::table('users')->where('votes', '>', 100)->dump();
                либо
                DB::table('users')->where('votes', '>', 100)->dumpRawSql();
                DB::table('users')->where('votes', '>', 100)->ddRawSql();

          //- Eloquent ORM
          //- работа с БД с помощью PHP-кода, SQL-запросов, миграций, моделей, сидов, фабрик и отношений
          details 
            summary Eloquent ORM
            p Eloquent ORM - это реализация Active Record для работы с БД с помощью PHP-кода, SQL-запросов, миграций, сидов, фабрик и отношений<br>

            //- Models
            //- классы для взаимодействия с таблицами БД
            details
              summary Модели
              p.
                models - классы моделей Eloquent для взаимодействия с таблицами БД методами построителя запросов<br>
                Eloquent будет предполагать, что модель Flight хранит записи в таблице flights<br>
                а модель AirTrafficController – в таблице air_traffic_controllers
              pre
                code.
                  - создать модель
                  php artisan make:model Flight
                  // + миграцию
                  php artisan make:model Flight --migration
                  php artisan make:model Flight -m
                  // + фабрику FlightFactory...
                  php artisan make:model Flight --factory
                  php artisan make:model Flight -f
                  // + наполнитель FlightSeeder...
                  php artisan make:model Flight --seed
                  php artisan make:model Flight -s
                  // + контроллер FlightController...
                  php artisan make:model Flight --controller
                  php artisan make:model Flight -c
                  // + контроллер, ресурс и запрос
                  php artisan make:model Flight --controller --resource --requests
                  php artisan make:model Flight -crR
                  // + политика FlightPolicy
                  php artisan make:model Flight --policy
                  // + миграция, фабрика, наполнитель и контроллер
                  php artisan make:model Flight -mfsc
                  // в полном комплекте (Model, Migration, Factory, Seeder, Request, Controller, Policy)
                  php artisan make:model Flight --all
                  php artisan make:model Flight -a
                  // без миграции
                  php artisan make:model Flight -cfs --policy
                  // при типе связи $this->belongsToMany() создать сводную модель
                  php artisan make:model Flight --pivot
                  php artisan make:model Flight -p
                  // помощь по созданию модели
                  php artisan help make:model
                  // обзор всех атрибутов и отношений модели
                  php artisan model:show Flight
                  // содажимое БД
                  php artisan db:show
                  php artisan db:table users
                  // содажимое таблицы БД
                  php artisan tinker
                  User::all();
                  php artisan make:scope AncientScope    // сгенерировать новый глобальный диапазон в app/Models/Scopes
              p в файле routes/console.php
              pre
                code.
                  php artisan model:prune   // удаления записей
                  code php artisan model:prune --pretend    // сколько записей будет удалено при выполнении чистки
              p в App\Providers\AppServiceProvider.php
              pre
                code.
                  public function boot(): void {Model::unguard();}    // не указывать fillable в моделях, модели без защиты
                  // генерировать исключение при попытке заполнения значением неподлежащего заполнению атрибута
                  Model::preventSilentlyDiscardingAttributes($this->app->isLocal());
                  // генерировать исключение при попытке назначить значение неподлежащего назначению атрибута
                  Model::preventSilentlyDiscardingAttributes(! $this->app->isProduction());
                  // запретить отложенную загрузку
                  Model::preventLazyLoading(! $this->app->isProduction());
              p в App\Http\Controllers
              pre
                code.
                  - вставить новую запись
                  class FlightController extends Controller
                  {
                    // Сохранить новый рейс в базе данных
                    public function store(Request $request): RedirectResponse {
                      // тут провести валидацию запроса
                      $flight = new Flight;   // создать экземпляр модели
                      $flight->name = $request->name;   // установить атрибуты модели
                      $flight->save();    // сохранить запись (экземпляр модели)
                      return redirect('/flights');
                    }}
                  либо
                  // при свойстве fillable или guarded в классе модели
                  $flight = Flight::create(['name' => 'London to Paris']);
                  - выполнять операцию с моделью, не изменяя ее метку времени в updated_at
                  Model::withoutTimestamps(fn () => $post->increment('reads'));
                  - получить все записи из связанной с моделью таблицы БД
                  foreach (Flight::all() as $flight) {echo $flight->name;}
                  - построить запрос с дополнительными условиями
                  $flights = Flight::where('active', 1)->orderBy('name')->take(10)->get();
                  - повторно извлечь модель из БД
                  $flight = Flight::where('number', 'FR 900')->first();
                  $freshFlight = $flight->fresh();
                  - повторно обновить существующую модель
                  $flight = Flight::where('number', 'FR 900')->first();
                  $flight->number = 'FR 456';
                  $flight->refresh();
                  $flight->number; // "FR 900"
                  - получить запись
                  $flight = Flight::find(1);    // по ее первичному ключу
                  $flight = Flight::where('active', 1)->first();    // первую соответствующую условиям запроса
                  либо
                  $flight = Flight::firstWhere('active', 1);
                  - если запись не найдена, то вернуть функцию
                  $flight = Flight::findOr(1, function () {});
                  $flight = Flight::where('legs', '>', 3)->firstOr(function () {});
                  - если запись не найдена, то вернуть исключение
                  $flight = Flight::findOrFail(1);
                  $flight = Flight::where('legs', '>', 3)->firstOrFail();
                  либо
                  Route::get('/api/flights/{id}', function (string $id) {return Flight::findOrFail($id);});
                  - если запись не найдена, то создать новую
                  $flight = Flight::firstOrCreate(['name' => 'London to Paris']);   // получить запись по `name` или создать
                  либо
                  $flight = Flight::firstOrNew(['name' => 'London to Paris']);
                  // получить запись по `name` или создать с атрибутами `name`,` delayed` и `arrival_time`
                  $flight = Flight::firstOrCreate(['name' => 'London to Paris'], ['delayed' => 1, 'arrival_time' => '11:30']);
                  либо
                  $flight = Flight::firstOrNew(['name' => 'Tokyo to Sydney'], ['delayed' => 1, 'arrival_time' => '11:30']);
                  $flight->save()   // сохраненить вручную
                  - возвращают соответствующее скалярное значение вместо экземпляра модели
                  $count = Flight::where('active', 1)->count();
                  $max = Flight::where('active', 1)->max('price');
                  - обновить запись
                  $flight = Flight::find(1);
                  $flight->name = 'Paris to London';
                  $flight->save();
                  - обновить или создать новую запись
                  $flight = Flight::updateOrCreate(['departure' => 'Oakland', 'destination' => 'San Diego'], ['price' => 99, 'discounted' => 1]);
                  - все рейсы с пунктом назначения в Сан-Диего, будут помечены как задержанные
                  Flight::where('active', 1)->where('destination', 'San Diego')->update(['delayed' => 1]);  // update возвращает количество затронутых строк
                  - обновление или создание записей за одну операцию
                  Flight::upsert([    // столбцы второго аргумента должны иметь “primary” или “unique” индекс
                      ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
                      ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
                  ], uniqueBy: ['departure', 'destination'], update: ['price']);
                  - изменения атрибутов
                  $user = User::create(['first_name' => 'Taylor', 'last_name' => 'Otwell', 'title' => 'Developer']);
                  $user->title = 'Painter';
                  $user->save();
                  // было ли изменение с момента получения модели
                  $user->isDirty(); // true
                  $user->isDirty('title'); // true
                  $user->isDirty('first_name'); // false
                  $user->isDirty(['first_name', 'title']); // true
                  // остался ли атрибут неизменным с момента получения модели
                  $user->isClean(); // false
                  $user->isClean('title'); // false
                  $user->isClean('first_name'); // true
                  $user->isClean(['first_name', 'title']); // false
                  $user->isDirty(); // false
                  $user->isClean(); // true
                  // были ли изменены какие-либо атрибуты при последнем сохранении модели в текущем цикле запроса
                  $user->wasChanged(); // true
                  $user->wasChanged('title'); // true
                  $user->wasChanged(['title', 'slug']); // true
                  $user->wasChanged('first_name'); // false
                  $user->wasChanged(['first_name', 'title']); // true
                  // возвращает массив, содержащий исходные атрибуты модели
                  $user = User::find(1);
                  $user->name; // John
                  $user->email; // john@example.com
                  $user->name = "Jack";
                  $user->name; // Jack
                  $user->getOriginal('name'); // John
                  $user->getOriginal(); // массив исходных атрибутов
                  - удалить запись
                  $flight = Flight::find(1);
                  $flight->delete();
                  - удалить все записи таблицы
                  Flight::truncate();
                  - удаление записи по ключу
                  Flight::destroy(1);
                  Flight::destroy(1, 2, 3);
                  Flight::destroy([1, 2, 3]);
                  Flight::destroy(collect([1, 2, 3]));
                  - удаление записи через запрос с условием
                  $deleted = Flight::where('active', 0)->delete();
                  - была ли данная запись программно удалена
                  if ($flight->trashed()) { }
                  - восстановить программно удаленную запись
                  $flight->restore();
                  либо
                  Flight::withTrashed()->where('airline_id', 1)->restore();
                  либо
                  $flight->history()->restore();  
                  - окончательно удалить запись
                  Flight::forceDestroy(1);
                  либо
                  $flight->forceDelete();
                  либо
                  $flight->history()->forceDelete();
                  - отобразить программно удаленные записи в результате запроса
                  $flights = Flight::withTrashed()->where('account_id', 1)->get();
                  либо
                  $flight->history()->withTrashed()->get();
                  - отобразить только программно удаленные записи
                  $flights = Flight::onlyTrashed()->where('airline_id', 1)->get();
              p в App\Models
              pre
                code.
                  - указать имя таблицы модели вручную
                  class Flight extends Model {protected $table = 'my_flights';}
                  - все атрибуты массово-заполняемые, модель без защиты
                  protected $guarded = [];
                  - определить массово-заполняемые атрибуты модели
                  protected $fillable = ['name'];
                  - для JSON-столбцов необходимо указать массово назначаемый ключ для каждого столбца
                  protected $fillable = ['options->enabled'];
                  // вернёт новую запись
                  $flight = Flight::create(['name' => 'London to Paris']);
                  // заполнить запись атрибутами
                  $flight->fill(['name' => 'Amsterdam to Frankfurt']);
                  - указать связи
                  class Employer extends Model
                  {
                    use HasFactory;
                    public function user(): BelongsTo {return $this->belongsTo(User::class);}
                    public function jobs(): HasMany {return $this->hasMany(Job::class);}
                  }
                  - указать первичным ключом не id столбец
                  protected $primaryKey = 'flight_id';
                  - первичный ключ неинкрементный
                  public $incrementing = false;
                  - первичный ключ не целочисленный
                  protected $keyType = 'string';
                  <span>
                  - «Составные» первичные ключи не поддерживаются, можно добавить дополнительные многоколоночные уникальные индексы вместе с первичным ключем таблицы<br>
                  - UUID – уникальные буквенно-цифровые идентификаторы длиной 36 символов<br>
                  - использовать ключ UUID вместо автоинкрементного целочисленного ключа<br>
                  (у таблицы должен быть столбец UUID,т.е. $table->uuid('id'); в миграции)<br>
                  </span>
                  use Illuminate\Database\Eloquent\Concerns\HasUuids;
                  use Illuminate\Database\Eloquent\Model;
                  class Article extends Model {use HasUuids;}
                  // применить в контроллере
                  $article = Article::create(['title' => 'Traveling to Europe']);
                  $article->id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"
                  - переопределить процесс генерации UUID
                  use Ramsey\Uuid\Uuid;
                  public function newUniqueId(): string {return (string) Uuid::uuid4();}
                  public function uniqueIds(): array {return ['id', 'discount_code'];}
                  - ULID имеют длину 26 символов (у таблицы должен быть столбец ULID,т.е. $table->ulid('id'); в миграции)
                  use Illuminate\Database\Eloquent\Concerns\HasUlids;
                  use Illuminate\Database\Eloquent\Model;
                  class Article extends Model {use HasUlids;}
                  // применить в контроллере
                  $article = Article::create(['title' => 'Traveling to Asia']);
                  $article->id; // "01gd4d3tgrrfqeda94gdbtdk5c"
                  - устанавливать значения столбцов created_at и updated_at вручную
                  public $timestamps = false;
                  - задать формат хранения даты в БД и сериализации модели в массив или JSON
                  protected $dateFormat = 'U';
                  - указать имена столбцов хранения временных меток
                  class Flight extends Model
                  {
                    const CREATED_AT = 'creation_date';
                    const UPDATED_AT = 'updated_date';
                  }
                  - указать соединение с БД не по умолчанию для отдельной модели
                  protected $connection = 'mysql';
                  - указать значения атрибутов по умолчанию
                  protected $attributes = [
                    'options' => '[]',    // для JSON столбца
                    'delayed' => false,
                    'status' => 'draft',
                    'view_count' => 0,
                  ];
                  - программное удаление: фактически не удаляются из БД, а устанавливается атрибут deleted_at
                  use Illuminate\Database\Eloquent\SoftDeletes;
                  class Flight extends Model {use SoftDeletes;}
                  - добавить столбец deleted_at в таблицу БД
                  Schema::table('flights', function (Blueprint $table) {$table->softDeletes();});
                  Schema::table('flights', function (Blueprint $table) {$table->dropSoftDeletes();});
                  - удалять данные, которые больше не нужны
                  use Illuminate\Database\Eloquent\Builder;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Prunable;
                  class Flight extends Model
                  {
                    use Prunable;
                    // получите запрос для удаления устаревших записей модели
                    public function prunable(): Builder
                    {return static::where('created_at', '<=', now()->subMonth());}
                  }
                  - метод pruning для удаления любых дополнительных ресурсов, связанных с записью
                  protected function pruning(): void { }
                  Schedule::command('model:prune')->daily();    // автоматически проверять и чистить модели от старых записей в app/Models
                  Schedule::command('model:prune', ['--model' => [Address::class, Flight::class]])->daily();    // если не в app/Models
                  Schedule::command('model:prune', ['--except' => [Address::class, Flight::class],])->daily();    // чистить модели кроме указанных
                  - удаление записей с помощью запросов массового удаления
                  {
                    use MassPrunable;
                    public function prunable(): Builder
                    {return static::where('created_at', '<=', now()->subMonth());}
                  }
                  - создать копию записи
                  $shipping = Address::create([
                    'type' => 'shipping',
                    'line_1' => '123 Example Street',
                    'city' => 'Victorville',
                    'state' => 'CA',
                    'postcode' => '90001',
                  ]);
                  $billing = $shipping->replicate()->fill(['type' => 'billing']);
                  $billing->save();
                  - создать копию записи без указанных атрибутов
                  $flight = Flight::create([
                    'destination' => 'LAX',
                    'origin' => 'LHR',
                    'last_flown' => '2020-03-04 11:00:00',
                    'last_pilot_id' => 747,
                  ]);
                  $flight = $flight->replicate(['last_flown', 'last_pilot_id']);
                  - глобальные диапазоны позволяют добавлять ограничения ко всем запросам для конкретной модели
                  namespace App\Models\Scopes;
                  use Illuminate\Database\Eloquent\Builder;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Scope;
                  class AncientScope implements Scope
                  {
                    // Применить диапазон к переданному построителю запросов
                    public function apply(Builder $builder, Model $model): void
                    {$builder->where('created_at', '<', now()->subYears(2000));}
                  }
                  // применить глобальный диапазон к модели
                  namespace App\Models;
                  use App\Models\Scopes\AncientScope;
                  use Illuminate\Database\Eloquent\Attributes\ScopedBy;
                  #[ScopedBy([AncientScope::class])]
                  class User extends Model { }
                  либо
                  namespace App\Models;
                  use App\Models\Scopes\AncientScope;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model
                  {
                    // Метод «booted» модели
                    protected static function booted(): void
                    {static::addGlobalScope(new AncientScope);}
                  }
                  // User::all() вернёт
                  select * from `users` where `created_at` < 0021-02-18 00:00:00
                  // создать глобальный диапозон без класса через функцию
                  class User extends Model {
                    protected static function booted(): void {
                      static::addGlobalScope('ancient', function (Builder $builder) {
                        $builder->where('created_at', '<', now()->subYears(2000));
                      });
                    }}
                  // исключения глобального диапазона в текущем запросе
                  User::withoutGlobalScope(AncientScope::class)->get();
                  либо
                  User::withoutGlobalScope('ancient')->get();
                  либо
                  User::withoutGlobalScopes()->get();   // игнорировать все глобальные диапазоны
                  User::withoutGlobalScopes([FirstScope::class, SecondScope::class])->get();    // игнорировать некоторые глобальные диапазоны
                  - чтобы определить локальный диапазон - добавить к методу префикс scope
                  class User extends Model {
                    // диапазон запроса, включающий только популярных пользователей
                    public function scopePopular(Builder $query): void {$query->where('votes', '>', 100);}
                    // диапазон запроса, включающий только активных пользователей
                    public function scopeActive(Builder $query): void {$query->where('active', 1);}
                    // диапазон запроса, включающий пользователей только определенного типа
                    public function scopeOfType(Builder $query, string $type): void {$query->where('type', $type);}
                  }
                  // вызвать метод при выполнении запроса
                  use App\Models\User;
                  $users = User::popular()->active()->orderBy('created_at')->get();
                  либо
                  $users = User::popular()->orWhere(function (Builder $query) {$query->active();})->get();
                  либо
                  $users = User::popular()->orWhere->active()->get();
                  либо
                  $users = User::ofType('admin')->get();
                  - сравнение моделей
                  if ($post->is($anotherPost)) {}
                  if ($post->isNot($anotherPost)) {}
                  if ($post->author()->is($user)) {}    // сравнить связанную модель без запроса на получение этой модели

            //- Events
            //- события позволяют использовать хуки жизненного цикла модели
            details
              summary Events
              p.
                - события позволяют использовать хуки жизненного цикла модели: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleting, forceDeleted, restoring, restored и replicating.<br>
                - события, заканчивающиеся на -ing, инициируются до сохранения изменений в модели, а события, заканчивающиеся на -ed, инициируются после сохранения изменений в модели.<br>
                - события saved, updated, deleting, и deleted при массовом обновлении или удалении не будут инициированы<br>
              pre
                code.
                  - прослушивание событий модели
                  namespace App\Models;
                  use App\Events\UserDeleted;
                  use App\Events\UserSaved;
                  use Illuminate\Foundation\Auth\User as Authenticatable;
                  use Illuminate\Notifications\Notifiable;
                  class User extends Authenticatable {
                    use Notifiable;
                    protected $dispatchesEvents = ['saved' => UserSaved::class, 'deleted' => UserDeleted::class];
                  }
                  либо через функции
                  protected static function booted(): void {static::created(function (User $user) {});}   // метод «booted» модели
                  // выполнить слушателя событий модели в фоновом режиме, используя очередь
                  use function Illuminate\Events\queueable;
                  static::created(queueable(function (User $user) {}));
                  - наблюдатель, чтобы сгруппировать слушателей в одном классе
                  php artisan make:observer UserObserver --model=User   // создать наблюдателя в app/Observers
                  namespace App\Observers;
                  use App\Models\User;
                  class UserObserver
                  {
                    public function created(User $user): void {}    // обработать событие «created»
                    public function updated(User $user): void {}    // обработать событие «updated»
                    public function deleted(User $user): void {}    // обработать событие «deleted»
                    public function restored(User $user): void {}   // обработать событие «restored»
                    public function forceDeleted(User $user): void {}   // обработать событие «forceDeleted»
                  }
                  // наблюдатель выполнит свои обработчики событий только после фиксирования транзакции БД
                  use Illuminate\Contracts\Events\ShouldHandleEventsAfterCommit;
                  class UserObserver implements ShouldHandleEventsAfterCommit
                  {public function created(User $user): void { }}
                  // регистрации наблюдателя
                  use App\Observers\UserObserver;
                  use Illuminate\Database\Eloquent\Attributes\ObservedBy;
                  #[ObservedBy([UserObserver::class])]
                  class User extends Authenticatable {}
                  либо в App\Providers\AppServiceProvider
                  use App\Models\User;
                  use App\Observers\UserObserver;
                  public function boot(): void {User::observe(UserObserver::class);}
                  - заглушить все события, запускаемые моделью
                  $user = User::withoutEvents(function () {
                    User::findOrFail(1)->delete();
                    return User::find(2);
                  });
                  - операции с моделью, не вызывая никаких событий
                  $user = User::findOrFail(1);
                  $user->name = 'Victoria Faith';
                  $user->saveQuietly();
                  $user->deleteQuietly();
                  $user->forceDeleteQuietly();
                  $user->restoreQuietly();

            //- Collections
            //- коллекции - это итераторы, которые можно перебирать как массив
            details 
              summary Collections
              a(href="http://github.com/Mezuno/laravel-collections-doc") Collections
              p коллекции - это итераторы, которые можно перебирать как массив
              pre
                code.
                  use App\Models\User;
                  $users = User::where('active', 1)->get();
                  foreach ($users as $user) {echo $user->name;}
                  - коллекции поддерживают map и reduce
                  $names = User::all()->reject(function (User $user) {return $user->active === false;})
                    ->map(function (User $user) {return $user->name;});
              p.
                - все коллекции Eloquent расширяют базовый класс коллекций Laravel<br>
                - методы collapse, flatten, flip, keys, pluck, и zip возвращают экземпляр базовой коллекции<br>
                - коллекции Eloquent наследуют все методы класса базовой коллекции и содержит расширенный набор методов<br>
              pre
                code.
                  $users->append('team');   // указать, что атрибут должен быть добавлен к каждой записи в коллекции
                  либо
                  $users->append(['team', 'is_admin']);
                  $users->contains(1);    // содержится ли запись в коллекции
                  либо
                  $users->contains(User::find(1));
                  $users = $users->diff(User::whereIn('id', [1, 2, 3])->get());   // возвращает все записи, которых нет в переданной коллекции
                  $users = $users->except([1, 2, 3]);   // озвращает все записи, у которых нет указанных первичных ключей
                  $users = User::all();   // возвращает запись по указанному ключу
                  $user = $users->find(1);
                  $users = User::all();   // возвращает запись по указанному ключу или исключение
                  $user = $users->findOrFail(1);
                  $users = $users->fresh();   // возвращает обновлённые записи
                  $users = $users->fresh('comments');   // возвращает обновлённые записи с отношением
                  $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());  // возвращает записи, которые присутствуют в указанной коллекции
                  $users->load(['comments', 'posts']);    // загружает указанные отношения для всех записей в коллекции
                  $users->load('comments.author');
                  $users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
                  $users->loadMissing(['comments', 'posts']);   // загружает ещё незагруженные отношения для всех записей в коллекции
                  $users->loadMissing('comments.author');
                  $users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
                  $users->modelKeys();    // возвращает первичные ключи для всех записей в коллекции [1, 2, 3, 4, 5]
                  $users = $users->makeVisible(['address', 'phone_number']);    // делает видимыми скрытые атрибуты записей из коллекции
                  $users = $users->makeHidden(['address', 'phone_number']);   // делает скрытыми атрибуты записей из коллекции
                  $users = $users->only([1, 2, 3]);   // возвращает все записи с указанными первичными ключами
                  $users = $users->setVisible(['id', 'name']);    // временно переопределяет видимые атрибуты для каждой записи в коллекции
                  // временно переопределяет скрытые атрибуты для каждой записи в коллекции
                  $users = $users->setHidden(['email', 'password', 'remember_token']);
                  // возвращает экземпляр построителя запросов
                  use App\Models\User;
                  $users = User::where('status', 'VIP')->get();
                  $users->toQuery()->update(['status' => 'Administrator']);
                  // возвращает уникальные записи в коллекции
                  $users = $users->unique();
                  - удаления записей из полученной коллекции
                  $flights = Flight::where('destination', 'Paris')->get();
                  $flights = $flights->reject(function (Flight $flight) {return $flight->cancelled;});
                  - перебирать коллекции
                  foreach ($flights as $flight) {echo $flight->name;}
                  - получать коллекцию записей частями
                  use App\Models\Flight;
                  use Illuminate\Database\Eloquent\Collection;
                  // 200 - количество записей за «порцию» к каждой порции применяется function (Collection $flights) {}
                  Flight::chunk(200, function (Collection $flights) {foreach ($flights as $flight) { }});
                  // извлекать записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
                  Flight::where('departed', true)->chunkById(200, function (Collection $flights) {
                    $flights->each->update(['departed' => false]);}, column: 'id');
                  // логическая группировка в запросе
                  Flight::where(function ($query) {$query->where('delayed', true)->orWhere('cancelled', true);})
                    ->chunkById(200, function (Collection $flights) {
                    $flights->each->update(['departed' => false, 'cancelled' => true]);}, column: 'id');
                  - lazy() возвращает каждую порцию записей как отдельную коллекцию
                  foreach (Flight::lazy() as $flight) { }
                  // lazyById извлекает записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
                  Flight::where('departed', true)->lazyById(200, column: 'id')->each->update(['departed' => false]);
                  // lazyByIdDesc - отфильтровать результаты по убыванию id
                  - при использовании cursor будет только один запрос к БД и только одна модель хранится в памяти в любой момент времени при итерации
                  foreach (Flight::where('destination', 'Zurich')->cursor() as $flight) { }
                  либо
                  $users = User::cursor()->filter(function (User $user) {return $user->id > 500;});
                  foreach ($users as $user) {echo $user->id;}
                  - извлечь информацию из связанных таблиц в одном запросе
                  // выбрал все пункты назначения и рейсы, которые прибыли последними в этот пункт назначения
                  use App\Models\Destination;
                  use App\Models\Flight;
                  return Destination::addSelect(['last_flight' => Flight::select('name')->whereColumn('destination_id', 'destinations.id')
                    ->orderByDesc('arrived_at')->limit(1)])->get();
                  // отсортировал пункты назначения по последнему рейсу
                  return Destination::orderByDesc(Flight::select('arrived_at')->whereColumn('destination_id', 'destinations.id')
                    ->orderByDesc('arrived_at')->limit(1))->get();
                  - использовать собственный объект Collection
                  namespace App\Models;
                  use App\Support\UserCollection;
                  use Illuminate\Database\Eloquent\Attributes\CollectedBy;
                  use Illuminate\Database\Eloquent\Model;
                  #[CollectedBy(UserCollection::class)]
                  class User extends Model { }
                  // либо
                  namespace App\Models;
                  use App\Support\UserCollection;
                  use Illuminate\Database\Eloquent\Collection;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model
                  {
                    public function newCollection(array $models = []): Collection
                    {return new UserCollection($models);}
                  }
            
            //- Accessors
            //- преобразует значения столбца таблицы при обращении к нему
            details 
              summary Accessors
              p Аксессор преобразует значение столбца таблицы (атрибута модели) при обращении к нему.<br>
              pre
                code.
                  - аксессор для атрибута first_name
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Casts\Attribute;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model {
                    protected function firstName(): Attribute {
                      // конструктор класса Attribute
                      return Attribute::make(get: fn (string $value) => ucfirst($value));   // способ доступа к атрибуту
                    }}
                  // получить доступ к значению аксессора
                  use App\Models\User;
                  $user = User::find(1);
                  $firstName = $user->first_name;
                  - преобразовать несколько атрибутов модели в один “объект-значение” (value object)
                  use App\Support\Address;
                  use Illuminate\Database\Eloquent\Casts\Attribute;
                  protected function address(): Attribute {
                    return Attribute::make(
                      get: fn (mixed $value, array $attributes) => new Address($attributes['address_line_one'], $attributes['address_line_two']),
                    );}
                  // При возвращении объектов-значений из аксессоров любые изменения, внесенные в объект-значение, автоматически синхронизируются с моделью перед ее сохранением.
                  use App\Models\User;
                  $user = User::find(1);
                  $user->address->lineOne = 'Updated Address Line 1 Value';
                  $user->address->lineTwo = 'Updated Address Line 2 Value';
                  $user->save();
                  - включить кэширование для примитивных значений
                  protected function hash(): Attribute
                  {return Attribute::make(get: fn (string $value) => bcrypt(gzuncompress($value)))->shouldCache();}
                  // отключить кэширование для атрибутов
                  protected function address(): Attribute
                  {return Attribute::make(get: fn (mixed $value, array $attributes) => new Address(
                    $attributes['address_line_one'], $attributes['address_line_two']))->withoutObjectCaching();
                  }

            //- Mutators
            //- преобразует значения при записи в столбец таблицы
            details 
              summary Mutators
              p Мутатор преобразует значение атрибута в момент его присвоения экземпляру Eloquent.
              pre
                code.
                  - мутатор для атрибута first_name
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Casts\Attribute;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model {
                    {return Attribute::make(get: fn (string $value) => ucfirst($value), set: fn (string $value) => strtolower($value));}}
                  // использовать мутатор
                  use App\Models\User;
                  $user = User::find(1);
                  // мутатор применит к 'Sally' функцию strtolower и установит полученное значение во внутреннем массиве $attributes
                  $user->first_name = 'Sally';
                  - установить несколько атрибутов в модели
                  use App\Support\Address;
                  use Illuminate\Database\Eloquent\Casts\Attribute;
                  protected function address(): Attribute
                  {return Attribute::make(
                    get: fn (mixed $value, array $attributes) => new Address($attributes['address_line_one'], $attributes['address_line_two']),
                    set: fn (Address $value) => ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo]);}

            //- Typing
            //- типизация значений столбца таблицы
            details 
              summary Typing
              a(href="http://laravel.su/docs/12.x/eloquent-mutators#privedenie-atributov-k-tipam") Поддерживаемые типы преобразования
              p.
                - Приведение атрибутов к типам обеспечивает функциональность, аналогичную аксессорам и мутаторам, но без необходимости определения каких-либо дополнительных методов модели.<br>
                - Метод casts должен возвращать массив, где ключом является имя приводимого атрибута, а значением — тип, к которому нужно привести столбец.<br>
              pre
                code.
                  - привести атрибут is_admin из значения 0 или 1 к логическому типу
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model {protected function casts(): array {return ['is_admin' => 'boolean'];}}
                  // применение атрибута (базовое значение хранится в базе данных как целое число)
                  $user = App\Models\User::find(1);
                  if ($user->is_admin) { }
                  // добавить новое временное приведение во время выполнения
                  $user->mergeCasts(['is_admin' => 'integer', 'options' => 'object']);
                  - преобразование в строку
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Casts\AsStringable;
                  class User extends Model {protected function casts(): array {return ['directory' => AsStringable::class];}}
                  - столбцы типа JSON или TEXT (содержащее сериализованный JSON) при типизации к array,
                    автоматически десериализует атрибут модели Eloquent в массив PHP
                  class User extends Model {protected function casts(): array {return ['options' => 'array'];}}
                  // при назначении атрибута options, массив будет автоматически сериализован обратно в JSON для сохранения
                  use App\Models\User;
                  $user = User::find(1);
                  $options = $user->options;
                  $options['key'] = 'value';
                  $user->options = $options;
                  $user->save();
                  // обновить одно поле JSON-атрибута (разрешить массовое назначение)
                  $user = User::find(1);
                  $user->update(['options->key' => 'value']);
                  // преобразовать атрибут JSON в класс ArrayObject
                  use Illuminate\Database\Eloquent\Casts\AsArrayObject;
                  protected function casts(): array {return ['options' => AsArrayObject::class];}
                  // преобразовать атрибут JSON в экземпляр Laravel Collection
                  use Illuminate\Database\Eloquent\Casts\AsCollection;
                  protected function casts(): array {return ['options' => AsCollection::class];}
                  - создать экземпляр пользовательского класса коллекции вместо базового
                  use App\Collections\OptionCollection;
                  use Illuminate\Database\Eloquent\Casts\AsCollection;
                  protected function casts(): array
                  {return ['options' => AsCollection::using(OptionCollection::class)];}
                  - типизация даты
                  protected function casts(): array {return ['created_at' => 'datetime:Y-m-d'];}
                  // настроить формат сериализации по умолчанию
                  protected function serializeDate(DateTimeInterface $date): string
                  {return $date->format('Y-m-d');}
                  // столбцы created_at и updated_at всегда форматируются в формате UTC, независимо от настроек часового пояса приложения
                  // указать формат сохранения дат модели в базе данных
                  protected $dateFormat = 'U';
                  - Типизация "Enum"
                  - преобразовать значение атрибута в перечисление PHP
                  use App\Enums\ServerStatus;
                  protected function casts(): array {return ['status' => ServerStatus::class];}
                  // атрибут будет автоматически преобразован в перечисление и обратно
                  if ($server->status == ServerStatus::Provisioned) {
                    $server->status = ServerStatus::Ready;
                    $server->save();
                  }
                  - массив значений перечисления в одном столбце
                  use App\Enums\ServerStatus;
                  use Illuminate\Database\Eloquent\Casts\AsEnumCollection;
                  protected function casts(): array
                  {return ['statuses' => AsEnumCollection::of(ServerStatus::class)];}
                  - приведение encrypted зашифрует значение атрибута модели
                  // при изменении ключа в переменной окружения APP_KEY придется вручную повторно зашифровать зашифрованные атрибуты
                  - типизация во время запроса
                  use App\Models\Post;
                  use App\Models\User;
                  $users = User::select(['users.*', 'last_posted_at' => Post::selectRaw('MAX(created_at)')
                    ->whereColumn('user_id', 'users.id')])->get();
                  // применить типизацию datetime к last_posted_at при выполнении запроса
                  $users = User::select(['users.*', 'last_posted_at' => Post::selectRaw('MAX(created_at)')
                    ->whereColumn('user_id', 'users.id')])->withCasts(['last_posted_at' => 'datetime'])->get();
              p создать свой преобразователь типов
              pre
                code.
                  php artisan make:cast Json
                  // get - преобразует “сырое” значения из БД к типизированному значению
                  // set – преобразует типизированное значение в “сырое” значение, которое можно сохранить в базе данных
                  namespace App\Casts;
                  use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
                  use Illuminate\Database\Eloquent\Model;
                  class Json implements CastsAttributes {
                    public function get(Model $model, string $key, mixed $value, array $attributes): array
                    {return json_decode($value, true);}
                    public function set(Model $model, string $key, mixed $value, array $attributes): string
                    {return json_encode($value);}}
                  // применение
                  namespace App\Models;
                  use App\Casts\Json;
                  use Illuminate\Database\Eloquent\Model;
                  class User extends Model {protected function casts(): array {return ['options' => Json::class];}}
                  // преобразовать значения к объектам - set возвращает массив пар ключ / значение
                  namespace App\Casts;
                  use App\ValueObjects\Address as AddressValueObject;
                  use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
                  use Illuminate\Database\Eloquent\Model;
                  use InvalidArgumentException;
                  class Address implements CastsAttributes {
                    public function get(Model $model, string $key, mixed $value, array $attributes): AddressValueObject
                    {return new AddressValueObject($attributes['address_line_one'], $attributes['address_line_two']);}
                    public function set(Model $model, string $key, mixed $value, array $attributes): array
                      {if (! $value instanceof AddressValueObject) {
                        throw new InvalidArgumentException('The given value is not an Address instance.');}
                      return ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo];}}
                  // применение
                  use App\Models\User;
                  $user = User::find(1);
                  $user->address->lineOne = 'Updated Address Value';
                  $user->save();
                  // атрибуты приведеные к объектам значений кэшируются автоматически
                  // отключить кэширование объектов в пользовательском классе приведения
                  class Address implements CastsAttributes {public bool $withoutObjectCaching = true;}
                  // при преобразовании таблицы в массив или JSON с использованием методов toArray и toJson,
                  // объекты-значения будут сериализованы автоматически, если типизаторы реализуют интерфейсы Illuminate\Contracts\Support\Arrayable и JsonSerializable
                  // сериализовать вручную в пользовательском типизаторе
                  public function serialize(Model $model, string $key, mixed $value, array $attributes): string
                  {return (string) $value;}
                  - сгенерировать класс приведения только для входящих значений (только преобразует указанные значения атрибутов модели)
                  php artisan make:cast Hash --inbound
                  // типизатор хеширует входящие значения с использованием указанного алгоритма
                  namespace App\Casts;
                  use Illuminate\Contracts\Database\Eloquent\CastsInboundAttributes;
                  use Illuminate\Database\Eloquent\Model;
                  class Hash implements CastsInboundAttributes {
                    public function __construct(protected string|null $algorithm = null) {}
                    public function set(Model $model, string $key, mixed $value, array $attributes): string
                      {return is_null($this->algorithm) ? bcrypt($value) : hash($this->algorithm, $value);}}
                  // параметры типизатора задаются с помощью символа : через запятую
                  protected function casts(): array
                  {return ['secret' => Hash::class.':sha256'];}
                  - определить класс типизатора в объекте-значения
                  // возвращает имя пользовательского класса типизатора
                  namespace App\ValueObjects;
                  use Illuminate\Contracts\Database\Eloquent\Castable;
                  use App\Casts\Address as AddressCast;
                  class Address implements Castable {
                    public static function castUsing(array $arguments): string{return AddressCast::class;}}
                  // применение
                  use App\ValueObjects\Address;
                  protected function casts(): array {return ['address' => Address::class.':argument'];}
                  // либо
                  namespace App\ValueObjects;
                  use Illuminate\Contracts\Database\Eloquent\Castable;
                  use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
                  class Address implements Castable {
                    public static function castUsing(array $arguments): CastsAttributes {
                      return new class implements CastsAttributes{
                        public function get(Model $model, string $key, mixed $value, array $attributes): Address
                        {return new Address($attributes['address_line_one'], $attributes['address_line_two']);}
                        public function set(Model $model, string $key, mixed $value, array $attributes): array
                        {return ['address_line_one' => $value->lineOne, 'address_line_two' => $value->lineTwo];}
                      };}}

            //- Api resources
            details 
              summary Api resources

              //- Resource classes
              //- классы ресурсов Eloquent преобразуют модель в массив
              details 
                summary Resource classes
                p классы ресурсов Eloquent преобразуют модель в массив
                pre
                  code.
                    - сгенерировать новый ресурс модели
                    php artisan make:resource UserResource
                    - класс ресурса
                    namespace App\Http\Resources;
                    use Illuminate\Http\Request;
                    use Illuminate\Http\Resources\Json\JsonResource;
                    class UserResource extends JsonResource
                    {public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}}
                    // вернуть ресурс из маршрута или контроллера (массив ресурса будет преобразован в JSON)
                    use App\Http\Resources\UserResource;
                    use App\Models\User;
                    Route::get('/user/{id}', function (string $id) {return new UserResource(User::findOrFail($id));});
                    // для возврата коллекции ресурса или ответа с постраничной разбивкой
                      экземпляр пагинатора можно передать методу collection ресурса или коллекции ресурса
                    Route::get('/users', function () {return UserResource::collection(User::all());});
                    - включить связанные ресурсы в ответ: добавить посты пользователя в ответ ресурса
                    use App\Http\Resources\PostResource;
                    use Illuminate\Http\Request;
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        'posts' => PostResource::collection($this->posts),
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}
                p ответ ресурса после возврата из маршрута или контроллера (преобразован в JSON)
                pre
                  code.
                    - верхний ресурс обёрнут в ключ data
                    {
                      "data": [
                        {
                          "id": 1,
                          "name": "Eladio Schroeder Sr.",
                          "email": "therese28@example.com"
                        },
                        {
                          "id": 2,
                          "name": "Liliana Mayert",
                          "email": "evandervort@example.com"
                        }
                      ]
                    }
                    - отключить обертывание верхнего ресурса
                    namespace App\Providers;
                    use Illuminate\Http\Resources\Json\JsonResource;
                    use Illuminate\Support\ServiceProvider;
                    class AppServiceProvider extends ServiceProvider
                    {
                      public function register(): void { }
                      public function boot(): void {JsonResource::withoutWrapping();}
                    }
                    - разбитые на страницы ответы всегда содержат ключи meta и links с информацией о состоянии постраничной разбивки,
                      поэтому Laravel обернет данные ресурса в ключ data, даже если был вызван метод withoutWrapping
                    {
                      "data": [
                          {
                            "id": 1,
                            "name": "Eladio Schroeder Sr.",
                            "email": "therese28@example.com"
                          },
                          {
                            "id": 2,
                            "name": "Liliana Mayert",
                            "email": "evandervort@example.com"
                          }
                      ],
                      "links":{
                        "first": "http://example.com/users?page=1",
                        "last": "http://example.com/users?page=1",
                        "prev": null,
                        "next": null
                      },
                      "meta":{
                        "current_page": 1,
                        "from": 1,
                        "last_page": 1,
                        "path": "http://example.com/users",
                        "per_page": 15,
                        "to": 10,
                        "total": 10
                      }
                    }
                    // настроить информацию, включаемую в ключи links или meta ответа пагинации
                    public function paginationInformation($request, $paginated, $default)
                    {
                      $default['links']['custom'] = 'https://example.com';
                      return $default;
                    }
                    - включить атрибут в ответ ресурса, по условию
                    // включить в ответ значение 'secret-value', только если текущий пользователь администратор
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        'secret' => $this->when($request->user()->isAdmin(), 'secret-value'),
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}
                    либо вычислить результирующее значение, только если переданное условие истинно
                    'secret' => $this->when($request->user()->isAdmin(), function () {return 'secret-value';}),
                    // включение атрибута, если он присутствует в модели
                    'name' => $this->whenHas('name')
                    // включение атрибута в ответ ресурса, если атрибут не равен null
                    'name' => $this->whenNotNull($this->name)
                    // несколько атрибутов при одном и том же условии
                      (ключи должны быть одного типа (string, int),цифровые ключи должны быть упорядочены)
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        $this->mergeWhen($request->user()->isAdmin(), ['first-secret' => 'value', 'second-secret' => 'value']),
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}
                    // включать отношения в ответ ресурса если отношение уже загружено в модель
                      (позволяет избежать проблем «N+1» с запросами в ресурсах)
                    // ключ posts будет удален из ответа ресурса, если отношение не было загружено
                    use App\Http\Resources\PostResource;
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        'posts' => PostResource::collection($this->whenLoaded('posts')),
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}
                    // включить счетчик отношений в ответ ресурса, если счетчик отношений был загружен в модели
                    new UserResource($user->loadCount('posts'));
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'email' => $this->email,
                        'posts_count' => $this->whenCounted('posts'),
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                      ];}
                    // условная загрузка агрегатов avg, sum, min и max
                    'words_avg' => $this->whenAggregated('posts', 'words', 'avg'),
                    'words_sum' => $this->whenAggregated('posts', 'words', 'sum'),
                    'words_min' => $this->whenAggregated('posts', 'words', 'min'),
                    'words_max' => $this->whenAggregated('posts', 'words', 'max'),
                    // включать данные из сводных таблиц отношений «многие ко многим» по условию
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        // 'role_user' - имя сводной таблицы
                        'expires_at' => $this->whenPivotLoaded('role_user', function () {
                          return $this->pivot->expires_at;
                        }),
                      ];}
                    либо экземпляр модели сводной таблицы в качестве первого аргумента
                    'expires_at' => $this->whenPivotLoaded(new Membership, function () {
                      return $this->pivot->expires_at;
                    }),
                    // если сводная таблица использует аксессор
                    public function toArray(Request $request): array {
                      return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'expires_at' => $this->whenPivotLoadedAs('subscription', 'role_user', function () {
                          return $this->subscription->expires_at;
                        }),
                      ];}
                    - включить в ответ самого верхнего русурса массив метаданных
                    namespace App\Http\Resources;
                    use Illuminate\Http\Resources\Json\ResourceCollection;
                    class UserCollection extends ResourceCollection
                    {
                      public function toArray(Request $request): array {return parent::toArray($request);}
                      public function with(Request $request): array {return ['meta' => ['key' => 'value']];}
                    }
                    // добавить данные верхнего уровня при создании экземпляров ресурсов в маршруте или контроллере
                    return (new UserCollection(User::all()->load('roles')))->additional(['meta' => ['key' => 'value',]]);
                    - метод response связанный с ресурсом, вернет экземпляр Illuminate\Http\JsonResponse, 
                      что даст полный контроль над заголовками HTTP-ответа
                    use App\Http\Resources\UserResource;
                    use App\Models\User;
                    Route::get('/user', function () {
                      return (new UserResource(User::find(1)))->response()->header('X-Value', 'True');});
                    либо определить метод withResponse внутри самого ресурса, если ресурс самый верхний в ответе
                    namespace App\Http\Resources;
                    use Illuminate\Http\JsonResponse;
                    use Illuminate\Http\Request;
                    use Illuminate\Http\Resources\Json\JsonResource;
                    class UserResource extends JsonResource {
                      public function toArray(Request $request): array {return ['id' => $this->id];}
                      public function withResponse(Request $request, JsonResponse $response): void
                      {$response->header('X-Value', 'True');}}

              //- Resource collections
              //- добавить метаданные в ответ, преобразовать коллекцию моделей в массив
              details 
                summary Resource collections
                p.
                  - коллекции ресурса, позволяет определить любые метаданные, которые должны быть включены в ответ<br>
                  - коллекции ресурса преобразуют коллекцию моделей в массив<br>
                  - каждый элемент коллекции сопостовляется с его единственным классом ресурсов<br>
                  - единственным классом ресурса является коллекции UserCollection может быть либо класс User либо класс UserResource<br>
                pre
                  code.
                    php artisan make:resource User --collection   // сгенерировать новую коллекцию ресурса
                    либо
                    php artisan make:resource UserCollection
                    - класс коллекции ресурса
                    namespace App\Http\Resources;
                    use Illuminate\Http\Request;
                    use Illuminate\Http\Resources\Json\ResourceCollection;
                    class UserCollection extends ResourceCollection {
                      public function toArray(Request $request): array
                        {return ['data' => $this->collection, 'links' => ['self' => 'link-value']];}}
                    // вернуть из маршрута или контроллера (массив коллекции будет преобразован в JSON)
                    use App\Http\Resources\UserCollection;
                    use App\Models\User;
                    Route::get('/users', function () {return new UserCollection(User::all());});
                    - сохранять исходные ключи коллекции при возврате из маршрута (по умолчанию меняет на числовые)
                    namespace App\Http\Resources;
                    use Illuminate\Http\Resources\Json\JsonResource;
                    class UserResource extends JsonResource {public $preserveKeys = true;}
                    // вернуть коллекцию ресурса
                    use App\Http\Resources\UserResource;
                    use App\Models\User;
                    Route::get('/users', function () {return UserResource::collection(User::all()->keyBy->id);});
                    - изменить класс ресурса для коллекции
                    namespace App\Http\Resources;
                    use Illuminate\Http\Resources\Json\ResourceCollection;
                    class UserCollection extends ResourceCollection {public $collects = Member::class;}
                p.
                  - чтобы обернуть все коллекции ресурсов ключом data, независимо от их вложенности<br>
                  нужно определить класс коллекции для каждого ресурса и вернуть коллекцию с ключом data<br>
                pre
                  code.
                    namespace App\Http\Resources;
                    use Illuminate\Http\Resources\Json\ResourceCollection;
                    class CommentsCollection extends ResourceCollection {
                      public function toArray(Request $request): array {return ['data' => $this->collection];}}

              //- Serialization
              details 
                summary Serialization
                p сериализация в массив
                pre
                  code.
                    - преобразовать модель и ее загруженные отношения в массив
                    use App\Models\User;
                    $user = User::with('roles')->first();
                    return $user->toArray();
                    - преобразованиe атрибутов модели в массив
                    $user = User::first();
                    return $user->attributesToArray();
                    - преобразовать коллекции моделей в массивы
                    $users = User::all();
                    return $users->toArray();
                p сериализация в JSON
                pre
                  code.
                    - преобразовать модель и ее загруженные отношения в JSON
                    use App\Models\User;
                    $user = User::find(1);
                    return $user->toJson();
                    return $user->toJson(JSON_PRETTY_PRINT);
                    - преобразование модели или коллекции в строку, автоматически вызовет метод toJson
                    return (string) User::find(1);
                    - Laravel автоматически сериализует модели и коллекции Eloquent в JSON, когда они возвращаются из маршрутов или контроллеров
                    Route::get('/users', function () {return User::all();});
                    - cкрытие атрибутов из JSON
                    namespace App\Models;
                    use Illuminate\Database\Eloquent\Model;
                    class User extends Model {protected $hidden = ['password'];}
                    либо только те, которые видны
                    protected $visible = ['first_name', 'last_name'];
                    // сделать некоторые обычно скрытые атрибуты видимыми на конкретном экземпляре модели
                    return $user->makeVisible('attribute')->toArray();
                    // скрыть некоторые атрибуты, которые обычно видны
                    return $user->makeHidden('attribute')->toArray();
                    // временно переопределить все видимые или скрытые атрибуты
                    return $user->setVisible(['id', 'name'])->toArray();
                    return $user->setHidden(['email', 'password', 'remember_token'])->toArray();
                p добавить атрибуты, которым нет соответствующего столбца в базе данных, при преобразовании моделей в массивы или JSON
                pre
                  code.
                    namespace App\Models;
                    use Illuminate\Database\Eloquent\Casts\Attribute;
                    use Illuminate\Database\Eloquent\Model;
                    class User extends Model
                    {protected function isAdmin(): Attribute {return new Attribute(get: fn () => 'yes');}}
                    - автоматическое добавление аксессора к массиву и JSON-представлению модели
                    namespace App\Models;
                    use Illuminate\Database\Eloquent\Model;
                    class User extends Model {protected $appends = ['is_admin'];}
                    - добавить дополнительные атрибуты во время выполнения скрипта
                    return $user->append('is_admin')->toArray();
                    - переопределить весь массив добавленных свойств для конкретного экземпляра модели
                    return $user->setAppends(['is_admin'])->toArray();
                p сериализация даты
                pre
                  code.
                    - формат сериализации массива/JSON для всех дат модели по умолчанию
                    protected function serializeDate(DateTimeInterface $date): string
                    {return $date->format('Y-m-d');}
                    - настроить формат сериализации отдельных атрибутов даты
                    protected function casts(): array
                    {return ['birthday' => 'date:Y-m-d', 'joined_at' => 'datetime:Y-m-d H:00'];}

            //- Migrations
            //- создают и изменяют таблицы БД
            details
              summary Migrations
              a(href="http://laravel.su/docs/12.x/migrations#dostupnye-psevdonimy-komand") псевдонимы команд
              a(href="http://laravel.su/docs/12.x/migrations#sobytiia") каждая операция миграции отправляет событие
              p.
                - миграции позволяют создавать и изменять таблицы БД<br>
                - сначала выполняются SQL-операторы дампа, потом все оставшиеся миграции, которые не были включены в дамп БД
              pre
                code.
                  php artisan make:migration create_flights_table  // создать миграцию в database/migrations
                  php artisan schema:dump   // «сжать» миграции в один файл SQL
                  php artisan schema:dump --prune  // выгрузить текущий дамп БД в database/schema и удалить все существующие миграции
                  php artisan schema:dump --database=testing --prune    // создать дамп БД с поключением тестов
                  php artisan migrate    // запустить все незавершенные миграции
                  php artisan migrate:status   // узнать какие миграции выполнены
                  php artisan migrate --pretend    // посмотреть SQL-запросы, которые будут выполнены миграциями без запуска миграций
                  php artisan migrate --isolated   // блокировать попытки выполнить команду migrate, пока выполняется текущая
                  php artisan migrate --force    // запуск команды без подтверждения
                  php artisan migrate:rollback   // откатить последнюю миграцию
                  php artisan migrate:rollback --step=5    // откатить ограниченное количество миграций
                  php artisan migrate:rollback --batch=3   // откатить все миграции в третьей партии (партии в таблице migrations)
                  php artisan migrate:reset    // откатить все миграции
                  php artisan migrate:refresh   // откат и миграция одной командой
                  php artisan migrate:refresh --seed    // откатить базу данных и запустить все наполнители БД
                  php artisan migrate:refresh --step=5    // откатить и повторно запустить последние пять миграций
                  php artisan migrate:fresh   // удалить все таблицы из БД и выполнить миграцию
                  php artisan migrate:fresh --seed    // удалить все таблицы из БД и выполнить миграцию с наполнением
                  php artisan migrate:fresh --database=admin    // указать имя соединения с БД, которое следует использовать (имя соединения из конфига)
              p Класс миграции содержит два метода: up для добавления новых таблиц, столбцов или индексов и down для отмены действий up
              pre
                code.
                  - создать таблицу flights
                  use Illuminate\Database\Migrations\Migration;
                  use Illuminate\Database\Schema\Blueprint;
                  use Illuminate\Support\Facades\Schema;
                  return new class extends Migration {
                    public function up(): void {Schema::create('flights', function (Blueprint $table) {
                      $table->id();
                      $table->string('name');
                      $table->string('airline');
                      $table->timestamps();
                    });}
                    public function down(): void {Schema::drop('flights');}};
                  либо
                  use Illuminate\Database\Schema\Blueprint;
                  use Illuminate\Support\Facades\Schema;
                  Schema::create('flights', function (Blueprint $table) {
                    $table->id();
                    $table->string('name');
                    $table->string('email');
                    $table->timestamps();});
                  Schema::table('users', function (Blueprint $table) {$table->integer('votes');});    // обновление существующих таблиц
                  Schema::rename($from, $to);   // переименовать существующую таблицу БД
                  Schema::connection('sqlite')->create('users', function (Blueprint $table) {$table->id();});   // подключение к БД не по умолчанию
                  protected $connection = 'pgsql';    // подключение к БД не по умолчанию
                  if (Schema::hasTable('users')) { }   // таблица `users` существует
                  if (Schema::hasColumn('users', 'email')) { }   // таблица `users` существует и содержит столбец `email`
                  if (Schema::hasIndex('users', ['email'], 'unique')) { }   // таблица `users` существует и имеет уникальный индекс в столбце `email`
                  Schema::create('users', function (Blueprint $table) {$table->engine('InnoDB');});   // механизм хранения таблицы в MariaDB или MySQL
                  // набор символов и кодировка для создаваемой таблицы в MariaDB или MySQL
                  Schema::create('users', function (Blueprint $table) {
                    $table->charset('utf8mb4');
                    $table->collation('utf8mb4_unicode_ci');});
                  // «временная» таблица видна только текущему соединению и удаляется при закрытии соединения
                  Schema::create('calculations', function (Blueprint $table) {$table->temporary();});
                  // комментарий к таблице БД, только в MariaDB, MySQL и PostgreSQL
                  Schema::create('calculations', function (Blueprint $table) {$table->comment('Business calculations');});
                  Schema::drop('users');    // удалить существующую таблицу (внешний ключ в таблице должен иметь явное имя в файлах миграции)
                  либо
                  Schema::dropIfExists('users');
              p столбцы
              a(href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-stolbcov") типы столбцов
              a(href="http://laravel.su/docs/12.x/migrations#modifikatory-stolbca") модификаторы столбцов
              a(href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-indeksov") типы индексов
              a(href="http://laravel.su/docs/12.x/migrations#udalenie-indeksov") удалить индекс
              pre
                code.
                  Schema::table('users', function (Blueprint $table) {$table->string('email')->nullable();});   // может быть NULL
                  $table->json('movies')->default(new Expression('(JSON_ARRAY())'));    // значение столбца по умолчанию
                  // добавить набор столбцов после существующего в MariaDB или MySQL
                  $table->after('password', function (Blueprint $table) {
                    $table->string('address_line1');
                    $table->string('address_line2');
                    $table->string('city');});
                  Schema::table('users', function (Blueprint $table) {$table->string('name', 50)->change();}); // изменить тип и атрибуты столбца
                  // добавить атрибуты unsigned, default и comment
                  Schema::table('users', function (Blueprint $table) {
                    $table->integer('votes')->unsigned()->default(1)->comment('мой комментарий')->change();});
                  Schema::table('users', function (Blueprint $table) {$table->renameColumn('from', 'to');});    // переименование столбца
                  Schema::table('users', function (Blueprint $table) {$table->dropColumn('votes');});   // удалениe столбца
                  либо
                  Schema::table('users', function (Blueprint $table) {$table->dropColumn(['votes', 'avatar', 'location']);});
                  $table->bigIncrements('id')->primary()->change();   // добавить индекс
                  $table->char('postal_code', 10)->unique(false)->change();   // удалить индекс
                  Schema::table('users', function (Blueprint $table) {$table->string('email')->unique();});   // создать индекс при создании столбца
                  $table->unique('email');    // создать индекс на существующем столбце
                  $table->index(['account_id', 'created_at']);   // созданиe составного индекса
                  $table->unique('email', 'unique_email');   // указать имя индекса вручную (второй аргумент)
                  $table->renameIndex('from', 'to')    // переименовать индекс
                  Schema::table('geo', function (Blueprint $table) {$table->dropIndex(['state']);});    // удалить простой индекс `geo_state_index`
                  - создание внешнего ключа (SQLite по умолчанию отключает внешние ключи)
                  Schema::table('posts', function (Blueprint $table) {
                    $table->unsignedBigInteger('user_id');
                    $table->foreign('user_id')->references('id')->on('users');});
                  либо
                  Schema::table('posts', function (Blueprint $table) {$table->foreignId('user_id')->constrained();});
                  // указать имя таблицы и созданного индекса
                  Schema::table('posts', function (Blueprint $table) {
                    $table->foreignId('user_id')->constrained(table: 'users', indexName: 'posts_user_id');});
                  $table->foreignId('user_id')->constrained()->onUpdate('cascade')->onDelete('cascade');    // действие при удалении и при обновлении
                  $table->foreignId('user_id')->nullable()->constrained();    // любые модификаторы перед constrained 
                  // удалить внешний ключ
                  $table->dropForeign('posts_user_id_foreign');   // имя внешнего ключа это имя таблицы, столбца и суффикса _foreign
                  либо
                  $table->dropForeign(['user_id']);
                  // включить или отключить внешний ключ в миграциях
                  Schema::enableForeignKeyConstraints();
                  Schema::disableForeignKeyConstraints();
                  Schema::withoutForeignKeyConstraints(function () { });    // ограничения отключены внутри функции

            //- Seeders
            //- классы наполнителей БД значениями
            details
              summary Seeders
              p классы наполнителей хранятся в database/seeders<br>
              pre
                code.
                  php artisan make:seeder UserSeeder    // сгенерировать новый наполнитель
                  php artisan db:seed   // наполнить БД
                  php artisan db:seed --class=UserSeeder    // указать конкретный класс наполнителя
                  php artisan migrate:fresh --seed    // полная перестройка БД с наполнением
                  php artisan migrate:fresh --seed --seeder=UserSeeder    // указать конкретный класс наполнителя
                  php artisan db:seed --force    // запустить наполнители без подтверждений
                  - вставлять данные в базу данных
                  namespace Database\Seeders;
                  use Illuminate\Database\Seeder;
                  use Illuminate\Support\Facades\DB;
                  use Illuminate\Support\Facades\Hash;
                  use Illuminate\Support\Str;
                  class DatabaseSeeder extends Seeder {
                    public function run(): void {
                      DB::table('users')->insert([
                        'name' => Str::random(10),
                        'email' => Str::random(10).'@example.com',
                        'password' => Hash::make('password'),
                      ]);
                    }}
                  - метод call для запуска других наполнителей
                  public function run(): void {
                    $this->call([
                      UserSeeder::class,
                      PostSeeder::class,
                      CommentSeeder::class,
                    ]);}
                  - отправка событий модели во время выполнения сидов
                  namespace Database\Seeders;
                  use Illuminate\Database\Seeder;
                  use Illuminate\Database\Console\Seeds\WithoutModelEvents;
                  class DatabaseSeeder extends Seeder {
                    use WithoutModelEvents;
                    public function run(): void {$this->call([UserSeeder::class]);}}
                  - Sequence меняет значения полей для каждой итерации цикла создания данных
                  public function run(): void {
                    $tags = Tag::factory(3)->create();
                    Job::factory(20)->hasAttached($tags)
                    ->create(new Sequence(['featured' => false, 'schedule' => 'Full Time'],
                      ['featured' => true, 'schedule' => 'Part Time']));}

            //- Factories
            //- создания большого количества записей в БД
            details 
              summary Factories
              p.
                - фабрики моделей для удобного создания большого количества записей в БД
                - языковой стандарт Faker - параметр faker_locale в config/app.php
              pre
                code.
                  - сгенерировать фабрику для модели User в database/factories с именем UserFactory
                  php artisan make:factory UserFactory
                  // в модели User
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Factories\HasFactory;
                  class User extends Authenticatable {use HasFactory;}
                  - создать фабрику вручную
                  // в модели
                  use Database\Factories\Administration\FlightFactory;
                  protected static function newFactory() {return FlightFactory::new();}
                  // в фабрике
                  use App\Administration\Flight;
                  use Illuminate\Database\Eloquent\Factories\Factory;
                  class FlightFactory extends Factory {protected $model = Flight::class;}
                  - состояние фабрик
                  // изменить значение атрибута в фабрике \Database\Factories\UserFactory
                  use Illuminate\Database\Eloquent\Factories\Factory;
                  public function suspended(): Factory {
                    return $this->state(function (array $attributes) {
                      return ['account_status' => 'suspended'];   // аккаунт пользователя временно приостановлен
                    });}
                  - создать модель без сохранения в базе данных
                  use App\Models\User;
                  $user = User::factory()->make();
                  - создать коллекцию из множества моделей
                  $users = User::factory()->count(3)->make();
                  - применить состояние к модели
                  $users = User::factory()->count(5)->suspended()->make();
                  - переопределить значения по умолчанию для моделей
                  $user = User::factory()->make(['name' => 'Abigail Otwell']);
                  либо
                  $user = User::factory()->state(['name' => 'Abigail Otwell'])->make();
                  - создать модель
                  use App\Models\User;
                  // Создаем один экземпляр `App\Models\User`
                  $user = User::factory()->create();
                  // Создаем три экземпляра `App\Models\User`
                  $users = User::factory()->count(3)->create();
                  // переопределить атрибуты модели по умолчанию
                  $user = User::factory()->create(['name' => 'Abigail']);
                  // чередовать значение атрибута для каждой создаваемой модели
                  use App\Models\User;
                  use Illuminate\Database\Eloquent\Factories\Sequence;
                  $users = User::factory()->count(10)->state(new Sequence(['admin' => 'Y'], ['admin' => 'N']))->create();
                  либо
                  use Illuminate\Database\Eloquent\Factories\Sequence;
                  $users = User::factory()->count(10)->state(new Sequence(
                    fn (Sequence $sequence) => ['role' => UserRoles::all()->random()]))->create();
                  либо
                  $users = User::factory()->count(10)
                    ->sequence(fn (Sequence $sequence) => ['name' => 'Name '.$sequence->index])->create();
                  либо
                  $users = User::factory()->count(2)->sequence(['name' => 'First User'], ['name' => 'Second User'])->create();
                  - отношения фабрик
                  // создать пользователя с тремя постами, модель User должна иметь метод posts, который определяет отношения
                  use App\Models\Post;
                  use App\Models\User;
                  $user = User::factory()->has(Post::factory()->count(3))->create();
                  // либо указать метод отношений модели User вручную
                  $user = User::factory()->has(Post::factory()->count(3), 'posts')->create();
                  // манипуляции с состоянием связанных моделей
                  $user = User::factory()->has(Post::factory()->count(3)
                    ->state(function (array $attributes, User $user) {return ['user_type' => $user->type];}))->create();
                  либо при наличии метода отношений posts модели User использовать магический метод отношений фабрики hasPosts()
                  $user = User::factory()->hasPosts(3)->create();
                  // создать 50 пользователей, по одному посту у каждого
                  use App\Models\User;
                  public function run(): void{User::factory()->count(50)->hasPosts(1)->create();}
                  // переопределение атрибутов в связанных моделях
                  $user = User::factory()->hasPosts(3, ['published' => false])->create();
                  либо
                  $user = User::factory()->hasPosts(3, function (array $attributes, User $user)
                  {return ['user_type' => $user->type]})->create();
                  // обратное отношение for, для определения родительской модели
                  use App\Models\Post;
                  use App\Models\User;
                  $posts = Post::factory()->count(3)->for(User::factory()->state(['name' => 'Jessica Archer']))->create();
                  либо
                  $user = User::factory()->create();
                  $posts = Post::factory()->count(3)->for($user)->create();
                  // магический метод отношений фабрики при наличии отношения user в модели Post
                  $posts = Post::factory()->count(3)->forUser(['name' => 'Jessica Archer'])->create();
                  // отношения Many To Many
                  use App\Models\Role;
                  use App\Models\User;
                  $user = User::factory()->has(Role::factory()->count(3))->create();
                  // установить атрибуты в связующей таблице
                  use App\Models\Role;
                  use App\Models\User;
                  $user = User::factory()->hasAttached(Role::factory()->count(3), ['active' => true])->create();
                  // преобразовать состояние связанной модели через доступ к родительской модели
                  $user = User::factory()->hasAttached(
                    Role::factory()->count(3)->state(function (array $attributes, User $user) {
                      return ['name' => $user->name.' Role'];}), ['active' => true])->create();
                  // прикрепить существующие записи к создаваемым моделям
                  // трем пользователям будут назначены одни и те же три роли
                  $roles = Role::factory()->count(3)->create();
                  $user = User::factory()->count(3)->hasAttached($roles, ['active' => true])->create();
                  // магический метод отношений фабрики при наличии метода отношений roles модели User
                  $user = User::factory()->hasRoles(1, ['name' => 'Editor'])->create();
                  // полиморфные отношения Morph Many создаются так же, как типичные отношения Has Many
                  // модель App\Models\Post имеет отношение morphMany с моделью App\Models\Comment
                  use App\Models\Post;
                  $post = Post::factory()->hasComments(3)->create();
                  // создать три комментария, относящиеся к одному посту, используя напрямую метод for
                  $comments = Comment::factory()->count(3)->for(Post::factory(), 'commentable')->create();
                  // полиморфные отношения Many To Many 
                  use App\Models\Tag;
                  use App\Models\Video;
                  $videos = Video::factory()->hasAttached(Tag::factory()->count(3), ['public' => true])->create();
                  либо
                  $videos = Video::factory()->hasTags(3, ['public' => true])->create();
                  // определить отношение в рамках фабрики
                  // создать нового пользователя при создании публикации
                  use App\Models\User;
                  public function definition(): array {
                    return [
                      'user_id' => User::factory(),
                      'title' => fake()->title(),
                      'content' => fake()->paragraph(),
                    ];}
                  public function definition(): array {
                    return [
                      'user_id' => User::factory(),
                      'user_type' => function (array $attributes) {return User::find($attributes['user_id'])->type;},
                      'title' => fake()->title(),
                      'content' => fake()->paragraph(),
                    ];}
                  // использовать одну и ту же авиакомпанию как для билета, так и для рейса
                  Ticket::factory()->recycle(Airline::factory()->create())->create();
                  // recycle принимает коллекцию существующих моделей - будет выбрана случайная модель из коллекции
                  Ticket::factory()->recycle($airlines)->create();

            //- Relations
            //- связи между моделями
            details 
              summary Relations
              p.
                Отношения реализованы поверх построителей запросов.<br>
                Внешний ключ в дочерней модели: родительская модель User, дочерняя модель Phone должна иметь столбец user_id<br>
              pre
                code.
                  $user->posts()->where('active', 1)->get();    // отношения определяются как методы ->posts() в классах модели $user
                  - один к одному (имеет одного)
                  // запись модели User связана с одной записью модели Phone
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\HasOne;
                  class User extends Model {
                    public function phone(): HasOne {
                      return $this->hasOne(Phone::class);   // получить телефон, связанный с пользователем
                      return $this->hasOne(Phone::class, 'foreign_key');    // задать внешний ключ вручную
                      return $this->hasOne(Phone::class, 'foreign_key', 'local_key');   // задать искомое значение в user_id вручную
                    }}
                  $phone = User::find(1)->phone;    // получить связанную запись в контроллере
                  // определить инверсию отношения hasOne
                  use Illuminate\Database\Eloquent\Relations\BelongsTo;
                  class Phone extends Model {
                    public function user(): BelongsTo {
                      return $this->belongsTo(User::class);   // получить пользователя, владеющего телефоном
                      return $this->belongsTo(User::class, 'foreign_key');    // задать внешний ключ вручную
                      return $this->belongsTo(User::class, 'foreign_key', 'owner_key');   // задать вручную искомое в id модели User значение
                    }}
                  - один ко многим (имеет много)
                  use Illuminate\Database\Eloquent\Relations\HasMany;
                  class Post extends Model {
                    public function comments(): HasMany {
                      return $this->hasMany(Comment::class);    // получить коллекцию связанных комментариев
                      return $this->hasMany(Comment::class, 'foreign_key');   // задать внешний ключ вручную
                      return $this->hasMany(Comment::class, 'foreign_key', 'local_key');    // задать искомое значение в post_id вручную
                    }}
                  $comments = Post::find(1)->comments;    // получить комментарии
                  foreach ($comments as $comment) { }   // перебор комментариев
                  $comment = Post::find(1)->comments()->where('title', 'foo')->first();   // дополнительные ограничения
                  // определить инверсию отношения hasMany
                  class Comment extends Model {
                    public function post(): BelongsTo {
                      return $this->belongsTo(Post::class);   // модель Comment имеет внешний ключ post_id
                      return $this->belongsTo(Post::class, 'foreign_key');    // задать внешний ключ вручную
                      return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');   // задать вручную искомое в id модели Post значение
                    }}
                  $comment = Comment::find(1);    // получить родительский пост комментария
                  return $comment->post->title;   // вернуть заголовок родительского пост комментария
                  public function latestOrder(): HasOne {return $this->hasOne(Order::class)->latestOfMany();} // получить последний заказ пользователя
                  public function oldestOrder(): HasOne {return $this->hasOne(Order::class)->oldestOfMany();} // получить первый заказ пользователя
                  // первый аргумент ofMany - столбец по которому ищем
                  public function largestOrder(): HasOne
                  {return $this->hasOne(Order::class)->ofMany('price', 'max');}  // получить самый дорогой заказ пользователя
                  либо через HasMany
                  public function orders(): HasMany {return $this->hasMany(Order::class);}    // получить заказы пользователя
                  public function largestOrder(): HasOne {return $this->orders()->one()->ofMany('price', 'max');}
                  public function currentPricing(): HasOne {
                    return $this->hasOne(Price::class)->ofMany(['published_at' => 'max', 'id' => 'max'],    // получить актуальную цену на продукт
                      function (Builder $query) {$query->where('published_at', '<', now());});}   // подзапрос
                  - один через отношение
                  // сопоставить модель с экземпляром другой модели, связавшись через третью модель
                  // механик связан с машиной, а машина связана с владельцем
                  mechanics
                    id - integer
                    name - string
                  cars
                    id - integer
                    model - string
                    mechanic_id - integer
                  owners
                    id - integer
                    name - string
                    car_id - integer
                  // механик получит доступ к владельцу через машину
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\HasOneThrough;
                  class Mechanic extends Model {
                    public function carOwner(): HasOneThrough {return $this->hasOneThrough(Owner::class, Car::class);}}    // получить владельца машины
                  либо через ключи
                  class Mechanic extends Model {
                    public function carOwner(): HasOneThrough {
                      return $this->hasOneThrough(
                        Owner::class,
                        Car::class,
                        'mechanic_id', // Внешний ключ в таблице `cars`
                        'car_id', // Внешний ключ в таблице `owners`
                        'id', // Локальный ключ в таблице `mechanics`
                        'id' // Локальный ключ в таблице `cars`
                      );}}
                  // получить владельца
                  return $this->through('cars')->has('owner');    // String based syntax
                  return $this->throughCars()->hasOwner();    // Dynamic syntax
                  - многие через отношение
                  projects
                    id - integer
                    name - string
                  environments
                    id - integer
                    project_id - integer
                    name - string
                  deployments
                    id - integer
                    environment_id - integer
                    commit_hash - string
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\HasManyThrough;
                  class Project extends Model {
                    public function deployments(): HasManyThrough {
                      return $this->hasManyThrough(Deployment::class, Environment::class);}}  // получит все развёртывания через среду окружения
                  // через ключи
                  class Project extends Model {
                    public function deployments(): HasManyThrough {
                      return $this->hasManyThrough(
                        Deployment::class,
                        Environment::class,
                        'project_id', // Внешний ключ в таблице `environments`
                        'environment_id', // Внешний ключ в таблице `deployments`
                        'id', // Локальный ключ в таблице `projects`
                        'id' // Локальный ключ в таблице `environments`
                      );}}
                  // получить развёртывания
                  return $this->through('environments')->has('deployments');    // String based syntax
                  return $this->throughEnvironments()->hasDeployments();    // Dynamic syntax
                  - получение доступа к родительской модели из дочерней при циклическом переборе записей дочерней модели может вызвать проблему «N + 1»
                  $posts = Post::with('comments')->get();
                  foreach ($posts as $post) {foreach ($post->comments as $comment) {echo $comment->post->title;}}   // проблема «N + 1»
                  // автоматически прикрепить запись из родительской модели к её дочерним записям из дочерней модели
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\HasMany;
                  class Post extends Model {public function comments(): HasMany {return $this->hasMany(Comment::class)->chaperone();}}
                  либо
                  $posts = Post::with(['comments' => fn ($comments) => $comments->chaperone()])->get();
                  - oтношения belongsTo, hasOne, hasOneThrough и morphOne позволяют определить модель по умолчанию при получении null
                  public function user(): BelongsTo {return $this->belongsTo(User::class)->withDefault();}    // вернёт пустую модель
                  либо получить автора поста
                  public function user(): BelongsTo {return $this->belongsTo(User::class)->withDefault(['name' => 'Guest Author']);}
                  либо
                  public function user(): BelongsTo
                  {return $this->belongsTo(User::class)->withDefault(function ($user, $post) {$user->name = 'Guest Author';});}
                  - определить в запросе к кому принадлежит
                  $posts = Post::where('user_id', $user->id)->get();
                  либо
                  $posts = Post::whereBelongsTo($user)->get();
                  либо
                  $users = User::where('vip', true)->get();
                  $posts = Post::whereBelongsTo($users)->get();
                  либо
                  $posts = Post::whereBelongsTo($user, 'author')->get();
                  - многие ко многим
                  // таблицы пользователей и ролей
                  users
                    id - integer
                    name - string
                  roles
                    id - integer
                    name - string
                  role_user
                    user_id - integer
                    role_id - integer
                  // роли, принадлежащие пользователю
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsToMany;
                  class User extends Model {
                    public function roles(): BelongsToMany {return $this->belongsToMany(Role::class);}}
                  $user = User::find(1);    // получить доступ к ролям пользователя
                  foreach ($user->roles as $role) { }   // перебрать роли пользователя
                  $roles = User::find(1)->roles()->orderBy('name')->get();    // с ограничениями и условиями
                  // обратное отношение многие-ко-многим
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsToMany;
                  class Role extends Model {
                    // пользователи, принадлежащие к роли
                    public function users(): BelongsToMany {return $this->belongsToMany(User::class);}}
                  // Eloquent автоматически соединит имена таблиц User и Role в алфавитном порядке role_user для поиска связующей таблицы
                  return $this->belongsToMany(Role::class, 'role_user');    // задать имя связующей таблицы вручную
                  return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');    // изменить имена столбцов ключей
                  // доступ к связующей таблице
                  $user = User::find(1);
                  foreach ($user->roles as $role) {echo $role->pivot->created_at;}
                  // дополнительные столбцы связующей таблицы
                  return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');
                  // чтобы связующая таблица имела временные метки created_at и updated_at, нужно вызвать withTimestamps
                  return $this->belongsToMany(Role::class)->withTimestamps();
                  // дугое имя для связующей таблицы
                  return $this->belongsToMany(Podcast::class)->as('subscription')->withTimestamps();
                  // получить столбец связующей таблицы
                  $users = User::with('podcasts')->get();
                  foreach ($users->flatMap->podcasts as $podcast) {echo $podcast->subscription->created_at;}
                  // фильтрация запросов по столбцам связующей таблицы
                  return $this->belongsToMany(Role::class)->wherePivot('approved', 1);
                  return $this->belongsToMany(Role::class)->wherePivotIn('priority', [1, 2]);
                  return $this->belongsToMany(Role::class)->wherePivotNotIn('priority', [1, 2]);
                  return $this->belongsToMany(Podcast::class)->as('subscriptions')
                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);
                  return $this->belongsToMany(Podcast::class)->as('subscriptions')
                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);
                  return $this->belongsToMany(Podcast::class)->as('subscriptions')->wherePivotNull('expired_at');
                  return $this->belongsToMany(Podcast::class)->as('subscriptions')->wherePivotNotNull('expired_at');
                  return $this->belongsToMany(Badge::class)->where('rank', 'gold')->orderByPivot('created_at', 'desc');
                  - определить свою модель связующей таблицы RoleUser
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsToMany;
                  class Role extends Model {
                    public function users(): BelongsToMany {
                      return $this->belongsToMany(User::class)->using(RoleUser::class);}}    // пользователи, принадлежащие к роли
                  // модель связующей модели RoleUser
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Relations\Pivot;
                  class RoleUser extends Pivot { }
                  // автоинкремент для связующей таблицы
                  public $incrementing = true;    // идентификаторы модели автоинкрементные
              p полиморфные отношения
              pre
                code.
                  - один к одному полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации
                  // таблицы
                  posts
                    id - integer
                    name - string
                  users
                    id - integer
                    name - string
                  images
                    id - integer
                    url - string
                    imageable_id - integer
                    imageable_type - string
                  // модели
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  class Image extends Model {
                    // получить родительскую модель (пользователя или поста), к которой относится изображение
                    public function imageable(): MorphTo{return $this->morphTo();}}
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphOne;
                  class Post extends Model {
                    // получить изображение поста
                    public function image(): MorphOne {return $this->morphOne(Image::class, 'imageable');}}
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphOne;
                  class User extends Model {
                    // получить изображение пользователя
                    public function image(): MorphOne {return $this->morphOne(Image::class, 'imageable');}}
                  // получить доступ к дочерней модели
                  use App\Models\Post;
                  $post = Post::find(1);
                  $image = $post->image;
                  // получить родительский объект полиморфной модели, вернёт Post или User
                  use App\Models\Image;
                  $image = Image::find(1);
                  $imageable = $image->imageable;
                  // получить родительскую модель, к которой относится изображение
                  public function imageable(): MorphTo {return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');}
                  - один ко многим полиморф: дочерняя модель принадлежит более чем к одному типу модели с использованием одной ассоциации
                  // таблицы
                  posts
                    id - integer
                    title - string
                    body - text
                  videos
                    id - integer
                    title - string
                    url - string
                  comments
                    id - integer
                    body - text
                    commentable_id - integer
                    commentable_type - string
                  // модели
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  class Comment extends Model {
                    // получить родительскую модель (поста или видео), к которой относится комментарий
                    public function commentable(): MorphTo {return $this->morphTo();}}
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphMany;
                  class Post extends Model {
                    // получить все комментарии поста
                    public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable');}}
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphMany;
                  class Video extends Model {
                    // получить все комментарии видео
                    public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable');}}
                  // доступ к дочерней модели
                  use App\Models\Post;
                  $post = Post::find(1);
                  foreach ($post->comments as $comment) { }
                  // доступ к родительской модели, вернет либо экземпляр Post, либо Video
                  use App\Models\Comment;
                  $comment = Comment::find(1);
                  $commentable = $comment->commentable;
                  // проблема «N + 1»
                  $posts = Post::with('comments')->get();
                  foreach ($posts as $post) {foreach ($post->comments as $comment) {echo $comment->commentable->title;}}
                  // автоматически связывать записи родительской модели с дочерними
                  class Post extends Model {
                    public function comments(): MorphMany {return $this->morphMany(Comment::class, 'commentable')->chaperone();}}
                  // либо
                  use App\Models\Post;
                  $posts = Post::with(['comments' => fn ($comments) => $comments->chaperone()])->get();
                  - один из многих полиморф
                  // Get the user's most recent image.
                  public function latestImage(): MorphOne {return $this->morphOne(Image::class, 'imageable')->latestOfMany();}
                  // либо
                  // Get the user's oldest image.public function oldestImage(): MorphOne {
                    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();}
                  ofMany('likes', 'max')    // задать столбец сортировки и способ сортировки вручную
                  // Получить изображение, у которого больше всего лайков.
                  public function bestImage() {return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');}
                  - многие ко многим полиморф
                  // таблицы
                  posts
                    id - integer
                    name - string
                  videos
                    id - integer
                    name - string
                  tags
                    id - integer
                    name - string
                  taggables
                    tag_id - integer
                    taggable_id - integer
                    taggable_type - string
                  // модель
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphToMany;
                  class Post extends Model {
                    // Получить все теги поста, taggable - связующая таблица
                    public function tags(): MorphToMany {return $this->morphToMany(Tag::class, 'taggable');}}
                  // получить записи родительской модели
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphToMany;
                  class Tag extends Model {
                    // Получить все посты, которым присвоен этот тег.
                    public function posts(): MorphToMany {return $this->morphedByMany(Post::class, 'taggable');}
                    // Получить все видео, которым присвоен этот тег.
                    public function videos(): MorphToMany {return $this->morphedByMany(Video::class, 'taggable');}}
                  // получить доступ к дочерней модели
                  use App\Models\Post;
                  $post = Post::find(1);
                  foreach ($post->tags as $tag) { }
                  // получить доступ к родительской модели
                  use App\Models\Tag;
                  $tag = Tag::find(1);
                  foreach ($tag->posts as $post) { }
                  foreach ($tag->videos as $video) { }
                  // задать псевдоним полиморфного типа модели вручную
                  use Illuminate\Database\Eloquent\Relations\Relation;
                  Relation::enforceMorphMap(['post' => 'App\Models\Post', 'video' => 'App\Models\Video']);
                  либо
                  $alias = $post->getMorphClass();    // определить псевдоним полиморфного типа конкретной модели
                  $class = Relation::getMorphedModel($alias); // определить полное имя класса, связанное с псевдонимом
                  - динамические отношения
                  // настроить динамические отношения в App\Providers\AppServiceProvider метод boot
                  use App\Models\Order;
                  use App\Models\Customer;
                  Order::resolveRelationUsing('customer', function (Order $orderModel) {
                    return $orderModel->belongsTo(Customer::class, 'customer_id');});
              p.
                - запросы отношений
                // получить экземпляр отношения, не выполняя запроса загрузки связанных моделей
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\HasMany;
                  class User extends Model {
                    // получить все посты пользователя
                    public function posts(): HasMany {return $this->hasMany(Post::class);}}
                  // запросить отношение posts
                  use App\Models\User;
                  $user = User::find(1);
                  $user->posts()->where('active', 1)->get();
                  либо
                  $user->posts()->where('active', 1)->orWhere('votes', '>=', 100)->get();
                  // вернёт
                  select * from posts where user_id = ? and active = 1 or votes >= 100
                  либо
                  use Illuminate\Database\Eloquent\Builder;
                  $user->posts()->where(function (Builder $query) {return $query->where('active', 1)
                    ->orWhere('votes', '>=', 100);})->get();
                  // вернёт
                  select * from posts where user_id = ? and (active = 1 or votes >= 100)
                  // получить доступ к отношению, как к свойству
                  use App\Models\User;
                  $user = User::find(1);
                  foreach ($user->posts as $post) { }
                  - получить записи таблицы, у которых есть отношения с другими таблицами
                  use App\Models\Post;
                  // Получить все посты, в которых есть хотя бы один комментарий
                  $posts = Post::has('comments')->get();
                  // Получить посты, в которых есть 3 или более комментариев
                  $posts = Post::has('comments', '>=', 3)->get();
                  // Получить посты, в которых есть хотя бы один комментарий с изображениями
                  $posts = Post::has('comments.images')->get();
                  либо
                  use Illuminate\Database\Eloquent\Builder;
                  // Получить посты с хотя бы одним комментарием, содержащим `code%`
                  $posts = Post::whereHas('comments', function (Builder $query) {
                    $query->where('content', 'like', 'code%');})->get();
                  // Получить посты с как минимум десятью комментариями, содержащими `code%`
                  $posts = Post::whereHas('comments', function (Builder $query) {
                    $query->where('content', 'like', 'code%');}, '>=', 10)->get();
                  // запросить все посты с не одобренными комментариями
                  use App\Models\Post;
                  $posts = Post::whereRelation('comments', 'is_approved', false)->get();
                  // запросить посты в зависимости от момента создания комментария
                  $posts = Post::whereRelation('comments', 'created_at', '>=', now()->subHour())->get();
                  - получить записи таблицы, у которых нет отношения с другими таблицами
                  // получить все посты блога, которые не имеют комментариев
                  use App\Models\Post;
                  $posts = Post::doesntHave('comments')->get();
                  // проверить содержимое комментария
                  use Illuminate\Database\Eloquent\Builder;
                  $posts = Post::whereDoesntHave('comments', function (Builder $query) {
                    $query->where('content', 'like', 'code%');})->get();
                  // получить посты без комментариев и с комментариями от незабаненных авторов
                  use Illuminate\Database\Eloquent\Builder;
                  $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
                    $query->where('banned', 0);})->get();
                  - узнать о существовании полиморфных «один-к» отношений
                  use App\Models\Comment;
                  use App\Models\Post;
                  use App\Models\Video;
                  use Illuminate\Database\Eloquent\Builder;
                  // Получить комментарии, связанные с постами или видео с заголовком, содержащими `code%`
                  $comments = Comment::whereHasMorph('commentable', [Post::class, Video::class],
                    function (Builder $query) {$query->where('title', 'like', 'code%');})->get();
                  // Получить комментарии, связанные с постами с заголовком, не содержащим `code%`
                  $comments = Comment::whereDoesntHaveMorph('commentable', Post::class,
                    function (Builder $query) {$query->where('title', 'like', 'code%');})->get();
                  // с указанием типа
                  use Illuminate\Database\Eloquent\Builder;
                  $comments = Comment::whereHasMorph('commentable', [Post::class, Video::class],
                    function (Builder $query, string $type) {
                      $column = $type === Post::class ? 'content' : 'title';
                      $query->where($column, 'like', 'code%');})->get();
                  // запросить дочерние элементы
                  $comments = Comment::whereMorphedTo('commentable', $post)->orWhereMorphedTo('commentable', $video)->get();
                  - извлечь все возможные полиморфные типы из БД
                  use Illuminate\Database\Eloquent\Builder;
                  $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
                    $query->where('title', 'like', 'foo%');})->get();
                  - агрегирование связанных моделей
                  // подсчитать количество связанных моделей для отношения, не загружая модели
                  use App\Models\Post;
                  $posts = Post::withCount('comments')->get();
                  foreach ($posts as $post) {echo $post->comments_count;}
                  // добавить «счетчики» для нескольких отношений, а также добавить дополнительные ограничения к запросам
                  use Illuminate\Database\Eloquent\Builder;
                  $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
                    $query->where('content', 'like', 'code%');}])->get();
                  echo $posts[0]->votes_count;
                  echo $posts[0]->comments_count;
                  // использовать псевдоним результата подсчета отношений
                  use Illuminate\Database\Eloquent\Builder;
                  $posts = Post::withCount(['comments',
                    'comments as pending_comments_count' => function (Builder $query) {
                      $query->where('approved', false);},])->get();
                  echo $posts[0]->comments_count;
                  echo $posts[0]->pending_comments_count;
                  // загрузить счетчик отношений после того, как родительская модель уже была получена
                  $book = Book::first();
                  $book->loadCount('genres');
                  // установить дополнительные ограничения запроса
                  $book->loadCount(['reviews' => function (Builder $query) {$query->where('rating', 5);}])
                  // withCount вызывать после метода select
                  $posts = Post::select(['title', 'body'])->withCount('comments')->get();
                  // сумма комментариев
                  use App\Models\Post;
                  $posts = Post::withSum('comments', 'votes')->get();
                  foreach ($posts as $post) {echo $post->comments_sum_votes;}
                  // с псевдонимом
                  $posts = Post::withSum('comments as total_comments', 'votes')->get();
                  foreach ($posts as $post) {echo $post->total_comments;}
                  // отложенное выполнение на уже полученных моделях
                  $post = Post::first();
                  $post->loadSum('comments', 'votes');
                  // все методы вызывать после select
                  $posts = Post::select(['title', 'body'])->withExists('comments')->get();
                  // посчитать количество отношений у родителей
                    Photo родитель Tag, Post родитель Comment, Photo и Post полиморфные родители ActivityFeed
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  // отложенное выполнение на уже загруженный записях ActivityFeed
                  $activities = ActivityFeed::with(['parentable' => function (MorphTo $morphTo) {
                    $morphTo->morphWithCount([Photo::class => ['tags'], Post::class => ['comments'],]);}])->get();
              p проблема «N+1»
              pre
                code.
                  // модель Book «принадлежит» модели Author
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsTo;
                  class Book extends Model {
                    // Получить автора книги.
                    public function author(): BelongsTo {return $this->belongsTo(Author::class);}}
                  // получим все книги и их авторов
                  // если в таблице 25 книг, то будет 26 запросов:
                  // один для получения всех книг
                  // 25 дополнительных запросов для получения автора каждой книги
                  use App\Models\Book;
                  $books = Book::all();
                  foreach ($books as $book) {echo $book->author->name;}
                  // при жадной загрузке будут выполнены только два запроса:
                  // один запрос для получения всех книг
                  // второй запрос – для получения всех авторов для всех книг
                  $books = Book::with('author')->get();
                  foreach ($books as $book) {echo $book->author->name;}
                  // вернёт
                  select * from books
                  select * from authors where id in (1, 2, 3, 4, 5, ...)
              p.
                  - жадная (eager) загрузка<br>
                  - При доступе к отношениям как к свойствам, связанные модели загружаются «отложенно», т.е. не загружаются, пока вы впервые не затребуете доступ к свойству.<br>
                  - Можно «жадно» загрузить отношения во время запроса родительской модели.<br>
                  - Жадная загрузка позволяет избежать проблем «N+1» с запросами. <br>
                  - Жадная загрузка обеспечивает значительное сокращение количества SQL-запросов, которые необходимо выполнить для загрузки отношений модели.<br>
                  - всегда предотвращать ленивую загрузку<br>
              pre
                code.
                  // в App\Providers\AppServiceProvider в boot
                  use Illuminate\Database\Eloquent\Model;
                  public function boot(): void {Model::preventLazyLoading(! $this->app->isProduction());}
                  // когда приложение попытается лениво загрузить отношение, будет исключение<br>
                  // регистрировать, а не выбрасывать исключение<br>
                  Model::handleLazyLoadingViolationUsing(function (Model $model, string $relation) {
                    $class = $model::class;
                    info("Attempted to lazy load [{$relation}] on model [{$class}].");});
                  // загрузить несколько разных отношений
                  $books = Book::with(['author', 'publisher'])->get();
                  // вложенная жадная загрузка контактов всех авторов книг
                  $books = Book::with('author.contacts')->get();
                  // одновременная загрузка нескольких вложенных отношений
                  $books = Book::with(['author' => ['contacts', 'publisher']])->get();
                  // загрузить полиморфное отношение «один-к»
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  class ActivityFeed extends Model {
                    // Получить родительский элемент записи ленты активности.
                    public function parentable(): MorphTo {return $this->morphTo();}}
                  // Event, Photo и Post могут создавать модели ActivityFeed
                  // Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
                  // получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  $activities = ActivityFeed::query()->with(['parentable' => function (MorphTo $morphTo) {
                    $morphTo->morphWith([
                      Event::class => ['calendar'],
                      Photo::class => ['tags'],
                      Post::class => ['author']]);}])->get();
                  $books = Book::with('author:id,name,book_id')->get();   // жадная загрузка указанных столбцов
                  // постоянная загрузка отношений при извлечении модели
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsTo;
                  class Book extends Model {
                    protected $with = ['author'];
                    public function author(): BelongsTo {return $this->belongsTo(Author::class);}   // получить автора книги
                    public function genre(): BelongsTo {return $this->belongsTo(Genre::class);}}   // получить жанр книги
                  // удалить элемент из свойства $with для одного запроса
                  $books = Book::without('author')->get();
                  // для одного запроса
                  $books = Book::withOnly('genre')->get();
                  // ключ массива – имя отношения
                  // значение массива – ограничение к запросу жадной загрузки
                  // загружать только те посты, столбец title которых содержит слово code
                  use App\Models\User;
                  use Illuminate\Contracts\Database\Eloquent\Builder;
                  $users = User::with(['posts' => function (Builder $query) {
                    $query->where('title', 'like', '%code%');}])->get();
                  // сортировка по времени создания
                  $users = User::with(['posts' => function (Builder $query) {
                    $query->orderBy('created_at', 'desc');}])->get();
                  // ограничения к жадной загрузке полиморфного отношения «один-к»
                  // загружать только скрытые посты, а видео только с типом как образовательное
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
                    $morphTo->constrain([
                      Post::class => function ($query) {$query->whereNull('hidden_at');},
                      Video::class => function ($query) {$query->where('type', 'educational');}
                    ]);}])->get();
                  // проверить наличие отношения при жадной загрузке
                  use App\Models\User;
                  $users = User::withWhereHas('posts', function ($query) {$query->where('featured', true);})->get();
                  // жадно загрузить отношение только после получения родительской модели
                  use App\Models\Book;
                  $books = Book::all();
                  if ($someCondition) {$books->load('author', 'publisher');}
                  // с ограничением
                  $author->load(['books' => function (Builder $query) {$query->orderBy('published_date', 'asc');}]);
                  $book->loadMissing('author');   // загрузить если еще не было загружено
                  // вложенная жадная пост-загрузка с полиморфными отношениями «один-к»
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\MorphTo;
                  class ActivityFeed extends Model {
                    // получить родительский элемент записи ленты активности
                    public function parentable(): MorphTo {return $this->morphTo();}}
                  // Event, Photo и Post могут создавать модели ActivityFeed
                  // Event принадлежит Calendar, Photo связана с Tag, Post принадлежит Author
                  // получить записи ActivityFeed и жадно загрузить все родительские с их вложениями
                  $activities = ActivityFeed::with('parentable')->get()->loadMorph('parentable', [
                    Event::class => ['calendar'],
                    Photo::class => ['tags'],
                    Post::class => ['author']]);
              p вставка и обновление связанных моделей
              pre
                code.
                  // добавить новый комментарий к посту
                  use App\Models\Comment;
                  use App\Models\Post;
                  $comment = new Comment(['message' => 'A new comment.']);
                  $post = Post::find(1);
                  $post->comments()->save($comment);
                  // сохранить несколько связанных записей
                  $post = Post::find(1);
                  $post->comments()->saveMany([
                    new Comment(['message' => 'A new comment.']),
                    new Comment(['message' => 'Another new comment.'])]);
                  // получить доступ к отношениям после использования методов save или saveMany
                  $post->comments()->save($comment);
                  $post->refresh();
                  // все комментарии, включая только что сохраненный комментарий
                  $post->comments;
                  // сохранить пост, его комментарии и авторы этих комментариев
                  $post = Post::find(1);
                  $post->comments[0]->message = 'Message';
                  $post->comments[0]->author->name = 'Author Name';
                  $post->push();
                  // сохранения поста и его связанных отношений без вызова каких-либо событий
                  $post->pushQuietly();
                  // метод save принимает экземпляр модели Eloquent, а create принимает простой массив PHP
                  use App\Models\Post;
                  $post = Post::find(1);
                  $comment = $post->comments()->create(['message' => 'A new comment.']);
                  // создание нескольких связанных записей
                  $post = Post::find(1);
                  $post->comments()->createMany([['message' => 'A new comment.'], ['message' => 'Another new comment.']]);
                  // создания постов без отправки каких-либо событий
                  $user = User::find(1);
                  $user->posts()->createQuietly(['title' => 'Post title.']);
                  $user->posts()->createManyQuietly([['title' => 'First post.'], ['title' => 'Second post.']]);
                  // создание и обновление записей методы findOrNew, firstOrNew, firstOrCreate, и updateOrCreate
                  // назначить дочернюю модель новой родительской модели
                  use App\Models\Account;
                  $account = Account::find(10);
                  $user->account()->associate($account);
                  $user->save();
                  удалить родительскую модель из дочерней модели
                  $user->account()->dissociate();
                  $user->save();
                  // присоединить «многие-ко-многим», вставив запись в связующую таблицу
                  use App\Models\User;
                  $user = User::find(1);
                  $user->roles()->attach($roleId);
                  // передать массив дополнительных данных для вставки в связующую таблицу
                  $user->roles()->attach($roleId, ['expires' => $expires]);
                  // удалить запись отношения «многие-ко-многим» - удалит запись из связующей таблицы
                  // Отсоединить одну роль от пользователя
                  $user->roles()->detach($roleId);
                  // Отсоединить от пользователя все роли
                  $user->roles()->detach();
                  либо
                  $user = User::find(1);
                  $user->roles()->detach([1, 2, 3]);
                  $user->roles()->attach([1 => ['expires' => $expires], 2 => ['expires' => $expires]]);
                  // создать ассоциации «многие-ко-многим», добавив массив идентификаторов в связующую таблицу
                  $user->roles()->sync([1, 2, 3]);
                  либо
                  $user->roles()->sync([1 => ['expires' => true], 2, 3]);
                  // вставить одинаковые значения в связующую таблицу для каждого ID
                  $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);
                  // не удалять существующие связи, идентификаторы которых отсутствуют в переданном массиве
                  $user->roles()->syncWithoutDetaching([1, 2, 3]);
                  // если переданный идентификатор в настоящее время присоединен, он будет отсоединен и наоборот
                  $user->roles()->toggle([1, 2, 3]);
                  // передать дополнительные значения для связующей таблицы вместе с идентификаторами
                  $user->roles()->toggle([1 => ['expires' => true], 2 => ['expires' => true]]);
                  // обновить существующую строку в связующей таблице
                  $user = User::find(1);
                  $user->roles()->updateExistingPivot($roleId, ['active' => false]);
              p временные метки родителя
              pre
                code.
                  // обновить временную метку родителя при обновлении дочерней модели
                  // свойство $touches дочерней модели, содержит имена отношений, которые должны обновляться с дочерней моделью
                  namespace App\Models;
                  use Illuminate\Database\Eloquent\Model;
                  use Illuminate\Database\Eloquent\Relations\BelongsTo;
                  class Comment extends Model {
                    protected $touches = ['post'];    // все отношения, временные метки которых должны быть затронуты
                    // получить пост, к которому принадлежит комментарий
                    public function post(): BelongsTo {return $this->belongsTo(Post::class);}}

          //- Pagination
          //- Пагинация
          details 
            summary Pagination
            p paginate автоматически устанавливает «предел» и «смещение» в запросе на основе текущей страницы
            pre
              code.
                - в tailwind.config.js
                content: [
                  './resources/**/*.blade.php',
                  './resources/**/*.js',
                  './resources/**/*.vue',
                  './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php']
                - отобразить 15 элементов на странице
                namespace App\Http\Controllers;
                use App\Http\Controllers\Controller;
                use Illuminate\Support\Facades\DB;
                use Illuminate\View\View;
                class UserController extends Controller {
                  public function index(): View
                  {return view('user.index', ['users' => DB::table('users')->paginate(15)]);}}
                - отображать только простые ссылки «Далее» и «Назад» без общего количества страниц
                $users = DB::table('users')->simplePaginate(15);
                - разбить запросы Eloquent на страницы
                use App\Models\User;
                $users = User::paginate(15);
                либо
                $users = User::where('votes', '>', 100)->paginate(15);
                либо
                $users = User::where('votes', '>', 100)->simplePaginate(15);
                либо
                $users = User::where('votes', '>', 100)->cursorPaginate(15);
                - отобразить два отдельных модуля пагинации на одном экране:
                  в третьем параметре указать имя страницы отдельно для каждого модуля пагинации
                use App\Models\User;
                $users = User::where('votes', '>', 100)->paginate($perPage = 15, $columns = ['*'], $pageName = 'users');
            p.
              - paginate и simplePaginate создают запросы с использованием SQL-оператора “offset”<br>
              - Cursor-пагинация работает путем создания конструкции “where”<br>
              - пагинация на основе смещения включает номер страницы в строке запроса URL-адресов<br>
              - Курсор представляет собой закодированную строку, содержащую место, с которого следующий запрос с пагинацией должен начать постраничную навигацию, и направление, в котором он должен разбиваться на страницы<br>
            pre
              code.
                $users = DB::table('users')->orderBy('id')->cursorPaginate(15);
                - отобразить “вторую страницу” результатов для таблицы users, упорядоченных по id
                select * from users order by id asc limit 15 offset 15;   // offset пагинация
                select * from users where id > 15 order by id asc limit 15;   // cursor пагинация
            p.
              Преимущества Cursor-пагинация перед Offset-пагинацией:<br>
              - Для больших наборов данных Cursor-пагинация обеспечивать лучшую производительность, если столбцы “order by” проиндексированы. Это связано с тем, что предложение “offset” сканирует все ранее сопоставленные данные.<br>
              - Для наборов данных с частыми записями Offset-пагинация может пропускать записи или отображать дубликаты, если результаты были недавно добавлены или удалены со страницы, которую пользователь просматривает в данный момент.<br>
              <br>
              Ограничения Cursor-пагинации:<br>
              - Как и simplePaginate, Cursor-пагинация может использоваться только для отображения ссылок “Далее” и “Назад” и не поддерживает создание ссылок с номерами страниц.<br>
              - Требуется, чтобы порядок был основан как минимум на одном уникальном столбце или на комбинации уникальных столбцов. - Столбцы с null – значениями не поддерживаются.<br>
              - Выражения запросов c “order by” поддерживаются только в том случае, если они имеют псевдоним и также добавлены в “select”.<br>
              - Выражения запросов с параметрами не поддерживаются.<br>
              - чтобы пагинатор генерировал ссылки типа http://example.com/admin/users?page=N
            pre
              code.
                use App\Models\User;
                Route::get('/users', function () {
                  $users = User::paginate(15);
                  $users->withPath('/admin/users');});
                - добавить sort=votes к каждой ссылке пагинации
                use App\Models\User;
                Route::get('/users', function () {
                  $users = User::paginate(15);
                  $users->appends(['sort' => 'votes']);});
                - добавить все значения строки текущего запроса к ссылкам постраничной навигации
                $users = User::paginate(15)->withQueryString();
                - добавить «хеш-фрагмент» к URL-адресам
                $users = User::paginate(15)->fragment('users');
            p.
              - вызов метода paginate возвращает экземпляр Illuminate\Pagination\LengthAwarePaginator<br>
              - вызов метода simplePaginate возвращает экземпляр Illuminate\Pagination\Paginator<br>
              - вызов метода cursorPaginate возвращает экземпляр Illuminate\Pagination\CursorPaginator<br>
              - экземпляры являются итераторами и могут быть перебраны как массив<br>
            a(href="http://laravel.su/docs/12.x/pagination#metody-ekzempliara-paginator-i-lengthawarepaginator") экземпляры содержат методы, описывающие результирующий набор
            pre
              code.
                &lt;div class="container"&gt;@foreach ($users as $user){{ $user->name }}@endforeach&lt;/div&gt;
                // links отрисует ссылки с переменной запроса page на остальные страницы
                {{ $users->links() }}
            p.
              - HTML, сгенерированный методом links, совместим с фреймворком Tailwind CSS<br>
              - пагинатор отображает навигационные ссылки, включающие номер текущей страницы, а также ссылки для трех страниц до и после текущей<br>
              - контролировать, сколько дополнительных ссылок отображается с каждой стороны от текущей страницы<br>
            pre
              code.
                {{ $users->onEachSide(5)->links() }}
                - преобразовать экземпляр пагинатора в JSON, вернув его из маршрута или действия контроллера
                use App\Models\User;
                Route::get('/users', function () {return User::paginate();});
            p передать свой шаблон отображения навигационных ссылок пагинации
            pre
              code.
                {{ $paginator->links('view.name') }}
                {{ $paginator->links('view.name', ['foo' => 'bar']) }}    // передача дополнительных данных в шаблон
            p.
              - отредактировать встроенные шаблоны постраничной навигации
              - файл tailwind.blade.php в resources/views/vendor/pagination - шаблон постраничной навигации по умолчанию<br>
            pre
              code.
                php artisan vendor:publish --tag=laravel-pagination
                - назначить другой файл шаблоном постраничной навигации по умолчанию<br>
                namespace App\Providers;
                use Illuminate\Pagination\Paginator;
                use Illuminate\Support\ServiceProvider;
                class AppServiceProvider extends ServiceProvider {
                  public function boot(): void {
                    Paginator::defaultView('view-name');
                    Paginator::defaultSimpleView('view-name');}}

          //- Redis
          //- используется как кэш и драйвер очереди
          details
            summary Redis
            a(href="http://laravel.su/docs/12.x/redis") redis
            p.
              - Redis используется в качестве кэша и драйвера очереди<br>
              - драйвер Redis по умолчанию использует расширение phpredis<br>
              - расширение predis не поддерживается<br>
              - расширение phpredis поддерживает Redis 3.0 и выше<br>
              - кеширование данных в Redis<br>
              - кеширование представлений в Redis<br>
              - кеширование маршрутов в Redis<br>
              - кеширование конфигурации в Redis<br>
            pre
              code.
                php artisan config:cache
                php artisan route:cache
                php artisan view:cache

                use Illuminate\Support\Facades\Redis;
                Redis::set('key', 'value');
                Redis::get('key');
                Redis::del('key');
                Redis::exists('key');
                Redis::expire('key', 60);
                Redis::ttl('key');
                Redis::keys('*');
                Redis::flushAll();

          //- MongoDB
          //- используется как драйвер кэша, очереди, сессий и БД
          details
            summary MongoDB
            a(href="http://laravel.su/docs/12.x/mongodb") mongodb
            p.
              - MongoDB используется в качестве драйвера кэша, очереди, сессий, БД<br>
              - драйвер MongoDB по умолчанию использует расширение mongodb<br>
              - расширение mongodb поддерживает MongoDB 2.6 и выше<br>
            code php artisan vendor:publish --provider="Jenssegers\Mongodb\MongodbServiceProvider"
              
        //- How to
        details
          summary How to
            
          //- Api
          details 
            summary Api
            p Установить пакет Sanctum, создать роут, миграцию personal_access_tokens_table и токен аутентификацию для api
            code ./sail artisan install:api
            p Создать модель с миграцией
            code ./sail artisan make:model Category -m
            p Обновить таблицы
            code ./sail artisan migrate
            p.
              создать контроллер в отдельной структуре папок (v1 - версия)
              --model=Category - привязка к модели
              --api - методы апи контроллера
              --requests - вынос валидации в отдельные классы
            code ./sail artisan make:controller Api/V1/CategoryController --model=Category --api --requests
            p сгруппировать роуты по версиям и создать рессурсный роут
            code.
              use App\Http\Controllers\Api\V1\CategoryController;
              Route::prefix('v1')->group(function()
              {
                  Route::apiResource('categories', CategoryController::class);
              });
            p просмотреть список роутов
            code ./sail artisan route:list --except-vendor
            p В файле bootstrap/app.php можно добавить свой обработчик ошибок
            code.
              use Illuminate\Foundation\Configuration\Exceptions;
              ->withExceptions(function (Exceptions $exceptions) {
                $exceptions->render(function (NotFoundHttpException $e, Request $request) {
                  if ($request->is('api/*')) {
                    return response()->json([
                      'message' => 'Record not found.'
                    ], 404);
                  }
                });
              })
            p Чтобы задать формат api ответа создать Resources
            code ./sail artisan make:resource Api/V1/CategoryResource
            p в контроллере возврат данных таблицы через рессурс-коллекцию для массива данных
            code return CategoryResource::collection(Category::all());
            p для возврата одной записи из таблицы данных
            code new CategoryResource(Category::findOrFail($id));
            p либо
            code.
              public function show(Category $category)
              {
                return new CategoryResource($category);
              }
            p в Api/V1/PostResource задаю условие: поле "content" показывать если роут posts.show
            code "content"=> $this->when(Route::currentRouteName() == 'posts.show', $this->content),
            p в Api/V1/PostResource по связи метода category из модели получаю свойство категории
            code "categoryName" => $this->category->title,
            p в Models/Post задаю связь с таблицей category методом category
            code.
              public function category()
              {
                return $this->belongsTo(Category::class);
              }
            p в Models/Post задаю список полей, которые не участвуют в работе методов
            code.
              protected $hidden = [
                "created_at",
              ];
            p.
              в PostController по связи метода category из модели Models/Post получаю всё одним запросом
              и вывожу частями по 5 постов
            code return PostResource::collection(Post::with('category')->paginate(5));
            p для ограничения количества запросов в App\Providers\AppServiceProvider добавить в метод boot()
            code.
              use Illuminate\Cache\RateLimiting\Limit;
              use Illuminate\Http\Request;
              use Illuminate\Support\Facades\RateLimiter;
              RateLimiter::for('api', function (Request $request) {
                return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
              });
            p ключить ограничение middleware(['throttle:api', 'auth:sanctum']) в роуты
            code Route::prefix('v1')->middleware(['throttle:api'])->group(function()
            p для доступа к данным апи через токен добавить в модель User
            code.
              use Laravel\Sanctum\HasApiTokens;
              use HasApiTokens
            p установить срок жизни токена в минутах в config/sanctum.php          
            code 'expiration' = 10,
            p просроченные токены удалять командой sanctum:prune-expired
            code.
              use Illuminate\Support\Facades\Schedule;
              Schedule::command('sanctum:prune-expired --hours=24')->daily();

          //- CRUD
          details
            summary CRUD
            p Create model
            code php artisan make:model Post -mfcr
            p.
              Add columns in migration<br>
              Define fillable columns and relation in Post model and relation in User model<br>
              Fill database/factories/PostFactory.php and database/seeders/DatabaseSeeder.php<br>
              Fill database fake data<br>
            code php artisan migrate:fresh --seed
            p.
              In resources/js/types/index.d.ts create interface Post<br>
              Create link for images
            code php artisan storage:link
            p.
              Add navItem in resources/js/components/app-sidebar.tsx to posts.index<br>
              Copy resources/js/pages/dashboard.tsx to resources/js/pages/posts/index.tsx<br>
              In resources/js/pages/posts/index.tsx import table from shadcn and create inertia link for post creating<br>
              Copy resources/js/pages/auth/login.tsx to resources/js/pages/posts/create.tsx<br>
              In resources/js/types/index.d.ts create type PostForm<br>
              Import and past textarea from shadcn into resources/js/pages/posts/create.tsx<br>
              Copy resources/js/pages/posts/create.tsx to resources/js/pages/posts/edit.tsx<br>
              Create resource for posts<br>
            code php artisan make:resource PostResource
            p Add to boot function AppServiceProvider
            code JsonResource::withoutWrapping();
            p.
              Register route for posts/ in routes/web.php<br>
              Fill methods in PostController<br>
              Clear and optimazing data<br>
            pre
              code.
                php artisan optimize
                php artisan optimize:clear
            p.
              Add flash messages to app/Http/Middleware/HandleInertia/Requests<br>
              In resources/js/types/index.d.ts create interface Flash<br>
              Import sonner toaster from shadcn component into resources/js/layouts/app-layout.tsx<br>
              Display toaster into resources/js/pages/posts/index.tsx<br>

            //- Access by SSH to VPS
            p.
              Access by SSH to VPS by password<br>
              Authenticated like user for installed Laravel on VPS<br>
            code su - user
            p To see domain folder with installed project
            code cd htdocs 
            p Come into Laravel files
            code cd domainfolder
            p In domainfolder generate ssh key for VPS
            code ssh-keygen -t ed25519 -C "my@email.com"   // leave passphrase empty
            p Read VPS ssh public key
            code cat ~/.ssh/id_ed25519.pub   // copy the key
            p.
              In github repository open settings>Deploy keys>Add deploy key, paste VPS ssh public key (Allow write server)<br>
              Move installed Laravel files into tmp folder<br>
            code  mv domainfolder/ tmp
            p Clone Laravel files from private repository github by ssh into domainfolder<br>
            code git clone githubUrl domainfolder
            p In domainfolder copy .env file
            code cp .env.exemple .env
            p In domainfolder
            code composer install
            p Create sqlite database
            code php artisan migrate
            p.
              Create mysql database on VPS server panel and change database setting into .env for mysql<br>
              Apply data into mysql database
            code php artisan migrate
            p Generate app key
            code php artisan key:generate --ansi
            p Install as root nodejs on VPS
            a(href="https://nodejs.org/en/download") Nodejs
            p In htdocs/domainfolder run as user
            pre
              code.
                npm install
                npm run build
            p Fill database fake data
            code php artisan migrate:fresh --seed
            p Test app in browser
            
            //- Resources
            a(href="http://laravel.com/docs/12.x/queues#supervisor-configuration") automaticaly ssr on VPS install as root
            a(href="https://youtu.be/lqKbDEBa2B0") youtube tutorial at 5:20:00
            p In conf file change command to 
            code artisan inertia:start-ssr
            p In .env file
            pre
              code.
                APP-NAME=Appname
                APP_ENV=prod
                APP_DEBUG=false
                APP_URL=Appurl
            p change mail settings
            p.
              Create localy .github/workflows/deploy.yml with action for github<br>
              Github repository>settings>Secrets and variables>Actions
              Create new secret - see youtube tutorial 5:41:30

          //- Rename table
          details
            summary Rename table
            p.
              в файле config/queue.php меняю название таблиц по умолчанию<br>
              к названию таблицы добавляю слово queue
            pre
              code.
                'database' => [
                  'driver' => 'database',
                  'connection' => env('DB_QUEUE_CONNECTION'),
                  'table' => env('DB_QUEUE_TABLE', 'queued_jobs'),
                  'queue' => env('DB_QUEUE', 'default'),
                  'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
                  'after_commit' => false,
                ],

                'batching' => [
                  'database' => env('DB_CONNECTION', 'sqlite'),
                  'table' => 'queued_job_batches',
                ],
                'failed' => [
                    'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
                    'database' => env('DB_CONNECTION', 'sqlite'),
                    'table' => 'queued_failed_jobs',
                ], 
            p.
              в папке database/migrations/<br>
              к названию файла по умолчанию добавляю слово queue
            code 0001_01_01_000002_create_queued_jobs_table.php
            p в нутри файлa к названиям таблиц добавляю слово queue
            pre
              code.
                Schema::create('queued_jobs', function (Blueprint $table) {
                  ...
                Schema::create('queued_job_batches', function (Blueprint $table) {
                  ...
                Schema::create('queued_failed_jobs', function (Blueprint $table) {
            p удаляю старые файлы и создаю новые c учётом изменений
            code php artisan migrate:fresh
            p чтобы внести изменения в базу данных:
            code php artisan migrate
