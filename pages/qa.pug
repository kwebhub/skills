extends templates/layout

block menu
  .menu__inner
    //- Practice
    details
      summary.menu__submenu Practice
      p.
        <dfn>Check-list</dfn>
        - Соответствие макету. Расположение элементов, кнопки, слайдеры работают.<br>
        - Кроссбраузерность. Открыть в разных браузерах.<br>
        - Валидность. html и css проверить в валидаторах, js - проверить в консоле браузера.<br>
        - Адаптивность. Нормально отображаются на смартфоне, планшете и т.д.<br>
        - Оптимизация. Сжать картинки, файлы и т.д. для ускорения загрузки.<br>
        - Сборка Gulp<br>
        - Минимальная вложенность css<br>
        - Проверить переполняемостью контента текст и картинки (отсутствие, меньше, больше).<br>
        - SVG, Webp, Avif, через тег picture, lazy load.<br>
        - Объединенные в спрайты иконки<br>
        - Семантика и доступность.<br>
        - Методология (БЭМ).<br>
        - Теги alt у картинок, фавикон, title.<br>
        - Закоментированный код удалить.<br>
        - У текстого поля убрать ресайз. Стилизовать ввод текста.<br>
        - Отступы между элементами марджином.<br>
        - форматы шрифтов — WOFF 2.0 и WOFF.<br>
        - link rel="preload" для ускорения загрузки шрифтов браузером.<br>
        <br>
        PageSpeed Insights от Google, GTMetrix<br>
        Page Ruler<br>
        PerfectPixel от Well Done Code<br>
        TinyImage Compressor<br>
        Kraken<br>
        JPEGmini<br>
        I love IMG<br>
      a(src="https://tinypng.com/") TinyPNG<br>
      a(src="https://squoosh.app/") Squoosh<br>
      a(src="https://w3techs.com/") Рейтинг технологий<br>
      a(src="https://caniuse.com/") Возможность применения технологий<br>
      a(src="https://www.browserstack.com/") Кроссбраузерность<br>
      a(src="https://validator.w3.org/") Валидатор HTML
      a(src="https://www.softwaretestinghelp.com/") Примеры и образцы
      img(src="./img/qc/QCways.png" alt="")

    //- Life Cycles
    details
      summary.menu__submenu Life Cycles
      p STLC входит в SDLC.

      //- STLC
      details
        summary STLC
        table
          caption STLC - Software Test Life Cycle
          thead
            tr
              th Этап
              th Активность
              th Документы
          tbody
            tr
              td Планирование
              td.
                Определяем список действий (активностей), которые нужно сделать, чтобы проверить
                максимально все возможные варианты работы продукта исходя имеющихся из времени и средств.<br>
                Каждое дествие имеет свою цель, задачи, методы, ограничения.<br>
                Для каждого действия указывается время выполнения в общем графике тестирования.<br>
                На примере холодильника:<br>
                - проверить корпус на целостность, вес и размеры<br>
                - проверить работу компрессора и электроники<br>
                - проверить гирметичность и работу дверей<br>
                и т.д.
              td <dfn>План тестирования</dfn> <br>(Test Plan)
            tr
              td Анализ
              td.
                В процессе анализа тестирования прописываем чему должны быть равны результаты тестов.<br>
                Т.е. описываем что мы ожидаем получить от каждого теста.<br>
                На примере холодильника:<br>
                - включенный холодильник должен создать температуру внутри себя равной температуре установленной на его табло.<br>
                И так прописать по каждому тесту.
              td <dfn>Дефект</dfn> <br>(Defect)
            tr
              td Проектирование и реализация
              td.
                Во время проектирования тестов прописываем шаги и ожидаемый результат по каждому тесту
                 и группируем их по общим начальным условиям для выполнения или по одинаковым шагам выполнения.<br>
                На примере холодильника объединяем по общим начальным условиям:<br>
                - чтобы проверить создаёт ли холодильник температуру такую как на табло, нужно написать четыре теста:<br>
                1. - проверить работу самого табло - правильно оно отображает установку температуры;<br>
                2. - проверить работу компрессора - даёт ли от необходимый поток охладителя;<br>
                3. - проверить работу охладителя - есть ли он в нужном качестве и количестве;<br>
                4. - проверить температуру внутри холодильника - равно ли значение на градуснике значению на табло.<br>
                <br>
                Во время реализации тестов создается и/или подготавливается необходимое тестовое обеспечение для 
                выполнения тестов.<br>
                На примере холодильника:<br>
                - чтобы проверить создаёт ли холодильник температуру такую как на табло, нужно:<br>
                1. - прибор, чтобы проверить электронику для работы табло;<br>
                2. - прибор, чтобы проверить какое давление создаёт компрессор;<br>
                3. - прибор для замера качества и количества охладителя;<br>
                4. - термометр для измерения температуры внутри холдильника;<br>
                По каждому тесту пишем список шагов (чек-лист) и, если необходимо, оформляем тестовые сценарии и тестовые данные.
              td.
                - <dfn>Чек-листы</dfn> <br>(Check lists) <br>
                - <dfn>Тестовые данные</dfn> <br>(Test Data) <br>
                - <dfn>Тестовые сценарии</dfn> <br>(Test Cases) <br>
                - <dfn>Наборы тестовых сценариев</dfn> <br>(Test Suites)
            tr
              td Выполнение
              td.
                Во время выполнения тестов, наборы тестов запускаются по расписанию выполнения тестов.<br>
                В чек-листах отмечается выполнение прописанных шагов и полученный результат.<br>
                В Дефекте по каждому тесту напротив ожидаемого результата указывается полученный
                 и отмечается выполнен тест или провален.
              td.
                - <dfn>Чек-листы</dfn> <br>(Check lists) <br>
                - <dfn>Дефект</dfn> <br>(Defect)
            tr
              td Завершение
              td.
                Описываем в итоговом отчёте условия и ход выполнения действий из плана тестирования с комментариями и пояснениями.<br>
                В запросе на улудшение указываем что лучше добавить или переделать в продукте с точки зрения удобства пользования.<br>
              td.
                - <dfn>Итоговый отчет</dfn> <br>(Test Summary Report) <br>
                - <dfn>Запросы на улучшение</dfn> <br>(Change Requests)
            tr
              td Мониторинг и контроль
              td.
                Мониторинг тестирования - это непрерывное сравнение фактического хода работы с планом тестирования.<br>
                Контроль тестирования - это принятие мер, для достижения целей плана тестирования.<br>
                План тестирования может быть обновлен.
              td.
                - <dfn>Отчет о ходе тестирования</dfn> <br>(Test Progress Report) <br>
                - <dfn>Итоговый отчет</dfn> <br>(Test Summary Report)

      //- SDLC
      details
        summary SDLC
        img(src="./img/qc/SDLC.png" alt="SDLC")
        table
          caption Software Develop Life Cycle
          thead
            tr
              th Step
              th Executor
              th Product
              th Comment
              th QA
          tbody
            tr
              td Idea
              td Product Owner (PO)
              td Idea
              td Владелец продукта озвучивает идею
              td.
                Сможем ли мы это протестировать? <br>
                Зачем это нужно? <br>
                Существует ли более простая альтернатива? <br>
            tr
              td Analysis
              td.
                Business Analyst (BA), <br>
                System Analyst (SA)
              td.
                Software Requirements Specification (SRS), <br>
                Business Requirements Document (BRD), <br>
                User story
              td Бизнес аналитик формирует бизнес требования
              td Все ли варианты развития событий учтены?
            tr
              td.
                Architecture, <br>
                Design
              td.
                System Architect, <br>
                Leads
              td Documentation
              td Архитектор составляет технические требования на основании бизнес требований.
              td
            tr
              td Development
              td Developers
              td Build
              td Разработчики получают каждый свою часть продукта для разработки
              td
            tr
              td Testing
              td QC
              td.
                Reports, <br>
                Bug Reports
              td Выполнение тестов
              td 
            tr
              td Bug fixing
              td Developers
              td Validation
              td Разработчики исправляют баги
              td(rowspan="3") Проверка снова и снова
            tr
              td Validation
              td.
                QA, <br>
                DevOps
              td.
                Release condidate build, <br>
                Acceptance Testing
              td Владелец продукта тестирует продукт
              td
            tr
              td Release
              td DevOps
              td Production
              td 
              td 
            tr
              td Support
              td Developers
              td Feedback from customers
              td(style="text-align:left; padding-left: .9375rem;").
                - Успокоить пользователя. <br>
                - Пофиксить или передать проблему разработчикам. <br>
                - Агрегировать и систематизировать пожелания потребителей.
              td(style="text-align:left; padding-left: .9375rem;").
                Уровни поддержки: <br>
                L1 - первый контакт с потребителем, попытка решить проблему без специальных знаний. <br>
                L2 - более глубокие технические знания для устранения или обхода проблемы. <br>
                L3 - разработчики вносят изменения в код программы.
            tr
              td(colspan="5") Death
                
    //- Models
    details
      summary.menu__submenu Models

      //- Waterfall
      details
        summary Waterfall
        p.
          <dfn>Каскадная модель</dfn> <br>(или водопадная – waterfall)<br>
          Самая старая и известная модель разработки. <br>
          - Каждый этап разработки, соответствующий стадии жизненного цикла ПО, продолжает предыдущий. <br>
          - Для того, чтобы перейти на новый этап, мы полностью должны завершить текущий. <br>
          - Предусматривает Quality Gate при переходе с этапа на этап. <br>
          - <dfn>Quality Gate</dfn> - сверка результата этапа с требованиями под розпись.<br>
          - Много правил и ритуалов.<br>
          - За каждым в команде закреплена его роль.<br>
          <br>
          <b>Применяется</b>: <br>
          - В проектах с четко определенными требованиями, для которых не предусматривается их изменений в процессе разработки. <br>
          - Для проектов, которые мигрируют с одной платформы на другую. То есть, требования остаются те же, меняется только 
          системное окружение и/или язык программирования. <br>
          - Очень важно качество. <br>
          - Сроки не критичны. <br>
          - Есть достаточно денег.<br>
        img(src="./img/qc/waterfall.png" alt="")
        p.
          <b>Достоинства</b>:<br>
          - Полное документирование каждого этапа.<br>
          - Простая в организации.<br>
          - Стабильность требований.<br>
          - Четкое планирование сроков и стоимости.<br>
          - Прозрачность процессов для заказчика<br>
          <br>
          <b>Недостатки</b>:<br>
          - Необходимость утверждения полного объема требований к системе еще на первом этапе.<br>
          - Увеличение затрат средств и времени в случае необходимости изменения требований.<br>
          - В случае внесения изменений в требования прийдется вернуться к первому этапу и всё сначала.<br>
          - Нет возможности узнать возможный результат проекта.<br>

      //- V-модель
      details
        summary V-модель
        img(src="./img/qc/V-model.jpg" alt="")
        img(src="./img/qc/V-model.png" alt="")
        p.
          <dfn>V-модель</dfn>
          Улучшенная версия классической каскадной модели. <br>
          - Компромис между качеством и гибкостью. <br>
          - Не много правил и ритуалов. <br>
          - На каждом этапе происходит контроль текущего процесса, для того чтобы убедится в возможности перехода на следующий уровень. <br>
          - Возможно совмещение или сокращение ролей в команде. <br>
          <br>
          <b>Применяется</b>:<br>
          - Требования меняются редко. <br>
          - Качество важно, но не критично. <br>
          - В проектах, в которых существуют временные и финансовые ограничения; <br>
          - Для задач, которые предполагают более широкое, по сравнению с каскадной моделью, тестовое покрытие. <br>
          <br>
          <b>Software testing levels</b>:
          - Unit testing<br>
          - Integration testing<br>
          - System testing<br>
          - Acceptance testing<br>
          <br>
          <b>Достоинства</b>:
          - Планирование тестирования и верификация системы производятся на ранних этапах<br>
          - Улучшенный, по сравнению с каскадной моделью, тайм-менеджмент<br>
          - Промежуточное тестирование<br>
          <br>
          <b>Недостатки</b>:
          - Недостаточная гибкость модели<br>
          - Недостаточный анализ рисков<br>
          - Нет работы с параллельными событиями и возможности динамического внесения изменений.<br>
      
      //- Итеративная / Инкрементальная
      details
        summary Итеративная / Инкрементальная
        img(src="./img/qc/Incremental.png" alt="")
        img(src="./img/qc/Int.png" alt="")
        p.
          <dfn>Итеративная и Инкрементальная модели</dfn><br> - не предполагают полного объема требований для начала работ над продуктом. <br>
          Применяется когда: <br>
          - Когда основные требования к системе четко определены и понятны, 
          в то же время некоторые детали могут дорабатываться с течением времени. <br>
          - Разработка программы может начинаться с требований к части функционала, которые могут впоследствии дополняться
          и изменяться. <br>
          - Есть несколько рисковых функциональностей или целей. <br>
          - Требуется ранний вывод продукта на рынок. <br>
          - Процесс повторяется, обеспечивая создание новой версии продукта для каждого цикла. <br>
          - При понимании и создании первой версии, вторая команда может уже анализировать и планировать вторую версию. <br>
          - Создание версий внахлёст.<br>
          <br>
          <b>Достоинства</b>:<br>
          - Ранний выход на рынок.<br>
          - Гибкость – готовность к изменению требований на любом этапе разработки.<br>
          - Каждая итерация – маленький этап, для которого тестирование и анализ рисков обеспечить проще, чем для всего жизненного цикла продукта<br>
          <br>
          <b>Недостатки</b>:<br>
          - Каждая фаза – самостоятельна, отдельные итерации не накладываются.<br>
          - Могут возникнуть проблемы с реализацией общей архитектуры системы, поскольку не все требования известны к началу проектирования.<br>

      //- Спиральная
      details
        summary Спиральная
        img(src="./img/qc/spiral.png" alt="")
        p.
          Спиральная модель похожа на инкрементную, но с акцентом на анализ рисков. <br>
          Она хорошо работает для: <br>
          - решения критически важных бизнес-задач <br>
          - когда неудача несовместима с деятельностью компании <br>
          - когда важен анализ рисков и затрат. <br>
          - в крупных долгосрочных проектах с отсутствием четких требований или вероятностью их динамического изменения. <br>
          - при разработке новой линейки продуктов.<br>
          <br>
          <b>Последовательность</b>:<br>
          - Сначала выпускаем версию с минимальным функционалом. <br>
          - Каждая последующая версия разработки использует предыдущую. <br>
          - Создание версий последовательно. <br>
          - Быстрый выпуск.<br>
          <br>
          <b>Достоинства</b>:<br>
          - Улучшенный анализ рисков.<br>
          - Хорошая документация процесса разработки.<br>
          - Гибкость – возможность внесения изменений и добавления новой функциональности даже на относительно поздних этапах.<br><br>
          <br>
          <b>Недостатки</b>:<br>
          - Может быть достаточно дорогой в использовании.<br>
          - Управление рисками требует привлечения высококлассных специалистов.<br>
          - Успех процесса в большой степени зависит от стадии анализа рисков.<br>

    //- Agile
    details
      summary.menu__submenu Agile
      img(src="./img/qc/Agile.png" alt="")
      p.
        Agile - Это не модель, а методы, фреймворки и практики! <br>
        Гибкая методология разработки (англ. Agile software development),<br>
        <br>
        <em>agile-методы</em> — обобщающий термин для набора подходов и практик,
        основанных на 4 ценностях и 12 принципах Манифеста.
      
      //- Agile Manifesto
      details
        summary.menu__submenu_lv1 Agile Manifesto

        //- Values
        details
          summary Values
          ol 
            li Люди и взаимодействие <b>важнее</b> процессов и инструментов
            li Работающий продукт <b>важнее</b> исчерпывающей документации
            li Сотрудничество с заказчиком <b>важнее</b> согласования условий контракта
            li Готовность к изменениям <b>важнее</b> следования первоначальному плану<br>
          p Не отрицая важности того, что справа, больше ценим то, что слева.

        //- Agile Principles
        details
          summary Agile Principles
          ol 
            li Наивысшим приоритетом является удовлетворение потребностей заказчика, благодаря регулярной и ранней поставке ценного программного обеспечения.
            li Изменение требований приветствуется, даже на поздних стадиях разработки
            li Работающий продукт следует выпускать как можно чаще, с периодичностью от пары недель до пары месяцев
            li На протяжении всего проекта разработчики и представители бизнеса должны ежедневно работать вместе
            li.
              Над проектом должны работать мотивированные профессионалы.<br>
              Чтобы работа была сделана, создайте условия, обеспечьте поддержку и полностью доверьтесь им.
            li Непосредственное общение является наиболее практичным и эффективным способом обмена информацией как ссамой командой, так и внутри команды
            li Работающий продукт — основной показатель прогресса
            li Инвесторы, разработчики и пользователи должны иметь возможность поддерживать постоянный ритм бесконечно
            li Постоянное внимание к техническому совершенству и качеству проектирования повышает гибкость проекта
            li Простота — искусство минимизации лишней работы — крайне необходима
            li Самые лучшие требования, архитектурные и технические решения рождаются у самоорганизующихся команд
            li Команда должна систематически анализировать возможные способы улучшения эффективности и соответственно корректировать стиль своей работы

      //- Наиболее популярные
      details
        summary.menu__submenu_lv1 Наиболее популярные фреймворки и практики

        //- Kanban
        details
          summary Kanban
          p.
            Kanban — с помощью карточек и столбцов на доске Kanban команды могут понять, на каком этапе находятся задачи, отслеживать их выполнение и перераспределять нагрузку.<br>

        //- Extreme Programming (XP)
        details
          summary Extreme Programming (XP)
          p.
            <b>Пять ценностей XP</b>:<br>
            - общение<br>
            - простота<br>
            - обратная связь<br>
            - смелость<br>
            - уважение<br>
            <br>
            <b>Практики</b>:<br>
            - Игра «Планирование»<br>
            - Маленькие релизы<br>
            - Метафора<br>
            - Простой дизайн<br>
            - Тестирование<br>
            - Рефакторинг<br>
            - Парное программирование<br>
            - Коллективная собственность<br>
            - Непрерывная интеграция<br>
            - 40-часовая неделя<br>
            - Клиент на месте<br>
            - Стандарт кодирования<br>

        //- Scrum
        details
          summary Scrum
          img(src="./img/qc/Scrum.png" alt="")
          a(href="https://scrumguides.org/") Scrum – это НЕ методология, а фреймворк!
          p.
            <dfn>Roles:</dfn> <br>
            <b>PO</b> - product owner <br>
            <b>SM</b> - scrum master <br>
            <b>Team</b><br>
            <br>
            <b>PB</b> - product backlog - требования (приоритизированный список задач) к продукту <br>
            <b>PO</b> приоритизирует задачи в PB<br>
            <br>
            <dfn>Эстимация</dfn> - оценка задач в: <br>
            <b>часах, днях</b> <br>
            <b>story point</b> <br>                                            
            <em>1 story point</em> - это одна элементарная задача, с которой сравниваются остальные задачи. <br>                                            
            <dfn>capacity</dfn> - количество story point в спринте. <br>
            <dfn>velocity</dfn> - производительность команды, т.е. сколько story point может выполнить за спринт<br>
            <br>
            <dfn>Cессии спринта</dfn>: <br>
            <em>planing</em> - в начале; формируется SB - sprint backlog, т.е. выбираем из PB задачи для спринта <br>
            <em>stand up (Daily Scrum)</em> - каждый день: что делал, что буду делать, какие вижу риски <br>
            <em>retro (Sprint Retrospective)</em> - sprint retro - пересмотреть спринт, всё ли сделали и всё ли правильно сделали <br>
            <em>demo (Sprint Demonstration)</em> - sprint demo - показать PO что сделали за спринт <br>
            <em>review (Sprint Review)</em> - sprint review - что было хорошо, что плохо <br>
            <dfn>Grooming</dfn> - это митинг для пересмотра PB. Организуется PO-ром.<br>
            <br>
            <dfn>Спринт (Sprint)</dfn> — итерация в скраме, в ходе которой создается инкремент бизнес-продукта. <br> 
            Жестко фиксирован по времени. Длительность одного спринта от 1 до 4 недель. <br>
            Чем короче спринт, тем более гибким является процесс разработки, релизы выходят чаще, быстрее поступают отзывы от потребителя, меньше времени тратится на работу в неправильном направлении<br>
            <dfn>Инкремент продукта</dfn> — это готовый продукт в конце спринта. Показывают заинтересованным на демонстрации, чтобы собрать отзывы и решить, что делать с продуктом дальше<br>
            <br>
            <em>Scrum - Роли</em><br>
            <dfn>Владелец Продукта (Product Owner)</dfn> полностью понимает его ценность для бизнеса.<br>
            Этот человек доносит потребности клиента/заказчика до Команды разработки, но не отвечает за техническую сторону процесса.<br>
            Владелец Продукта также отвечает за пользовательские истории и определяет их приоритетность<br>
            <br>
            <dfn>Скрам-мастер (Scrum Master)</dfn> помогает Владельцу Продукта и Команде разработки выполнять работу без препятствий и отвлекающих факторов.<br>
            Вся коммуникация людей вне команды с Командой разработки проходит через Скрам-Мастера<br>
            <br>
            <dfn>Команда разработки (Scrum team)</dfn> численностью 5-9 человек выполняет все технические задачи по разработке.<br>
            Команда кросс функциональна и отвечает за анализ, дизайн, программирование, тестирование, техническую коммуникацию и т. д.<br>
            В этом она руководствуется пользовательскими историями и их приоритетностью<br>
            <br>
            <em>Scrum - Встречи</em>:<br>
            <dfn>Ежедневный Скрам (Daily Scrum)</dfn> — Скрам-мероприятия, которые проходят ежедневно во время спринтов.<br>
            Они короткие (до 15 минут) и предназначены для того, чтобы спланировать дневное расписание Команды разработки.<br>
            Здесь можно обсудить рабочие сложности или прояснить пользовательские истории.<br>
            Встреча обязательна для Команды разработки в полном составе, каждый член команды рассказывает что сделал вчера и что быдет делать сегодня.<br>
            Скрам-мастер может на ней присутствовать<br>
            <br>
            <dfn>Ретроспектива Спринта (Sprint Retrospective)</dfn> - Окончание спринта. Пересмотр Пересмотр всего спринта, что планировалось, что сделано и как сделано.<br>
            <br>
            <dfn>Демонстрация Спринта (Sprint Demonstration)</dfn> — демонстрация действующего продукта, разработанного во время спринта.<br>
            Это мероприятие проходит в конце спринта и предназначено в первую очередь для того, чтобы в подробностях показать достигнутое Заказчикам<br>
            <br>
            <dfn>Обзор Спринта (Sprint Review)</dfn> — это своего рода вскрытие, обсуждение того, как команда справилась во время спринта и как можно повысить качество её работы в будущем<br>
            <br>
            <em>Scrum - Артефакты</em>:<br>
            <dfn>Журнал задач проекта (Product Backlog)</dfn> — все необходимые действия, связанные с пользовательской и технической сторонами проекта<br>
            <br>
            <dfn>Журнал задач спринта (Sprint Backlog)</dfn> – совокупность всех задач, которые нужно выполнить за итерацию спринта.<br>
            Их выводят из журнала задач продукта во время Планирования Спринта.<br>
            <br>
            <dfn>История пользователя (User Story)</dfn> — требуемую бизнес-функциональность, которую добавляют в бэклог, часто называют историей.<br>
            <br>Зачастую User Story имеет следующую структуру: <br>
            «Будучи пользователем 'тип пользователя' я хочу сделать 'действие', чтобы получить 'результат'».<br>
            Такая структура удобна тем, что понятна как разработчикам, так и заказчикам. <br>
            User Story - это заголовок для кретериев приемки (Acceptance Criteria). <br>
            Одна функциональность - одно User Story<br>
            <br>
            <dfn>Очки за пользовательскую историю (Story Points)</dfn> — Абстрактная метрика оценки сложности истории, которая не учитывает затраты в человеко-часах.<br>
            Обычно используют одну из следующих шкал: <br>
            - ряд Фибоначчи (1,2,3,5,8,13,21,34,55);<br>
            - линейную шкалу (1,2,3,4 ... n);<br>
            - степень двойки (1,2,4,8 ... 2n);<br>
            - размеры одежды (XS, S, M, L, XL) <br>
            <br>
            <dfn>Диаграмма сгорания задач (Burndown chart)</dfn> — Диаграмма, демонстрирующая количество сделанной и оставшейся работы относительно времени на разработку проекта. <br>
            Данные диаграммы необходимо ежедневно обновлять, чтобы в реальном времени показывать подвижки и издержки в работе над спринтом и проектом, доступные для всех членов SCRUM-команды: скрам-мастера и скрам-владельца продукта. <br>
            Диаграмма сгорания работ для спринта — показывает, сколько задач сделано и сколько еще остается сделать в текущем спринте

        //- Lean
        details
          summary Lean
          p.
            Основатель Toyota - Киитиро Тойода разработал методологию для экономии ресурсов и устранения потерь.<br>
            Методология бережливого производства опирается на два столпа, оптимизация производства и совершенствование продукта.<br>
            <br>
            <b>Принципы методологии Lean</b>:<br>
            - Определите ценность<br>
            - Составьте карту потока создания ценности<br>
            - Создайте поток<br>
            - Установить притяжение<br>
            - Стремитесь к совершенству<br>

        //- FDD
        details
          summary Feature Driven Development (FDD)
          p.
            Организует разработку программного обеспечения вокруг улучшения фичи. <br>
            Фичи в контексте FDD больше похожи на пользовательские истории в Scrum.<br>
            <br>
            <b>Жизненный цикл проекта</b>:<br>
            - Разработать общую модель<br>
            - Создайте список функций<br>
            - Планирование по функциям<br>
            - Дизайн по функциям<br>
            - Создавать по функциям<br>

        //- SAFe
        details
          summary Scaled Agile Framework (SAFe)
          p Набор шаблонов организации рабочих процессов для крупных предприятий.

    //- Quality
    details
      summary.menu__submenu Quality
      p.
        9 сентября - день тестировщика. <br>
        09.09.1947 - первый баг. <br>
        <dfn>Качество</dfn> - это степень соответствия системы, компонента или процесса, явным и неявным требованиям, в рамках установленного срока и бюджета.

      //- Характеристики качества
      details
        summary.menu__submenu_lv1 Характеристики качества

        //- Функциональность
        details
          summary Функциональность
          p.
            <dfn>Функциональность</dfn> - способность ПО решать явные и неявные задачи пользователя, при заданных условиях<br>
            - Функциональная исправимость.<br>
            - Соответствие стандартам.<br>
            - Функциональная совместимость.<br>
            - Безопасность.<br>
            - Точность.
          br
          p.
            <dfn>Функциональная полнота</dfn> - способность ПО покрывать все задачи и цели пользователей без сторонней помощи.<br>
          br
          p.
            <dfn>Функциональная правильность</dfn>:<br>
            - Способность продукта обеспечивать правильные результаты с необходимой степенью точности. <br>
            - Например у банковского ПО точность должна быть до копейки.
          br
          p.
            <dfn>Функциональная целесообразность</dfn> - насколько это ПО нужно для выполнения задач и достижения целей.

        //- Производительность
        details
          summary Производительность
          p.
            <dfn>Производительность</dfn> - cпособность ПО выполнять то, что от него требуется с выделенными ресурсами, временем и другими обозначенными условиями<br>
            <dfn>Время выполнения</dfn> - время за которое ПО откликается, пропускная способность и скорость выполнения задачи<br>
            <dfn>Использование ресурсов</dfn> - на сколько ресурсы потребляемые в работе, соответствуют указанным в требованиях.<br>
            <dfn>Емкость</dfn> - на сколько количественные показатели (какой объём данных обрабатывает, сколько пользователей) соответсвуют лимитам производительности заявленным в требованиях.<br>

        //- Удобство использования
        details
          summary Удобство использования
          p.
            <dfn>Удобство использования</dfn> - возможность легкого понимания, изучения, использования и привлекательности ПО для пользователя<br>
            - Удобство изучения. <br>
            - Понятность. <br>
            - Удобство и простота использования.
          br
          p.
            <dfn>Определимость пригодности</dfn> - Как быстро пользователи могут определить подходит ли система для выполнения их целей и задач<br>
            <dfn>Обучаемость</dfn> - Насколько быстро новый пользователь может разобраться с системой и использовать максимальное количество ее возможностей (подсказки, инструкции)<br>
            <dfn>Управляемость</dfn> - Насколько интерфейс системы удобен для выполнение задач пользователя<br>
            <dfn>Защищенность от ошибок пользователя</dfn> - Насколько сильно система защищает пользователей от ошибок (подсказки и валидация действий пользователя)<br>
            <dfn>Эстетика пользовательского интерфейса</dfn> - Насколько привлекательный для пользователя дизайн<br>

        //- Совместимость
        details
          summary Совместимость
          p.
            <dfn>Совместимость</dfn> - способность системы обмениваться информацией с другими системами или выполнять свои функции используя совместно аппаратную или програмную среду<br>
            <br>
            <dfn>Interoperability</dfn>:<br>
            - Способность системы обмениваться информацией с другими системами, а также использовать полученную информацию<br>
            - Передаваемая нашим ПО информация хорошо воспринимается другим ПО.<br>
            <br>
            <dfn>Сосуществование</dfn>:<br>
            - Способность системы эффективно выполнять свои задачи при совместном использовании общей среды и ресурсов с другими продуктами без вредного воздействия на любой другой продукт. <br>
            - Наше ПО не влияет на работу другого ПО и наоборот.

        //- Надежность
        details
          summary Надежность
          p.
            <dfn>Надежность</dfn> - Способность ПО выполнять требуемые задачи в обозначенных условиях на протяжении заданного промежутка времени или указанное количество операций<br>
            - Завершенность. <br>
            - Восстанавливаемость. <br>
            - Устойчивость к отказам.<br>
            <br>
            <dfn>Доступность</dfn> - Доступность системы, продукта или компонента, когда это необходимо для использования<br>
            <dfn>Отказоустойчивость</dfn> - Способность системы работать, как предполагалось, несмотря на наличие аппаратных или программных сбоев<br>
            <dfn>Восстанавливаемость</dfn> - Насколько быстро система может восстановить данные и свою работоспособность при сбоях<br>

        //- Безопасность
        details
          summary Безопасность
          p.
            <dfn>Безопасность</dfn> - Способность системы обеспечивать доступ только к тем данным, которые разрешены для пользователя или других систем в соответствии с их правами<br>
            <dfn>Конфиденциальность</dfn> - Способность системы предоставлять доступ к данным только тем, кто имеет на это право<br>
            <dfn>Целостность</dfn> - Способность системы предотвращать несанкционированный доступ или модификацию данных<br>
            <dfn>Ответственность</dfn> - Способность отслеживать и идентифицировать инициатора любого действия<br>
            <dfn>Подлинность</dfn> - Степень, в которой личность субъекта или ресурса может быть доказана как заявленная<br>

        //- Сопровождаемость
        details
          summary Сопровождаемость
          p.
            <dfn>Сопровождаемость</dfn> - легкость, с которой ПО может анализироваться, тестироваться, изменяться для исправления дефектов, для реализации новых требований, для облегчения дальнейшего обслуживания и адаптироваться к имеющемуся окружению<br>
            - Стабильность. <br>
            - Анализируемость. <br>
            - Контролепригодность. <br>
            - Изменяемость.<br>
            <br>
            <dfn>Модульность</dfn>:<br>
            - Степень, в которой система состоит из отдельных компонентов, так что изменение одного компонента оказывает минимальное влияние на другие компоненты. <br>
            - Возможность многократного использования.<br>
            <br>
            <dfn>Анализируемость</dfn> - Насколько просто оценить влияние потенциального изменения на другие компоненты системы<br>
            <dfn>Модифицируемость</dfn> - Насколько легко добавить или изменить функционал ПО.<br>
            <dfn>Тестируемость</dfn> - Насколько просто установить критерии тестирования и выполнять тестирование<br>

        //- Переносимость
        details
          summary Переносимость
          p.
            <dfn>Переносимость</dfn> - характеризует ПО с точки зрения легкости его переноса из одного окружения (software/hardware) в другое.<br>
            - Удобство установки. <br>
            - Заменяемость. <br>
            - Совместимость.<br>
            <br>
            <dfn>Адаптивность</dfn> - Способность системы адаптироваться к разным окружениям и средам<br>
            <dfn>Устанавливаемость</dfn> - Способность системы разворачиваться и устанавливаться в различных окружениях и средах<br>
            <dfn>Заменяемость</dfn> - Способность системы заменять другие системы со схожей функциональностью<br>

      //- Качества тестировщика
      details
        summary.menu__submenu_lv1 Качества тестировщика
        p. 
          - Саморазвитие<br>
          - Внимательность<br>
          - Любопытсво<br>
          - Подозрительность<br>
          - Поставить себя на место пользователя<br>
          - Небезразличие<br>
          - Исследовательский склад ума<br>
          - Логическое мышление<br>
          - Умение концентрироваться<br>
          - Аналитические способности<br>
          - Визуализация<br>
          - Креативность<br>
          - Изобретательность<br>
          - Коммуникабельность<br>
          - Ответственность<br>
          - Инициативность<br>
          - Упорство<br>
          - Трудолюбие<br>
          - Увлечённость<br>
          - Настойчивость<br>
          <br>
          <dfn>Цель тестировщика</dfn> - делать продукт лучше, а людей счастливее. <br>
          <dfn>Задача тестировщика</dfn> - находить баги. <br>
          <dfn>Тестировщик оценивает</dfn> и измеряет качество.

      //- Bug
      details
        summary.menu__submenu_lv1 Bug
        p.
          Люди совершают ошибки (<b>Error</b>)<br>
          <dfn>Ошибка</dfn> - человеческое действие, которое приводит к неправильному результату (<b>ISTQD</b>)<br>
          Ошибка в коде или архитектуре программы - это дефект (<b>Defect</b>)<br>
          <dfn>Дефект</dfn> - несовершенство или недостаток в рабочем продукте, если он не соответствует его требованиям или спецификациям (<b>ISTQD</b>)<br>
          Дефект может привести к отказу (<b>Failure</b>)<br>
          <dfn>Отказ</dfn> - событие, при котором компонент или система не выполняет требуемое действие в заданных рамках (<b>ISTQD</b>)<br>
        img(src="./img/qc/def.png" alt="")
        br
        p.
            Пример дефектов:<br>
            - Программа не делает чего-то, что она должна делать согласно техническим требованиям<br>
            - Программа делает что-то, чего она не должна делать согласно техническим требованиям<br>
            - Программа не делает чего-то, о чем не говорится в требованиях, однако подразумевается, что она должна делать это<br>
            - Программа трудна для понимания, неудобна в использовании<br>
        img(src="./img/qc/DLC.png" alt="")

      //- QM
      details
        summary.menu__submenu_lv1 QM
        p.
          <dfn>QM</dfn> - Quality management = QA + QC<br>
          <dfn>QA</dfn> - Занимается вся команда, возможно с привлечением консультанта.<br>
          QA занимается Верификацией! <br>
          <dfn>QC</dfn> - Занимаються тестировщики. <br>
          QC занимается Валидацией! <br>              
          <dfn>Tester</dfn> - Выполнение тест-кейсов. Часть QC.

        //- Верификация
        details
          summary Верификация
          p.
            - Настраивает систему тестирования работы команды, пишет документацию. <br>
            - Определяет какую документацию будет делать команда, какие характеристики в приоритете и т.д. <br>
            - Проверка выполнения требований к процессу разработки ПО. <br>
            - Подтверждение на основе представления объективных свидетельств того, что установленные требования были выполнены<br>
            - Делаем ли мы продукт ПРАВИЛЬНО?<br>
            <br>
            <em>QA - Quality Assurance:</em> <br>
            - гарантирует, что мы делаем правильные шаги в правильном направлении <br>
            - фокусируется на создании системы качества и привентирования дефектов <br>
            - имеет дело с процессом создания продукта <br>
            - на весь SDLC <br>
            - это процесс упреждения <br>
            <br>
            <b>Применяется к документации</b>:
            - Планы<br>
            - Требованиям<br>
            - Дизайну<br>
            - Коду<br>
            - Тест Кейсам<br>
            <br>
            <b>Основные активности</b>:
            - Reviews<br>
            - Walkthroughs<br>
            - Inspections<br>
          br
          img(src="./img/qc/Must know QA.JPG" alt="")
          img(src="./img/qc/Must know QA_.JPG" alt="")

        //- Валидация
        details
          summary Валидация
          p.
            - Тест-дизайн. Тест-аналитикa.<br>
            - Пишет тестовую документацию и анализирует результаты тестирования. <br>  
            - Проверка выполнения требований к продукту. <br>
            - Подтверждение на основе представления объективных свидетельств того, что требования, предназначенные для конкретного использования или применения, выполнены <br>
            - Делаем ли мы ПРАВИЛЬНЫЙ продукт?<br>
            - QС занимается Валидацией!<br>
            - Применяется к разрабатываемому продукту<br>
            - Основнае активность тестирование<br>
            <br>
            <em>QC - Quality Control:</em><br>
            - гарантирует, что результат нашей работы соответствует ожидаемому<br>
            - фокусируется на тестировании и обнаружении дефектов<br>
            - имеет дело с продуктом<br>
            - на этапе тестирования в SDLC<br>
            - это процесс исправления<br>

    //- Testing
    details
      summary.menu__submenu Testing
      p.
        <dfn>Тестирование</dfn> - процесс исследования, испытания продукта с целью проверки соответствия между реальным поведением и ожидаемым на конечном наборе тестов, выбранных определенным образом.
        Всегда перед тестированием спросить какие есть требования. <br>
        Если нет требований, то ищем требования похожего предмета тестирования, основываемся на общую практику и опыт пользователя. <br>
        Пишем свои требования. <br>
        Нефункциональное тестирование без требований не проводят. <br>
        Первым всегда выполняем <dfn>Smoke Testing</dfn> - проверяем самый основной функционал. <br>
        Всегда сначала пишем и выполняем позитивные тесты. <br>
        Приоритет составления (выполнения) тест-кейсов определяется вопросом: что мы теряем если оно не работает? <br>
        Чем более вероятен сценарий, тем более он приоритетен. <br>
        Так таковых видов тестирования нет. <br>
        Всё тестирование разделяется на уровни и типы тестирования.<br>
      img(src="./img/qc/testtype.png" alt="")

      //- Цели тестирования
      details
        summary Цели тестирования:
        p.
          - Повышение качества ПО<br>
          - Предотвращение появления дефектов<br>
          - Предоставление информации о качестве ПО конечному заказчику<br>

      //- Принципы тестирования
      details
        summary Принципы тестирования (парадигмы тестирования)
        p.
          <dfn>Тестирование демонстрирует наличие дефектов</dfn>: <br>
          Тестирование может показать, что дефекты присутствуют, но не может доказать, что их нет.<br>
          Тестирование снижает вероятность наличия дефектов, находящихся в программном обеспечении, но, даже если дефекты не были обнаружены, тестирование не доказывает его корректности<br>
          <br>
          <dfn>Исчерпывающее тестирование недостижимо</dfn>: <br>
          Полное тестирование с использованием всех комбинаций вводов и предусловий физически невыполнимо, за исключением тривиальных случаев.<br>
          Вместо попытки исчерпывающего тестирования должны использоваться анализ рисков, методы тестирования и расстановка приоритетов, чтобы сосредоточить усилия по тестированию<br>
          <br>
          <dfn>Раннее тестирование</dfn>: <br>
          Для нахождения дефектов на ранних стадиях, как статические, так и динамические активности по тестированию должны быть начаты как можно раньше в жизненном цикле разработки программного обеспечения<br>
          <br>
          <dfn>Кластеризация дефектов</dfn>: <br>
          Обычно небольшое количество модулей содержит большинство дефектов, обнаруженных во время тестирования перед выпуском, или отвечает за большинство эксплуатационных отказов <br>
          Принцип Парето: Из общего количества возможных тестов всегда необходимо выбирать 20% таких, которые найдут 80% всех багов<br>
          <br>
          <dfn>Парадокс пестицида</dfn>: <br>
          Если одни и те же тесты будут выполняться снова и снова, в конечном счете эти тесты больше не будут находить новых дефектов.<br>
          Для обнаружения новых дефектов может потребоваться изменение существующих тестов и тестовых данных, а также написание новых тестов.<br>
          <br>
          <dfn>Тестирование зависит от контекста</dfn>: <br>
          Тестирование выполняется по-разному в зависимости от контекста.<br>
          Например, программное обеспечение управления производством, в котором критически важна безопасность, тестируется иначе, чем мобильное приложение электронной коммерции<br>
          <br>
          <dfn>Заблуждение об отсутствии ошибок</dfn>: <br>
          Нахождение и исправление дефектов не поможет, если ПО не удовлетворяет потребности и нужды пользователя<br>

      //- Уровни тестирования
      details
        summary Уровни тестирования:
        p.
          Уровни тестирования разделяются по времени тестирования и по изолированности компонентов.<br>
          Группы активностей тестирования, которые организуются и управляются как единое целое.<br>
          Каждый уровень тестирования — это реализация процесса тестирования, состоящего из мероприятий STLC, и исполняемого в отношении ПО, находящегося на конкретном уровне разработки, начиная с отдельных модулей и компонентов и заканчивая целыми системами<br>
          <br>
          <dfn>Компонентное тестирование</dfn> (Unit Testing) - фокусируется на компонентах, которые могут быть проверены отдельно.<br>
          Типичными объектами для компонентного тестирования являются:<br>
          Компоненты, модули<br>
          Код и структуры данных<br>
          Классы<br>
          Модули БД<br>
          Выполняется в основном разработчиками<br>
        img(src="./img/qc/typesLevels.png" alt="")
        br
        p.
          <dfn>Интеграционное тестирование</dfn> (Integration Testing) - фокусируется на взаимодействии между компонентами или системами<br>
          Типичными объектами тестирования при интеграционном тестировании являются:<br>
          Подсистемы<br>
          Базы данных<br>
          Инфраструктура<br>
          Интерфейсы<br>
          Программные интерфейсы приложения (API)<br>
          Микросервисы<br>
          <br>
          <em>Уровни интеграционного тестирования</em>:<br>
          <b>Компонентный интеграционный уровень</b> (Component Integration testing) - проверяется взаимодействие между компонентами системы после проведения компонентного тестирования <br>
          Выполняется в основном разработчиками<br>
          <br>
          <b>Системный интеграционный уровень</b> (System Integration Testing) - проверяется взаимодействие между разными системами после проведения системного тестирования <br>
          Выполняется в основном тестировщиками<br>
          <br>
          <dfn>Системное тестирование</dfn> (System Testing – ST) - фокусируется на поведении и возможностях целой системы или продукта, часто учитывая сквозные задачи, которые может выполнять система, и нефункциональное поведение, которое она демонстрирует при выполнении этих задач<br>
          Типичные объекты системного тестирования включают:<br>
          Приложения<br>
          Аппаратные/программные системы<br>
          Тестируемая система<br>
          Операционные системы<br>
          Конфигурация системы и конфигурация данных<br>
          Выполняется в основном тестировщиком<br>
          <br>
          <dfn>Приемочное тестирование</dfn>, как и системное тестирование, обычно фокусируется на поведении и возможностях системы или продукта в целом<br>
          Типичными формами приемочного тестирования являются:<br>
          <b>Пользовательское приемочное тестирование</b> (User Acceptance Testing – UAT) - обычно сосредоточено на проверке пригодности использования системы предполагаемыми пользователями в реальной или моделируемой рабочей среде<br>
          <b>Эксплуатационное приемочное тестирование</b><br>
          <b>Контрактное и нормативное приемочное тестирование</b><br>
          <b>Альфа-тестирование и бета-тестирование</b> - обычно используются разработчиками готовых коммерческих решений, которые хотят получить обратную связь от потенциальных или существующих пользователей, клиентов и/или операторов до того, как программный продукт будет выставлен в коммерческую продажу.<br>
          Выполняется в основном клиентами, заказчиками, пользователями<br>
          <br>
          <dfn>Системное и приемочное тестирование</dfn>:<br>
          системное проверяет на соответствие системы требованиям.<br>
          приемочное проверяет систему с точки зрения пользования системой<br>
          тесты в системном и приёмочном тестировании очень похожи, разница в формулировки теста.<br>
          <br>
          <dfn>Unit testing</dfn>: <br>
          выполняется до других видов тестирования<br>
          модуль не полагается на внешний код или функции<br>
          состоит из 3-х ступеней:<br>
          - подготовка и обзор модуля <br>
          - сделать test cases and scripts <br>
          - провести тест кода<br>
          <br>
          <dfn>Проверка безопасти</dfn> - это проверка возможности обхода обычных путей использования и/или функционала.<br>

      //- Типы тестирования
      details
        summary Типы тестирования:
        img(src="./img/qc/typesTest.png" alt="")
        p.
          Типы тестирования разделяются в зависимости от цели тестирования.<br>
          <dfn>Тип тестирования</dfn> – это совокупность активностей тестирования, направленных на тестирование заданных характеристик системы или ее части, основываясь на конкретных целях<br>
          <dfn>Функциональное тестирование</dfn> (Functional testing) системы включает тесты по оценке функций, которые должна выполнять система. Проверка того, «что делает система» <br>
          Тестирование на основе требований выполняется в строгом соответствии с установленными требованиями. <br>
          Тестирование на основе бизнес-процесса выполняется в соответствии с знаниями, основанными на повседневном использовании системы в бизнесе.<br>
          <dfn>Нефункциональное тестирование</dfn> (Non Functional testing) Нефункциональное тестирование системы выполняется для оценки таких характеристик системы и программного обеспечения, как удобство использования, производительность или безопасность Проверка того, «насколько хорошо работает система»<br>
          <br>
          <em>Основные подтипы нефункционального тестирования</em>:<br>
          <dfn>Производительности</dfn> (Performance) - намеревается определить, как система работает с точки зрения быстроты реагирования и стабильности при определенной нагрузке.<br>
          <dfn>Характеристики</dfn>:<br>
          <b>Время отклика</b> (response time)<br>
          <b>Пропускная способность</b> (throughput)<br>
          <b>Способность к параллеливанию</b> (concurrency)<br>
          <b>Доступность</b> (availability, uptime)<br>
          <b>Потребление ресурсов</b> (resource utilization)<br>
          <b>Потенциальная мощность</b> (capacity)<br>
          <br>
          <dfn>Виды тестирования производительности</dfn>:<br>
          <b>Нагрузочное тестирование</b> (Load testing) – оценка поведения системы при различных нагрузках, обычно между ожидаемыми условиями низкого, типичного и пикового использования<br>
          <b>Стресс-тестирование</b> (Stress testing) – оценка поведения системы в пределах или за пределами ожидаемых или заданных рабочих нагрузок или с ограниченной доступностью ресурсов, таких как доступ к памяти или серверам<br>
          <b>Объемное тестирование</b> (Volume testing) – позволяет анализировать производительность системы за счет увеличения объема данных в базе данных<br>
          <b>Тестирование стабильности</b> (Stability testing)<br>
          <b>Тестирование параллелизма</b> (Concurrency testing)<br>
          <b>Тестирование на масштабируемость</b> (Scalability testing)<br>
          <b>Тестирование на выносливость</b> (Endurance testing)<br>
        img(src="./img/qc/Performance.png" alt="")
        p.
          <em>Быстро или медленно</em>:<br>
          - меньше 0.1 секунды - мгновенно<br>
          - меньше секунды - быстро<br>
          - меньше 2 секунд - достаточно быстро<br>
          - 2-4 секунды - приемлемо<br>
          - 4-15 секунды - медленно<br>
          - больше 15 секунд - очень долго<br>
          <em>Классификация проблем</em>:<br>
          - медленная подсистема/функция (например медленно загружается страница или выполняется скрипт)<br>
          - точка насыщения/"узкое горлышко" (например, пропускная способность сети или очереди для запросов, когда исчерпывается длина этой очереди и начинаются отказы)<br>
          - функциональный дефект (когда несколько систем используют один объект и одновременно меняют его состояние)<br>
          - дефект интерфейса (восстановление от ошибки - тесно граничит с UX тестированием)<br>
          <em>Требования к производительности</em>:<br>
          - стала ли новая версия работать быстрее?<br>
          - что тормозит - софт или железо?<br>
          - почему пользователи не завершают заказы?<br>
          - выдержит ли сервер?<br>
          - какое состояние приложения?<br>
          <em>Цели тестирования</em>:<br>
          - сравнить две версии приложения<br>
          - найти причину проблемы с производительностью<br>
          - оценить потенциальные возможности<br>
          - получить подтверждение, что все хорошо<br>
          <em>Проектирование тестов</em>:<br>
          - Выясняем цели<br>
          - Описываем требования и условия<br>
          - Формулируем гипотезу для проверки<br>
          - Описываем профиль нагрузки<br>
          - Делаем сценарии для профиля нагрузки<br>
          <em>Как выбрать операцию</em>?<br>
          - Критически важные (например, авторизация)<br>
          - Связанные с рисками (например, возврат средств)<br>
          - Требуемые заказчиком (например, есть просадки по завершению оплаты)<br>
          - Часто используемые (например, поиск товаров)<br>
          - Ресурсоемкие (например, получение архива)<br>
        img(src="./img/qc/perfor.png" alt="")
        p.
          Запрос - одна операция <br>
          Транзакция - группа операций/запросов <br>
          Сценарий - группа транзакций (например переходы по нескольким страницам сайта)<br>
          <br>
          <em>Профиль нагрузки</em> - это подбор сценариев (объединение логических действий) для эмулирования нагрузки на ресурс.<br>
          - Количество пользователей<br>
          - Количество сценариев<br>
          - Количество запросов (транзакций)<br>
          - Задержки между запросами (помогают регулировать количество операций)<br>
          - Задержки между транзакциями (группами запросов, например загрузка страницы, так как пользователь читает инфу, заполняет данные и тд)<br>
          - Пользовательского интерфейса (UI)<br>
          - Удобства использования (Usability)<br>
          - Безопасности (Security): <br>
          <br>
          <em>Тестирование безопасности</em> (Security Testing) направлено на то, чтобы обеспечить информационную систему защитой данных и поддерживать функциональность по назначению<br>
          - Тестирование проникновения (Penetration Testing) – это симуляция атаки вредоносного источника, которое позволяет оценить безопасность компьютерной системы или сети<br>
          - XSS (Cross-SiteScripting) — это вид уязвимости программного обеспечения (Web приложений), при которой, на генерированной сервером странице, выполняются вредоносные скрипты<br>
          - XSRF / CSRF (RequestForgery) — это вид уязвимости, позволяющий использовать недостатки HTTP протокола.Злоумышленники работают по следующей схеме: ссылка на вредоносный сайт устанавливается на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя, для получения полного контроля над ней<br>
          - Code injections (SQL, PHP, ASP и т.д.) — это вид уязвимости, при котором становится возможно осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам, несанкционированного доступа к данным либо выведения системы из строя<br>
          - AuthorizationBypass — это вид уязвимости, при котором возможно получить несанкционированный доступ к учетной записи или документам другого пользователя<br>
          - Конфигурации (Configuration)<br>
          - Локализации (Localization)<br>
          - Совместимости (Compatibility)<br>
          <br>
          <em>Структурное тестирование</em> (тестирование методом белого ящика – White Box Testing) основывается на внутренней структуре системы или ее реализации. Под внутренней структурой подразумевается программный код, архитектура, принципы работы и/или потоки данных внутри системы<br>
          - Statement Coverage проверяет, что каждый оператор в программе выполняется хотя бы один раз во время тестирования программы.<br>
          - Path Coverage предназначен для удовлетворения критериев охвата каждого логического пути через программу.<br>
          - Branch Coverage проверяет, имеют ли каждое условие ветвления для программы истинные или ложные значения.<br>
          - Condition Coverage похоже на Branch Coverage. Основное различие заключается в проверке состояния покрытия для условных и не условных ветвей.<br>
          <br>
          <em>Tестирование связанное с изменениями</em>: <br>Когда в систему вносятся изменения, выполненные для исправления дефекта, либо из-за новой или изменяющейся функциональности, необходимо провести тестирование, чтобы подтвердить, что изменения исправили дефект или что функциональность правильно реализована и изменения не вызвали каких-либо непредвиденных неблагоприятных последствий.<br>
          - Дымное тестирование (Smoke testing) – Набор тестов, который охватывает основные функции компонента или системы, чтобы определить, работает ли он должным образом до начала запланированного тестирования<br>
          - Подтверждающее тестирование (Confirmation testing, Re-test) – после того как дефект исправлен, программное обеспечение может быть протестировано с использованием всех тех же тестовых сценариев, которые завершились с ошибкой из-за найденного дефекта<br>
          - Санитарное тестирование (Sanity testing) - используется с целью доказательства работоспособности конкретной функции или модуля согласно заявленным техническим требованиям. Зачастую санитарное тестирование используют для проверки какой либо части программы или приложения в результате внесенных изменений<br>
          - Регрессионное тестирование (Regression testing) – тестирование ранее протестированного компонента или системы после модификации, чтобы убедиться, что дефекты не были обнаружены или были обнаружены в неизменных областях программного обеспечения в результате внесенных изменений. <br>
          <br>
          <em>Регрессионное тестирование</em> (Regression testing) проводится после того, как вся функциональность реализована и все дефекты найденые на предыдущих уровнях исправлены или принято решениио их переносе.<br>
          Идеально начинать регрессию ПОСЛЕ заморозки кода (Code Freeze)<br>

      //- Техники тестирования
      details
        summary Техники тестирования
        img(src="./img/qc/testTechnics.png" alt="")
        p.
          <dfn>Статическое тестирование</dfn> - тип техники тестирования, который предполагает, что программный код во время тестирования не будет выполняться. При этом самотестирование может быть как ручным, так и автоматизированным<br>
          Виды статического тестирования:<br>
          - вычитка исходного кода программы<br>
          - проверка требований<br>
          <br>
          <dfn>Динамическое тестирование</dfn> - тип техники тестирования, который предполагает запуск программного кода. Таким образом, анализируется поведение программы во время ее работы.<br>
          <dfn>Методы черного ящика<.dfn>: <br>
        img(src="./img/qc/blackbox.png" alt="")
        p.
          <b>Эквивалентное разделение</b> (Equivalence Partitioning): <br>
          Класс эквивалентности (equivalence class) – набор данных, обработка которых приводит к одному и тому же результату<br>
          Разделение на классы эквивалентности – это техника, при которой функционал (диапазон возможных входных значений) разделяется на группы значений эквивалентных по воздействию на систему<br>
          <br>
        p <b>Анализ граничных значений</b> (Boundary Value Analysis) - техника тест-дизайна, которая направлена на проверку поведения системы на граничных значениях входных данных (границах классов эквивалентности)<br>
        img(src="./img/qc/Boundary.png" alt="")
        p <b>Метод попарного тестирования</b> (Pairwise testing) – основан на следующей идее: подавляющее большинство багов, выявляются тестами, проверяющими либо один параметр, либо сочетание двух параметров<br>
        img(src="./img/qc/Pairwise.png" alt="")
        br
        a(target="_blank" href="https://pairwise.teremokgames.com/") Тренировка<br>
        br
        p.
          <dfn>Таблица принятия решений</dfn> (Decision table) - это способ компактного представления модели со сложной логикой. <br>
          Простыми словами, это варианты действий при различных входных условиях<br>
          <br>
          Шаги построения таблицы:<br>
          - Определить/записать условия<br>
          - Посчитать количество возможных комбинаций условий: <b>N = n1 * n2 * ... * nm</b><br>
          - Заполнить комбинации<br>
          - Записать действия <br>
        img(src="./img/qc/Decision Table.png" alt="")
        p.
          Используется для описания (и визуализации) сложных бизнес и системных требований <br>
          Помогают создавать тест кейсы (Условия – тестовые данный, Действия – Ожидаемый результат) <br>
          Не помогает ограничивать набор тестовых случаев<br>
          <br>
          <dfn>Тестирование состояний и переходов</dfn> (State - transition testing): <br>
          <b>Диаграмма состояний и переходов</b> (State transition diagrams) — показывает начальное и конечное состояния системы, а также описывает переходы между состояниями <br>
        img(src="./img/qc/State transition diagrams.png" alt="")
        br
        p <b>Таблица состояний и переходов</b>: <br>
        img(src="./img/qc/State transition tables.png" alt="")
        br
        p.
          <dfn>Тестирование по сценариям использования</dfn> (Use case Testing): <br>
          Тестирование вариантов использования определяется как метод тестирования программного обеспечения, который помогает идентифицировать тестовые случаи, охватывающие всю систему, транзакция за транзакцией от начала до конечной точки.<br>
        a(href="http://okiseleva.blogspot.com/2015/11/blog-post_86.html") Обзор<br>
        img(src="./img/qc/Use case Testing.png" alt="")                  
        br
        p.
          <dfn>Техники основанные на опыте</dfn>:<br>
          <em>Предугадывание ошибок</em> (Error Guessing) - это способ предотвращения ошибок, дефектов и отказов, основанный на знаниях тестировщика, включающих:<br>
          - Историю работы приложения в прошлом<br>
          - Наиболее вероятные типы дефектов, допускаемых при разработке<br>
          - Типы дефектов, которые были обнаружены в схожих приложениях<br>
          <em>Исследовательское тестирование</em>: <br>
          - Во время исследовательского тестирования неформальные (т.е. не созданные заранее) тестовые сценарии разрабатываются, выполняются, анализируются и оцениваются динамически во время выполнения тестов. <br>
          - Результаты тестирования используются для изучения компонента или системы и последующей разработки тестовых сценариев для непокрытых областей.
        a(href="https://blog.noveogroup.ru/2018/06/issledovatelskoe-testirovanie-agile/") Обзор
        p.
          <em>Интуитивное тестирование</em> (Ad-hoc testing) - это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. <br>
          Это неформальное, импровизационное тестирование<br>
          <br>
          <dfn>workaround</dfn> - обходной путь при неработающем основном.<br>
          На проекте нужно определять критерии оценки приоритета багов<br>
          Описать баг<br>
          Воспроизвести шаги на других устройствах<br>
          Попробывать обопщить баг с другими случаями<br>
          Обопщенный вариант (если есть) пробуем воспроизвести на других устройствах<br>

      //- Test artifacts
      details
        summary Test artifacts
        
        //- Требования
        details
          summary Требования
          p.
            Некое свойство программного обеспечения, необходимое пользователю, для решения проблемы при достижении поставленной цели. <br>
            Некое свойство программного обеспечения, которым должна обладать система или ее компонент, чтобы удовлетворить требования контракта, стандарта, спецификации либо иной формальной документации.<br>
            Могут быть:<br>
            - Прямыми(Формализованными в технической документации, спецификациях, User Story)<br>
            - Косвенными(Проистекающими из прямых, либо являющиеся негласным стандартом для данной продукции или основывающиеся на опыте и здравом смысле использования продукта или продуктов подобных ему)<br>
            <br>
            <dfn>Уровни требований</dfn>:<br>
            <em>Бизнес-требования</em>: <br> описание высокоуровневых целей организации или заказчика, достигаемых посредством разрабатываемой системы<br>
            Пример:<br>
            - Увеличить охват пользователей<br>
            - Увеличить прибыль<br>
            - Создать дополнительный канал продаж<br>
            <br>
            <dfn>Требования заинтересованных лиц</dfn>: <br>
            Формулировка потребностей определенного заинтересованного лица или их группы.<br>
            Кроме потребности описывается также способ взаимодействия заинтересованных лиц с решением<br>
            <b>Покупатель</b>:<br>
            - Выбрать товар по определенным критериям<br>
            - Сравнить разные товары<br>
            - Купить товар с помощью кредитной карты<br>
            <br>
            <b>Администратор</b>:<br>
            - Поддерживать перечень товаров в актуальном состоянии<br>
            - Быстро отслеживать и управлять заказами<br>
            <br>
            <dfn>Требования к решению</dfn>:<br>
            <em>Функциональные</em>:
            <b>Покупатель должен иметь возможность</b>:<br>
            - Просмотреть список товаров<br>
            - Фильтровать товары<br>
            - Сравнивать товары между собой<br>
            - Добавлять товары в корзину<br>
            - Оформить заказ<br>
            <br>
            <b>Администратор должен иметь возможность</b>:<br>
            - Добавлять/удалять товар<br>
            - Менять цену<br>
            - Видеть заказы и менять ему статус<br>
            <br>
            <em>Нефункциональные</em>:<br>
            <b>Атрибуты качества</b><br>
            Пример:<br>
            - Время загрузки главной страницы и страницы товара – не выше 3 секунд<br>
            - База данных должна разворачиваться на основные СУБД без дополнительных изменений<br>
            - Сайт должен быть адаптирован под мобильные устройства<br>
            <br>
            <b>Ограничения в проектировании или реализации</b><br>
            Пример:<br>
            - Серверная часть должна быть написана на Java<br>
            - Сайт должен устанавливаться на ОС Ubuntu<br>
            <br>
            <b>Внешние интерфейсы</b><br>
            Пример:<br>
            - Поддержка платежных систем Visa и MasterCard<br>
            - Поддержка API социальных сетей<br>
            <br>
            <dfn>Способы документации</dfn>:
            <b>Текстовый вид</b>:<br>
            - Видение продукта (Product Vision)<br>
            - Для (целевой заказчик/аудитория)<br>
            - Которым (описание нужд или возможностей)<br>
            - Продукт (имя, категория продуктов)<br>
            - Который (ключевые выгоды, повод купить)<br>
            - В отличие (главное отличие от конкурентов)<br>
            - Наш продукт (главное преимущество)<br>
            <br>
            <b>Пользовательская история</b> (User story): <br>
            Способ описания требований, к разрабатываемой системе, сформулированный, как одно или более предложений на повседневном или деловом языке. <br>
            Цель пользовательских историй состоит в том, чтобы быть в состоянии оперативно и без накладных затрат реагировать на быстро изменяющиеся требования реального мира <br>
          img(src="./img/qc/userStory1.png" alt="")
          img(src="./img/qc/userStory2.png" alt="")
          br
          p.
            <b>Критерии приемки</b> (Acceptance Criteria): <br>
            это критерии, в том числе требования к рабочим характеристикам и основные условия, которые должны быть выполнены чтобы результаты проекта были принятыми <br>
            <b>Критерий приема = минимальное требование</b> <br>
          img(src="./img/qc/criteria.png" alt="")
          br
          p.
            <b>Сценарий использования</b> (Use Case): <br>
            это перечень действий, сценарий по которому пользователь взаимодействует с приложением, программой для выполнения какого-либо действия для достижения конкретной цели
            Пример:<br>
            - Пользователь захотел разместить объявление<br>
            - Пользователь зашел в систему<br>
            - Пользователь авторизовался в системе<br>
            - Пользователь создал объявление<br>
            - Система отобразила сообщение об успешном создании объявления<br>
            <br>
            <b>Графический вид</b>:<br>
            - Макеты (Wireframe):<br>
            <b>Вайрфрейм</b> — это низко детализированное представление дизайна. Он чётко должен показывать:<br>
            - Основные группы содержимого. Что?<br>
            - Информационную структуру. Где?<br>
            - Описание взаимодействия пользователя с интерфейсом и его примерную визуализацию. Как?<br>
          img(src="./img/qc/Wireframe.png" alt="")
          br
          p.
            <b>Диаграммы</b> (Diagrams): <br>
            UML (англ. Unified Modeling Language — унифицированный язык моделирования) — язык графического описания для объектного моделирования в области разработки программного обеспечения, для моделирования бизнес-процессов, системного проектирования и отображения организационных структур<br>
          img(src="./img/qc/UML.png" alt="")
          img(src="./img/qc/Diagrams.png" alt="")
          img(src="./img/qc/DFD.png" alt="")
          img(src="./img/qc/ERD.png" alt="")
          br
          p.
            <dfn>Требования к требованиям</dfn>: <br>
            <em>Основные проблемы требований</em>:
            - непонятность требований<br>
            - частая изменяемость<br>
            - изменения, вносимые в последний момент<br>
            - неверная трактовка требований<br>
            <br>
            <em>Характеристики требований</em>:<br>
            <b>Завершенность</b> - Требование полностью определено в одном месте и вся необходимая информация присутствует<br>
            <b>Последовательность</b> - Требование не противоречит другим требованиям и полностью соответствует внешней документации<br>
            <b>Атомарность</b> - Требование «атомарно». То есть оно не может быть разбито на ряд более детальных требований без потери завершенности<br>
            <b>Отслеживаемость</b> - возможность отследить связь между требованием и другими артефактами проекта, каждое требование имеет уникальный идентификатор, по которому оно легко прослеживается<br>
            <b>Актуальность</b> - Требование не стало устаревшим с течением времени<br>
            <b>Выполнимость</b> - Требование может быть реализовано в пределах проекта<br>
            <b>Недвусмысленность</b> - Требование кратко определено без обращения к техническому жаргону, акронимам и другим скрытым формулировкам. <br>
            - Выражает объективные факты, не субъективные мнения. <br>
            - Возможна одна и только одна интерпретация. <br>
            - Определение не содержит нечётких фраз. <br>
            - Использование отрицательных утверждений и составных утверждений запрещено<br>
            <b>Обязательность</b> - Требование представляет определенную заинтересованным лицом характеристику, отсутствие которой приводит к неполноценности решения, которая не может быть проигнорирована<br>
            <b>Необязательное требование</b> — противоречие самому понятию требования<br>
            <b>Проверяемость</b> – существует способ однозначной проверки выполнено требование или нет<br>
            <br>
            <dfn>Техники тестирования требований</dfn>:<br>
            <b>Взаимный просмотр</b>:<br>
            - беглый просмотр — автор показывает свою работу коллегам, они в свою очередь дают свои рекомендации, высказывают свои вопросы и замечания<br>
            - технический просмотр — выполняется группой специалистов<br>
            - формальная инспекция — привлекается большое количество специалистов, представляет собой структурированный, систематизированный и документированный подход.<br>
            Минус такого варианта — тратится много времени<br>
            Вопросы — если возникают вопросы, то можно спрашивать у представителей заказчика, более опытных коллег<br>
            <br>
            <b>Тест-кейсы и чек-листы</b> — хорошее требование должно быть проверяемым, чтобы это определить можно использовать чек-листы или полноценные тест-кейсы. <br> Если можно быстро придумать несколько пунктов чек-листа — это уже хороший знак<br>
            <b>Исследование поведения системы</b> — необходимо мысленно смоделировать процесс работы пользователя с системой, созданной по тестируемым требованиям, после этого определить неоднозначные варианты определения системы<br>
            <b>Рисунки и прототипы</b> — графическое представление дает наглядное представление приложения, на рисунке проще увидеть, что какие-то элементы не стыкуются, где-то чего-то не хватает и т.д. <br> Сделав наброски пользовательского интерфейса, легко оценить применение тех или иных пользовательских решений<br>
            Пример: <br>
            Шаг 1: <br>
          img(src="./img/qc/example1.png" alt="")
          br
          p Шаг 2: <br>
          img(src="./img/qc/Example2.png" alt="")
          br
          p Шаг 3: <br>
          img(src="./img/qc/Example3.png" alt="")
          br
          p Шаг 4: <br>
          img(src="./img/qc/Example4.png" alt="")
          br
          p Шаг 5: <br>
          img(src="./img/qc/Example5.png" alt="")

        //- Документация
        details
          summary Документация
          p.
            Документация пишеться в passive voice.<br>
            Тестовая документация бывает двух видов:

          //- Внешняя
          details
            summary Внешняя
            p.
              <dfn>Отчет о дефекте</dfn> (Bug or Defect Report) - это документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата<br>
              <em>Структура</em>:<br>
              <b>Короткое описание</b> (Summary) общее описание дефекта и наблюдаемого сбоя.<br> Очень важная часть дефекта, так как это первое, что менеджеры и разработчики видят<br>
              <b>Предусловия</b> (Preconditions)<br>
              <b>Компонент приложения</b> (Component)<br>
              <b>Номер версии</b> (Version)<br>
              <b>Серьезность</b> (Severity) - это атрибут, характеризующий влияние дефекта на работоспособность приложения. <br> Показывает технологическую степень влияния дефекта на ВСЮ СИСТЕМУ<br>
            img(src="./img/qc/Severity.png" alt="")
            p.
              <b>Приоритет</b> (Priority) - это атрибут, указывающий на очередность выполнения задачи или устранения дефекта.<br> Чем выше приоритет, тем быстрее нужно исправить дефект.<br> Показывает степень важности выполнения задач для БИЗНЕСА<br>
              - P1 Срочный (Urgent)<br>
              - P2 Высокий (High)<br>
              - P3 Средний (Medium)<br>
              - P4 Низкий (Low)<br>
              <b>Статус</b> (Status)<br>
              <b>Автор</b> (Reporter)<br>
              <b>Описание</b> (Description)<br>
              - Шаги воспроизведения (Steps to Reproduce)<br>
              - Фактический Результат (Actual Result)<br>
              - Ожидаемый результат (Expected Result)<br>
              - Вложения (Attachments)<br>
              <br>
              <dfn>Запрос на изменение</dfn> (Change Request)<br>
              <dfn>Отчет о тестировании</dfn> (Test Report)<br>

          //- Внутренняя
          details
            summary Внутренняя

            //- Test Plan
            details
              summary Test Plan
              p.
                <dfn>План тестирования</dfn> (Test Plan)<br>
                Документ, описывающий весь объем работ по тестированию.<br>
                Хороший тест план должен как минимум описывать следующее:<br>
                - Что будем тестировать?<br>
                - Как будем тестировать?<br>
                - Когда будете тестировать?<br>
                <br>
                <em>Объем тестирования</em> (Scope of Work)<br>
                - Что мы будем делать?<br>
                - Зачем?<br>
                - Для какого клиента?<br>
                - Кто будет использовать продукт?<br>
                - Для чего будет использоваться продукт?<br>
                - Какие компоненты и функции нужно протестировать, а какие тестироваться не будут?<br>
                <br>
                <em>Стратегии тестирования</em> (Test Strategy)<br>
                Наиболее важная часть документа. <br>
                Иногда даже может выноситься в отдельный документ. <br>
                Стратегия тестирования определяет:<br>
                - Процесс тестирования<br>
                - Уровни и типы тестирования<br>
                - Роли и ответственность<br>
                - Анализ рисков<br>
                - Тестовое окружение<br>
                - Используемые ресурсы<br>
                - Документация<br>
                - Hеобходимого в процессе работы оборудования<br>
                - Cпециальных знаний<br>
                - Oценки рисков с вариантами их разрешения<br>
                - Утверждение плана (Approvals)<br>
                <br>
                <em>Pасписание тестирования</em><br>
                содержит в себе:<br>
                - список необходимых задач, их последовательность<br>
                - оценка и сроки выполнения<br>
                - критериев начала и окончания тестирования (Entry & Exit Criteria)<br>
                <br>
                <b>Entry Criteria</b>:<br>
                - Готовность тестовой платформы (тестового стенда)<br>
                - Законченность разработки требуемого функционала<br>
                - Наличие всей необходимой документации<br>
                <br>
                <b>Exit Criteria</b>:<br>
                - Определенный процент критических кейсов пройден<br>
                - Нет открытых критических дефектов<br>
                - Прошло определенное время без открытия новых дефектов (Zero Bug Bounce)<br>
                - Закончились средства<br>
                - Наступил дедлайн<br>
                <br>
                Для увеличения ценности тест плана рекомендуется проводить его периодическое рецензирование со стороны участников проектной группы:<br>
                - Ведущий тестировщик<br>
                - Тест менеджер (менеджер по качеству)<br>
                - Руководитель разработки<br>
                - Менеджер проекта<br>
                <br>
                Примеры рисков:<br>
                - Ограниченность ресурсов<br>
                - Недостаточная квалификация<br>
                - Отсутствие документации<br>
                - Поздние изменения<br>
                - Проблемы сторонних решений<br>
                - Контрактные проблемы<br>
              img(src="./img/qc/risks.png" alt="")
              br
              p Структура тест-плана: <br>
              img(src="./img/qc/testPlan.png" alt="")

            //- Check List
            details
              summary Check List
              p.
                <dfn>Список проверок</dfn> (Check List)<br>
                Это документ, описывающий что должно быть протестировано. <br>
                При этом чек-лист может быть абсолютно разного уровня детализации. <br>
                На сколько детальным будет чек-лист зависит от:<br>
                - Требований к отчётности<br>
                - Уровня знания продукта сотрудниками<br>
                - Сложности продукта<br>
                <br>
                <b>чек-лист нужен</b>:<br>
                - Не забыть требуемые тесты<br>
                - Для деления задач по уровню квалификации<br>
                - Для сохранения отчётности и результатов тестирования<br>
                - Замена тестовым случаям (Test Cases) в условиях нехватки времени<br>
                <br>
                В целом, грамотно составленные списки в значительной степени могут эффективно справится с функциями детально расписанных тест-кейсов. <br>
                Именно поэтому не во всех случаях рациональным будет трата времени на написание тест-кейсов. <br>
                Решение о их необходимости (или же наоборот) является результатом тщательно обдуманного планирования и не может быть универсальным для всех проектов. <br>
              img(src="./img/qc/checkList1.png" alt="")
              img(src="./img/qc/checkList2.png" alt="")
              img(src="./img/qc/checkList3.png" alt="")
              img(src="./img/qc/checkList4.png" alt="")
              img(src="./img/qc/checkList5.png" alt="")

            //- Test case
            details
              summary Test case     
              p.
                <dfn>Тестовый случай</dfn> (Test case) - это совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или её части. <br>
                <br>
                Тестовый случай состоит из:
                - Уникальный идентификатор (ID)
                - Название (Description)
                - Предусловия (Precondition) – опционально
                - Шаги (Steps)
                - Ожидаемый результат (Expected result)
                <br>
                <b>Тест-кейсы нужны</b>:<br>
                - Жизненно важные системы, ошибка в которых может привести к гибели (самолетостроение, медицина, ПО для атомных станций)<br>
                - При тестировании сложных систем или сложных частей системы, чтобы не запутаться в чек-листе<br>
                - Планирование, и только потом – выполнение!<br>
                - Дают нам структурированный системный подход, что снижает вероятность пропуска ошибки.<br>
                - Хороший способ хранения части проектной информации.<br>
                - Один из способов протестировать проектную документацию еще до выхода первого билда<br>
                - Ускоряет регрессионное тестирование<br>
                - Можно доверить выполнять новичку или призванному на помощь коллеге из другого отдела<br>
                - Можем в любой момент «вспомнить», что мы делали месяц, полгода, год назад<br>
                - Тест-кейсы позволяют легко отслеживать прогресс: <br>
                - X% тестов выполнено <br>
                - Y% тестов прошло/завалилось <br>
                - Z% требований покрыто тестами <br>
                <br>
                <b>Тест-кейсы НЕ нужны</b>:<br>
                - Простые системы (веб-сайты, мобильные приложения и т. п.)<br>
                - Ситуации, когда в команде всего один или два тестировщика, знающие свой продукт.<br>
                Время, потраченное на создание и поддержку тест-кейсов никогда не окупится<br>
                <br>
                <b>Преимущества тест-кейсов</b>:<br>
                - Время (приоритизация проверок)<br>
                - Более быстрое введение в проект новых людей или подключение коллег из других проектов для проведения сессии тестирования<br>
                - Напоминание о конфигурировании и настройке системы<br>
                - Незаменимы при работе над на «тяжелых» проектах<br>
                - Понимание информации одинаково всеми участниками процесса<br>
                - Напоминание о старой функциональности, которую все еще нужно тестировать<br>
                <br>
                <b>Недостатки тест-кейсов</b>:<br>
                - Разные Test Case, для одного функционала очень похожи<br>
                - Сложность поддержки<br>
                - Неактуальное состояние<br>
                - Следуя сценарию, можно упустить важные проблемы<br>
                - Валидация небольшого кусочка функциональности<br>
                <br>
                Тестировщик проверяет продукт, а не тестирует его<br>
                Тестировщики выключают мозг, проходя Test Case<br>
                Любой может выполнять их, они не заменяют опытных тестировщиков, которые могут тестировать<br>
              img(src="./img/qc/testCase.jpg" alt="")
              img(src="./img/qc/testCase1.jpg" alt="")

            //- Test Suites
            details
              summary Test Suites
              p.
                <dfn>Набор тестов</dfn> (Test Suites) это перечень тестовых случаев (test case), которые объединены тем что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования.<br>
                <br>
                <dfn>Матрица соответствия</dfn> (Traceability Matrix) <br>
                Это двумерная таблица, содержащая соответствие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). <br>
                В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. <br>
                На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки.<br>
                Матрица обычно хранится в виде электронной таблицы.<br>
              a(href="https://habr.com/ru/company/simbirsoft/blog/412677/") Обзор
              img(src="./img/qc/Matrix.png" alt="")
              img(src="./img/qc/tracematrix.png" alt="")
              p.
                Это матрица покрытия требований тест-кейсами. <br>
                При разработке тестов ориентироваться какие из требований уже покрыты. <br>
                При выполнении тестирования ориентироваться какие из ребований прошли все написанные для них тесты успешно.

    //- Mobile testing
    details
      summary.menu__submenu Mobile testing
      p.
        <dfn>Native apps</dfn> <br>
        Под нативным мы подразумеваем мобильное приложение, которое создается для определенной платформы и непосредственно устанавливается на устройство пользователя (занимая определенный объем памяти).<br>
        Такие приложения пользователь загружает через магазин приложений той или иной платформы, такой как Play Store для Google и Apple App Store для iOS.<br>
        Органично выглядят на телефоне<br>
        Используют все функции программного обеспечения гаджета<br>
        Имеют быстрый отклик и плавность анимаций интерфейса<br>
        Надежнее (работают стабильнее)<br>
        Экономнее расходуют ресурсы телефона: батарею, память<br>
        Дорого в разработке<br>
        <br>
        <dfn>Web apps</dfn> <br>
        Веб приложения работают через веб-браузер на устройстве пользователя.<br>
        Эти приложения по сути являются индивидуализированными вебсайтами, которые сделаны таким образом, чтобы выглядеть и использоваться как нативные приложения, но на самом деле они не находятся на устройстве пользователя<br>
        - Приложения на веб-основе легче поддерживаются и они могут функционировать на платформе с любой ОС<br>
        - Разработчики могут предлагать приложения без необходимости их утверждения какими-либо магазинами приложений<br>
        - Более быстрая разработка циклов с использованием CSS, HTML и JavaScript<br>
        - Нет доступа к устройству пользователя<br>
        - Пользователи должны использовать их через сеть, что значительно снижает контроль безопасности<br>
        - Поиск приложения может быть затруднительным, так как не существует магазина приложений с каталогом и функцией поиска в нем<br>
        <br>
        <dfn>Hybrid apps</dfn> <br>
        Гибридные приложения являются чем-то средним между нативными и веб-приложениями.<br>
        Фактически они создаются так, чтобы выглядеть и использоваться как нативные приложения.<br>
        Их также устанавливают на телефон пользователя и их можно найти в магазинах приложений.<br>
        Различие заключается в том, что они обязательно должны размещаться в рамках нативного приложения и созданы, чтобы работать через WebView.<br>
        - Запускается не из браузера, возможно независимое обновление.<br>
        - Скорость разработки, а, следственно, и цена значительно ниже, чем нативные приложения.<br>
        - Возможность распространяться через магазины приложений (в отличие от веб-приложений).<br>
        - Скорость и стабильность работы оставляют желать лучшего.<br>
        - Сложности в масштабировании и развитии проекта<br>
        - Сложности и нестабильность при использовании различных модулей/функций смартфона<br>
      
      //- Этапы pазработки и тестирования
      details
        summary Этапы pазработки и тестирования
        p <em>User Story</em>

        //- Создание проекта и дизайна
        details
          summary Создание проекта и дизайна
          p.
            <dfn>UI design</dfn> — это визуальное оформление «изделия» - какие использовать цвета, удобно ли будет человеку попадать пальцем в кнопки, читабельным ли будет текст.<br>
            - Сравнить дизайн с эталонным вариантов <br>
            - Рекомендации: ios, android <br>
            - Реальные UI элементы ОС<br>
            - Проверка разработанного UI с дизайном продукта<br>
            <br>
            <dfn>UX design</dfn> — Опыт пользователя, опыт взаимодействия (User eXperience, UX) — это восприятие и ответные действия пользователя, возникающие в результате использования и/или предстоящего использования продукции, системы или услуги. <br>
            Принципы обеспечения UX<br>
            - <b>Видимость статуса системы</b> - Пользователь должен всегда знать, что происходит, получая подходящую обратную связь в приемлемое время.
            - <b>Соответствие между системой и реальным миром</b> - Система должна «говорить на языке пользователя», используя понятную ему терминологию и концепции, а не «системно-ориентированный» язык.<br>
            - <b>Управляемость и свобода для пользователя</b> - Пользователь часто выбирает системные функции по ошибке и должен иметь ясно видимый «аварийный выход» из нежелаемого состояния системы, не требующий сложных диалогов.<br> Следует поддерживать функции отмены (undo) и повтора (redo).<br>
            - <b>Согласованность и стандарты</b> - Пользователи не должны гадать, значат ли одно и то же разные слова, ситуации или операции.<br> Также нужно следовать соглашениям, принятым для данной платформы.<br>
            - <b>Предотвращение ошибок</b> <br>Продуманный дизайн, который не позволяет какой-то проблеме даже возникнуть, лучше, чем самые хорошие сообщения об ошибках. Следует устранять сами условия возникновения ошибок, либо выявлять их и предупреждать пользователя о предстоящей проблеме.<br>
            - <b>Распознавать лучше, чем вспоминать</b> - Минимизируйте нагрузку на память пользователя, явно показывая ему объекты, действия и варианты выбора.<br> Пользователь не должен в одной части диалога запоминать информацию, которая потребуется ему в другой.<br> Инструкции по использованию системы должны быть видимы или легко получаемы везде, где возможно.<br>
            - <b>Эстетический и минималистический дизайн</b> - В интерфейсе не должно быть информации, которая не нужна пользователю или которая может понадобиться ему в редких случаях.<br> Каждый избыточный элемент диалога отнимает внимание от нужных элементов.<br>
            - <b>Помочь пользователю понять и исправить ошибку</b> - Сообщения об ошибках следует писать простым языком, без кодов, чётко формулируя проблему и предлагая конструктивное решение.<br>
            - <b>Справка и документация</b><br>
            <br>
            <dfn>Pекомендации по UX/UI</dfn>:<br>
            - Удалите беспорядок<br>
            - Сделайте навигацию самоочевидной<br>
            - Создайте бесшовный опыт<br>
            - Используйте правильные размеры целей нажатия (тэп таргеты)<br>
            - Текст должен быть разборчивым<br>
            - Элементы интерфейса должны быть ясно видны<br>
            - Разработайте управление, основанное на расположении руки<br>
            - Снизьте необходимость в наборе текста<br>
            Так же, как с любыми другими элементами дизайна, советы, указанные выше – это только место для старта. <br>
            Смешивайте и сочетайте эти идеи с вашим собственным для достижения наилучших результатов.<br>
            Просто помните, что дизайн — не только для дизайнеров — он для пользователей.<br>
            <br>

        //- Тестирование
        details
          summary Тестирование
          p.
            <dfn>Check list</dfn>
            - Все элементы должны быть такого размера, чтобы пользователь мог попасть по ним<br>
            - Отсутствие пустых экранов в приложениях<br>
            - Многократные нажатия на кнопки<br>
            - Проверка нативных жестов в приложениях<br>
            - Обработка ситуаций нехватки памяти, для работы приложения<br>
            - Недостаток места для установки приложения<br>
            - Отсутствие у приложений поддерживаемых функций (SD – карта, 3G)<br>
            - Установка или перенос приложения на SD – карту<br>
            - Соответствие правилам хорошего тона (Apple HIG, Google Material Design)<br>
            - Размер элементов<br>
            - Количество информации<br>
            - Адаптация под разные размеры экранов<br>
            - Проверка изменения ориентации устройства (Portrait, Landscape)<br>
            - Отзывчивость на воздействия (Графическая, звуковая, тактильная)<br>
            - Сообщения об ошибках<br>
            - Цветовая гамма<br>
            - Retina и обычные экраны (изображения для retina, попавшие в обычные устройства будут выглядеть очень большими)<br>
            - Версии OS (Приложения не должны устанавливаться на неподдерживаемые версии OS)<br>
            - Соответствие используемых экранов в приложении (Решения, которые имеют смысл для одной платформы, могут быть неуместны в другой)<br>
            - Входящие и исходящие SMS, MMS, звонки, оповещения других приложений<br>
            - Выключение устройства, изъятие аккумулятора, зарядка устройства<br>
            - Переход в режим ожидания (В том числе и с защитой паролем)<br>
            - Изменение ориентации устройства в режиме ожидания<br>
            - Включение/отключение сети, GPS, авиа – режима, Bluetooth<br>
            - Отключение/подключение SD – карты, физической клавиатуры, гарнитуры<br>
            - Соответствие цены и содержимого, заявленного в приложении тому, что попадает к пользователю<br>
            - Восстановление покупок<br>
            - Сохранение покупок при обновлении приложения<br>
            - Использование различных функциональных возможностей девайса (Например, кнопка Back на Android)<br>
            - Проверка корректности перевода<br>
            - Все переведенные слова, корректно располагаются в отведенных для них местах<br>
            - Проверка форматов дат, разделителей в числах и других нетривиальных моментах<br>
            - Проверка работоспособности в разных часовых регионах<br>
            - Убедиться, что поддерживаются все версии из предыдущих релизов (если в приложении добавлена функциональность из новой версии ОС, то необходимо разрабатывать урезанный функционал для старых версий ОС)<br>
            - Проверка обновлений (Сохранение всех данных пользователей, Авторизация)<br>
            - Если приложение поддерживает Portrait/Landscape – уделите смене ориентации много времени<br>
            - Лучше всего переходите между экранами во время взаимодействия с сетью<br>
            - Запросы должны отменяться, если они не завершены<br>
            - Использовать настройки разработчика: эмитирование слабого соединения, не сохранять действие (состояние активити - Android) и тд<br>
            - Проверять деинсталляцию - удаление всех пользовательских данных<br>
          br
          p.
            <dfn>Основные особенности</dfn><br>
            <b>Экран</b><br>
            - Ориентация (landscape, portrait)<br>
            - Разрешение экрана<br>
            - Монобровь<br>
            <br>
            <b>Ресурсы устройства</b><br>
            - Мало места для установки или работы<br>
            - Установка и перенос на SD карту<br>
            - Очистка данных при удалении<br>
            - Утечки памяти<br>
            - Работа с низким зарядом батареи<br>
            - Переключение между wifi и mobile data<br>
            - Переход из 4G в 3G<br>
            - Отключение интернета<br>
            - Работа с датчиками, Bluetooth, GPS, камерой, контактами<br>
            <br>
            <b>Usability</b><br>
            - Соответствие рекомендациям: Apple Human Interface Guidline и Google Material Design<br>
            - Размер элементов<br>
            - Количество информации<br>
            - Отклик на действие<br>
            - Управление одной рукой<br>
            - Push сообщения<br>
            - Сообщения об ошибках и предупреждения<br>
            - Прогресс бары<br>
            <br>
            <b>OS</b><br>
            - Отдельно Android, отдельно IOS<br>
            - Разные версии OS<br>
            - Приложение не должно устанавливаться на неподдерживаемые OS<br>
            - Требования AppStore и Google Play<br>
            <br>
            <b>Прерывания</b><br>
            - Звонки и SMS<br>
            - Push сообщения<br>
            - Выключение телефона<br>
            - Вход/выход спящий режим<br>
            - Изменение ориентации в спящем режиме<br>
            - Включение/выключение GPS, Bluetooth<br>
            - Отключение/подключения USB кабеля, SD карты, клавиатуры, гарнитуры<br>
            <br>
            <b>Платный контент</b><br>
            - Соответствие цены и содержимого, заявленного в приложении тому, что попадает к пользователю<br>
            - Восстановление покупок<br>
            - Сохранение покупок при обновлении приложения<br>
            <br>
            <b>Интернационализация</b><br>
            - Корректность перевода<br>
            - Все слова помещаются в элементы<br>
            - Форматы дат, разделителей в числах и другие нетривиальные моменты<br>
            <br>
            <b>Обновления</b><br>
            - Обратная совместимость<br>
            - Поддержка старых версий OS<br>
            - Сохранение данных пользователей<br>
            - Авторизация<br>
            <b>Советы</b><br>
            - Если приложение поддерживает Portrait/Landscape – уделите смене ориентации много времени<br>
            - Лучше всего переходите между экранами во время взаимодействия с сетью<br>
            - Запросы должны отменяться, если они не завершены<br>
            - Ответ от сервера на удаленный из памяти (невидимый) экран, не должны крэшить приложение<br>
            - Скриншоты, логи, видео<br>
            - Использование «Обезьянок», для поиска крэшей и зависаний (Android – UI Monkey Exerciser, iOS - CrashMonkey)<br>
            - Использование Бета – версии (Для Android – встроенное в магазин решение, для iOS - TestFlight). Желательно оборачивать приложения в оболочки (Crashlytics, TestFairy, HockeyApp)<br>
            - Использовать настройки разработчика<br>
            - iOS – позволяет настраивать скорость интернет – соединения и раздавать его используя устройство, как точку доступа, логировать использование трафика и энергии, удобное тестирование iAd – рекламы<br>
            - Android – настройки на любой вкус – от отображения загрузки процессора до изменения анимации интерфейса<br>
            - Эмуляторы и симуляторы<br>
            - Мониторинг<br>

    //- Web testing
    details
        summary.menu__submenu Web testing
        img(src="./img/qc/ClientServer.png" alt="")

        //- GUI
        details
          summary GUI
          p.
            У любого тестируемого предмета и веб-приложения есть внешний вид, поэтому тестирование графического интерфейса или попросту внешнего вида — это самое первое что мы можем сделать.<br>
            <b>Верстка</b> — размещение элементов веб-приложения (изображения, текст, кнопки, видео и т.д.) в соответствии с макетом или требованиями.<br>
            - Сравнение с макетом<br>
            - Измерение размеров элемента<br>
            - Правильность шрифтов<br>
            - Цвета интерфейса<br>
            - Контент<br>
            - Курсор<br>
            - Масштабируемость<br>
            - Фавикон<br>
            - Заголовки, title<br>
            - Браузерные расширения<br>
            - Back button<br>
            - Scroll<br>
            - Стандарты HTML/CSS<br>
            - Кодировка<br>
            - Правильность перевода<br>
            - Длина переведенных слов<br>
            - Сокращения/аббревиатуры<br>
            - Валюта<br>
            - Шрифты<br>
            - Дата/время, разделители чисел<br>
            - Поиск<br>
            - RTL (right to left languages)<br>

        //- Functional
        details
          summary Functional
          p.
            проверяем работоспособность и взаимодействие элементов<br>
            <br>
            <b>Label</b> (метка):<br>
            - Один уровень с полями<br>
            - Выровнены по отношению к друг другу<br>
            - Длинные строки<br>
            <br>
            <b>Placeholder</b>:<br>
            - Цвет шрифта<br>
            - Отступ<br>
            - Пропадает при вводе значения/фокусе<br>
            - Появляется при очистке<br>
            - Нельзя скопировать<br>
            <br>
            <b>Text field</b>:<br>
            - Цвет шрифта, отступы<br>
            - Граничные значения<br>
            - Классы эквивалентности<br>
            - Длинные строки<br>
            - Маска паролей<br>
            - Trim<br>
            - Работа с текстом<br>
            <br>
            <b>Text area</b>:<br>
            - Длина<br>
            - Перенос слов<br>
            - Маштабирование<br>
            - Скролы<br>
            - Enter (Ctrl-Enter)<br>
            <br>
            <b>Checkbox</b>:<br>
            - Все состояния<br>
            - Неактивный<br>
            - Неактивный включенный<br>
            - Взаимное расположение<br>
            <br>
            <b>Radiobutton</b>:<br>
            - Значение по умолчанию<br>
            - Неактивный<br>
            - Неактивный включенный<br>
            - Взаимное расположение<br>
            - Отображение группы<br>
            <br>
            <b>Switcher</b>:<br>
            - Значение по умолчанию<br>
            - Неактивный<br>
            - Неактивный включенный<br>
            - Стили<br>
            <br>
            <b>Dropdown list</b>:<br>
            - Значение по умолчанию<br>
            - Длина опций<br>
            - Длина списка<br>
            - Выпадение вверх<br>
            - Подсветка выделенной опции<br>
            - Скрол<br>
            - Поиск<br>
            - Каскадные списки<br>
            <br>
            <b>Combo box</b>:<br>
            - Значение по умолчанию/placeholder<br>
            - Раскрытие списка<br>
            - Длина опций<br>
            - Подсветка выделенной опции<br>
            - Поиск<br>
            - Количество опций<br>
            - Выпадение вверх<br>
            - Скрол<br>
            - Mul tiselection<br>
            - Добавление/удаление вариантов<br>
            <br>
            <b>Button</b>:<br>
            - Размер и положение<br>
            - Enabled/Disabled<br>
            - Enter (Ctrl-Enter)<br>
            - Hover/Click эффекты<br>
            - Длина текста<br>
            - Текст с заглавной<br>
            <br>
            <b>Slider</b>:<br>
            - Диапазон<br>
            - Шкала<br>
            - Метки<br>
            - Связанное поле<br>
            - Изменение клавиатурой<br>
            <br>
            <b>Date picker</b>:<br>
            - Выбор даты<br>
            - Ввод даты вручную<br>
            - Формат даты<br>
            - Граничные значения<br>
            - Некорректная дата<br>
            - 29 февраля<br>
            <br>
            <b>Time picker</b>:<br>
            - Выбор времени<br>
            - Ввод времени вручную<br>
            - Некорректное время<br>
            - Время сервера<br>
            - Временные зоны<br>
            <br>
            <b>Tabs</b>:<br>
            - С заглавной буквы<br>
            - Активная/Не активные<br>
            - Hover эффект<br>
            <br>
            <b>Validation message</b>:<br>
            - Текст отражает суть<br>
            - Нет серверных ошибок<br>
            - Красный цвет<br>
            - Не должно ломать верстку<br>
            - Исчезновение при исправлении<br>
            <br>
            <b>Popup</b>:<br>
            - Расположение по центру<br>
            - Закрытие по ESC<br>
            - Закрытие по клику<br>
            - Кнопка закрытия<br>
            <br>
            <b>Дополнительно</b>:<br>
            - Разрыв соединения<br>
            - Работа в нескольких вкладках<br>
            - Проверка консоли и логов<br>
            - Отключение Javascript<br>

        //- Usability
        details
          summary Usability
          p.
            от этого зависит, будет ли востребован продукт вообще:<br>
            - Соответствует ли приложение ожиданиям конечного пользователя<br>
            - Логичность интерфейса<br>
            - Самое нужное «сверху»<br>
            - Продуманная навигация<br>
            - Минимизация действий<br>
            - Локализация<br>
            - Совместимость с другим софтом (соцсети) и железом<br>
            - Скорость работы приложения<br>
            - Информативность (сообщения/обязательные поля)<br>
            - Возможность отмены действий пользователя<br>
            - Подсказки и подтверждения<br>
            - Help — должна быть инструкция, как работать с приложением<br>
          p.
            <em>Security</em><br>
            - Матрица ролей<br>
            - SQL – инъекции<br>
            - XSS<br>
            - HTML tags<br>
            <br>
            <em>Performance</em><br>
            - Несколько сессий<br>
            - Длительные сессии<br>
            - Большое количество действий<br>
            - Большие файлы<br>
            - Сложные запросы<br>
            - Низкая скорость интернета<br>
            - Throttling<br>
            <br>
            <em>Configuration</em> <br>
            - Кроссбраузерность

    //- APP
    details
      summary.menu__submenu APP
      p <em>Bug Tracking Systems</em>:
      img(src="./img/qc/BTS.png" alt="")
      p.
        <em>Jira</em> <br>
        коммерческая системаотслеживания ошибок.<br>
        Разработана компанией Atlassian, является одним из двух её основных продуктов (наряду с вики-системой Confluence).<br>
        Имеет веб-интерфейс.<br>
      a(href="https://www.atlassian.com/ru/software/jira") Обзор
      br
      p.
        <em>JMeter</em> <br>
        - Инструмент нагрузочного тестирования<br>
        - Графический интерфейс<br>
        - Кроссплатформенность (Написан на Java)<br>
        - Бесплатно весь функционал<br>
        - Генерация отчетов<br>
        - Работа в консоли<br>
        - Возможность расширения и тонкой настройки<br>
        - Эмуляция одновременной работы пользователей<br>
        - Распределенная нагрузка<br>
        - Снятие метрик<br>
      img(src="./img/qc/per.png" alt="")
      br
      p.
        Jenkins<br>
        SoapUI<br>
        REST-assured<br>
        Selenium<br>
        TestComplete<br>
        Cypress<br>
      a(href="https://www.postman.com/") Postman<br>
      a(href="https://www.telerik.com/fiddler") Fiddler<br>
      a(href="https://www.charlesproxy.com/") Charles

    //- Automation
    details
      summary.menu__submenu Automation
      img(src="./img/qc/manual testing.png" alt="")
      img(src="./img/qc/automation.png" alt="")
      p.
        <dfn>Автоматизированное (автоматическое) тестирование</dfn><br> является составной частью процесса тестирования. <br>
        Оно использует программные средства для выполнения тестов и проверки результатов пробега этих тестов, что помогает сократить время тестирования и упростить его процесс<br>
        <br>
        <b>Преимущества</b>:<br>
        - <em>Повторяемость</em> – все написанные тесты всегда будут выполняться однообразно, то есть исключен «человеческий фактор». <br>
        Тестировщик не пропустит тест по неосторожности и ничего не напутает в результатах<br>
        - <em>Быстрое выполнение</em> – автоматизированному скрипту не нужно сверяться с инструкциями и документациями, это сильно экономит время выполнения<br>
        - <em>Отчеты</em> – автоматически рассылаемые и сохраняемые отчеты о результатах тестирования<br>
        - <em>Выполнение без вмешательства</em> – во время выполнения тестов инженер-тестировщик может заниматься другими полезными делами, или тесты могут выполняться в нерабочее время (этот метод предпочтительнее, так как нагрузка на локальные сети ночью снижена)<br>
        <br>
        <b>Недостатки</b>:<br>
        - <em>Повторяемость</em> – все написанные тесты всегда будут выполняться однообразно. <br>
        Это одновременно является и недостатком, так как тестировщик, выполняя тест вручную, может oбратить внимание на некоторые детали и, проведя несколько дополнительных операций, найти дефект. <br>
        Скрипт этого сделать не может.<br>
        - <em>Затраты на поддержку</em> – несмотря на то, что в случае автоматизированных тестов они меньше, чем затраты на ручное тестирование того же функционала – они все же есть. <br>
        Чем чаще изменяется приложение, тем они выше.<br>
        - <em>Большие затраты на разработку</em> – разработка автоматизированных тестов это сложный процесс, так как фактически идет разработка приложения, которое тестирует другое приложение. <br>
        В сложных автоматизированных тестах также есть фреймворки, утилиты, библиотеки и прочее. <br>
        Естественно, все это нужно тестировать и отлаживать, а это требует времени.<br>
        - <em>Пропуск мелких ошибок</em> – автоматический cкрипт может пропускать мелкие ошибки на проверку которых он не запрограммирован. <br>
        Это могут быть неточности в позиционировании окон, ошибки в надписях, которые не проверяются, ошибки элементов и форм с которыми не осуществляется взаимодействие во время выполнения скрипта.<br>
        <br>
        <b>Автоматизировать</b>:<br>
        - Unit Tests<br>
        - Smoke tests<br>
        - Integration tests<br>
        - Performance<br>
        - Regression<br>
        <br>
        <b>Применение</b>:<br>
        - Труднодоступные места в системе (бэкенд процессы, логирование файлов, запись в БД)<br>
        - Часто используемая функциональность, риски от ошибок в которой достаточно высоки.<br>Автоматизировав проверку критической функциональности, можно гарантировать быстрое нахождение ошибок, а значит и быстрое их решение.<br>
        - Рутинные операции, такие как переборы данных (формы с большим количеством вводимых полей.<br>Автоматизировать заполнение полей различными данными и их проверку после сохранения)<br>
        - Валидационные сообщения (Автоматизировать заполнение полей не корректными данными и проверку на появление той или иной валидации).<br>
        - Длинные end-to-end сценарии.<br>
        - Проверка данных, требующих точных математических расчетов.<br>
        - Проверка правильности поиска данных.<br>
        <br>
        <b>Случаи для автоматизации</b>:<br>
        - Функционал стабилен<br>
        - Большое количество ручных тестов и не хватает времени на регулярное проведение полного регресса<br>
        - Короткие циклы тестирования продукта<br>
        - Подготовка к тестированию (настройка конфигурации, генерация тестовых данных) занимает много времени<br>
        - Поддержка старых версий ПО, в которых нужно тестировать новые патчи и сервис-паки<br>
        - В каждом случае – если это экономически целесообразно<br>
        - Когда мануальное тестирование невозможно<br>
        <br>
        <b>Инструменты Unit Tests</b><br>
        - JUnit<br>
        - Nunit<br>
        - Mocha<br>
        <br>
        <b>UI automation tool</b> <br>
        - selenium WebDriver Architecture<br>
        <br>
        <b>Тесты подлежащие автоматизации</b>: <br>
        - часто повторяющиеся (ежедневно) <br>
        - занимающие много времени <br>
        - отработанные тесты (тесты для стабильного функционала, который уже в продакшине)<br>
        <br>
        <b>Ещё инструменты</b>
        - ферма браузеров<br>
        - web driver<br>
        - xpaph<br>
        - functional testing automation<br>
        - layout testing automation<br>
        - поиск элементов по id, XPaph, css selectors<br>

    //- Interview
    details
      summary.menu__submenu Interview
      <ol> <b>Всегда задаваемые вопросы</b>
        li Как составлять тест-кейсы?
        li Как составлять чек-листы?
        li Что такое классы эквивалентности и как их выделять?
        li Что такое метод граничных значений?
        li Как правильно оформить баг?
        li Какие бывают виды и уровни тестирования?
        li Что такое клиент-серверная архитектура и как она работает?
      p.
        <dfn>Manual testing questions</dfn>:<br>
        1. <em>What is software testing?</em><br>
        It is an investigation conducted to provide stakeholders with information about the quality of the software product or service under test. <br>
        <em>OR</em><br>
        It is a process of verifying a system with the purpose of identifying any errors, gaps or missing information.<br>
        <br>
        2. <em>What is Quality Assurance?</em><br>
        QA is a way of preventing mistakes and defects in manufactured products and avoiding problems when delivering products or services to customers.<br>
        <br>
        3. <em>What is Quality Control?</em><br>
        QC is a set of procedures intended to ensure that a manufactured product or performed service adheres to a defined set of quality criteria.<br>
        <br>
        4. <em>What is the difference between verification and validation?</em><br>
        Verification is the process of checking that a software achieves its goal without any bugs.<br>
        Validation is the process of cheking whether the specification captures the customer's needs.<br>
        <br>
        5. <em>What is Test Plan?</em><br>
        It is a document detailing the objectives, resources and processes for a specific test for a software or hardware product.<br>
        <br>
        6. <em>What is Defect Density?</em><br>
        It is a number of confirmed bugs in a software application during the period of development, divided by the size of the software. <br>
        <em>OR</em> <br>
        It is the average number of defects per thousand lines of code.<br>
        <br>
        7. <em>What is stub?</em><br>
        It is a piece of code used to stand in for some other programming functionality.<br>
        A stub may simul ate the behavior of existing code.<br>
        <br>
        8. <em>What is driver?</em><br>
        It is a program that interacts with a particul ar device or special kind of software.<br>
        <br>
        9. <em>What is debugging?</em><br>
        It is the process of finding and removing the causes of software failures.<br>
        <br>
        10. <em>What is Gorilla Testing</em><br>
        It is a testing technique in which sometimes developers also join testers to test a particular module thoroughly in all aspects.<br>
        <br>
        11. <em>What is Gray Box Testing?</em><br>
        It is a combination of Black Box and White Dox testing methodologies.<br>
        <br>
        12. <em>What is Positive Testing?</em><br>
        It is a testing aimed at showing software works. (Test to Pass).<br>
        <br>
        13. <em>What is Negative Testing?</em><br>
        It is a testing aimed at showing software doesn't work. (Test to Fail).<br>
        <br>
        14. <em>What is Recovery Testing?</em><br>
        It confirms that the program recovers from expected or unexpected events without loss of date or functionality.<br>
        <br>
        15. <em>What is Release Candidate?</em><br>
        It is a prerelease version, which contains the desired functionality of the final version, but which needs to be tested for bugs.<br>
        <br>
        16. <em>Why does software have bugs?</em><br>
        - miscommunication <br>
        - programming errors <br>
        - time pressure <br>
        - changing requirements <br>
        - software complexity<br>
        <br>
        17. <em>What is Test Environment?</em><br>
        It is the hardware and software environment in which test will be run.<br>
        <br>
        18. <em>What is Traceability Matrix?</em><br>
        It is a document showing the relationship between Test Requirements and Test Cases.<br>
        <br>
        19. <em>What is Good Code?</em><br>
        Good Code is a code that works, is bug free, is readable and maintainable.<br>
        <br>
        20. <em>What is Test Harness?</em><br>
        It is a collection of stub and drivers and other supporting tools to conduct a test.<br>
        <br>
        21. <em>How to perform testing when there are no documents?</em><br>
        Ad hoc testing is done without use of any documentation or planning. <br>
        This is the least formal type of testing. <br>
        To perform this type of testing, tester needs to have in-depth understanding of the application and all its functional flows.<br>
        <br>
        22. <em>Define a web server.</em><br>
        Wed server follows the client/server model where the program uses HTTP.<br>
        <br>
        23. <em>What is the difference between Authorization and Authentication?</em><br>
        Authentication is the process with which the system identifies who the user is. <br>
        Authorization is the process with which the system identifies what user is authorized to do.<br>
        <br>
        24. <em>Define HTTP.</em><br>
        HTTP is the data transfer protocol that defines how messages are formatted and transferred over the world wide web.<br>
        <br>
        25. <em>What is the difference between Static and Dynamic website?</em><br>
        Static website is the one which gives out information only and there is no sort of interaction between the user and the website. <br>
        Dynamic website is the one where interaction is possible between the website and the user.<br>
        <br>
        26. <em>What is Proxy server?</em><br>
        It is a server that acts as an intermediary or is one that lies between the client and the main server.<br>
        <br>
        27. <em>What is Priority?</em><br>
        It indicates the importance or urgency of fixing a defect.<br>
        <br>
        28. <em>When can the testing be stopped?</em><br>
        - deadlines <br>
        - test cases completed with certain percentage passed <br>
        - test budget depleted <br>
        - bug rate falls below a certain level <br>
        - beta and alpha testing period ends <br>
        <br>
        29. <em>What's the goal of a software tester?</em><br>
        The goal of a software tester is to find bugs, find them as early as possible, and make shure they get fixed.<br>
        <br>
        30. <em>What's the difference between translation and localization?</em><br>
        Translation is concerned only with the language aspects - translating the words. <br>
        Localization takes into account the customs, conventions, and cul ture of the region or locale.<br>
        <br>
        31. <em>What might you include in a quality assurance testing document?</em><br>
        Test Plans, Test Scenarios, Test Cases, Check list, Bug Report, Traceability Matrix, Test Suits.<br>
        <br>
        32. <em>What is a bug?</em><br>
        A bug is any kind of error, mistake or failure in software code that prevents the software function from executing properly.<br>
        <br>
        33. <em>What is the difference between severity and priority?</em><br>
        Severity is how difficul t the issue is to fix. <br>
        Priority is how important the issue is to fix.<br>
        <br>
 
    a(href="https://lms.ithillel.ua/auth") hillel<br>
    a(href="https://habr.com/en/companies/badoo/articles/301764/") habr<br>
    a(href="https://habr.com/en/feed/") habr<br>
    a(href="https://www.portnov.com/") portnov<br>
    a(href="https://www.youtube.com/watch?v=JbhG8bruYsU&list=PL7XXjge0nKZfUjvs_pul SXpkV-dBrihZu") Курс<br>
    a(href="https://software-testing.ru/") software<br>
    a(href="https://dou.ua/") dou<br>
    a(href="https://www.themoviedb.org/") themoviedb<br>
    a(href="https://www.guru99.com/") guru99<br>
    a(href="https://www.drow.io") drow<br>
